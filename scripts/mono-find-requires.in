#!/bin/bash
#
# mono-find-requires
#
# Authors:
#       Ben Maurer (bmaurer@ximian.com)
#
# (C) 2005 Novell (http://www.novell.com)
#

IFS=$'\n'
filelist=($(grep -Ev '/usr/doc/|/usr/share/doc/'))
monolist=($(printf "%s\n" "${filelist[@]}" | egrep "\\.(exe|dll)\$"))

# parse .config files to find which native libraries to depend on 
#  (target attribute must have double quotes for this to work, ie: target="file" )
# Add /etc/mono/config ?
configlist=($(printf "%s\n" "${filelist[@]}" | egrep "\\.config\$"))

# Set the prefix, unless it is overriden (used when building mono rpms)
: ${prefix=@prefix@}

libdir=$prefix/@reloc_libdir@
bindir=$prefix/bin

# Bail out if monodis or libmono is missing
if [ ! -x $bindir/monodis ] || [ ! -f $libdir/libmono.so ] ; then
	echo "monodis missing or unusable, exiting..." 1>&2
	exit 1
fi

# special case for 64bit archs
if test "x@reloc_libdir@" = "xlib64" ; then
        libext="()(64bit)"
else
        libext=""
fi

# set LD_LIBRARY_PATH to ensure that libmono.so is found
export LD_LIBRARY_PATH=$libdir${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}

REQUIRES=$(
	for i in "${monolist[@]}"; do
		($bindir/monodis --assemblyref $i | awk '
			BEGIN { START=0; LIBNAME=""; VERSION=""; }
			(START==0) && /^[0-9]+: Version=/ {
				START=1;
				sub(/Version=/, "", $2);
				VERSION=$2
			}

			(START==1) && /^\tName=/ {
				sub(/Name=/, "", $1);
				LIBNAME=$1
				# Allow rpm deps to be resolved for 1.0 profile version
				if (VERSION=="1.0.3300.0")
					OP=">="
				else
					OP="="
				print "mono(" LIBNAME ") " OP " " VERSION
				START=0
			}
		    ') 2> /dev/null
	done
	# Parse the xml .config files to see what native binaries we call into
	# TODO: also check monodis --moduleref
	for i in "${configlist[@]}"; do
		awk 'match($_, /<dllmap .*target=.*/) {
			ignore=0
			req=""
			split($_, toks, "\"")
			for(i=1; i <= length(toks); i++) {
				if(toks[i] ~ /target=/) {
					req=toks[i+1]
				}
				if(toks[i] ~ /os=/) {
					negate=0
					found=0

					attr=toks[i+1]
					if(attr ~ /^!/) {
						attr=substr(attr, 2, length(attr)-1)
						negate=1
					}

					split(attr, os_targets, ",")
					for(j=1; j <= length(os_targets); j++) {
						if(os_targets[j] == "linux") {
							found=1
						}
					}

					if(negate) {
						found=!found
					}
					if (!found) {
						ignore=1
					} 
				}
			}
			if(!ignore) {
				system("rpm -q --whatprovides --queryformat \"%{NAME}\n\" ""\""req"'$libext'""\"")
			}
		} ' $i 2>/dev/null
	done
)

PROVIDES=$(
	for i in "${monolist[@]}"; do
		($bindir/monodis --assembly $i | awk '
			BEGIN { LIBNAME=""; VERSION=""; }
			/^Version:/ { VERSION=$2 }
			/^Name:/    { LIBNAME=$2 }
			END {
				if (VERSION && LIBNAME)
					print "mono(" LIBNAME ") = " VERSION
			}
		    ') 2>/dev/null
	done
)
#
# This is a little magic trick to get all REQUIRES that are not
# in PROVIDES. While RPM functions correctly when such deps exist,
# they make the metadata a bit bloated.
#

# Filter out dups from both lists
REQUIRES=$(echo "$REQUIRES" | sort | uniq)
PROVIDES=$(echo "$PROVIDES" | sort | uniq)

#
# Get a list of elements that exist in exactly one of PROVIDES or REQUIRES
#
UNIQ=$(echo "$PROVIDES
$REQUIRES" | sort | uniq -u)

#
# Of those, only choose the ones that are in REQUIRES
#
echo "$UNIQ
$REQUIRES" | sort | uniq -d
