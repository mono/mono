Index: report.cs
===================================================================
--- report.cs	(revision 63019)
+++ report.cs	(working copy)
@@ -634,6 +634,10 @@
 			: base (message)
 		{
 		}
+
+		public InternalErrorException (string message, params object[] args)
+			: base (String.Format (message, args))
+		{ }
 	}
 
 	/// <summary>
Index: generic.cs
===================================================================
--- generic.cs	(revision 63019)
+++ generic.cs	(working copy)
@@ -151,11 +151,14 @@
 		}
 
 		public override string TypeParameter {
-			get {
-				return name;
-			}
+			get { return name; }
 		}
 
+		public Constraints Clone ()
+		{
+			return new Constraints (name, constraints, loc);
+		}
+
 		GenericParameterAttributes attrs;
 		TypeExpr class_constraint;
 		ArrayList iface_constraints;
@@ -739,7 +742,7 @@
 						TypeManager.CSharpName (mparam), TypeManager.CSharpSignature (mb));
 					return false;
 				}
-			} else if (DeclSpace is Iterator) {
+			} else if (DeclSpace is CompilerGeneratedClass) {
 				TypeParameter[] tparams = DeclSpace.TypeParameters;
 				Type[] types = new Type [tparams.Length];
 				for (int i = 0; i < tparams.Length; i++)
@@ -2622,7 +2625,7 @@
 
 				Argument a = (Argument) arguments [i];
 				if ((a.Expr is NullLiteral) || (a.Expr is MethodGroupExpr) ||
-				    (a.Expr is AnonymousMethod))
+				    (a.Expr is AnonymousMethodExpression))
 					continue;
 
 				arg_types [i] = a.Type;
Index: parameter.cs
===================================================================
--- parameter.cs	(revision 63019)
+++ parameter.cs	(working copy)
@@ -665,7 +665,7 @@
 			}
 		}
 
-		Parameter this [int pos]
+		public Parameter this [int pos]
 		{
 			get {
 				if (pos >= count && (HasArglist || HasParams)) {
Index: ecore.cs
===================================================================
--- ecore.cs	(revision 63019)
+++ ecore.cs	(working copy)
@@ -4040,9 +4040,9 @@
 		{
 			ILGenerator ig = ec.ig;
 			
-			if (li.FieldBuilder != null) {
+			if (li.Field != null) {
 				ig.Emit (OpCodes.Ldarg_0);
-				ig.Emit (OpCodes.Ldfld, li.FieldBuilder);
+				ig.Emit (OpCodes.Ldfld, li.Field.FieldBuilder);
 			} else {
 				ig.Emit (OpCodes.Ldloc, li.LocalBuilder);
 			}
@@ -4052,9 +4052,9 @@
 		{
 			ILGenerator ig = ec.ig;
 			
-			if (li.FieldBuilder != null) {
+			if (li.Field != null) {
 				ig.Emit (OpCodes.Ldarg_0);
-				ig.Emit (OpCodes.Ldflda, li.FieldBuilder);
+				ig.Emit (OpCodes.Ldflda, li.Field.FieldBuilder);
 			} else {
 				ig.Emit (OpCodes.Ldloca, li.LocalBuilder);
 			}
@@ -4062,12 +4062,12 @@
 		
 		public void Store (EmitContext ec, Expression right_side)
 		{
-			if (li.FieldBuilder != null)
+			if (li.Field != null)
 				ec.ig.Emit (OpCodes.Ldarg_0);
 			
 			right_side.Emit (ec);
-			if (li.FieldBuilder != null) {
-				ec.ig.Emit (OpCodes.Stfld, li.FieldBuilder);
+			if (li.Field != null) {
+				ec.ig.Emit (OpCodes.Stfld, li.Field.FieldBuilder);
 			} else {
 				ec.ig.Emit (OpCodes.Stloc, li.LocalBuilder);
 			}
@@ -4075,15 +4075,15 @@
 		
 		public void EmitThis (EmitContext ec)
 		{
-			if (li.FieldBuilder != null) {
+			if (li.Field != null) {
 				ec.ig.Emit (OpCodes.Ldarg_0);
 			}
 		}
 		
 		public void EmitStore (ILGenerator ig)
 		{
-			if (li.FieldBuilder != null)
-				ig.Emit (OpCodes.Stfld, li.FieldBuilder);
+			if (li.Field != null)
+				ig.Emit (OpCodes.Stfld, li.Field.FieldBuilder);
 			else
 				ig.Emit (OpCodes.Stloc, li.LocalBuilder);
 		}
Index: class.cs
===================================================================
--- class.cs	(revision 63019)
+++ class.cs	(working copy)
@@ -429,8 +429,8 @@
 		// Holds the operators
 		MemberCoreArrayList operators;
 
-		// Holds the iterators
-		ArrayList iterators;
+		// Holds the compiler generated classes
+		ArrayList compiler_generated;
 
 		//
 		// Pointers to the default constructor and the default static constructor
@@ -772,12 +772,12 @@
 			operators.Add (op);
 		}
 
-		public void AddIterator (Iterator i)
+		public void AddCompilerGeneratedClass (CompilerGeneratedClass c)
 		{
-			if (iterators == null)
-				iterators = new ArrayList ();
+			if (compiler_generated == null)
+				compiler_generated = new ArrayList ();
 
-			iterators.Add (i);
+			compiler_generated.Add (c);
 		}
 
 		public override void ApplyAttributeBuilder (Attribute a, CustomAttributeBuilder cb)
@@ -822,9 +822,9 @@
 			}
 		}
 
-		public ArrayList Iterators {
+		public ArrayList CompilerGenerated {
 			get {
-				return iterators;
+				return compiler_generated;
 			}
 		}
 
@@ -1202,7 +1202,7 @@
 			// Let's do it as soon as possible, since code below can call DefineType() on classes
 			// that depend on us to be populated before they are.
 			//
-			if (!(this is Iterator))
+			if (!(this is Iterator) && !(this is CompilerGeneratedClass))
 				RootContext.RegisterOrder (this); 
 
 			if (base_type != null) {
@@ -1541,16 +1541,11 @@
 					part.member_cache = member_cache;
 			}
 #endif
-			if (iterators != null) {
-				foreach (Iterator iterator in iterators) {
-					if (iterator.DefineType () == null)
+			if (compiler_generated != null) {
+				foreach (CompilerGeneratedClass c in compiler_generated) {
+					if (c.DefineType () == null)
 						return false;
 				}
-
-				foreach (Iterator iterator in iterators) {
-					if (!iterator.DefineMembers ())
-						return false;
-				}
 			}
 
 			return true;
@@ -1564,9 +1559,9 @@
 
 		public override bool Define ()
 		{
-			if (iterators != null) {
-				foreach (Iterator iterator in iterators) {
-					if (!iterator.Define ())
+			if (compiler_generated != null) {
+				foreach (CompilerGeneratedClass c in compiler_generated) {
+					if (!c.Define ())
 						return false;
 				}
 			}
@@ -2282,9 +2277,9 @@
 				if (pending.VerifyPendingMethods ())
 					return;
 
-			if (iterators != null)
-				foreach (Iterator iterator in iterators)
-					iterator.EmitType ();
+			if (compiler_generated != null)
+				foreach (CompilerGeneratedClass c in compiler_generated)
+					c.EmitType ();
 		}
 		
 		public override void CloseType ()
@@ -2324,9 +2319,9 @@
 				foreach (Delegate d in Delegates)
 					d.CloseType ();
 
-			if (Iterators != null)
-				foreach (Iterator i in Iterators)
-					i.CloseType ();
+			if (CompilerGenerated != null)
+				foreach (CompilerGeneratedClass c in CompilerGenerated)
+					c.CloseType ();
 			
 			types = null;
 			properties = null;
@@ -2341,7 +2336,7 @@
 			events = null;
 			indexers = null;
 			operators = null;
-			iterators = null;
+			compiler_generated = null;
 			default_constructor = null;
 			default_static_constructor = null;
 			type_bases = null;
Index: decl.cs
===================================================================
--- decl.cs	(revision 63019)
+++ decl.cs	(working copy)
@@ -525,6 +525,7 @@
 				caching_flags |= Flags.ClsCompliantAttributeTrue;
 				return true;
 			}
+
 			return false;
 		}
 
Index: delegate.cs
===================================================================
--- delegate.cs	(revision 63019)
+++ delegate.cs	(working copy)
@@ -816,8 +816,8 @@
 			
 			Expression e = a.Expr;
 
-			if (e is AnonymousMethod && RootContext.Version != LanguageVersion.ISO_1)
-				return ((AnonymousMethod) e).Compatible (ec, type);
+			if (e is AnonymousMethodExpression && RootContext.Version != LanguageVersion.ISO_1)
+				return ((AnonymousMethodExpression) e).Anonymous.Compatible (ec, type);
 
 			MethodGroupExpr mg = e as MethodGroupExpr;
 			if (mg != null)
Index: iterators.cs
===================================================================
--- iterators.cs	(revision 63019)
+++ iterators.cs	(working copy)
@@ -71,10 +71,13 @@
 		
 		public override bool Resolve (EmitContext ec)
 		{
+			Report.Debug (64, "RESOLVE YIELD", this, expr, expr.GetType ());
 			expr = expr.Resolve (ec);
 			if (expr == null)
 				return false;
 
+			Report.Debug (64, "RESOLVE YIELD #1", this, expr, expr.GetType ());
+
 			if (!CheckContext (ec, loc, false))
 				return false;
 
@@ -119,7 +122,7 @@
 		}
 	}
 
-	public class Iterator : Class {
+	public class Iterator : CompilerGeneratedClass {
 		protected ToplevelBlock original_block;
 		protected ToplevelBlock block;
 
@@ -164,8 +167,6 @@
 			Running
 		}
 
-		static int proxy_count;
-
 		public void EmitYieldBreak (ILGenerator ig)
 		{
 			ig.Emit (OpCodes.Ldarg_0);
@@ -174,7 +175,7 @@
 			ig.Emit (OpCodes.Br, move_next_error);
 		}
 
-		public void EmitMoveNext (EmitContext ec)
+		protected void EmitMoveNext (EmitContext ec)
 		{
 			ILGenerator ig = ec.ig;
 
@@ -336,31 +337,14 @@
 			point.Define (ig);
 		}
 
-		private static MemberName MakeProxyName (string name, GenericMethod generic, Location loc)
-		{
-			int pos = name.LastIndexOf ('.');
-			if (pos > 0)
-				name = name.Substring (pos + 1);
-
-			string proxy_name = "<" + name + ">__" + (proxy_count++);
-
-			if (generic != null) {
-				TypeArguments args = new TypeArguments (loc);
-				foreach (TypeParameter tparam in generic.CurrentTypeParameters)
-					args.Add (new SimpleName (tparam.Name, loc));
-				return new MemberName (proxy_name, args, loc);
-			} else
-				return new MemberName (proxy_name, loc);
-		}
-
 		//
 		// Our constructor
 		//
 		public Iterator (IMethodData m_container, DeclSpace parent, GenericMethod generic,
 				 int modifiers)
-			: base (parent.NamespaceEntry, parent,
-				MakeProxyName (m_container.MethodName.Name, generic, m_container.Location),
-				(modifiers & Modifiers.UNSAFE) | Modifiers.PRIVATE, null)
+			: base (parent, generic,
+				(modifiers & Modifiers.UNSAFE) | Modifiers.PRIVATE,
+				m_container.Location)
 		{
 			this.orig_method = m_container;
 
@@ -370,17 +354,13 @@
 			this.original_block = orig_method.Block;
 			this.block = new ToplevelBlock (orig_method.Block, parameters, orig_method.Location);
 
-			if (generic != null) {
-				ArrayList constraints = new ArrayList ();
-				foreach (TypeParameter tparam in generic.TypeParameters)
-					constraints.Add (tparam.Constraints);
-
-				SetParameterInfo (constraints);
-			}
-
 			IsStatic = (modifiers & Modifiers.STATIC) != 0;
 		}
 
+		public override ConstructorInfo Constructor {
+			get { return ctor.ConstructorBuilder; }
+		}
+
 		public AnonymousContainer Host {
 			get { return move_next_method; }
 		}
@@ -423,7 +403,7 @@
 			else
 				this_type = container.TypeBuilder;
 
-			container.AddIterator (this);
+			container.AddCompilerGeneratedClass (this);
 
 			orig_method.Block = block;
 			return true;
@@ -457,6 +437,8 @@
 			if (dispose_method == null)
 				return false;
 
+			Report.Debug (64, "ITERATOR DEFINE MEMBERS", this);
+
 			return true;
 		}
 
@@ -476,7 +458,7 @@
 			else
 				ec.ContainerType = ec.TypeContainer.TypeBuilder;
 
-			ec.ig = move_next_method.method.MethodBuilder.GetILGenerator ();
+			// ec.ig = move_next_method.method.MethodBuilder.GetILGenerator ();
 
 			if (!ctor.Define ())
 				return false;
@@ -489,38 +471,13 @@
 			if (!ec.ResolveTopBlock (null, block, parameters, orig_method, out unreachable))
 				return false;
 
-			original_block.CompleteContexts ();
+			original_block.CompleteContexts (ec);
 
 			cc.EmitAnonymousHelperClasses (ec);
 
-			return true;
-		}
+			move_next_method.ComputeMethodHost ();
 
-		TypeExpr InflateType (Type it)
-		{
-			if (generic_method == null)
-				return new TypeExpression (it, Location);
-
-			if (it.IsGenericParameter && (it.DeclaringMethod != null)) {
-				int pos = it.GenericParameterPosition;
-				it = CurrentTypeParameters [pos].Type;
-			} else if (it.IsGenericType) {
-				Type[] args = it.GetGenericArguments ();
-
-				TypeArguments inflated = new TypeArguments (Location);
-				foreach (Type t in args)
-					inflated.Add (InflateType (t));
-
-				return new ConstructedType (it, inflated, Location);
-			} else if (it.IsArray) {
-				TypeExpr et_expr = InflateType (it.GetElementType ());
-				int rank = it.GetArrayRank ();
-
-				Type et = et_expr.ResolveAsTypeTerminal (ec, false).Type;
-				it = et.MakeArrayType (rank);
-			}
-
-			return new TypeExpression (it, Location);
+			return DefineMembers ();
 		}
 
 		Parameter InflateParameter (Parameter param)
@@ -587,11 +544,6 @@
 			else
 				current_type = new TypeExpression (TypeBuilder, Location);
 
-			if (IsGeneric) {
-				foreach (TypeParameter tparam in TypeParameters)
-					tparam.InflateConstraints (current_type.Type);
-			}
-
 			parameters = InflateParameters (original_parameters, ec);
 			if (!parameters.Resolve (ec)) {
 				// TODO:
@@ -647,7 +599,11 @@
 				args.Add (new Argument (
 					new SimpleParameterReference (t, first + i, Location)));
 
-				cc.AddParameterToContext (move_next_method, name, inflated, first + i);
+				Report.Debug (64, "ITERATOR ADD PARAMETER", this, i, t, name,
+					      inflated);
+
+				cc.AddParameterToContext (
+					move_next_method, parameters [i], first + i, Location);
 			}
 
 			TypeExpr proxy_type;
@@ -723,7 +679,8 @@
 				new SetState (this, State.Running, Location),
 				Location));
 
-			ctor.Block.AddStatement (new InitScope (this, Location));
+			ExpressionStatement init_scope = move_next_method.GetScopeInitializer (Location);
+			ctor.Block.AddStatement (new StatementExpression (init_scope));
 		}
 
 		Statement Create_ThrowInvalidOperation ()
@@ -1001,7 +958,7 @@
 			Iterator iterator;
 
 			public MoveNextMethod (Iterator iterator, Location loc)
-				: base (iterator.parameters, iterator.original_block, loc)
+				: base (iterator, iterator.parameters, iterator.original_block, loc)
 			{
 				this.iterator = iterator;
 			}
@@ -1010,45 +967,35 @@
 			{
 				method = new Method (
 					iterator, null, TypeManager.system_boolean_expr,
-					Modifiers.PUBLIC, false, new MemberName ("MoveNext", loc),
+					Modifiers.PUBLIC, false,
+					new MemberName ("MoveNext", Location),
 					Parameters.EmptyReadOnlyParameters, null);
 
 				method.Block = Block;
 
-				MoveNextStatement inline = new MoveNextStatement (iterator, loc);
+				MoveNextStatement inline = new MoveNextStatement (iterator, Location);
 				Block.AddStatement (inline);
 
 				return true;
 			}
 
-			public bool CreateMethod (EmitContext ec)
+			public override bool Resolve (EmitContext ec)
 			{
-				return CreateMethodHost (ec);
+				return true;
 			}
 
 			public override Iterator Iterator {
 				get { return iterator; }
 			}
 
-			public void ComputeHost ()
-			{
-				ComputeMethodHost ();
-			}
-			
 			public override bool IsIterator {
 				get { return true; }
 			}
 
-			public override void CreateScopeType (EmitContext ec, ScopeInfo scope)
+			public override CompilerGeneratedClass CreateScopeType (ScopeInfo scope)
 			{
-				scope.ScopeTypeBuilder = iterator.TypeBuilder;
-				scope.ScopeConstructor = iterator.ctor.ConstructorBuilder;
+				return iterator;
 			}
-
-			public override void Emit (EmitContext ec)
-			{
-				throw new InternalErrorException ();
-			}
 		}
 
 		protected class MoveNextStatement : Statement {
@@ -1067,7 +1014,6 @@
 
 			protected override void DoEmit (EmitContext ec)
 			{
-				iterator.move_next_method.ComputeHost ();
 				ec.CurrentAnonymousMethod = iterator.move_next_method;
 				ec.InIterator = true;
 
@@ -1151,27 +1097,6 @@
 			}
 		}
 
-		protected class InitScope : Statement
-		{
-			Iterator iterator;
-
-			public InitScope (Iterator iterator, Location loc)
-			{
-				this.iterator = iterator;
-				this.loc = loc;
-			}
-
-			public override bool Resolve (EmitContext ec)
-			{
-				return true;
-			}
-
-			protected override void DoEmit (EmitContext ec)
-			{
-				iterator.cc.EmitInitScope (ec);
-			}
-		}
-
 		void Define_Reset ()
 		{
 			Method reset = new Method (
Index: cs-parser.jay
===================================================================
--- cs-parser.jay	(revision 63019)
+++ cs-parser.jay	(working copy)
@@ -45,6 +45,9 @@
 
 		Delegate   current_delegate;
 
+		GenericMethod current_generic_method;
+		AnonymousMethod current_anonymous_method;
+
 		/// <summary>
 		///   This is used by the unary_expression code to resolve
 		///   a name against a parameter.  
@@ -1074,6 +1077,7 @@
 		method.Block = (ToplevelBlock) $3;
 		current_container.AddMethod (method);
 
+		current_generic_method = null;
 		current_local_parameters = null;
 		iterator_container = null;
 
@@ -1133,6 +1137,7 @@
 				     name, (Parameters) $6, (Attributes) $1);
 
 		current_local_parameters = (Parameters) $6;
+		current_generic_method = generic;
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
@@ -1169,6 +1174,7 @@
 				     (int) $2, false, name, (Parameters) $6, (Attributes) $1);
 
 		current_local_parameters = (Parameters) $6;
+		current_generic_method = generic;
 
 		if (RootContext.Documentation != null)
 			method.DocComment = Lexer.consume_doc_comment ();
@@ -3396,6 +3402,7 @@
 		if (oob_stack == null)
 			oob_stack = new Stack (6);
 
+		oob_stack.Push (current_anonymous_method);
 		oob_stack.Push (current_local_parameters);
 		current_local_parameters = (Parameters)$2;
 
@@ -3403,7 +3410,12 @@
 		oob_stack.Push (current_block);
 		oob_stack.Push (top_current_block);
 		current_block = null;
-	  } 
+
+		Location loc = (Location) $1;
+		current_anonymous_method = new AnonymousMethod (
+			current_anonymous_method, current_container, (Parameters) $2,
+			(ToplevelBlock) top_current_block, loc);
+	  }
 	  block
 	  {
 		Location loc = (Location) $1;
@@ -3416,11 +3428,16 @@
 			ToplevelBlock anon_block = (ToplevelBlock) $4;
 
 			anon_block.Parent = current_block;
-			$$ = new AnonymousMethod (current_container, (Parameters) $2, (ToplevelBlock) top_current_block, 
-				anon_block, loc);
+
+			current_anonymous_method.Block = anon_block;
+			anon_block.SetHaveAnonymousMethods (loc, current_anonymous_method);
+
+			$$ = new AnonymousMethodExpression (current_anonymous_method);
 		}
-			current_local_parameters = (Parameters) oob_stack.Pop ();
-		}
+
+		current_local_parameters = (Parameters) oob_stack.Pop ();
+		current_anonymous_method = (AnonymousMethod) oob_stack.Pop ();
+	}
 	;
 
 opt_anonymous_method_signature
@@ -4000,7 +4017,8 @@
 	: OPEN_BRACE 
 	  {
 		if (current_block == null){
-			current_block = new ToplevelBlock ((ToplevelBlock) top_current_block, current_local_parameters, (Location) $1);
+			current_block = new ToplevelBlock ((ToplevelBlock) top_current_block, current_local_parameters,
+							   current_generic_method, (Location) $1);
 			top_current_block = current_block;
 		} else {
 			current_block = new Block (current_block, (Location) $1, Location.Null);
Index: convert.cs
===================================================================
--- convert.cs	(revision 63019)
+++ convert.cs	(working copy)
@@ -838,8 +838,8 @@
 				if (!TypeManager.IsDelegateType (target_type))
 					return false;
 
-				AnonymousMethod am = (AnonymousMethod) expr;
-				return am.ImplicitStandardConversionExists (target_type);
+				AnonymousMethodExpression ame = (AnonymousMethodExpression) expr;
+				return ame.Anonymous.ImplicitStandardConversionExists (target_type);
 			}
 
 			return false;
@@ -1325,10 +1325,11 @@
 					return null;
 				}
 
-				AnonymousMethod am = (AnonymousMethod) expr;
+				AnonymousMethodExpression ame = (AnonymousMethodExpression) expr;
+
 				int errors = Report.Errors;
 
-				Expression conv = am.Compatible (ec, target_type);
+				Expression conv = ame.Anonymous.Compatible (ec, target_type);
 				if (conv != null)
 					return conv;
 				
Index: anonymous.cs
===================================================================
--- anonymous.cs	(revision 63019)
+++ anonymous.cs	(working copy)
@@ -20,14 +20,139 @@
 
 namespace Mono.CSharp {
 
-	public abstract class AnonymousContainer : Expression
+	public abstract class CompilerGeneratedClass : Class
 	{
+		GenericMethod generic_method;
+		static int next_index = 0;
+
+		private static MemberName MakeProxyName (GenericMethod generic, Location loc)
+		{
+			string name = String.Format ("<>c__CompilerGenerated{0}", ++next_index);
+			if (generic != null) {
+				TypeArguments args = new TypeArguments (loc);
+				foreach (TypeParameter tparam in generic.CurrentTypeParameters)
+					args.Add (new SimpleName (tparam.Name, loc));
+				return new MemberName (name, args, loc);
+			} else
+				return new MemberName (name, loc);
+		}
+
+		protected CompilerGeneratedClass (DeclSpace parent, GenericMethod generic,
+						  int mod, Location loc)
+			: base (parent.NamespaceEntry, parent,
+				MakeProxyName (generic, loc), mod, null)
+		{
+			this.generic_method = generic;
+
+			if (generic != null) {
+				ArrayList list = new ArrayList ();
+				foreach (TypeParameter tparam in generic.CurrentTypeParameters) {
+					if (tparam.Constraints != null)
+						list.Add (tparam.Constraints.Clone ());
+				}
+				SetParameterInfo (list);
+			}
+		}
+
+		protected override bool DefineNestedTypes ()
+		{
+			RootContext.RegisterCompilerGeneratedType (TypeBuilder);
+			return base.DefineNestedTypes ();
+		}
+
+		public GenericMethod GenericMethod {
+			get { return generic_method; }
+		}
+
+		public abstract ConstructorInfo Constructor {
+			get;
+		}
+
+		public TypeExpr InflateType (Type it)
+		{
+			if (generic_method == null)
+				return new TypeExpression (it, Location);
+
+			if (it.IsGenericParameter && (it.DeclaringMethod != null)) {
+				int pos = it.GenericParameterPosition;
+				it = CurrentTypeParameters [pos].Type;
+			} else if (it.IsGenericType) {
+				Type[] args = it.GetGenericArguments ();
+
+				TypeArguments inflated = new TypeArguments (Location);
+				foreach (Type t in args)
+					inflated.Add (InflateType (t));
+
+				return new ConstructedType (it, inflated, Location);
+			} else if (it.IsArray) {
+				TypeExpr et_expr = InflateType (it.GetElementType ());
+				int rank = it.GetArrayRank ();
+
+				Type et = et_expr.ResolveAsTypeTerminal (this, false).Type;
+				it = et.MakeArrayType (rank);
+			}
+
+			return new TypeExpression (it, Location);
+		}
+
+		protected override bool DoDefineMembers ()
+		{
+			Report.Debug (64, "DO DEFINE MEMBERS", this, Name);
+			return base.DoDefineMembers ();
+		}
+	}
+
+	public class AnonymousMethodExpression : Expression
+	{
+		public readonly AnonymousMethod Anonymous;
+
+		public AnonymousMethodExpression (AnonymousMethod anon)
+		{
+			this.Anonymous = anon;
+			loc = anon.Location;
+		}
+
+		public override string ExprClassName {
+			get {
+				return "anonymous method";
+			}
+		}
+
+		public override Expression DoResolve (EmitContext ec)
+		{
+			//
+			// Set class type, set type
+			//
+
+			eclass = ExprClass.Value;
+
+			//
+			// This hack means `The type is not accessible
+			// anywhere', we depend on special conversion
+			// rules.
+			// 
+			type = TypeManager.anonymous_method_type;
+
+			if (!Anonymous.Resolve (ec))
+				return null;
+
+			return this;
+		}
+
+		public override void Emit (EmitContext ec)
+		{
+			// nothing, as we only exist to not do anything.
+		}
+	}
+
+	public abstract class AnonymousContainer : CompilerGeneratedClass
+	{
 		// Used to generate unique method names.
 		protected static int anonymous_method_count;
-		    
+
 		// An array list of AnonymousMethodParameter or null
 		public Parameters Parameters;
-		
+
 		//
 		// The block that makes up the body for the anonymous mehtod
 		//
@@ -43,13 +168,10 @@
 		//
 		public Method method;
 
-		protected MethodInfo invoke_mb;
-		
 		// The emit context for the anonymous method
-		public EmitContext aec;
-		public string[] TypeParameters;
 		public Type[] TypeArguments;
 		protected bool unreachable;
+		protected readonly Location loc;
 
 		// The method scope
 		ScopeInfo method_scope;
@@ -70,49 +192,40 @@
 		//
 		// Points to our container anonymous method if its present
 		//
-		public AnonymousContainer ContainerAnonymousMethod;	
+		public AnonymousContainer ContainerAnonymousMethod;
 
-		protected AnonymousContainer (Parameters parameters, ToplevelBlock container,
-					      ToplevelBlock block, Location l)
+		protected AnonymousContainer (AnonymousContainer parent, TypeContainer host,
+					      Parameters parameters, ToplevelBlock container,
+					      Location l)
+			: base (parent != null ? parent : host, null, 0, l)
 		{
+			ContainerAnonymousMethod = parent;
 			Parameters = parameters;
-			Block = block;
 			loc = l;
 
+			Report.Debug (64, "NEW ANONYMOUS CONTAINER", this, parent, host, host.Name,
+				      container);
+
+			host.AddCompilerGeneratedClass (this);
+
 			//
 			// The order is important: this setups the CaptureContext tree hierarchy.
 			//
-			if (container == null) {
+			if (container == null)
 				return;
-			}
+
 			container.SetHaveAnonymousMethods (l, this);
-			block.SetHaveAnonymousMethods (l, this);
+			container.RegisterAnonymousMethod (this);
 		}
 
-		protected AnonymousContainer (Parameters parameters, ToplevelBlock container,
-					      Location l):
-			this (parameters, container, new ToplevelBlock (container, parameters, l), l)
+		protected AnonymousContainer (TypeContainer host, Parameters parameters,
+					      ToplevelBlock container, Location l)
+			: this (null, host, parameters, container, l)
 		{
+			Block = new ToplevelBlock (container, parameters, l);
+			Block.SetHaveAnonymousMethods (l, this);
 		}
 
-		public override Expression DoResolve (EmitContext ec)
-		{
-			//
-			// Set class type, set type
-			//
-
-			eclass = ExprClass.Value;
-
-			//
-			// This hack means `The type is not accessible
-			// anywhere', we depend on special conversion
-			// rules.
-			// 
-			type = TypeManager.anonymous_method_type;
-
-			return this;
-		}
-
 		public void RegisterScope (ScopeInfo scope)
 		{
 			if (scopes_used.Contains (scope))
@@ -194,11 +307,20 @@
 				throw new Exception ("Internal error, AnonymousContainer.Scope is being used before its container is computed");
 			}
 		}
-		
-		
+
+		public bool CreateMethod (EmitContext ec)
+		{
+			if (method != null)
+				return true;
+
+			return CreateMethodHost (ec);
+		}
+
+		public abstract bool Resolve (EmitContext ec);
+
 		protected abstract bool CreateMethodHost (EmitContext ec);
 
-		public abstract void CreateScopeType (EmitContext ec, ScopeInfo scope);
+		public abstract CompilerGeneratedClass CreateScopeType (ScopeInfo scope);
 
 		public abstract Iterator Iterator {
 			get;
@@ -207,12 +329,70 @@
 		public abstract bool IsIterator {
 			get;
 		}
+
+		public override ConstructorInfo Constructor {
+			get { throw new InternalErrorException (); }
+		}
+
+		public ExpressionStatement GetScopeInitializer (Location loc)
+		{
+			return new AnonymousMethodScopeInitializer (this, loc);
+		}
+
+		protected class AnonymousMethodScopeInitializer : ExpressionStatement
+		{
+			AnonymousContainer am;
+
+			public AnonymousMethodScopeInitializer (AnonymousContainer am, Location loc)
+			{
+				this.am = am;
+				this.loc = loc;
+				eclass = ExprClass.Value;
+			}
+
+			public override Expression DoResolve (EmitContext ec)
+			{
+				ScopeInfo scope = am.Scope;
+				if (scope == null) {
+					type = am.Parent.TypeBuilder;
+					return this;
+				}
+
+				AnonymousContainer container = am.ContainerAnonymousMethod;
+				if ((container != null) && (scope == container.Scope)) {
+					type = scope.ScopeType;
+					return this;
+				}
+
+				return scope.GetScopeInitializer (ec);
+			}
+
+			public override void Emit (EmitContext ec)
+			{
+				ec.ig.Emit (OpCodes.Nop);
+
+				if (ec.IsStatic)
+					ec.ig.Emit (OpCodes.Ldnull);
+				else
+					ec.ig.Emit (OpCodes.Ldarg_0);
+			}
+
+			public override void EmitStatement (EmitContext ec)
+			{
+				Emit (ec);
+			}
+		}
 	}
 
 	public class AnonymousMethod : AnonymousContainer
 	{
 		TypeContainer host;
+		MethodInfo invoke_mb;
 
+		public EmitContext aec;
+
+		new public string[] TypeParameters;
+
 		//
 		// The value return by the Compatible call, this ensure that
 		// the code works even if invoked more than once (Resolve called
@@ -220,9 +400,10 @@
 		//
 		Expression anonymous_delegate;
 
-		public AnonymousMethod (TypeContainer host, Parameters parameters, ToplevelBlock container,
-					ToplevelBlock block, Location l)
-			: base (parameters, container, block, l)
+		public AnonymousMethod (AnonymousMethod parent, TypeContainer host,
+					Parameters parameters, ToplevelBlock container,
+					Location l)
+			: base (parent, host, parameters, container, l)
 		{
 			this.host = host;
 		}
@@ -235,11 +416,6 @@
 			get { return false; }
 		}
 
-		public override void Emit (EmitContext ec)
-		{
-			// nothing, as we only exist to not do anything.
-		}
-
 		//
 		// Creates the host for the anonymous method
 		//
@@ -247,30 +423,21 @@
 		{
 			ComputeMethodHost ();
 
-			//
-			// Crude hack follows: we replace the TypeBuilder during the
-			// definition to get the method hosted in the right class
-			//
-			TypeBuilder current_type = ec.TypeContainer.TypeBuilder;
-			TypeBuilder type_host = (Scope == null ) ? current_type : Scope.ScopeTypeBuilder;
+			if (method != null)
+				return true;
 
-			if (current_type == null)
-				throw new Exception ("The current_type is null");
-			
-			if (type_host == null)
-				throw new Exception (String.Format ("Type host is null, method_host is {0}", Scope == null ? "null" : "Not null"));
+			if ((Scope != null) && (Scope.HelperClass == null))
+				throw new InternalErrorException ();
 
-			if (current_type != type_host)
-				method_modifiers = Modifiers.INTERNAL;
-
-			if (current_type == type_host && ec.IsStatic){
+			method_modifiers = (Scope != null) ? Modifiers.INTERNAL : Modifiers.PRIVATE;
+			if ((Scope == null) && ec.IsStatic)
 				method_modifiers |= Modifiers.STATIC;
-				current_type = null;
-			} 
 
-			string name = "<#AnonymousMethod>" + anonymous_method_count++;
+			string name = "<>c__AnonymousMethod" + anonymous_method_count++;
 			MemberName member_name;
 
+			Report.Debug (64, "CREATE METHOD HOST", this, Scope, name);
+
 			GenericMethod generic_method = null;
 			if (TypeParameters != null) {
 				TypeArguments args = new TypeArguments (loc);
@@ -280,8 +447,7 @@
 				member_name = new MemberName (name, args, loc);
 
 				generic_method = new GenericMethod (
-					ec.DeclContainer.NamespaceEntry,
-					(TypeContainer) ec.TypeContainer, member_name,
+					NamespaceEntry, this, member_name,
 					new TypeExpression (invoke_mb.ReturnType, loc),
 					Parameters);
 
@@ -290,21 +456,12 @@
 				member_name = new MemberName (name, loc);
 
 			method = new Method (
-				(TypeContainer) ec.TypeContainer, generic_method,
+				this, generic_method,
 				new TypeExpression (invoke_mb.ReturnType, loc),
 				method_modifiers, false, member_name, Parameters, null);
 			method.Block = Block;
 
-			//
-			// Swap the TypeBuilder while we define the method, then restore
-			//
-			if (current_type != null)
-				ec.TypeContainer.TypeBuilder = type_host;
-			bool res = method.Define ();
-			if (current_type != null)
-				ec.TypeContainer.TypeBuilder = current_type;
-
-			return res;
+			return method.Define ();
 		}
 
 		void Error_ParameterMismatch (Type t)
@@ -319,7 +476,7 @@
 				return true;
 
 			MethodGroupExpr invoke_mg = Delegate.GetInvokeMethod (host.TypeBuilder, delegate_type, loc);
-			invoke_mb = (MethodInfo) invoke_mg.Methods [0];
+			MethodInfo invoke_mb = (MethodInfo) invoke_mg.Methods [0];
 			ParameterData invoke_pd = TypeManager.GetParameterData (invoke_mb);
 
 			if (Parameters.Count != invoke_pd.Count)
@@ -340,7 +497,7 @@
 		{
 			if (anonymous_delegate != null)
 				return anonymous_delegate;
-			
+
 			//
 			// At this point its the first time we know the return type that is 
 			// needed for the anonymous method.  We create the method here.
@@ -408,7 +565,7 @@
 					}
 				}
 			}
-			
+
 			//
 			// Second: the return type of the delegate must be compatible with 
 			// the anonymous type.   Instead of doing a pass to examine the block
@@ -439,42 +596,49 @@
 			return null;
 		}
 
-		public override Expression DoResolve (EmitContext ec)
+		public override bool Resolve (EmitContext ec)
 		{
 			if (!ec.IsAnonymousMethodAllowed) {
-				Report.Error (1706, loc, "Anonymous methods are not allowed in the attribute declaration");
-				return null;
+				Report.Error (1706, loc,
+					      "Anonymous methods are not allowed in the attribute declaration");
+				return false;
 			}
 
-			if (Parameters != null && !Parameters.Resolve (ec)) {
-				return null;
-			}
+			if ((Parameters != null) && !Parameters.Resolve (ec))
+				return false;
 
-			return base.DoResolve (ec);
+			return true;
 		}
 
-
-		public override string ExprClassName {
-			get {
-				return "anonymous method";
-			}
-		}
-
 		public MethodInfo GetMethodBuilder ()
 		{
 			MethodInfo builder = method.MethodBuilder;
+			return builder;
+
+#if FIXME
 			if (TypeArguments != null)
 				return builder.MakeGenericMethod (TypeArguments);
-			else
+#endif
+
+			GenericMethod generic = ContainingBlock.Toplevel.GenericMethod;
+			if (generic != null) {
+				TypeParameter[] tparams = generic.TypeParameters;
+				Type[] targs = new Type [tparams.Length];
+				for (int i = 0 ; i < tparams.Length; i++)
+					targs [i] = tparams [i].Type;
+
+				Type scope_type = builder.DeclaringType.MakeGenericType (targs);
+
+				MethodGroupExpr mg = (MethodGroupExpr) Expression.MemberLookup (
+					scope_type, scope_type, builder.Name, loc);
+				if (mg == null)
+					throw new InternalErrorException ();
+
+				return (MethodInfo) mg.Methods [0];
+			} else
 				return builder;
 		}
 
-		public override string GetSignatureForError ()
-		{
-			string s = TypeManager.CSharpSignature (invoke_mb);
-			return s.Substring (0, s.IndexOf (".Invoke("));
-		}
-		
 		public bool EmitMethod (EmitContext ec)
 		{
 			if (!CreateMethodHost (ec))
@@ -497,50 +661,29 @@
 			return true;
 		}
 
-		public override void CreateScopeType (EmitContext ec, ScopeInfo scope)
+		public override CompilerGeneratedClass CreateScopeType (ScopeInfo scope)
 		{
-			TypeBuilder container = ec.TypeContainer.TypeBuilder;
-			string name = String.Format ("<>AnonHelp<{0}>", scope.id);
+			Report.Debug (64, "CREATE SCOPE TYPE", this, scope, scope.ParentScope);
 
-			scope.ScopeTypeBuilder = container.DefineNestedType (name,
-				TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit | TypeAttributes.NestedPrivate,
-					 TypeManager.object_type);
+			if (scope.ParentScope == null) {
+				if (!Define ())
+					return null;
+				if (DefineType () == null)
+					return null;
+				return this;
+			}
 
-			Type [] constructor_types = Type.EmptyTypes;
-			ConstructorBuilder ctor = scope.ScopeTypeBuilder.DefineConstructor (
-				MethodAttributes.Public | MethodAttributes.HideBySig |
-				MethodAttributes.SpecialName | MethodAttributes.RTSpecialName,
-				CallingConventions.HasThis, constructor_types);
-			TypeManager.RegisterMethod (ctor, Parameters.EmptyReadOnlyParameters);
+			AnonymousHelper helper = new AnonymousHelper (this);
 
-			ILGenerator cig = ctor.GetILGenerator ();
-			cig.Emit (OpCodes.Ldarg_0);
-			cig.Emit (OpCodes.Call, TypeManager.object_ctor);
-			cig.Emit (OpCodes.Ret);
+			if (!helper.Define ())
+				return null;
 
-			if (ec.TypeContainer.IsGeneric) {
-				TypeParameter[] tparam = ec.TypeContainer.TypeParameters;
-				string[] names = new string [tparam.Length];
-				Type[] types = new Type [tparam.Length];
+			if (helper.DefineType () == null)
+				return null;
 
-				for (int i = 0; i < names.Length; i++) {
-					names [i] = tparam [i].Name;
-					types [i] = tparam [i].Type;
-				}
+			AddCompilerGeneratedClass (helper);
 
-				scope.ScopeTypeBuilder.DefineGenericParameters (names);
-				scope.ScopeTypeBuilder.GetGenericTypeDefinition ();
-
-				scope.ScopeType = scope.ScopeTypeBuilder.MakeGenericType (types);
-			} else
-				scope.ScopeType = scope.ScopeTypeBuilder;
-
-
-			if (ec.TypeContainer.IsGeneric)
-				scope.ScopeConstructor = TypeBuilder.GetConstructor (
-					scope.ScopeType, ctor);
-			else
-				scope.ScopeConstructor = ctor;
+			return helper;
 		}
 
 		public static void Error_AddressOfCapturedVar (string name, Location loc)
@@ -549,6 +692,30 @@
 				"Local variable `{0}' or its members cannot have their address taken and be used inside an anonymous method block",
 				name);
 		}
+
+		protected class AnonymousHelper : CompilerGeneratedClass
+		{
+			ConstructorInfo ctor;
+
+			public AnonymousHelper (AnonymousMethod anonymous)
+				: base (anonymous,
+					anonymous.ContainingBlock.Toplevel.GenericMethod,
+					Modifiers.PUBLIC, anonymous.Location)
+			{ }
+
+			protected override bool DoDefineMembers ()
+			{
+				if (!base.DoDefineMembers ())
+					return false;
+
+				ctor = default_constructor.ConstructorBuilder;
+				return true;
+			}
+
+			public override ConstructorInfo Constructor {
+				get { return ctor; }
+			}
+		}
 	}
 
 	//
@@ -573,54 +740,122 @@
 		
 		public override void Emit (EmitContext ec)
 		{
+			Report.Debug (64, "ANONYMOUS DELEGATE", this, am, ec.ContainerType, type,
+				      ec, ec.capture_context, loc);
+
 			if (!am.EmitMethod (ec))
 				return;
 
 			//
 			// Now emit the delegate creation.
 			//
-			if ((am.method.ModFlags & Modifiers.STATIC) == 0)
-				delegate_instance_expression = new AnonymousInstance (am);
-			
+			if ((am.method.ModFlags & Modifiers.STATIC) == 0) {
+				delegate_instance_expression = am.GetScopeInitializer (loc).Resolve (ec);
+				Report.Debug (64, "ANONYMOUS DELEGATE #0", this,
+					      delegate_instance_expression);
+
+				if (delegate_instance_expression == null)
+					throw new InternalErrorException ();
+			}
+
 			Expression ml = Expression.MemberLookup (ec.ContainerType, type, ".ctor", loc);
 			constructor_method = ((MethodGroupExpr) ml).Methods [0];
 			delegate_method = am.GetMethodBuilder ();
+			Report.Debug (64, "ANONYMOUS DELEGATE #1", constructor_method, delegate_method);
 			base.Emit (ec);
 		}
+	}
 
-		class AnonymousInstance : Expression {
-			AnonymousMethod am;
-			
-			public AnonymousInstance (AnonymousMethod am)
-			{
-				this.am = am;
-				eclass = ExprClass.Value;
-			}
-
-			public override Expression DoResolve (EmitContext ec)
-			{
-				return this;
-			}
-			
-			public override void Emit (EmitContext ec)
-			{
-				am.aec.EmitMethodHostInstance (ec, am);
-			}
+	class CapturedVariable : Field
+	{
+		public CapturedVariable (ScopeInfo scope, string name, Type type)
+			: base (scope.HelperClass, scope.HelperClass.InflateType (type),
+				Modifiers.INTERNAL, name, null, scope.loc)
+		{
+			scope.HelperClass.AddField (this);
 		}
 	}
 
 	class CapturedParameter {
-		public Type Type;
-		public FieldBuilder FieldBuilder;
-		public int Idx;
+		public readonly Parameter Parameter;
+		public readonly Field Field;
+		public readonly int Idx;
 
-		public CapturedParameter (Type type, int idx)
+		public CapturedParameter (ScopeInfo scope, Parameter par, int idx)
 		{
-			Type = type;
+			this.Parameter = par;
 			Idx = idx;
+			Field = new CapturedVariable (scope, "<p:" + par.Name + ">", par.ParameterType);
 		}
 	}
 
+	public class CapturedParameterReference : Expression, IAssignMethod, IMemoryLocation, IVariable
+	{
+		ScopeInfo scope;
+		CapturedParameter cp;
+		VariableInfo vi;
+		bool prepared;
+
+		internal CapturedParameterReference (ScopeInfo scope, CapturedParameter cp,
+						     Location loc)
+		{
+			this.scope = scope;
+			this.cp = cp;
+			this.loc = loc;
+
+			type = cp.Field.MemberType;
+			eclass = ExprClass.Variable;
+		}
+
+		public VariableInfo VariableInfo {
+			get { return vi; }
+		}
+
+		public override Expression DoResolve (EmitContext ec)
+		{
+			// We are born fully resolved.
+			return this;
+		}
+
+		public override Expression DoResolveLValue (EmitContext ec, Expression right_side)
+		{
+			// We are born fully resolved.
+			return this;
+		}
+
+		LocalTemporary temp;
+
+		public override void Emit (EmitContext ec)
+		{
+			Emit (ec, false);
+		}
+
+		public void Emit (EmitContext ec, bool leave_copy)
+		{
+			scope.CaptureContext.EmitParameter (
+				ec, cp.Parameter.Name, leave_copy, prepared, ref temp);
+		}
+
+		public void EmitAssign (EmitContext ec, Expression source, bool leave_copy,
+					bool prepare_for_load)
+		{
+			prepared = prepare_for_load;
+			scope.CaptureContext.EmitAssignParameter (
+				ec, cp.Parameter.Name, source, leave_copy, prepare_for_load, ref temp);
+		}
+
+		public void AddressOf (EmitContext ec, AddressOp mode)
+		{
+			scope.CaptureContext.EmitAddressOfParameter (ec, cp.Parameter.Name);
+		}
+
+		public bool VerifyFixed ()
+		{
+			// A parameter is fixed if it's a value parameter (i.e., no modifier like out, ref, param).
+			return cp.Parameter.ModFlags == Parameter.Modifier.NONE;
+		}
+	}
+
 	//
 	// Here we cluster all the variables captured on a given scope, we also
 	// keep some extra information that might be required on each scope.
@@ -629,7 +864,6 @@
 		public CaptureContext CaptureContext;
 		public ScopeInfo ParentScope;
 		public Block ScopeBlock;
-		public bool NeedThis = false;
 		public bool HostsParameters = false;
 		
 		// For tracking the number of scopes created.
@@ -643,22 +877,21 @@
 		//
 		// The types and fields generated
 		//
+		public readonly Location loc;
 		public TypeBuilder ScopeTypeBuilder;
 		public Type ScopeType;
-		public ConstructorInfo ScopeConstructor;
-		public FieldBuilder THIS;
-		public FieldBuilder ParentLink;
+		public Field THIS;
+		public Field ParentLink;
 
-		//
-		// Points to the object of type `ScopeTypeBuilder' that
-		// holds the data for the scope
-		//
-		LocalBuilder scope_instance;
+		public CompilerGeneratedClass HelperClass;
+
+		ExpressionStatement scope_instance;
 		
-		public ScopeInfo (CaptureContext cc, Block b)
+		public ScopeInfo (CaptureContext cc, Block block)
 		{
 			CaptureContext = cc;
-			ScopeBlock = b;
+			ScopeBlock = block;
+			loc = cc.loc;
 			id = count++;
 
 			cc.RegisterCaptureContext ();
@@ -719,8 +952,6 @@
 			Pad ();
 			Console.WriteLine ("START");
 			indent++;
-			Pad ();
-			Console.WriteLine ("NeedThis=" + NeedThis);
 			foreach (LocalInfo li in locals){
 				Pad ();
 				Console.WriteLine ("var {0}", MakeFieldName (li.Name));
@@ -738,64 +969,104 @@
 			return "<" + id + ":" + local_name + ">";
 		}
 
+		bool resolved;
+
+		public void CreateScopeType ()
+		{
+			if (HelperClass != null)
+				return;
+
+			if (ParentScope != null)
+				ParentScope.CreateScopeType ();
+
+			HelperClass = CaptureContext.Host.CreateScopeType (this);
+			ScopeTypeBuilder = HelperClass.TypeBuilder;
+
+			ScopeType = (HelperClass.CurrentType != null) ?
+				HelperClass.CurrentType : HelperClass.TypeBuilder;
+		}
+
 		public void EmitScopeType (EmitContext ec)
 		{
 			// EmitDebug ();
 
-			if (ScopeTypeBuilder != null)
+			if (resolved)
 				return;
-			
-			Type container;
-			if (ec.TypeContainer.CurrentType != null)
-				container = ec.TypeContainer.CurrentType;
-			else
-				container = ec.TypeContainer.TypeBuilder;
 
-			CaptureContext.Host.CreateScopeType (ec, this);
-			
-			if (NeedThis)
-				THIS = ScopeTypeBuilder.DefineField ("<>THIS", container, FieldAttributes.Assembly);
+			Report.Debug (64, "EMIT SCOPE TYPE", this, HelperClass, CaptureContext,
+				      CaptureContext.NeedThis, ParentScope, ScopeTypeBuilder);
 
+			if (ParentScope != null)
+				ParentScope.EmitScopeType (ec);
+			else if (CaptureContext.NeedThis) {
+				Type container;
+				if (ec.TypeContainer.CurrentType != null)
+					container = ec.TypeContainer.CurrentType;
+				else
+					container = ec.TypeContainer.TypeBuilder;
+
+				THIS = new CapturedVariable (this, "<>THIS", container);
+			}
+
 			if (ParentScope != null){
 				if (ParentScope.ScopeTypeBuilder == null){
-					throw new Exception (String.Format ("My parent has not been initialized {0} and {1}", ParentScope, this));
+					throw new InternalErrorException (
+						"My parent has not been initialized " +
+						"{0} and {1}", ParentScope, this);
 				}
 
-				if (ParentScope.ScopeTypeBuilder != ScopeTypeBuilder)
-					ParentLink = ScopeTypeBuilder.DefineField (
-						"<>parent", ParentScope.ScopeType, FieldAttributes.Assembly);
+				if ((ParentScope.CaptureContext.Host == CaptureContext.Host) &&
+				    (ParentScope.ScopeTypeBuilder != ScopeTypeBuilder))
+					ParentLink = new CapturedVariable (
+						this, "<>parent", ParentScope.ScopeType);
 			}
 			
-			if (NeedThis && ParentScope != null)
-				throw new Exception ("I was not expecting THIS && having a parent");
+			foreach (LocalInfo info in locals) {
+				info.Field = new CapturedVariable (
+					this, MakeFieldName (info.Name), info.VariableType);
+			}
 
-			foreach (LocalInfo info in locals)
-				info.FieldBuilder = ScopeTypeBuilder.DefineField (
-					MakeFieldName (info.Name), info.VariableType, FieldAttributes.Assembly);
-
+#if FIXME
 			if (HostsParameters){
 				Hashtable captured_parameters = CaptureContext.captured_parameters;
 				
 				foreach (DictionaryEntry de in captured_parameters){
 					string name = (string) de.Key;
 					CapturedParameter cp = (CapturedParameter) de.Value;
-					FieldBuilder fb;
-					
-					fb = ScopeTypeBuilder.DefineField ("<p:" + name + ">", cp.Type, FieldAttributes.Assembly);
-					cp.FieldBuilder = fb;
+
+					cp.Field = new CapturedVariable (
+						this, "<p:" + name + ">", cp.Type);
 				}
 			}
+#endif
 
-			foreach (ScopeInfo si in children){
+			resolved = true;
+
+			if (!(CaptureContext.Host.IsIterator)) {
+				HelperClass.ResolveType ();
+				HelperClass.DefineMembers ();
+			}
+
+			foreach (ScopeInfo si in children) {
 				si.EmitScopeType (ec);
 			}
+
+#if FIXME
+			if (NeedThis && ParentScope != null)
+				throw new InternalErrorException (
+					"I was not expecting THIS && having a parent");
+#endif
 		}
 
-		public void CloseTypes ()
+		public ExpressionStatement GetScopeInitializer (EmitContext ec)
 		{
-			RootContext.RegisterCompilerGeneratedType (ScopeTypeBuilder);
-			foreach (ScopeInfo si in children)
-				si.CloseTypes ();
+			if (scope_instance == null) {
+				scope_instance = new ScopeInitializer (this, loc);
+				if (scope_instance.Resolve (ec) == null)
+					throw new InternalErrorException ();
+			}
+
+			return scope_instance;
 		}
 
 		//
@@ -805,15 +1076,19 @@
 		{
 			ILGenerator ig = ec.ig;
 
+			return;
+
 			if (inited)
 				return;
 
-			if (ScopeConstructor == null)
-				throw new Exception ("ScopeConstructor is null for" + this.ToString ());
+			if (HelperClass == null)
+				throw new InternalErrorException (
+					"HelperClass is null for " + this.ToString ());
 			
+#if FIXME
 			if (!CaptureContext.Host.IsIterator) {
 				scope_instance = ig.DeclareLocal (ScopeType);
-				ig.Emit (OpCodes.Newobj, ScopeConstructor);
+				ig.Emit (OpCodes.Newobj, HelperClass.Constructor);
 				ig.Emit (OpCodes.Stloc, scope_instance);
 			}
 
@@ -825,8 +1100,9 @@
 					ig.Emit (OpCodes.Ldloc, scope_instance);
 					ig.Emit (OpCodes.Ldarg_0);
 				}
-				ig.Emit (OpCodes.Stfld, THIS);
+				ig.Emit (OpCodes.Stfld, THIS.FieldBuilder);
 			}
+#endif
 
 			//
 			// Copy the parameter values, if any
@@ -840,9 +1116,9 @@
 				foreach (DictionaryEntry de in captured_parameters){
 					CapturedParameter cp = (CapturedParameter) de.Value;
 
-					EmitScopeInstance (ig);
+					EmitScopeInstance (ec);
 					ParameterReference.EmitLdArg (ig, cp.Idx + extra);
-					ig.Emit (OpCodes.Stfld, cp.FieldBuilder);
+					ig.Emit (OpCodes.Stfld, cp.Field.FieldBuilder);
 				}
 			}
 
@@ -855,25 +1131,25 @@
 					// Only emit initialization in our capturecontext world
 					//
 					if (ParentScope.CaptureContext == CaptureContext){
-						EmitScopeInstance (ig);
-						ParentScope.EmitScopeInstance (ig);
-						ig.Emit (OpCodes.Stfld, ParentLink);
+						EmitScopeInstance (ec);
+						ParentScope.EmitScopeInstance (ec);
+						ig.Emit (OpCodes.Stfld, ParentLink.FieldBuilder);
 					} else {
-						EmitScopeInstance (ig);
+						EmitScopeInstance (ec);
 						ig.Emit (OpCodes.Ldarg_0);
-						ig.Emit (OpCodes.Stfld, ParentLink);
+						ig.Emit (OpCodes.Stfld, ParentLink.FieldBuilder);
 					}
 				}
 			}
 			inited = true;
 		}
 
-		public void EmitScopeInstance (ILGenerator ig)
+		public void EmitScopeInstance (EmitContext ec)
 		{
 			if (CaptureContext.Host.IsIterator)
-				ig.Emit (OpCodes.Ldarg_0);
+				ec.ig.Emit (OpCodes.Ldarg_0);
 			else {
-				if (scope_instance == null){
+				if (scope_instance == null) {
 					//
 					// This is needed if someone overwrites the Emit method
 					// of Statement and manually calls Block.Emit without
@@ -882,16 +1158,9 @@
 					//   ec.EmitScopeInitFromBlock (The_Block);
 					//   The_Block.Emit (ec);
 					// 
-
-					Console.WriteLine (
-				        	"The scope_instance has not been emitted, this typically means\n" +
-						"that inside the compiler someone is calling Block.Emit without\n" +
-						"first calling EmitScopeInitFromBlock for the block.  See compiler" +
-						"source code for an explanation");
-					throw new Exception ("Internal compiler error");
-					
+					throw new InternalErrorException ();
 				}
-				ig.Emit (OpCodes.Ldloc, scope_instance);
+				scope_instance.Emit (ec);
 			}
 		}
 
@@ -935,6 +1204,205 @@
 
 			return sb.ToString ();
 		}
+
+		protected class ScopeInitializer : ExpressionStatement
+		{
+			ScopeInfo scope;
+			TypeExpr scope_type;
+			LocalTemporary scope_instance;
+			Expression scope_ctor;
+
+			FieldExpr this_field;
+			Hashtable captured_params;
+
+			FieldExpr parent_field;
+			Expression parent_init;
+
+			public ScopeInitializer (ScopeInfo scope, Location loc)
+			{
+				this.scope = scope;
+				this.loc = loc;
+				eclass = ExprClass.Value;
+			}
+
+			public LocalTemporary ScopeInstance {
+				get { return scope_instance; }
+			}
+
+			public ScopeInfo Scope {
+				get { return scope; }
+			}
+
+			public bool IsIterator {
+				get { return scope.CaptureContext.Host.IsIterator; }
+			}
+
+			public override Expression DoResolve (EmitContext ec)
+			{
+				if (scope_type != null)
+					return this;
+
+				Scope.EmitScopeType (ec);
+
+				if (Scope.HelperClass == null)
+					throw new InternalErrorException (
+						"HelperClass is null for " + Scope.ToString ());
+
+				Report.Debug (64, "RESOLVE SCOPE INITIALIZER", this, Scope, ec,
+					      ec.TypeContainer.Name);
+
+				if (ec.DeclContainer.IsGeneric)
+					scope_type = new ConstructedType (
+						Scope.ScopeType, ec.DeclContainer.TypeParameters, loc);
+				else
+					scope_type = new TypeExpression (Scope.ScopeType, loc);
+
+				scope_type = scope_type.ResolveAsTypeTerminal (ec, false);
+				if ((scope_type == null) || (scope_type.Type == null))
+					throw new InternalErrorException ();
+				type = scope_type.Type;
+
+				if (!IsIterator) {
+					scope_instance = new LocalTemporary (type);
+					scope_ctor = new New (scope_type, null, loc).Resolve (ec);
+					if (scope_ctor == null)
+						throw new InternalErrorException ();
+				}
+
+				if (Scope.THIS != null) {
+					this_field = (FieldExpr) Expression.MemberLookup (
+						ec.ContainerType, type, "<>THIS", loc);
+					Report.Debug (64, "RESOLVE SCOPE INITIALIZER #1", this, Scope, ec,
+						      ec.ContainerType, type, this_field,
+						      Scope.ParentScope);
+					if (this_field == null)
+						throw new InternalErrorException ();
+				}
+
+				if ((Scope.ParentScope != null) &&
+				    (Scope.ParentScope.CaptureContext.Host == Scope.CaptureContext.Host) &&
+				    (Scope.ParentScope.ScopeTypeBuilder != Scope.ScopeTypeBuilder)) {
+					parent_field = (FieldExpr) Expression.MemberLookup (
+						ec.ContainerType, type, "<>parent", loc);
+					if (parent_field == null)
+						throw new InternalErrorException ();
+
+					parent_init = Scope.ParentScope.GetScopeInitializer (ec);
+					if (parent_init == null)
+						throw new InternalErrorException ();
+
+					parent_field.InstanceExpression = this;
+					if (parent_field.ResolveLValue (ec, parent_init, loc) == null)
+						throw new InternalErrorException ();
+				}
+
+				//
+				// Copy the parameter values, if any
+				//
+				int extra = ec.IsStatic ? 0 : 1;
+				if (IsIterator)
+					extra++;
+				if (Scope.HostsParameters){
+					Hashtable hash = Scope.CaptureContext.captured_parameters;
+					captured_params = new Hashtable ();
+					foreach (CapturedParameter cp in hash.Values) {
+						FieldExpr fe = (FieldExpr) Expression.MemberLookup (
+							ec.ContainerType, type, cp.Field.Name, loc);
+						if (fe == null)
+							throw new InternalErrorException ();
+
+						captured_params.Add (cp.Idx + extra, fe);
+					}
+				}
+
+				return this;
+			}
+
+			bool initialized;
+
+			protected void EmitScopeInstance (EmitContext ec)
+			{
+				if (IsIterator)
+					ec.ig.Emit (OpCodes.Ldarg_0);
+				else {
+					try {
+						scope_instance.Emit (ec);
+					} catch {
+						Report.Debug (64, "EMIT SCOPE INSTANCE FUCK",
+							      this, Scope, ec);
+						Report.StackTrace ();
+
+						ec.ig.Emit (OpCodes.Ldarg_0);
+
+						// ec.ig.Emit (OpCodes.Neg);
+						// ec.ig.Emit (OpCodes.Not);
+						// ec.ig.Emit (OpCodes.Neg);
+					}
+				}
+			}
+
+			static int next_id;
+			int id = ++next_id;
+
+			protected void DoEmit (EmitContext ec)
+			{
+				if (initialized)
+					return;
+				initialized = true;
+
+				Report.Debug (64, "EMIT SCOPE INIT", this, id,
+					      Scope, scope_instance, ec);
+
+				ec.ig.Emit (OpCodes.Nop);
+				ec.ig.Emit (OpCodes.Ldc_I4, id);
+				ec.ig.Emit (OpCodes.Pop);
+				ec.ig.Emit (OpCodes.Nop);
+
+				if (!IsIterator) {
+					scope_ctor.Emit (ec);
+					scope_instance.Store (ec);
+				}
+
+				if (Scope.THIS != null) {
+					if (IsIterator) {
+						ec.ig.Emit (OpCodes.Ldarg_0);
+						ec.ig.Emit (OpCodes.Ldarg_1);
+					} else {
+						scope_instance.Emit (ec);
+						ec.ig.Emit (OpCodes.Ldarg_0);
+					}
+					ec.ig.Emit (OpCodes.Stfld, this_field.FieldInfo);
+				}
+
+				if (Scope.HostsParameters) {
+					foreach (DictionaryEntry de in captured_params) {
+						FieldExpr fe = (FieldExpr) de.Value;
+						int idx = (int) de.Key;
+
+						EmitScopeInstance (ec);
+						ParameterReference.EmitLdArg (ec.ig, idx);
+						ec.ig.Emit (OpCodes.Stfld, fe.FieldInfo);
+					}
+				}
+
+				if (parent_field != null) {
+					Report.Debug (64, "EMIT SCOPE INIT PARENT", this, Scope,
+						      Scope.ParentScope, parent_init, parent_field, ec);
+					parent_field.EmitAssign (ec, parent_init, false, false);
+				}
+			}
+
+			public override void Emit (EmitContext ec)
+			{
+				DoEmit (ec);
+				EmitScopeInstance (ec);
+			}
+
+			public override void EmitStatement (EmitContext ec)
+			{
+				DoEmit (ec);
+			}
+		}
 	}
 
 	//
@@ -980,10 +1448,8 @@
 		{
 			cc_id = count++;
 			this.toplevel_owner = toplevel_owner;
+			this.Host = host;
 			this.loc = loc;
-
-			if (host != null)
-				Host = host;
 		}
 
 		void DoPath (StringBuilder sb, CaptureContext cc)
@@ -1034,13 +1500,19 @@
 			ScopeInfo si = (ScopeInfo) scopes [block.ID];
 			if (si != null)
 				return si;
-			si = new ScopeInfo (this, block);
+			Report.Debug (64, "GET SCOPE FOR BLOCK", this, block, block.Parent);
+
+			block.ScopeInfo = si = new ScopeInfo (this, block);
+			si.CreateScopeType ();
 			scopes [block.ID] = si;
 			return si;
 		}
 		
 		public void AddLocal (AnonymousContainer am, LocalInfo li)
 		{
+			Report.Debug (64, "ADD LOCAL", this, li.Name, loc, li.Block,
+				      li.Block.Toplevel, toplevel_owner);
+
 			if (li.Block.Toplevel != toplevel_owner){
 				ParentCaptureContext.AddLocal (am, li);
 				return;
@@ -1093,27 +1565,32 @@
 		//
 		// Records the captured parameter at the appropriate CaptureContext
 		//
-		public void AddParameter (EmitContext ec, AnonymousContainer am,
-					  string name, Type t, int idx)
+		public Expression AddParameter (EmitContext ec, Parameter par, int idx, Location loc)
 		{
-			CaptureContext cc = ContextForParameter (ec.CurrentBlock.Toplevel, name);
-
-			cc.AddParameterToContext (am, name, t, idx);
+			CaptureContext cc = ContextForParameter (ec.CurrentBlock.Toplevel, par.Name);
+			return cc.AddParameterToContext (ec.CurrentAnonymousMethod, par, idx, loc);
 		}
 
 		//
 		// Records the parameters in the context
 		//
-		public void AddParameterToContext (AnonymousContainer am, string name, Type t, int idx)
+		public Expression AddParameterToContext (AnonymousContainer am, Parameter par,
+							 int idx, Location loc)
 		{
 			if (captured_parameters == null)
 				captured_parameters = new Hashtable ();
-			if (captured_parameters [name] == null)
-				captured_parameters [name] = new CapturedParameter (t, idx);
 
 			ScopeInfo scope = GetScopeForBlock (toplevel_owner);
 			scope.HostsParameters = true;
 			am.RegisterScope (scope);
+
+			CapturedParameter cp = (CapturedParameter) captured_parameters [par.Name];
+			if (cp == null) {
+				cp = new CapturedParameter (scope, par, idx);
+				captured_parameters.Add (par.Name, cp);
+			}
+
+			return new CapturedParameterReference (scope, cp, loc);
 		}
 
 		//
@@ -1164,6 +1641,10 @@
 			}
 		}
 
+		public bool NeedThis {
+			get { return HaveCapturedFields || referenced_this; }
+		}
+
 		public bool IsCaptured (LocalInfo local)
 		{
 			foreach (ScopeInfo si in scopes.Values){
@@ -1188,45 +1669,36 @@
 
 		public void EmitAnonymousHelperClasses (EmitContext ec)
 		{
-			if (roots.Count != 0){
-				foreach (ScopeInfo root in roots){
-					//
-					// FIXME: We really should do this in a per-ScopeInfo
-					// basis, instead of having the NeedThis applied to
-					// all of the roots.
-					//
-					root.NeedThis = HaveCapturedFields || referenced_this;
-					
+#if FIXME
+			Host.ResolveType ();
+			Host.DefineMembers ();
+#endif
+
+			if (roots.Count != 0) {
+				foreach (ScopeInfo root in roots)
 					root.EmitScopeType (ec);
-				}
 			} 
 		}
 
-		public void CloseAnonymousHelperClasses ()
+#if FIXME
+		protected void EmitInitScope (EmitContext ec)
 		{
+			EmitAnonymousHelperClasses (ec);
 			if (roots.Count != 0)
 				foreach (ScopeInfo root in roots)
-					root.CloseTypes ();
+					root.EmitInitScope (ec);
 		}
+#endif
 
-		public void EmitInitScope (EmitContext ec)
+		public ExpressionStatement GetScopeInitializerForBlock (EmitContext ec, Block b)
 		{
-			EmitAnonymousHelperClasses (ec);
-			if (roots.Count != 0)
-				foreach (ScopeInfo root in roots)
-					root.EmitInitScope (ec);		}
-
-		//
-		// This is called externally when we start emitting code for a block
-		// if the block has a ScopeInfo associated, emit the init code
-		//
-		public void EmitScopeInitFromBlock (EmitContext ec, Block b)
-		{
+			Report.Debug (64, "GET SCOPE INIT FOR BLOCK", this, Host, b);
 			ScopeInfo si = (ScopeInfo) scopes [b.ID];
 			if (si == null)
-				return;
+				return null;
 
-			si.EmitInitScope (ec);
+			Report.Debug (64, "GET SCOPE INIT FOR BLOCK #1", this, Host, b, si);
+			return si.GetScopeInitializer (ec);
 		}
 		
 		//
@@ -1241,7 +1713,7 @@
 
 			if (li.Block.Toplevel == toplevel_owner){
 				si = (ScopeInfo) scopes [li.Block.ID];
-				si.EmitScopeInstance (ig);
+				si.EmitScopeInstance (ec);
 				return;
 			}
 
@@ -1254,13 +1726,14 @@
 
 				while (si.ScopeBlock.ID != li.Block.ID){
 					if (si.ParentLink != null)
-						ig.Emit (OpCodes.Ldfld, si.ParentLink);
+						ig.Emit (OpCodes.Ldfld, si.ParentLink.FieldBuilder);
 					si = si.ParentScope;
 					if (si == null) {
 						si = am.Scope;
-						Console.WriteLine ("Target: {0} {1}", li.Block.ID, li.Name);
+						Console.WriteLine ("Target: {0} {1}", li.Block, li.Name);
 						while (si.ScopeBlock.ID != li.Block.ID){
-							Console.WriteLine ("Trying: {0}", si.ScopeBlock.ID);
+							Console.WriteLine ("Trying: {0} {1}",
+									   si, si.ScopeBlock);
 							si = si.ParentScope;
 						}
 
@@ -1295,7 +1768,7 @@
 
 			if (ec.CurrentBlock.Toplevel == toplevel_owner) {
 				si = (ScopeInfo) scopes [toplevel_owner.ID];
-				si.EmitScopeInstance (ig);
+				si.EmitScopeInstance (ec);
 			} else {
 				si = ec.CurrentAnonymousMethod.Scope;
 				ig.Emit (OpCodes.Ldarg_0);
@@ -1303,7 +1776,7 @@
 
 			if (si != null){
 				while (si.ParentLink != null) {
-					ig.Emit (OpCodes.Ldfld, si.ParentLink);
+					ig.Emit (OpCodes.Ldfld, si.ParentLink.FieldBuilder);
 					si = si.ParentScope;
 				} 
 			}
@@ -1328,11 +1801,11 @@
 				// FIXME: implementing this.
 				//
 			}
-			ec.ig.Emit (OpCodes.Ldfld, par_info.FieldBuilder);
+			ec.ig.Emit (OpCodes.Ldfld, par_info.Field.FieldBuilder);
 
 			if (leave_copy){
 				ec.ig.Emit (OpCodes.Dup);
-				temp = new LocalTemporary (par_info.FieldBuilder.FieldType);
+				temp = new LocalTemporary (par_info.Field.MemberType);
 				temp.Store (ec);
 			}
 		}
@@ -1357,10 +1830,10 @@
 			source.Emit (ec);
 			if (leave_copy){
 				ig.Emit (OpCodes.Dup);
-				temp = new LocalTemporary (par_info.FieldBuilder.FieldType);
+				temp = new LocalTemporary (par_info.Field.MemberType);
 				temp.Store (ec);
 			}
-			ig.Emit (OpCodes.Stfld, par_info.FieldBuilder);
+			ig.Emit (OpCodes.Stfld, par_info.Field.FieldBuilder);
 			if (temp != null)
 				temp.Emit (ec);
 		}
@@ -1378,29 +1851,9 @@
 			}
 			EmitParameterInstance (ec, name);
 			CapturedParameter par_info = (CapturedParameter) captured_parameters [name];
-			ec.ig.Emit (OpCodes.Ldflda, par_info.FieldBuilder);
+			ec.ig.Emit (OpCodes.Ldflda, par_info.Field.FieldBuilder);
 		}
 
-		//
-		// The following methods are only invoked on the host for the
-		// anonymous method.
-		//
-		public void EmitMethodHostInstance (EmitContext target, AnonymousContainer am)
-		{
-			ILGenerator ig = target.ig;
-			ScopeInfo si = am.Scope;
-
-			AnonymousContainer container = am.ContainerAnonymousMethod;
-
-			if ((si == null) || ((container != null) && (si == container.Scope))) {
-				ig.Emit (OpCodes.Ldarg_0);
-				return;
-			}
-
-			si.EmitInitScope (target);
-			si.EmitScopeInstance (ig);
-		}
-
 		public void RegisterCaptureContext ()
 		{
 			toplevel_owner.RegisterCaptureContext (this);
@@ -1474,7 +1927,7 @@
 			}
 			return parent;
 		}
-		
+
 		//
 		// Links all the scopes
 		//
@@ -1483,11 +1936,13 @@
 		{
 			if (linked)
 				return;
-			
+
 			linked = true;
 			if (ParentCaptureContext != null)
 				ParentCaptureContext.LinkScopes ();
 
+			// GetScopeForBlock (toplevel_owner);
+
 			int scope_count = scopes.Keys.Count;
 			ScopeInfo [] scope_list = new ScopeInfo [scope_count];
 			scopes.Values.CopyTo (scope_list, 0);
@@ -1510,7 +1965,7 @@
 			if (ParentCaptureContext != null && roots.Count != 0){
 				ScopeInfo one_root = (ScopeInfo) roots [0];
 				bool found = false;
-				
+
 				foreach (ScopeInfo a_parent_root in ParentCaptureContext.roots){
 					if (!IsAncestor (a_parent_root, one_root))
 						continue;
Index: expression.cs
===================================================================
--- expression.cs	(revision 63019)
+++ expression.cs	(working copy)
@@ -3443,7 +3443,7 @@
 		{
 			ILGenerator ig = ec.ig;
 
-			if (local_info.FieldBuilder == null){
+			if (local_info.Field == null){
 				//
 				// A local variable on the local CLR stack
 				//
@@ -3455,7 +3455,7 @@
 				if (!prepared)
 					ec.EmitCapturedVariableInstance (local_info);
 				
-				ig.Emit (OpCodes.Ldfld, local_info.FieldBuilder);
+				ig.Emit (OpCodes.Ldfld, local_info.Field.FieldBuilder);
 			}
 		}
 		
@@ -3464,7 +3464,7 @@
 			Emit (ec);
 			if (leave_copy){
 				ec.ig.Emit (OpCodes.Dup);
-				if (local_info.FieldBuilder != null){
+				if (local_info.Field != null){
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
@@ -3476,7 +3476,7 @@
 			ILGenerator ig = ec.ig;
 			prepared = prepare_for_load;
 
-			if (local_info.FieldBuilder == null){
+			if (local_info.Field == null){
 				//
 				// A local variable on the local CLR stack
 				//
@@ -3501,7 +3501,7 @@
 					temp = new LocalTemporary (Type);
 					temp.Store (ec);
 				}
-				ig.Emit (OpCodes.Stfld, local_info.FieldBuilder);
+				ig.Emit (OpCodes.Stfld, local_info.Field.FieldBuilder);
 				if (temp != null)
 					temp.Emit (ec);
 			}
@@ -3511,7 +3511,7 @@
 		{
 			ILGenerator ig = ec.ig;
 
-			if (local_info.FieldBuilder == null){
+			if (local_info.Field == null){
 				//
 				// A local variable on the local CLR stack
 				//
@@ -3521,7 +3521,7 @@
 				// A local variable captured by anonymous methods or iterators
 				//
 				ec.EmitCapturedVariableInstance (local_info);
-				ig.Emit (OpCodes.Ldflda, local_info.FieldBuilder);
+				ig.Emit (OpCodes.Ldflda, local_info.Field.FieldBuilder);
 			}
 		}
 
@@ -3636,15 +3636,6 @@
 						par.Name);
 					return false;
 				}
-
-				//
-				// If we are referencing the parameter from the external block
-				// flag it for capturing
-				//
-				//Console.WriteLine ("Is parameter `{0}' local? {1}", name, block.IsLocalParameter (name));
-				if (!block.Toplevel.IsLocalParameter (name)){
-					ec.CaptureParameter (name, type, idx);
-				}
 			}
 
 			return true;
@@ -3684,6 +3675,9 @@
 			if (is_out && ec.DoFlowAnalysis && (!ec.OmitStructFlowAnalysis || !vi.TypeInfo.IsStruct) && !IsAssigned (ec, loc))
 				return null;
 
+			if (ec.MustCaptureParameter (block, name))
+				return ec.capture_context.AddParameter (ec, par, idx, loc);
+
 			return this;
 		}
 
@@ -3694,6 +3688,9 @@
 
 			SetAssigned (ec);
 
+			if (ec.MustCaptureParameter (block, name))
+				return ec.capture_context.AddParameter (ec, par, idx, loc);
+
 			return this;
 		}
 
@@ -3742,8 +3739,8 @@
 			ILGenerator ig = ec.ig;
 			int arg_idx = idx;
 
-			if (ec.HaveCaptureInfo && ec.IsParameterCaptured (name)){				
-				ec.EmitParameter (name, leave_copy, prepared, ref temp);
+			if (ec.HaveCaptureInfo && ec.IsParameterCaptured (name)) {
+				ec.capture_context.EmitParameter (ec, name, leave_copy, prepared, ref temp);
 				return;
 			}
 
@@ -3777,15 +3774,14 @@
 		{
 			prepared = prepare_for_load;
 			if (ec.HaveCaptureInfo && ec.IsParameterCaptured (name)){
-				ec.EmitAssignParameter (name, source, leave_copy, prepare_for_load, ref temp);
+				ec.capture_context.EmitAssignParameter (
+					ec, name, source, leave_copy, prepare_for_load, ref temp);
 				return;
 			}
 
 			ILGenerator ig = ec.ig;
 			int arg_idx = idx;
-			
-			
-			
+
 			if (!ec.MethodIsStatic)
 				arg_idx++;
 
@@ -3818,7 +3814,7 @@
 		public void AddressOf (EmitContext ec, AddressOp mode)
 		{
 			if (ec.HaveCaptureInfo && ec.IsParameterCaptured (name)){
-				ec.EmitAddressOfParameter (name);
+				ec.capture_context.EmitAddressOfParameter (ec, name);
 				return;
 			}
 			
Index: codegen.cs
===================================================================
--- codegen.cs	(revision 63019)
+++ codegen.cs	(working copy)
@@ -529,12 +529,6 @@
 			get { return capture_context != null; }
 		}
 
-		public void EmitScopeInitFromBlock (Block b)
-		{
-			if (capture_context != null)
-				capture_context.EmitScopeInitFromBlock (this, b);
-		}
-
 		// <summary>
 		//   Starts a new code branching.  This inherits the state of all local
 		//   variables and parameters from the current branching.
@@ -624,11 +618,6 @@
 			li.IsCaptured = true;
 		}
 
-		public void CaptureParameter (string name, Type t, int idx)
-		{
-			capture_context.AddParameter (this, CurrentAnonymousMethod, name, t, idx);
-		}
-
 		public void CaptureThis ()
 		{
 			capture_context.CaptureThis (CurrentAnonymousMethod);
@@ -664,19 +653,6 @@
 		}
 
 		//
-		// Emits the instance pointer for the host method
-		//
-		public void EmitMethodHostInstance (EmitContext target, AnonymousMethod am)
-		{
-			if (capture_context != null)
-				capture_context.EmitMethodHostInstance (target, am);
-			else if (IsStatic)
-				target.ig.Emit (OpCodes.Ldnull);
-			else
-				target.ig.Emit (OpCodes.Ldarg_0);
-		}
-
-		//
 		// Returns whether the `local' variable has been captured by an anonymous
 		// method
 		//
@@ -691,6 +667,16 @@
 				return capture_context.IsParameterCaptured (name);
 			return false;
 		}
+
+		public bool MustCaptureParameter (Block block, string name)
+		{
+			if (CurrentAnonymousMethod == null)
+				return false;
+			if (CurrentAnonymousMethod.IsIterator)
+				return true;
+			else
+				return !block.Toplevel.IsLocalParameter (name);
+		}
 		
 		public void EmitMeta (ToplevelBlock b)
 		{
@@ -788,7 +774,9 @@
 				}
 			}
 
-			block.CompleteContexts ();
+			if (!block.CompleteContexts (this))
+				return false;
+
 			resolved = true;
 			return true;
 		}
@@ -829,12 +817,6 @@
 					ig.Emit (OpCodes.Ret);
 				}
 			}
-
-			//
-			// Close pending helper classes if we are the toplevel
-			//
-			if (capture_context != null && capture_context.ParentToplevel == null)
-				capture_context.CloseAnonymousHelperClasses ();
 		}
 
 		/// <summary>
@@ -1006,12 +988,12 @@
 				ScopeInfo si = CurrentAnonymousMethod.Scope;
 				while (si != null){
 					if (si.ParentLink != null)
-						ig.Emit (OpCodes.Ldfld, si.ParentLink);
+						ig.Emit (OpCodes.Ldfld, si.ParentLink.FieldBuilder);
 					if (si.THIS != null){
-						if (need_address && TypeManager.IsValueType (si.THIS.FieldType))
-							ig.Emit (OpCodes.Ldflda, si.THIS);
+						if (need_address && TypeManager.IsValueType (si.THIS.MemberType))
+							ig.Emit (OpCodes.Ldflda, si.THIS.FieldBuilder);
 						else
-							ig.Emit (OpCodes.Ldfld, si.THIS);
+							ig.Emit (OpCodes.Ldfld, si.THIS.FieldBuilder);
 						break;
 					}
 					si = si.ParentScope;
@@ -1030,21 +1012,6 @@
 			
 			capture_context.EmitCapturedVariableInstance (this, li, CurrentAnonymousMethod);
 		}
-
-		public void EmitParameter (string name, bool leave_copy, bool prepared, ref LocalTemporary temp)
-		{
-			capture_context.EmitParameter (this, name, leave_copy, prepared, ref temp);
-		}
-
-		public void EmitAssignParameter (string name, Expression source, bool leave_copy, bool prepare_for_load, ref LocalTemporary  temp)
-		{
-			capture_context.EmitAssignParameter (this, name, source, leave_copy, prepare_for_load, ref temp);
-		}
-
-		public void EmitAddressOfParameter (string name)
-		{
-			capture_context.EmitAddressOfParameter (this, name);
-		}
 		
 		public Expression GetThis (Location loc)
 		{
Index: statement.cs
===================================================================
--- statement.cs	(revision 63019)
+++ statement.cs	(working copy)
@@ -977,7 +977,7 @@
 		//
 		//
 		public LocalBuilder LocalBuilder;
-		public FieldBuilder FieldBuilder;
+		public Field Field;
 
 		public Type VariableType;
 		public readonly string Name;
@@ -1275,6 +1275,8 @@
 		//
 		Block switch_block;
 
+		ExpressionStatement scope_init;
+
 		protected static int id;
 
 		int this_id;
@@ -1679,6 +1681,8 @@
 			}
 		}
 
+		public ScopeInfo ScopeInfo;
+
 		/// <summary>
 		///   Emits the variable declarations and labels.
 		/// </summary>
@@ -1794,7 +1798,10 @@
 		public void EmitMeta (EmitContext ec)
 		{
 			ILGenerator ig = ec.ig;
-			
+
+			if (ec.capture_context != null)
+				scope_init = ec.capture_context.GetScopeInitializerForBlock (ec, this);
+
 			if (variables != null){
 				bool have_captured_vars = ec.HaveCapturedVariables ();
 				
@@ -1818,9 +1825,8 @@
 				}
 				foreach (LocalInfo vi in temporary_variables) {
 					if (scope != null) {
-						if (vi.FieldBuilder == null)
-							vi.FieldBuilder = scope.DefineField (
-								vi.Name, vi.VariableType, FieldAttributes.Assembly);
+						if (vi.Field == null)
+							throw new InternalErrorException ();
 					} else
 						vi.LocalBuilder = ig.DeclareLocal (vi.VariableType);
 				}
@@ -2039,7 +2045,8 @@
 				}
 			}
 			ec.Mark (StartLocation, true);
-			ec.EmitScopeInitFromBlock (this);
+			if (scope_init != null)
+				scope_init.EmitStatement (ec);
 			DoEmit (ec);
 			ec.Mark (EndLocation, true); 
 
@@ -2083,11 +2090,13 @@
 		// Pointer to the host of this anonymous method, or null
 		// if we are the topmost block
 		//
+		GenericMethod generic;
 		ToplevelBlock container;
 		CaptureContext capture_context;
 		FlowBranchingToplevel top_level_branching;
 
 		Hashtable capture_contexts;
+		ArrayList anonymous_methods;
 		ArrayList children;
 
 		public bool HasVarargs {
@@ -2110,16 +2119,33 @@
 			capture_contexts [cc] = cc;
 		}
 
-		public void CompleteContexts ()
+		public void RegisterAnonymousMethod (AnonymousContainer am)
 		{
-			if (capture_contexts == null)
-				return;
+			if (anonymous_methods == null)
+				anonymous_methods = new ArrayList ();
+			anonymous_methods.Add (am);
+		}
 
-			foreach (CaptureContext cc in capture_contexts.Keys){
-				cc.LinkScopes ();
+		public bool CompleteContexts (EmitContext ec)
+		{
+			if (capture_contexts != null) {
+				foreach (CaptureContext cc in capture_contexts.Keys)
+					cc.LinkScopes ();
 			}
+
+			if (anonymous_methods != null) {
+				foreach (AnonymousContainer am in anonymous_methods)
+					if (!am.CreateMethod (ec))
+						return false;
+			}
+
+			return true;
 		}
 
+		public GenericMethod GenericMethod {
+			get { return generic; }
+		}
+
 		public CaptureContext ToplevelBlockCaptureContext {
 			get { return capture_context; }
 		}
@@ -2144,6 +2170,13 @@
 			this (container, (Flags) 0, parameters, start)
 		{
 		}
+
+		public ToplevelBlock (ToplevelBlock container, Parameters parameters, GenericMethod generic,
+				      Location start) :
+			this (container, parameters, start)
+		{
+			this.generic = generic;
+		}
 		
 		public ToplevelBlock (Parameters parameters, Location start) :
 			this (null, (Flags) 0, parameters, start)
@@ -3772,8 +3805,10 @@
 				
 				ig.BeginCatchBlock (c.CatchType);
 
+#if FIXME
 				if (c.VarBlock != null)
 					ec.EmitScopeInitFromBlock (c.VarBlock);
+#endif
 				if (c.Name != null){
 					vi = c.Block.GetLocalInfo (c.Name);
 					if (vi == null)
@@ -3785,7 +3820,7 @@
 						
 						ec.EmitCapturedVariableInstance (vi);
 						ig.Emit (OpCodes.Ldloc, e);
-						ig.Emit (OpCodes.Stfld, vi.FieldBuilder);
+						ig.Emit (OpCodes.Stfld, vi.Field.FieldBuilder);
 					} else
 						ig.Emit (OpCodes.Stloc, vi.LocalBuilder);
 				} else
@@ -4164,7 +4199,7 @@
 
 			Type var_type = texpr.Type;
 
-			if (expr.eclass == ExprClass.MethodGroup || expr is AnonymousMethod) {
+			if (expr.eclass == ExprClass.MethodGroup || expr is AnonymousMethodExpression) {
 				Report.Error (446, expr.Location, "Foreach statement cannot operate on a `{0}'",
 					expr.ExprClassName);
 				return false;
