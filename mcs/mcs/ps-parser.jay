%{
//
// ps-parser.jay: The Parser for the PlayScript language
// Authors: Miguel de Icaza (miguel@gnome.org)
//          Ravi Pratap     (ravi@ximian.com)
//          Marek Safar	    (marek.safar@gmail.com)
//          Ben Cooley	    (bcooley@zynga.com)
// Dual Licensed under the terms of the GNU GPL and the MIT X11 license
//
// (C) 2001 Ximian, Inc (http://www.ximian.com)
// (C) 2004-2011 Novell, Inc
// Copyright 2011-2012 Xamarin Inc.
//

using System.Text;
using System.IO;
using System;
using System.Collections.Generic;
using Mono.CSharp;
using Linq = Mono.CSharp.Linq;
using Enum = Mono.CSharp.Enum;
using Attribute = Mono.CSharp.Attribute;
using Delegate = Mono.CSharp.Delegate;
using Nullable = Mono.CSharp.Nullable;

namespace Mono.PlayScript
{
	/// <summary>
	///    The PlayScript Parser
	/// </summary>
	public class PlayScriptParser
	{
		[Flags]
		enum ParameterModifierType
		{
			Ref		= 1 << 1,
			Out		= 1 << 2,
			This	= 1 << 3,
			Params	= 1 << 4,
			Arglist	= 1 << 5,
			DefaultValue = 1 << 6,
			
			All = Ref | Out | This | Params | Arglist | DefaultValue
		}
		
		public const bool parsing_playscript = true;
		
		static readonly object ModifierNone = 0;

		LocatedToken namespace_modifier;
	
//		const string RootNs = PredefinedTypes.RootNamespace;
	
		NamespaceContainer current_namespace;
		NamespaceContainer prev_namespace;
		NamespaceContainer private_namespace;
		TypeContainer current_container;
		TypeDefinition current_type;
		PropertyBase current_property;
		FieldBase current_field;
		Constructor current_constructor;
		
		// Set by config params to enable/disable inclusion of methods, fields, consts, classes, structs, etc.
		bool is_config_enabled = true;
		
		bool is_package_function = false;
	
		/// <summary>
		///   Current block is used to add statements as we find
		///   them.  
		/// </summary>
		Block      current_block;
		
		BlockVariable current_variable;

		Delegate   current_delegate;
		
		AnonymousMethodExpression current_anonymous_method;

		/// <summary>
		///   This is used by the unary_expression code to resolve
		///   a name against a parameter.  
		/// </summary>
		
		// FIXME: This is very ugly and it's very hard to reset it correctly
		// on all places, especially when some parameters are autogenerated.
		ParametersCompiled current_local_parameters;

		bool parsing_anonymous_method;
		
		bool async_block;

		///
		/// An out-of-band stack.
		///
		Stack<object> oob_stack;

		///
		/// Controls the verbosity of the errors produced by the parser
		///
		int yacc_verbose_flag;

		/// 
		/// Used by the interactive shell, flags whether EOF was reached
		/// and an error was produced
		///
		public bool UnexpectedEOF;

		///
		/// The current file.
		///
		readonly CompilationSourceFile file;

		///
		/// Temporary Xml documentation cache.
		/// For enum types, we need one more temporary store.
		///
		string tmpComment;
		string enumTypeComment;
	       		
		/// Current attribute target
		string current_attr_target;
		
		ParameterModifierType valid_param_mod;
		
		bool default_parameter_used;

		/// When using the interactive parser, this holds the
		/// resulting expression
		public Class InteractiveResult;

		// Current modifier namespace identifier
		public string ns_modifier;

		//
		// Keeps track of global data changes to undo on parser error
		//
		public Undo undo;
		
		Stack<Linq.QueryBlock> linq_clause_blocks;

		ModuleContainer module;
		
		readonly CompilerContext compiler;
		readonly LanguageVersion lang_version;
		readonly bool doc_support;
		readonly CompilerSettings settings;
		readonly Report report;
		
		//
		// Instead of allocating carrier array everytime we
		// share the bucket for very common constructs which can never
		// be recursive
		//
		List<Parameter> parameters_bucket;
		
		//
		// Full AST support members
		//
		LocationsBag lbag;
		List<Tuple<Modifiers, Location>> mod_locations;
%}

%token EOF
%token NONE   /* This token is never returned by our lexer */
%token ERROR		// This is used not by the parser, but by the tokenizer.
			// do not remove.

/*
 *These are the C# keywords
 */
%token FIRST_KEYWORD
%token ABSTRACT	
%token AS
%token SUPER	
%token BOOL
%token BOOLEAN	
%token BREAK	
%token BYTE	
%token CASE	
%token CATCH
%token CHAR	
%token CLASS	
%token CONST	
%token CONTINUE	
%token DECIMAL	
%token DEFAULT	
%token DELETE
%token DO	
%token DOUBLE
%token DOUBLE2
%token DOUBLE3
%token DOUBLE4
%token DYNAMIC
%token EACH	
%token ELSE	
%token EXPLICIT
%token EXTENDS	
%token FALSE
%token FINAL	
%token FINALLY	
%token FIXED	
%token FLOAT
%token FLOAT2
%token FLOAT3
%token FLOAT4
%token FOR	
%token FOR_EACH	
%token FUNCTION 
%token FUNCTION_GET
%token FUNCTION_SET
%token GOTO	
%token IF	
%token IMPLICIT	
%token IMPLEMENTS
%token IMPORT
%token IN
%token INDEXER	
%token INSTANCEOF
%token INT	
%token INTERFACE
%token INTERNAL	
%token IS	
%token LONG	
%token NAMESPACE
%token NATIVE	
%token NEW	
%token NULL	
%token OBJECT	
%token OPERATOR	
%token OUT	
%token OVERRIDE
%token OVERLOAD
%token PACKAGE
%token PRIVATE
%token PROPERTY	
%token PROTECTED
%token PUBLIC	
%token READONLY	
%token REF	
%token RETURN	
%token SBYTE	
%token SHORT	
%token STATIC	
%token STRING	
%token STRUCT	
%token SWITCH	
%token THIS	
%token THROW	
%token TRUE	
%token TRY	
%token TYPEOF	
%token UINT	
%token ULONG	
%token UNSAFE
%token USE	
%token USHORT	
%token USING	
%token VAR
%token VIRTUAL	
%token VOID	
%token VOLATILE
%token WHERE
%token WHILE
%token WITH
%token PARTIAL
%token ARROW
%token FROM
%token FROM_FIRST
%token JOIN
%token ON
%token EQUALS
%token SELECT
%token GROUP
%token BY
%token LET
%token ORDERBY
%token ASCENDING
%token DESCENDING
%token INTO
%token INTERR_NULLABLE
%token EXTERN
%token ASYNC
%token AWAIT

/* C# keywords which are not really keywords */
%token GET
%token SET

%left LAST_KEYWORD

/* C# single character operators/punctuation. */
%token OPEN_BRACE
%token CLOSE_BRACE
%token OPEN_BRACKET
%token CLOSE_BRACKET
%token OPEN_PARENS
%token CLOSE_PARENS

%token DOT
%token DOT_AT
%token DOT_STAR
%token DOTDOT
%token DOTDOT_AT
%token DOTDOT_STAR
%token DOTDOTDOT
%token DOT_OPEN_PARENS
%token CLOSE_PARENS_DOT
%token COMMA
%token COLON
%token SEMICOLON
%token TILDE

%token PLUS
%token MINUS
%token BANG
%token ASSIGN
%token OP_LT
%token OP_GT
%token BITWISE_AND
%token BITWISE_OR
%token LOGICAL_AND_ASSIGN
%token LOGICAL_OR_ASSIGN
%token STAR
%token PERCENT
%token DIV
%token CARRET
%token INTERR

/* C# multi-character operators. */
%token DOUBLE_COLON
%token OP_INC
%token OP_DEC
%token OP_SHIFT_LEFT
%token OP_SHIFT_RIGHT
%token OP_USHIFT_RIGHT
%token OP_LE
%token OP_GE
%token OP_EQ
%token OP_REF_EQ
%token OP_NE
%token OP_REF_NE
%token OP_AND
%token OP_OR
%token OP_MULT_ASSIGN
%token OP_DIV_ASSIGN
%token OP_MOD_ASSIGN
%token OP_ADD_ASSIGN
%token OP_SUB_ASSIGN
%token OP_SHIFT_LEFT_ASSIGN
%token OP_SHIFT_RIGHT_ASSIGN
%token OP_USHIFT_RIGHT_ASSIGN
%token OP_AND_ASSIGN
%token OP_XOR_ASSIGN
%token OP_OR_ASSIGN
%token OP_PTR
%token OP_COALESCING
%token OP_IN
%token OP_AT

/* Generics <,> tokens */
%token OP_GENERICS_LT
%token OP_GENERICS_LT_DECL
%token OP_GENERICS_GT

%token LITERAL

%token IDENTIFIER
%token IDENTIFIER_CONFIG
%token OPEN_PARENS_LAMBDA
%token OPEN_PARENS_CAST
%token GENERIC_DIMENSION
%token DEFAULT_COLON
%token OPEN_BRACKET_EXPR
%token OPEN_BRACE_INIT

// Make the parser go into eval mode parsing (statements and compilation units).
%token EVAL_STATEMENT_PARSER
%token EVAL_COMPILATION_UNIT_PARSER
%token EVAL_USING_DECLARATIONS_UNIT_PARSER

%token DOC_SEE

// 
// This token is generated to trigger the completion engine at this point
//
%token GENERATE_COMPLETION

//
// This token is return repeatedly after the first GENERATE_COMPLETION
// token is produced and before the final EOF
//
%token COMPLETE_COMPLETION

/* Add precedence rules to solve dangling else s/r conflict */
%nonassoc IF
%nonassoc ELSE

/* Define the operator tokens and their precedences */
%right ASSIGN
%right OP_COALESCING
%right INTERR
%left OP_OR
%left OP_AND
%left BITWISE_OR
%left BITWISE_AND
%left OP_SHIFT_LEFT OP_SHIFT_RIGHT
%left PLUS MINUS
%left STAR DIV PERCENT
%right BANG CARRET UMINUS
%nonassoc OP_INC OP_DEC
%left OPEN_PARENS
%left NEW
%left OPEN_BRACKET OPEN_BRACE
%left DOT

%start compilation_unit
%%

compilation_unit
	: outer_declaration opt_EOF
	  {
		Lexer.check_incorrect_doc_comment ();
	  }
	| interactive_parsing  { Lexer.CompleteOnEOF = false; } opt_EOF
	| documentation_parsing
	;
	
outer_declaration
	: opt_extern_alias_directives opt_package_directives
	| opt_extern_alias_directives opt_package_directives package_declaration opt_attributes
	  {
		if ($4 != null) {
			Attributes attrs = (Attributes) $4;
			report.Error (1730, attrs.Attrs [0].Location,
				"Assembly and module attributes must precede all other elements except using clauses and extern alias declarations");

			current_namespace.UnattachedAttributes = attrs;
		}
	  }
	| opt_extern_alias_directives opt_package_directives attribute_sections
	  {
		module.AddAttributes ((Attributes) $3, current_namespace);
	  }
	| error
	  {
		if (yyToken == Token.EXTERN)
			report.Error (439, lexer.Location, "An extern alias declaration must precede all other elements");
		else
			Error_SyntaxError (yyToken);
	  }
	;
	
opt_EOF
	: /* empty */
	| EOF
	;

extern_alias_directives
	: extern_alias_directive
	| extern_alias_directives extern_alias_directive
	;

extern_alias_directive
	: EXTERN IDENTIFIER IDENTIFIER SEMICOLON
	  {
		var lt = (LocatedToken) $2;
		string s = lt.Value;
		if (s != "alias") {
			syntax_error (lt.Location, "`alias' expected");
		} else {
			if (lang_version == LanguageVersion.ISO_1)
				FeatureIsNotAvailable (lt.Location, "external alias");

			lt = (LocatedToken) $3;
			if (lt.Value == QualifiedAliasMember.GlobalAlias) {
				RootNamespace.Error_GlobalNamespaceRedefined (report, lt.Location);
			}
			
			var na = new UsingExternAlias (new SimpleMemberName (lt.Value, lt.Location), GetLocation ($1));
			current_namespace.AddUsing (na);
			
			lbag.AddLocation (na, GetLocation ($2), GetLocation ($4));
		}
	  }
	| EXTERN error
	  {
		Error_SyntaxError (yyToken);
	  }
	;
 
no_config_package_directive
	: import_directive
	| use_namespace_directive
	; 
 
package_directive
	: no_config_package_directive
	| config_package_directive
	;

config_package_directive
	: IDENTIFIER_CONFIG 
	  {
		var lt = (LocatedToken) $1;
	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
	  } 
	  no_config_package_directive
	  {
	  	is_config_enabled = true;
	  	$$ = $3;
	  }
	| IDENTIFIER_CONFIG 
	  {
		var lt = (LocatedToken) $1;
	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
	  } 
	  OPEN_BRACE opt_package_directives CLOSE_BRACE
	  {
	  	is_config_enabled = true;
	  	$$ = $4;
	  }
	; 
   
package_directives
    : package_directive
    | package_directives package_directive
    ;

use_namespace_directive
	: use_namespace
	  {
		if (doc_support)
			Lexer.doc_state = XmlCommentState.Allowed;
	  }
	;

use_namespace
	: USE NAMESPACE IDENTIFIER SEMICOLON
	;
 
import_directive
	: import_package
	  {
		if (doc_support)
			Lexer.doc_state = XmlCommentState.Allowed;
	  }
	;

import_package
	: IMPORT namespace_or_type_expr
	  {
	    Lexer.AllowAutoSemiAfterToken(Token.DOT_STAR, true);
	  }
	  DOT_STAR SEMICOLON 
	  {
	    if (is_config_enabled) {
			var un = new UsingNamespace ((ATypeNameExpression) $2, GetLocation ($1));
		  	current_namespace.AddUsing (un);
		
			lbag.AddLocation (un, GetLocation ($5));
			
		    Lexer.AllowAutoSemiAfterToken(Token.DOT_STAR, false);
		}
	  }	
	| IMPORT typeof_type_expression SEMICOLON 
	  {
	    if (is_config_enabled) {
			var ut = new UsingType ((ATypeNameExpression) $2, GetLocation ($1));
			current_namespace.AddUsing (ut);
		
			lbag.AddLocation (ut, GetLocation ($3));
		}
	  }
	| IMPORT IDENTIFIER ASSIGN namespace_or_type_expr SEMICOLON
	  {
	    if (is_config_enabled) {
			var lt = (LocatedToken) $2;
			if (lang_version != LanguageVersion.ISO_1 && lt.Value == "global") {
				report.Warning (440, 2, lt.Location,
				 "An alias named `global' will not be used when resolving `global::'. The global namespace will be used instead");
			}

			var un = new UsingAliasNamespace (new SimpleMemberName (lt.Value, lt.Location), (ATypeNameExpression) $4, GetLocation ($1));
			current_namespace.AddUsing (un);
		
			lbag.AddLocation (un, GetLocation ($3), GetLocation ($5));
		}
	  }
	| IMPORT error
	  {
		Error_SyntaxError (yyToken);
		$$ = null;
	  }
	;

//
// Strictly speaking, namespaces don't have attributes but
// we parse global attributes along with namespace declarations and then
// detach them
// 
package_declaration
	: opt_attributes PACKAGE 
	  {
	  	Lexer.AutoSemiInsertion = false;
	  }
	  opt_package_name
	  {
		Attributes attrs = (Attributes) $1;
		var name = $4 as MemberName;
//		if (name == null) {
//			name = new MemberName(RootNs);
//		}
/*		
		if (attrs != null) {
			bool valid_global_attrs = true;
			if ((current_namespace.DeclarationFound || current_namespace != file)) {
				valid_global_attrs = false;
			} else {
				foreach (var a in attrs.Attrs) {
					if (a.ExplicitTarget == "assembly" || a.ExplicitTarget == "module")
						continue;
						
					valid_global_attrs = false;
					break;
				}
			}
			
			if (!valid_global_attrs)
				report.Error (1671, name.Location, "A namespace declaration cannot have modifiers or attributes");
		}
	
		module.AddAttributes (attrs, current_namespace);
*/		
	    // Close the private package namespace (if it's active)
	  	if (current_namespace == private_namespace) {
	  		if (private_namespace.Containers.Count > 0) {
		  		prev_namespace.AddTypeContainer(private_namespace);
				var priv_un = new UsingNamespace (
					private_namespace.NS.MakeTypeNameExpression(GetLocation($1)), GetLocation ($1));
				prev_namespace.AddUsing(priv_un, true);
			}
			current_container = current_namespace = prev_namespace.Parent;
			prev_namespace = private_namespace = null; 
	  	}
		
		var ns = Package.Create (name, current_namespace);
		current_namespace.AddTypeContainer (ns);
		current_container = current_namespace = ns;
//		var un = new UsingNamespace (new SimpleName (RootNs, GetLocation ($1)), GetLocation ($1));
//		current_namespace.AddUsing(un, true);
	  }
	  OPEN_BRACE
	  {
		if (doc_support)
			Lexer.doc_state = XmlCommentState.Allowed;
			
		Lexer.AutoSemiInsertion = true;
	  }
	  opt_package_statements_or_blocks CLOSE_BRACE opt_semicolon
	  {
	  	lbag.AddLocation (current_container, GetLocation ($2), GetLocation ($6), GetLocation ($8));
/*	  
	  	if (current_namespace.Parent != null && current_namespace.Parent.Parent == null) { // Is this the top level package?
			var ns = new NamespaceContainer (new MemberName("__" + file.FileName.Replace(".","_")), current_namespace);
			prev_namespace = current_namespace;
			current_container = private_namespace = current_namespace = ns;
	    } else
*/
		{
			current_container = current_namespace = current_namespace.Parent;
		}
		
		lexer.parsing_modifiers = false;
	  }
	  opt_package_statements_or_blocks
	  {
	    // Close the private package namespace (if it's active)
	  	if (current_namespace == private_namespace) {
/*
	  		if (private_namespace.Containers.Count > 0) {
		  		prev_namespace.AddTypeContainer(private_namespace);
				var priv_un = new UsingNamespace (
					private_namespace.NS.MakeTypeNameExpression(GetLocation($1)), GetLocation ($1));
				prev_namespace.AddUsing(priv_un, true);
			}
*/
			current_container = current_namespace = prev_namespace.Parent;
			prev_namespace = private_namespace = null; 
	  	}
	  
//	  	lbag.AddLocation (current_container, GetLocation ($2), GetLocation ($6), GetLocation ($11));
	  }
	;

opt_package_name
	: /* empty */
	| package_name
	;

package_name
	: IDENTIFIER
	  {
		var lt = (LocatedToken) $1;
		$$ = new MemberName (lt.Value, lt.Location);
	  }
	| package_name DOT IDENTIFIER
	  {
		var lt = (LocatedToken) $3;
		$$ = new MemberName ((MemberName) $1, lt.Value, lt.Location);		
	  }
	| error
	  {
		Error_SyntaxError (yyToken);
		$$ = new MemberName ("<invalid>", lexer.Location);
	  }
	;

opt_semicolon
	: /* empty */
	| SEMICOLON
	;

opt_comma
	: /* empty */
	| COMMA
	;

opt_package_statements_or_blocks
	: opt_extern_alias_directives opt_package_statements
	| OPEN_BRACE opt_package_statements_or_blocks CLOSE_BRACE
	;
	
opt_package_directives
	: /* empty */
	| package_directives
	;

opt_extern_alias_directives
	: /* empty */
	| extern_alias_directives
	;

opt_package_statements
	: /* empty */
	| package_statements
	;

package_statements
	: package_statement
	| package_statements package_statement
	;

package_statement
	: no_config_package_statement
	| config_package_statement
	| attribute_sections CLOSE_BRACE {
		current_namespace.UnattachedAttributes = (Attributes) $1;
		report.Error (1518, lexer.Location, "Attributes must be attached to class, delegate, enum, interface or struct");
		lexer.putback ('}');
		is_config_enabled = true;		
	  }
	;

no_config_package_statement
	: type_declaration
	  {
	    if (is_config_enabled) {
			if ($1 != null) {
				TypeContainer ds = (TypeContainer)$1;

				if ((ds.ModFlags & (Modifiers.PRIVATE | Modifiers.PROTECTED)) != 0){
					report.Error (1527, ds.Location, 
					"Namespace elements cannot be explicitly declared as private, protected or protected internal");
				}

				// Here is a trick, for explicit attributes we don't know where they belong to until
				// we parse succeeding declaration hence we parse them as normal and re-attach them
				// when we know whether they are global (assembly:, module:) or local (type:).
				if (ds.OptAttributes != null) {
					ds.OptAttributes.ConvertGlobalAttributes (ds, current_namespace, !current_namespace.DeclarationFound && current_namespace == file);
				}
			}
			current_namespace.DeclarationFound = true;
		}
	  }
	| method_declaration
	  {
	  	if (is_config_enabled) {
			current_namespace.DeclarationFound = true;
		}
	  }
	| constant_declaration
	| no_config_package_directive	  
	;

config_package_statement
	: IDENTIFIER_CONFIG 
	  {
		var lt = (LocatedToken) $1;
	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	 	  
	  }
	  no_config_package_statement
	  {
	    is_config_enabled = true;
	    $$ = $3;
	  }
	| IDENTIFIER_CONFIG 
	  {
		var lt = (LocatedToken) $1;
	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
	  } 
	  OPEN_BRACE opt_package_statements CLOSE_BRACE
	  {
	  	is_config_enabled = true;
	  	$$ = $4;
	  }	  
	;

type_declaration
	: class_declaration	
	| interface_declaration
	;
		
//
// Enable this when we have handled all errors, because this acts as a generic fallback
//
//	| error {
//		Console.WriteLine ("Token=" + yyToken);
//		report.Error (1518, GetLocation ($1), "Expected class, struct, interface, enum or delegate");
//	  }
	;

//
// Attributes
//

opt_attributes
	: /* empty */ 
	| attribute_sections
    ;
 
attribute_sections
	: attribute_section
	  {
		var sect = $1 as List<Attribute>;
		if (sect != null) {
			$$ = new Attributes (sect);
		}
	  }
	| attribute_sections attribute_section
	  {
		Attributes attrs = $1 as Attributes;
		var sect = $2 as List<Attribute>;
		if (sect != null) {
			if (attrs == null)
				attrs = new Attributes (sect);
			else
				attrs.AddAttributes (sect);
		}
		$$ = attrs;
	  }
	;
	
attribute_section
	: OPEN_BRACKET
	  {
		lexer.parsing_attribute_section = true;
	  }
	  attribute_section_cont
	  {
		lexer.parsing_attribute_section = false;
		$$ = $3;
	  }
	;
	
attribute_section_cont
	: attribute_target COLON
	  {
		current_attr_target = (string) $1;
		if (current_attr_target == "assembly" || current_attr_target == "module") {
			Lexer.check_incorrect_doc_comment ();
		}
	  }
	  attribute_list opt_comma CLOSE_BRACKET
	  {
		// when attribute target is invalid
		if (current_attr_target == string.Empty)
			$$ = new List<Attribute> (0);
		else
			$$ = $4;
	  
		current_attr_target = null;
		lexer.parsing_attribute_section = false;
		lexer.AutoSemiInsertionAfter = 1;
 	  }
	| attribute_list opt_comma CLOSE_BRACKET
	  {
		lexer.AutoSemiInsertionAfter = 1;
		$$ = $1;
	  }
	;	

attribute_target
	: IDENTIFIER
	  {
		var lt = (LocatedToken) $1;
		$$ = CheckAttributeTarget (lt.Value, lt.Location);
	  }
	| RETURN { $$ = "return"; }
	| error
	  {
		if (yyToken == Token.IDENTIFIER) {
			Error_SyntaxError (yyToken);
			$$ = null;
		} else {
			string name = GetTokenName (yyToken);
			$$ = CheckAttributeTarget (name, GetLocation ($1));
		}
	  }
	;

attribute_list
	: attribute
	  {
		$$ = new List<Attribute> (4) { (Attribute) $1 };
	  }
	| attribute_list COMMA attribute
	  {
		var attrs = (List<Attribute>) $1;
		attrs.Add ((Attribute) $3);

		$$ = attrs;
	  }
	;

attribute
	: attribute_name
	  {
		++lexer.parsing_block;
	  }
	  opt_attribute_arguments
	  {
		--lexer.parsing_block;
		
		var tne = (ATypeNameExpression) $1;
		if (tne.HasTypeArguments) {
			report.Error (404, tne.Location, "Attributes cannot be generic");
		}

		$$ = new Attribute (current_attr_target, tne, (Arguments[]) $3, GetLocation ($1), lexer.IsEscapedIdentifier (tne));
	  }
	;

attribute_name
	: namespace_or_type_expr
	;

opt_attribute_arguments
	: /* empty */   { $$ = null; }
	| OPEN_PARENS attribute_arguments CLOSE_PARENS
	  {
	    lexer.AutoSemiInsertionAfter = 1;
		$$ = $2;
	  }
	;


attribute_arguments
	: /* empty */ 		{ $$ = null; } 
	| positional_or_named_argument
	  {
	  	Arguments a = new Arguments (4);
		a.Add ((Argument) $1);
		$$ = new Arguments [] { a, null };
	  }
	| named_attribute_argument
	  {
	  	Arguments a = new Arguments (4);
		a.Add ((Argument) $1);  
		$$ = new Arguments [] { null, a };
	  }
    | attribute_arguments COMMA positional_or_named_argument
	  {
		Arguments[] o = (Arguments[]) $1;
		if (o [1] != null) {
			report.Error (1016, ((Argument) $3).Expr.Location, "Named attribute arguments must appear after the positional arguments");
			o [0] = new Arguments (4);
		}
		
		Arguments args = ((Arguments) o [0]);
		if (args.Count > 0 && !($3 is NamedArgument) && args [args.Count - 1] is NamedArgument)
			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
		
		args.Add ((Argument) $3);
	  }
    | attribute_arguments COMMA named_attribute_argument
	  {
		Arguments[] o = (Arguments[]) $1;
		if (o [1] == null) {
			o [1] = new Arguments (4);
		}

		((Arguments) o [1]).Add ((Argument) $3);
	  }
    ;

positional_or_named_argument
	: expression
	  {
	  	$$ = new Argument ((Expression) $1);
	  }
	| named_argument
	;

named_attribute_argument
	: IDENTIFIER ASSIGN
	  {
		++lexer.parsing_block;
	  }
	  expression
	  {
	  	--lexer.parsing_block;
	  	var lt = (LocatedToken) $1;
		$$ = new NamedArgument (lt.Value, lt.Location, (Expression) $4);	  
		lbag.AddLocation ($$, GetLocation($2));
	  }
	;
	
named_argument
	: identifier_inside_body COLON opt_named_modifier expression
	  {
		if (lang_version <= LanguageVersion.V_3)
			FeatureIsNotAvailable (GetLocation ($1), "named argument");
			
		// Avoid boxing in common case (no modifier)
		var arg_mod = $3 == null ? Argument.AType.None : (Argument.AType) $3;
			
		var lt = (LocatedToken) $1;
		$$ = new NamedArgument (lt.Value, lt.Location, (Expression) $4, arg_mod);
		lbag.AddLocation ($$, GetLocation($2));
	  }
	;
	
opt_named_modifier
	: /* empty */   { $$ = null; }
	| REF
	  { 
	  	CheckIsPlayScript("ref parameters", GetLocation($1));
		$$ = Argument.AType.Ref;
	  }
	| OUT
	  { 
	  	CheckIsPlayScript("out parameters", GetLocation($1));
		$$ = Argument.AType.Out;
	  }
	;
		  
opt_class_member_declarations
	: /* empty */
	| class_member_declarations
	;

class_member_declarations
	: class_member_declaration
	  {
		lexer.parsing_modifiers = true;
	  }
	| class_member_declarations class_member_declaration
	  {
		lexer.parsing_modifiers = true;
	  }
	;
	
class_member_declaration
	: constant_declaration
	| field_declaration
	| method_declaration
	| namespace_declaration
	| indexer_declaration
	| operator_declaration
	| type_declaration
	| member_config_block
	| config_member_declaration	
	| attributes_without_members
	| use_namespace_class_directive
	| import_class_directive
	| error
	  {
		report.Error (1519, lexer.Location, "Unexpected symbol `{0}' in class, struct, or interface member declaration",
			GetSymbolName (yyToken));
		$$ = null;
		lexer.parsing_generic_declaration = false;
	  }
	;
	
use_namespace_class_directive
	: opt_attributes
	  opt_modifiers
	  use_namespace_directive
	  {
	  	if ($1 != null || (Modifiers) $2 != 0) {
			report.Error (7058, GetLocation($1 ?? $2), "Modifiers and attributes not allowed");
	  	}
	  }
	;

import_class_directive
	: opt_attributes
	  opt_modifiers
	  import_directive
	  {
	  	if ($1 != null || (Modifiers) $2 != 0) {
			report.Error (7058, GetLocation($1 ?? $2), "Modifiers and attributes not allowed");
	  	}
	  }
	;

config_member_declaration
	: IDENTIFIER_CONFIG
	  {
		var lt = (LocatedToken) $1;
	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
	  }
	  class_member_declaration
	  {
	    is_config_enabled = true;
	    $$ = $3;
	  }
	;
	  

member_config_block
	: IDENTIFIER_CONFIG 
	  {
		var lt = (LocatedToken) $1;
	    is_config_enabled = file.IsConditionalDefined (lt.Value.Replace("::","_"));	  
	  } 
	  OPEN_BRACE opt_class_member_declarations CLOSE_BRACE
	  {
	  	is_config_enabled = true;
	  	$$ = $4;
	  }
	;	  

namespace_declaration
	: opt_attributes 
	  opt_modifiers
	  NAMESPACE IDENTIFIER opt_namespace_initializer SEMICOLON
	  {
		var lt = (LocatedToken) $4;
		var td = GetTypeDefinition (current_container);

		var ns = new NamespaceField (td, (Modifiers) $2, CreateFullMemberName (lt), (Expression) $5, (Attributes) $1);
		td.AddMember (ns);
	  }
	;

opt_namespace_initializer
	: /* empty */
	| ASSIGN constant_initializer_expr 
	  {
		$$ = $2;
	  }
	;
	
constant_declaration
	: opt_attributes 
	  opt_modifiers
	  CONST IDENTIFIER COLON type
	  {
		var lt = (LocatedToken) $4;
		var td = GetTypeDefinition (current_container);
		current_field = new ConstantField (td, (FullNamedExpression) $6, (Modifiers) $2, CreateFullMemberName (lt), (Attributes) $1);
		if (is_config_enabled) {
			td.AddMember (current_field);
		}
		is_config_enabled = true;
				
		$$ = current_field;
	  }
	  opt_field_initializer opt_field_declarators SEMICOLON
	  {
		if (doc_support) {
			current_field.DocComment = Lexer.consume_doc_comment ();
			Lexer.doc_state = XmlCommentState.Allowed;
		}
		
		lbag.AddMember (current_field, mod_locations, GetLocation ($3), GetLocation ($10));
		current_field = null;
	  }
	;

constant_initializer_expr
    : constant_expression
    ;

field_declaration
	: opt_attributes
	  opt_modifiers
	  VAR IDENTIFIER COLON member_type
	  {
	  	lexer.parsing_generic_declaration = false;

		FullNamedExpression type = (FullNamedExpression) $6;
		if (type.Type != null && type.Type.Kind == MemberKind.Void)
			report.Error (670, GetLocation ($6), "Fields cannot have void type");
			
		var lt = (LocatedToken) $4;
		current_field = new Field (current_type, type, (Modifiers) $2, CreateFullMemberName (lt), (Attributes) $1);
		if (is_config_enabled) {
			current_type.AddField (current_field);
		}
		is_config_enabled = true;
		$$ = current_field;
	  }
	  opt_field_initializer
	  opt_field_declarators
	  SEMICOLON
	  { 
		if (doc_support) {
			current_field.DocComment = Lexer.consume_doc_comment ();
			Lexer.doc_state = XmlCommentState.Allowed;
		}
			
		lbag.AddMember (current_field, mod_locations, GetLocation ($10));
		$$ = current_field;
		current_field = null;
	  }
	;
	
opt_field_initializer
	: /* empty */
	| ASSIGN
	  {
	  	++lexer.parsing_block;
		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
	  	start_block (GetLocation ($1));
	  }
	  variable_initializer
	  {
	  	--lexer.parsing_block;
		current_field.Initializer = (Expression) $3;
		end_block (lexer.Location);
		current_local_parameters = null;
	  }
	;
	
opt_field_declarators
	: /* empty */
	| field_declarators
	;
	
field_declarators
	: field_declarator
	  {
		current_field.AddDeclarator ((FieldDeclarator) $1);
	  }
	| field_declarators field_declarator
	  {
		current_field.AddDeclarator ((FieldDeclarator) $2);
	  }
	;
	
field_declarator
	: COMMA IDENTIFIER COLON member_type
	  {
		var lt = (LocatedToken) $2;
	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), null, (FullNamedExpression) $4);
	  	lbag.AddLocation ($$, GetLocation ($1));
	  }
	| COMMA IDENTIFIER COLON member_type ASSIGN
	  {
		++lexer.parsing_block;
	  }
	  variable_initializer
	  {
		--lexer.parsing_block;
		var lt = (LocatedToken) $2;	  
	  	$$ = new FieldDeclarator (new SimpleMemberName (lt.Value, lt.Location), (Expression) $7, (FullNamedExpression) $4);
	  	lbag.AddLocation ($$, GetLocation ($1), GetLocation ($5));
	  }
	;	

variable_initializer
	: expression
	| error
	  {
		// It has to be here for the parent to safely restore artificial block
	  	Error_SyntaxError (yyToken);
	  	$$ = null;
	  }
	;

method_declaration
	: method_header
	  {
		if (doc_support)
			Lexer.doc_state = XmlCommentState.NotAllowed;

		// Add it early in the case of body being eof for full ast
		Method m = $1 as Method;
		if (m != null) {
			async_block = (m.ModFlags & Modifiers.ASYNC) != 0;
			if (is_config_enabled) {
				GetTypeDefinition (current_container).AddMember (m);
			}
			is_config_enabled = true;
		}
		
		Constructor c = $1 as Constructor;
		if (c != null) {
			if (is_config_enabled) {
				current_type.AddConstructor (c);
			}
			is_config_enabled = true;
			current_constructor = c;
		}
		
		if (is_package_function)
			lexer.DynamicParsing = false;
			
	  }
	  method_body opt_semicolon
	  {
		if (is_package_function)
			lexer.DynamicParsing = true;
	  
	 	async_block = false;

		if ($1 is Method) {
		
			Method method = $1 as Method;
			
			if ($3 == null) {
				method.ParameterInfo.CheckParameters (method);
	
				if ((method.ModFlags & Modifiers.ASYNC) != 0) {
					report.Error (1994, method.Location, "`{0}': The async modifier can only be used with methods that have a body",
						method.GetSignatureForError ());
				}
			} else {
				method.Block = (ToplevelBlock) $3;
				
				if (current_container.Kind == MemberKind.Interface) {
					report.Error (531, method.Location, "`{0}': interface members cannot have a definition",
						method.GetSignatureForError ());
				}
			}
			
		} else if ($1 is Constructor) {
		
			Constructor c = $1 as Constructor;
			
			if ($3 != null) {		
				c.Block = (ToplevelBlock) $3;
			}
			
			if (doc_support)
				c.DocComment = ConsumeStoredComment ();
		
		} else {
		
			Property.PropertyMethod propMethod = $1 as Property.PropertyMethod;
			
			if ($3 != null) {
		  		propMethod.Block = (ToplevelBlock) $3;			
		  	
				if (current_container.Kind == MemberKind.Interface) {
					report.Error (531, propMethod.Block.StartLocation,
						"`{0}': interface members cannot have a definition", propMethod.GetSignatureForError ());
				}
			}
			
		}

		current_local_parameters = null;
		current_property = null;
		current_constructor = null;
		
		is_package_function = false;
	
		if (doc_support)
			Lexer.doc_state = XmlCommentState.Allowed;
	  }
	;

method_header
	: opt_attributes
	  opt_modifiers
	  FUNCTION
	  method_declaration_name OPEN_PARENS
	  {
		valid_param_mod = ParameterModifierType.All;
		
		if (current_container is Package) {
			is_package_function = true;
		}
		
	  }
	  opt_formal_parameter_list CLOSE_PARENS opt_method_return_type
	  {
		lexer.ConstraintsParsing = true;
	  }
	  opt_type_parameter_constraints_clauses
	  {
		lexer.ConstraintsParsing = false;
		valid_param_mod = 0;
		MemberName name = (MemberName) $4;
		current_local_parameters = (ParametersCompiled) $7;

		var modifiers = (Modifiers) $2;
		
		if (current_type != null && name.Name == current_type.MemberName.Name) {

			var c = new Constructor (current_type, name.Name, modifiers, Modifiers.PUBLIC, (Attributes) $1, current_local_parameters, name.Location);

			if ($11 != null) {
					report.Error (7011, c.Location,
						"`{0}': constructor can not have type constraints.",
						c.GetSignatureForError ());
			}

			if ((modifiers & Modifiers.STATIC) != 0) {
				if ((modifiers & Modifiers.AccessibilityMask) != 0){
					report.Error (515, c.Location,
						"`{0}': static constructor cannot have an access modifier",
						c.GetSignatureForError ());
				}
			}

			if (doc_support)
				c.DocComment = Lexer.consume_doc_comment ();
				
			lbag.AddMember (c, mod_locations, GetLocation ($5), GetLocation ($8));
			$$ = c;
		
		} else {
			var method = Method.Create (GetTypeDefinition (current_container), (FullNamedExpression) $9, modifiers,
					     name, current_local_parameters, (Attributes) $1);

			if ($11 != null)
				method.SetConstraints ((List<Constraints>) $11);
					     
			if (doc_support)
				method.DocComment = Lexer.consume_doc_comment ();

			lbag.AddMember (method, mod_locations, GetLocation ($5), GetLocation ($8));
			$$ = method;
			
		}
	  }
	| opt_attributes
	  opt_modifiers
	  FUNCTION_GET method_declaration_name OPEN_PARENS  
	  {
		valid_param_mod = ParameterModifierType.All;
	  }
	  opt_formal_parameter_list CLOSE_PARENS method_colon member_type
	  {
		var type = (FullNamedExpression) $10;
		var name = (MemberName) $4;
		var modifiers = (Modifiers) $2;
		var parameters = (ParametersCompiled) $7;		
		
		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null &&
			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
				modifiers |= Modifiers.VIRTUAL;

		if (parameters != null && parameters.Count > 0)
			report.Error (7016, GetLocation ($10), "Property getter functions may not have parameters");

		current_property = null;		
						
		MemberCore member;
		if (current_type.DefinedNames.TryGetValue(name.Name, out member)) {
			current_property = member as Property;
		}
		
		if (current_property == null) {
			current_property = new Property (current_type, type, modifiers, name, (Attributes) $1);
			if (is_config_enabled) {
				current_type.AddMember (current_property);
			}
			is_config_enabled = true;
			modifiers = (Modifiers) 0;
		} else {
//			if (!type.Equals(current_property.TypeExpression)) {
//				report.Error (7002, GetLocation ($10), "Type of property getter and setter must match", current_property.GetSignatureForError ());
//			}
			if (current_property.Set != null && ModifiersExtensions.IsRestrictedModifier (current_property.ModFlags & Modifiers.AccessibilityMask, modifiers & Modifiers.AccessibilityMask)) {
				current_property.Set.ModFlags |= current_property.ModFlags & Modifiers.AccessibilityMask;
				current_property.ModFlags = (current_property.ModFlags & ~Modifiers.AccessibilityMask) | (modifiers & Modifiers.AccessibilityMask);
				modifiers = (Modifiers) 0;
			} else if ((modifiers & Modifiers.AccessibilityMask) == (current_property.ModFlags & Modifiers.AccessibilityMask)) {
				modifiers = (Modifiers) 0;
			}
		}
		
		if (type.Type != null && type.Type.Kind == MemberKind.Void)
			report.Error (547, GetLocation ($10), "`{0}': property or indexer cannot have void type", current_property.GetSignatureForError ());					
			
		if (current_property.Get != null) {
			report.Error (1007, GetLocation ($3), "Property accessor already defined");
		}
		
		current_property.Get = new Property.GetMethod (current_property,
			modifiers & Modifiers.AccessibilityMask, (Attributes) $1, GetLocation ($3));
	  
		lbag.AddMember (current_property, mod_locations, GetLocation ($10));
		current_local_parameters = current_property.Get.ParameterInfo;
		$$ = current_property.Get;
	  }
    | opt_attributes
	  opt_modifiers
	  FUNCTION_SET method_declaration_name OPEN_PARENS  
	  {
		valid_param_mod = ParameterModifierType.All;
	  }
	  opt_formal_parameter_list CLOSE_PARENS method_colon member_type
	  {
		var void_type = (FullNamedExpression) $10;
		var name = (MemberName) $4;
		var modifiers = (Modifiers) $2;
		var parameters = (ParametersCompiled) $7;
		
		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null &&
			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
				modifiers |= Modifiers.VIRTUAL;
		
		if (void_type.Type != null && void_type.Type.Kind != MemberKind.Void)
			report.Error (7003, GetLocation ($10), "Property setter function must not be of type void");					

		current_property = null;
						
		MemberCore member;
		if (current_type.DefinedNames.TryGetValue(name.Name, out member)) {
			current_property = member as Property;
		}

		FullNamedExpression type; 
		
		if (parameters == null || parameters.Count != 1 || parameters.FixedParameters.Length != parameters.Count) {
			report.Error (7001, GetLocation ($7), "Property setter must have a single parameter");
			type = new TypeExpression (compiler.BuiltinTypes.Int, GetLocation ($7));
		} else {
			type = ((Parameter)parameters.FixedParameters[0]).TypeExpression;	
		}
				
		if (current_property == null) {
			current_property = new Property (current_type, type, modifiers, name, (Attributes) $1);
			if (is_config_enabled) {
				current_type.AddMember (current_property);
			}
			is_config_enabled = true;
			modifiers = (Modifiers) 0;			
		} else {
//			if (!type.Equals(current_property.TypeExpression)) {
//				report.Error (7002, GetLocation ($10), "Type of property getter and setter must match", current_property.GetSignatureForError ());
//			}
			if (current_property.Get != null && ModifiersExtensions.IsRestrictedModifier (current_property.ModFlags & Modifiers.AccessibilityMask, modifiers & Modifiers.AccessibilityMask)) {
				current_property.Get.ModFlags |= current_property.ModFlags & Modifiers.AccessibilityMask;
				current_property.ModFlags = (current_property.ModFlags & ~Modifiers.AccessibilityMask) | (modifiers & Modifiers.AccessibilityMask);
				modifiers = (Modifiers) 0;
			} else if ((modifiers & Modifiers.AccessibilityMask) == (current_property.ModFlags & Modifiers.AccessibilityMask)) {
				modifiers = (Modifiers) 0;
			}
		}
		
		if (current_property.Set != null) {
			report.Error (1007, GetLocation ($3), "Property accessor already defined");
		}
		
		current_property.Set = new Property.SetMethod (current_property, 
			modifiers & Modifiers.AccessibilityMask, (ParametersCompiled) $7, (Attributes) $1, GetLocation ($3));
	  
		lbag.AddMember (current_property, mod_locations, GetLocation ($10));
		current_local_parameters = parameters;
		$$ = current_property.Set;
	  }
	| opt_attributes
	  opt_modifiers
	  PARTIAL
	  FUNCTION
	  {
		lexer.parsing_generic_declaration = true;
	  }
	  method_declaration_name
	  OPEN_PARENS
	  {
		lexer.parsing_generic_declaration = false;
	  	valid_param_mod = ParameterModifierType.All;
	  }
	  opt_formal_parameter_list CLOSE_PARENS COLON VOID
	  {
		lexer.ConstraintsParsing = true;
	  }
	  opt_type_parameter_constraints_clauses
	  {
		lexer.ConstraintsParsing = false;
		valid_param_mod = 0;

		MemberName name = (MemberName) $6;
		current_local_parameters = (ParametersCompiled) $9;

		var modifiers = (Modifiers) $2;
		modifiers |= Modifiers.PARTIAL;

		if (name.ExplicitInterface == null && (modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
			modifiers |= Modifiers.VIRTUAL;
			
		var method = Method.Create (current_type, new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($12)),
				     modifiers, name, current_local_parameters, (Attributes) $1);

		if ($14 != null)
			method.SetConstraints ((List<Constraints>) $14);

		if (doc_support)
			method.DocComment = Lexer.consume_doc_comment ();

		StoreModifierLocation (Modifiers.PARTIAL, GetLocation ($3));
		lbag.AddMember (method, mod_locations, GetLocation ($7), GetLocation ($10));
		$$ = method;
	  }
	| opt_attributes
	  opt_modifiers
	  FUNCTION
	  modifiers method_declaration_name OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS method_colon member_type
	  {
		MemberName name = (MemberName) $5;
		report.Error (1585, name.Location, 
			"Member modifier `{0}' must precede the member type and name", ModifiersExtensions.Name ((Modifiers) $4));

		var method = Method.Create (GetTypeDefinition (current_container), (FullNamedExpression) $1,
					    0, name, (ParametersCompiled) $7, (Attributes) $1);

		current_local_parameters = (ParametersCompiled) $7;

		if (doc_support)
			method.DocComment = Lexer.consume_doc_comment ();

		$$ = method;
	  }
	| opt_attributes
	  opt_modifiers
	  FUNCTION
	  method_declaration_name error
	  {
		Error_SyntaxError (yyToken);
		current_local_parameters = ParametersCompiled.Undefined;

		MemberName name = (MemberName) $4;
		var method = Method.Create (GetTypeDefinition (current_container), new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($4)), (Modifiers) $2,
									name, current_local_parameters, (Attributes) $1);

		if (doc_support)
			method.DocComment = Lexer.consume_doc_comment ();

		$$ = method;
	  }
	;

opt_method_return_type
	: /* empty */
	| method_colon member_type
	  {
		$$ = $2;
	  }
	;

method_colon
	: COLON
	  {
		if (current_container.Kind == MemberKind.Interface) 
			Lexer.AutoSemiInsertion = true;	  
	  }
	;	

method_body
	: block
	| SEMICOLON		
	  { 
	  	// method body.
	   	$$ = null; 
	  }
	;

opt_formal_parameter_list
	: /* empty */			{ $$ = ParametersCompiled.EmptyReadOnlyParameters; }
	| formal_parameter_list
	;
	
formal_parameter_list
	: fixed_parameters
	  {
		var pars_list = (List<Parameter>) $1;
	  	$$ = new ParametersCompiled (pars_list.ToArray ());
	  } 
	| fixed_parameters COMMA parameter_array
	  {
		var pars_list = (List<Parameter>) $1;
		pars_list.Add ((Parameter) $3);

		$$ = new ParametersCompiled (pars_list.ToArray ()); 
	  }
	| parameter_array COMMA error
	  {
		if ($1 != null)
			report.Error (231, ((Parameter) $1).Location, "A params parameter must be the last parameter in a formal parameter list");

		$$ = new ParametersCompiled (new Parameter[] { (Parameter) $1 } );			
	  }
	| fixed_parameters COMMA parameter_array COMMA error
	  {
		if ($3 != null)
			report.Error (231, ((Parameter) $3).Location, "A params parameter must be the last parameter in a formal parameter list");

		var pars_list = (List<Parameter>) $1;
		pars_list.Add (new ArglistParameter (GetLocation ($3)));

		$$ = new ParametersCompiled (pars_list.ToArray (), true);
	  }
	| parameter_array 
	  {
		$$ = new ParametersCompiled (new Parameter[] { (Parameter) $1 } );
	  }
	| error
	  {
		Error_SyntaxError (yyToken);
		$$ = ParametersCompiled.EmptyReadOnlyParameters;
	  }
	;

fixed_parameters
	: fixed_parameter	
	  {
		parameters_bucket.Clear ();
		Parameter p = (Parameter) $1;
		parameters_bucket.Add (p);
		
		default_parameter_used = p.HasDefaultValue;
		$$ = parameters_bucket;
	  }
	| fixed_parameters COMMA fixed_parameter
	  {
		var pars = (List<Parameter>) $1;
		Parameter p = (Parameter) $3;
		if (p != null) {
			if (p.HasExtensionMethodModifier)
				report.Error (1100, p.Location, "The parameter modifier `this' can only be used on the first parameter");
			else if (!p.HasDefaultValue && default_parameter_used)
				report.Error (1737, p.Location, "Optional parameter cannot precede required parameters");

			default_parameter_used |= p.HasDefaultValue;
			pars.Add (p);
			
			lbag.AddLocation (p, GetLocation ($2));
		}
		
		$$ = $1;
	  }
	;

fixed_parameter
	: opt_attributes
	  opt_parameter_modifier
	  IDENTIFIER
	  COLON
	  parameter_type
	  {
		var lt = (LocatedToken) $3;
		$$ = new Parameter ((FullNamedExpression) $5, lt.Value, (Parameter.Modifier) $2, (Attributes) $1, lt.Location);
	  }
	| attribute_sections error
	  {
		Error_SyntaxError (yyToken);
	  	Location l = GetLocation ($2);
		$$ = new Parameter (null, null, Parameter.Modifier.NONE, (Attributes) $1, l);
	  }
	| opt_attributes
	  opt_parameter_modifier
	  IDENTIFIER
	  COLON
	  error
	  {
		Error_SyntaxError (yyToken);
	  	Location l = GetLocation ($5);
		var lt = (LocatedToken) $3;
		$$ = new Parameter (new TypeExpression (compiler.BuiltinTypes.Object, GetLocation ($5)), lt.Value, (Parameter.Modifier) $2, (Attributes) $1, l);
	  }
	| opt_attributes
	  opt_parameter_modifier
	  IDENTIFIER
	  COLON
	  parameter_type
	  ASSIGN
	  {
	  	++lexer.parsing_block;
	  }
	  constant_expression
	  {
	  	--lexer.parsing_block;
		if (lang_version <= LanguageVersion.V_3) {
			FeatureIsNotAvailable (GetLocation ($6), "optional parameter");
		}
		
		Parameter.Modifier mod = (Parameter.Modifier) $2;
		if (mod != Parameter.Modifier.NONE) {
			switch (mod) {
			case Parameter.Modifier.REF:
			case Parameter.Modifier.OUT:
				report.Error (1741, GetLocation ($2), "Cannot specify a default value for the `{0}' parameter",
					Parameter.GetModifierSignature (mod));
				break;
				
			case Parameter.Modifier.This:
				report.Error (1743, GetLocation ($2), "Cannot specify a default value for the `{0}' parameter",
					Parameter.GetModifierSignature (mod));
				break;
			default:
				throw new NotImplementedException (mod.ToString ());
			}
				
			mod = Parameter.Modifier.NONE;
		}
		
		if ((valid_param_mod & ParameterModifierType.DefaultValue) == 0)
			report.Error (1065, GetLocation ($6), "Optional parameter is not valid in this context");
		
		var lt = (LocatedToken) $3;
		$$ = new Parameter ((FullNamedExpression) $5, lt.Value, mod, (Attributes) $1, lt.Location);
		lbag.AddLocation ($$, GetLocation ($6));
		
		if ($8 != null)
			((Parameter) $$).DefaultValue = new DefaultParameterValueExpression ((Expression) $8);
	  }
	;

opt_parameter_modifier
	: /* empty */		{ $$ = Parameter.Modifier.NONE; }
	| parameter_modifiers
	;

parameter_modifiers
	: parameter_modifier
	  {
		$$ = $1;
	  }
	| parameter_modifiers parameter_modifier
	  {
		Parameter.Modifier p2 = (Parameter.Modifier)$2;
  		Parameter.Modifier mod = (Parameter.Modifier)$1 | p2;
  		if (((Parameter.Modifier)$1 & p2) == p2) {
  			Error_DuplicateParameterModifier (lexer.Location, p2);
  		} else {
	  		switch (mod & ~Parameter.Modifier.This) {
  				case Parameter.Modifier.REF:
					report.Error (1101, lexer.Location, "The parameter modifiers `this' and `ref' cannot be used altogether");
  					break;
   				case Parameter.Modifier.OUT:
					report.Error (1102, lexer.Location, "The parameter modifiers `this' and `out' cannot be used altogether");
  					break;
  				default:
 					report.Error (1108, lexer.Location, "A parameter cannot have specified more than one modifier");
 					break;
 			}
  		}
  		$$ = mod;
	  }
	;

parameter_modifier
	: REF
	  {
	  	if ((valid_param_mod & ParameterModifierType.Ref) == 0)
	  		Error_ParameterModifierNotValid ("ref", GetLocation ($1));
	  		
	  	$$ = Parameter.Modifier.REF;
	  }
	| OUT
	  {
	  	if ((valid_param_mod & ParameterModifierType.Out) == 0)
	  		Error_ParameterModifierNotValid ("out", GetLocation ($1));
	  
	  	$$ = Parameter.Modifier.OUT;
	  }
	| THIS
	  {
		if ((valid_param_mod & ParameterModifierType.This) == 0)
	  		Error_ParameterModifierNotValid ("this", GetLocation ($1));

	  	if (lang_version <= LanguageVersion.ISO_2)
	  		FeatureIsNotAvailable (GetLocation ($1), "extension methods");
	  			
		$$ = Parameter.Modifier.This;
	  }
	;

parameter_array
	: opt_attributes DOTDOTDOT IDENTIFIER opt_rest_parameter_type
	  {
		var lt = (LocatedToken) $3;
		$$ = new RestArrayParameter (lt.Value, (Attributes) $1, lt.Location);
	  }
	| opt_attributes DOTDOTDOT error
	  {
		Error_SyntaxError (yyToken);
		$$ = null;
	  }
	;

opt_rest_parameter_type
	: /* empty */
	| COLON IDENTIFIER
	  {
		var lt = (LocatedToken) $2;

		// TODO: Do I need to resolve the type for correct checking
		if (lt.Value != "Array")
			report.ErrorPlayScript (1140, GetLocation ($2), "Parameters specified after the ...rest parameter definition keyword can only be an Array data type");        
		}
	;
	
indexer_declaration
	: opt_attributes opt_modifiers
	  INDEXER indexer_declaration_name OPEN_PARENS
	  {
	  	valid_param_mod = ParameterModifierType.Params | ParameterModifierType.DefaultValue;
	  }
	  opt_formal_parameter_list CLOSE_PARENS COLON member_type OPEN_BRACE
	  {
		valid_param_mod = 0;
		var type = (FullNamedExpression) $10;

		var modifiers = (Modifiers) $2;
		
		var name = (MemberName) $4;

		if (current_container.Kind == MemberKind.Class && name.ExplicitInterface == null && 
			(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
				modifiers |= Modifiers.VIRTUAL;
		
		Indexer indexer = new Indexer (current_type, type, name, modifiers, (ParametersCompiled) $7, (Attributes) $1);
			
		current_property = indexer;

		if (is_config_enabled) {
	  		current_type.AddIndexer (indexer);
	  	}
	  	is_config_enabled = true;
		lbag.AddMember (current_property, mod_locations, GetLocation ($5), GetLocation ($8));
  		
		if (type.Type != null && type.Type.Kind == MemberKind.Void)
			report.Error (620, GetLocation ($3), "`{0}': indexer return type cannot be `void'", indexer.GetSignatureForError ());  		

		if (indexer.ParameterInfo.IsEmpty) {
			report.Error (1551, GetLocation ($5), "Indexers must have at least one parameter");
		}

		if (doc_support) {
			tmpComment = Lexer.consume_doc_comment ();
			Lexer.doc_state = XmlCommentState.Allowed;
		}

		lexer.PropertyParsing = true;
	  }
	  accessor_declarations 
	  {
		lexer.PropertyParsing = false;
	  }
	  CLOSE_BRACE
	  {
  		CheckIsPlayScript("indexer", GetLocation($3)); 	
	  
		if (current_property.AccessorFirst != null && current_property.AccessorFirst.Block == null)
			((Indexer) current_property).ParameterInfo.CheckParameters (current_property);
	  
		if (doc_support)
			current_property.DocComment = ConsumeStoredComment ();
			
		lbag.AppendToMember (current_property, GetLocation ($12));
		current_property = null;		
	  }
	;


accessor_declarations
	: get_accessor_declaration
	| get_accessor_declaration accessor_declarations
	| set_accessor_declaration
	| set_accessor_declaration accessor_declarations
	| error
	  {
	  	if (yyToken == Token.CLOSE_BRACE) {
	  		report.Error (548, lexer.Location, "`{0}': property or indexer must have at least one accessor", current_property.GetSignatureForError ());
		} else {
			if (yyToken == Token.SEMICOLON)
				report.Error (1597, lexer.Location, "Semicolon after method or accessor block is not valid");
			else
				report.Error (1014, GetLocation ($1), "A get or set accessor expected");
		}
	  }
	;

get_accessor_declaration
	: opt_attributes opt_modifiers GET
	  {
		if ($2 != ModifierNone && lang_version == LanguageVersion.ISO_1) {
			FeatureIsNotAvailable (GetLocation ($2), "access modifiers on properties");
		}
	  
		if (current_property.Get != null) {
			report.Error (1007, GetLocation ($3), "Property accessor already defined");
		}
		
		if (current_property is Indexer) {
			current_property.Get = new Indexer.GetIndexerMethod (current_property, (Modifiers) $2, ((Indexer)current_property).ParameterInfo.Clone (),
				(Attributes) $1, GetLocation ($3));
		} else {
			current_property.Get = new Property.GetMethod (current_property,
				(Modifiers) $2, (Attributes) $1, GetLocation ($3));
		}	
	  
		current_local_parameters = current_property.Get.ParameterInfo;	  
		lbag.AddMember (current_property.Get, mod_locations);
		lexer.PropertyParsing = false;
	  }
	  accessor_body
	  {
	  	if ($5 != null) {
	  		current_property.Get.Block = (ToplevelBlock) $5;			
	  	
			if (current_container.Kind == MemberKind.Interface) {
				report.Error (531, current_property.Get.Block.StartLocation,
					"`{0}': interface members cannot have a definition", current_property.Get.GetSignatureForError ());
			}		
		}
	  
		current_local_parameters = null;
		lexer.PropertyParsing = true;

		if (doc_support)
			if (Lexer.doc_state == XmlCommentState.Error)
				Lexer.doc_state = XmlCommentState.NotAllowed;
	  }
	;

set_accessor_declaration
	: opt_attributes opt_modifiers SET 
	  {
		if ($2 != ModifierNone && lang_version == LanguageVersion.ISO_1) {
			FeatureIsNotAvailable (GetLocation ($2), "access modifiers on properties");
		}
		
		if (current_property.Set != null) {
			report.Error (1007, GetLocation ($3), "Property accessor already defined");
		}
	  
		if (current_property is Indexer) {
			current_property.Set = new Indexer.SetIndexerMethod (current_property, (Modifiers) $2,
				ParametersCompiled.MergeGenerated (compiler,
				((Indexer)current_property).ParameterInfo, true, new Parameter (
					current_property.TypeExpression, "value", Parameter.Modifier.NONE, null, GetLocation ($3)),
					null),
				(Attributes) $1, GetLocation ($3));
		} else {
			current_property.Set = new Property.SetMethod (current_property, (Modifiers) $2, 
				ParametersCompiled.CreateImplicitParameter (current_property.TypeExpression, GetLocation ($3)),
				(Attributes) $1, GetLocation ($3));
		}
		
		current_local_parameters = current_property.Set.ParameterInfo;	
		lbag.AddMember (current_property.Set, mod_locations);
		lexer.PropertyParsing = false;
	  }
	  accessor_body
	  {
		if ($5 != null) {		
			current_property.Set.Block = (ToplevelBlock) $5;
		
			if (current_container.Kind == MemberKind.Interface) {
				report.Error (531, current_property.Set.Block.StartLocation,
					"`{0}': interface members cannot have a definition", current_property.Set.GetSignatureForError ());
			}
		}
		
		current_local_parameters = null;
		lexer.PropertyParsing = true;

		if (doc_support
			&& Lexer.doc_state == XmlCommentState.Error)
			Lexer.doc_state = XmlCommentState.NotAllowed;
	  }
	;

accessor_body
	: block 
	| SEMICOLON
	  {
		// TODO: lbag
	  	$$ = null;
	  }
	| error
	  {
	  	Error_SyntaxError (1043, yyToken, "Invalid accessor body");
	  	$$ = null;
	  }
	;

interface_declaration
	: opt_attributes
	  opt_modifiers
	  opt_partial
	  INTERFACE
	  {
		lexer.ConstraintsParsing = true;
	    Lexer.AutoSemiInsertion = false;
	  }
	  type_declaration_name
	  {
	    bool is_partial = IsPartial($1) || $3 != null;
		push_current_container (new Interface (current_container, (MemberName) $6, (Modifiers) $2, (Attributes) $1), is_partial);
		lbag.AddMember (current_container, mod_locations, GetLocation ($4));		
	  }
	  opt_class_extends
	  opt_class_implements
	  opt_type_parameter_constraints_clauses
	  {
		lexer.ConstraintsParsing = false;

		if ($10 != null)
			current_container.SetConstraints ((List<Constraints>) $10);

		if (doc_support) {
			current_container.PartialContainer.DocComment = Lexer.consume_doc_comment ();
			Lexer.doc_state = XmlCommentState.Allowed;
		}
		
		lexer.parsing_modifiers = true;
	  }
	  OPEN_BRACE
	  {
	    Lexer.AutoSemiInsertion = true;
	  }
	  opt_interface_member_declarations CLOSE_BRACE opt_semicolon
	  {
		--lexer.parsing_declaration;	  
		if (doc_support)
			Lexer.doc_state = XmlCommentState.Allowed;

	    lbag.AppendToMember (current_container, GetLocation ($12), GetLocation ($15));
		$$ = pop_current_class ();
	  }
	| opt_attributes opt_modifiers opt_partial INTERFACE error
	  {
		Error_SyntaxError (yyToken);	  
	  }
	;

opt_interface_member_declarations
	: /* empty */
	| interface_member_declarations
	;

interface_member_declarations
	: interface_member_declaration
	  {
		lexer.parsing_modifiers = true;
	  }
	| interface_member_declarations interface_member_declaration
	  {
		lexer.parsing_modifiers = true;
	  }
	;

interface_member_declaration
	: constant_declaration
	  {
		report.Error (525, GetLocation ($1), "Interfaces cannot contain fields or constants");
	  }
	| field_declaration
	  {
		report.Error (525, GetLocation ($1), "Interfaces cannot contain fields or constants");
	  }
	| method_declaration
	| indexer_declaration
	| operator_declaration
	  {
	  	report.Error (567, GetLocation ($1), "Interfaces cannot contain operators");
	  }
	| type_declaration
	  {
	  	report.Error (524, GetLocation ($1), "Interfaces cannot declare classes, structs, interfaces, delegates, or enumerations");
	  }
	;

operator_declaration
	: opt_attributes opt_modifiers operator_declarator 
	  {
	  }
	  operator_body
	  {
		OperatorDeclaration decl = (OperatorDeclaration) $3;
		if (decl != null) {
			var modifiers = (Modifiers) $2;
			
//			if (current_container.Kind == MemberKind.Class && 
//				(modifiers & (Modifiers.NEW | Modifiers.SEALED | Modifiers.STATIC | Modifiers.PRIVATE | Modifiers.VIRTUAL | Modifiers.OVERRIDE)) == 0)
//					modifiers |= Modifiers.VIRTUAL;			
		
			if (current_local_parameters.Count < 1) {
			
				report.Error (7037, GetLocation ($1), "Invalid number of parameters for operator.");			
			
			} else {
			
				Operator op = new Operator (
					current_type, decl.optype, decl.ret_type, modifiers, 
					current_local_parameters,
					(ToplevelBlock) $5, (Attributes) $1, decl.location);
				
				if (op.Block == null)
					op.ParameterInfo.CheckParameters (op);

				if (doc_support) {
					op.DocComment = tmpComment;
					Lexer.doc_state = XmlCommentState.Allowed;
				}

				// Note again, checking is done in semantic analysis
				if (is_config_enabled) {
					current_type.AddOperator (op);
				}
				is_config_enabled = true;

				lbag.AddMember (op, mod_locations, lbag.GetLocations (decl));
			}
		}
		
		current_local_parameters = null;
	  }
	;

operator_body 
	: block
	| SEMICOLON { $$ = null; }
	; 

operator_type
	: type_expression_or_array
	| VOID
	  {
		report.Error (590, GetLocation ($1), "User-defined operators cannot return void");
		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
	  }
	;

operator_declarator
	: OPERATOR overloadable_operator OPEN_PARENS
	  {
		valid_param_mod = ParameterModifierType.DefaultValue;
	  }
	  opt_formal_parameter_list CLOSE_PARENS COLON operator_type 
	  {
		CheckIsPlayScript("operator", GetLocation($1)); 	  
	  
		valid_param_mod = 0;

		Location loc = GetLocation ($1);
		Operator.OpType op = (Operator.OpType) $8;
		current_local_parameters = (ParametersCompiled)$5;
		
		int p_count = current_local_parameters.Count;
		if (p_count == 1) {
			if (op == Operator.OpType.Addition)
				op = Operator.OpType.UnaryPlus;
			else if (op == Operator.OpType.Subtraction)
				op = Operator.OpType.UnaryNegation;
		}
		
		if (IsUnaryOperator (op)) {
			if (p_count == 2) {
				report.Error (1020, loc, "Overloadable binary operator expected");
			} else if (p_count != 1) {
				report.Error (1535, loc, "Overloaded unary operator `{0}' takes one parameter",
					Operator.GetName (op));
			}
		} else {
			if (p_count > 2) {
				report.Error (1534, loc, "Overloaded binary operator `{0}' takes two parameters",
					Operator.GetName (op));
			} else if (p_count != 2) {
				report.Error (1019, loc, "Overloadable unary operator expected");
			}
		}
		
		if (doc_support) {
			tmpComment = Lexer.consume_doc_comment ();
			Lexer.doc_state = XmlCommentState.NotAllowed;
		}

		$$ = new OperatorDeclaration (op, (FullNamedExpression) $8, loc);
		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($3), GetLocation ($6));
	  }
	| conversion_operator_declarator
	;

overloadable_operator
// Unary operators:
	: BANG   { $$ = Operator.OpType.LogicalNot; }
        | TILDE  { $$ = Operator.OpType.OnesComplement; }  
        | OP_INC { $$ = Operator.OpType.Increment; }
        | OP_DEC { $$ = Operator.OpType.Decrement; }
        | TRUE   { $$ = Operator.OpType.True; }
        | FALSE  { $$ = Operator.OpType.False; }
// Unary and binary:
        | PLUS { $$ = Operator.OpType.Addition; }
        | MINUS { $$ = Operator.OpType.Subtraction; }
// Binary:
        | STAR { $$ = Operator.OpType.Multiply; }
        | DIV {  $$ = Operator.OpType.Division; }
        | PERCENT { $$ = Operator.OpType.Modulus; }
        | BITWISE_AND { $$ = Operator.OpType.BitwiseAnd; }
        | BITWISE_OR { $$ = Operator.OpType.BitwiseOr; }
        | CARRET { $$ = Operator.OpType.ExclusiveOr; }
        | OP_SHIFT_LEFT { $$ = Operator.OpType.LeftShift; }
        | OP_SHIFT_RIGHT { $$ = Operator.OpType.RightShift; }
//TODO: really        | OP_USHIFT_RIGHT { $$ = Operator.OpType.AsURightShift; }
        | OP_EQ { $$ = Operator.OpType.Equality; }
        | OP_NE { $$ = Operator.OpType.Inequality; }
        | OP_GT { $$ = Operator.OpType.GreaterThan; }
        | OP_LT { $$ = Operator.OpType.LessThan; }
        | OP_GE { $$ = Operator.OpType.GreaterThanOrEqual; }
        | OP_LE { $$ = Operator.OpType.LessThanOrEqual; }
//TODO:        | OP_IN { $$ = Operator.OpType.AsIn; }
	;

conversion_operator_declarator
	: IMPLICIT OPERATOR type OPEN_PARENS
	  {
		valid_param_mod = ParameterModifierType.DefaultValue;
	  }
	  opt_formal_parameter_list CLOSE_PARENS
	  {
		valid_param_mod = 0;

		Location loc = GetLocation ($2);
		current_local_parameters = (ParametersCompiled)$6;  
		  
		if (doc_support) {
			tmpComment = Lexer.consume_doc_comment ();
			Lexer.doc_state = XmlCommentState.NotAllowed;
		}

		$$ = new OperatorDeclaration (Operator.OpType.Implicit, (FullNamedExpression) $3, loc);
		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4), GetLocation ($7));
	  }
	| EXPLICIT OPERATOR type OPEN_PARENS
	  {
		valid_param_mod = ParameterModifierType.DefaultValue;
	  }
	  opt_formal_parameter_list CLOSE_PARENS
	  {
		valid_param_mod = 0;
		
		Location loc = GetLocation ($2);
		current_local_parameters = (ParametersCompiled)$6;  
		  
		if (doc_support) {
			tmpComment = Lexer.consume_doc_comment ();
			Lexer.doc_state = XmlCommentState.NotAllowed;
		}

		$$ = new OperatorDeclaration (Operator.OpType.Explicit, (FullNamedExpression) $3, loc);
		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($2), GetLocation ($4), GetLocation ($7));
	  }
	| IMPLICIT error 
	  {
	  	Error_SyntaxError (yyToken);
		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
		$$ = new OperatorDeclaration (Operator.OpType.Implicit, null, GetLocation ($1));
	  }
	| EXPLICIT error 
	  {
	  	Error_SyntaxError (yyToken);
		current_local_parameters = ParametersCompiled.EmptyReadOnlyParameters;
	  	$$ = new OperatorDeclaration (Operator.OpType.Explicit, null, GetLocation ($1));
	  }
	;


attributes_without_members
	: attribute_sections CLOSE_BRACE
	  {
		current_type.UnattachedAttributes = (Attributes) $1;
		report.Error (1519, GetLocation ($1), "An attribute is missing member declaration");
		lexer.putback ('}');
	  }
	;

opt_nullable
	: /* empty */
	| INTERR_NULLABLE
	  {
		if (lang_version < LanguageVersion.ISO_2)
			FeatureIsNotAvailable (GetLocation ($1), "nullable types");
	  
	  	$$ = ComposedTypeSpecifier.CreateNullable (GetLocation ($1));
	  }
	;

namespace_or_type_expr
	: member_name
	| qualified_identifier IDENTIFIER opt_type_argument_list
	  {
		var lt1 = (LocatedToken) $1;
		var lt2 = (LocatedToken) $2;
		
		$$ = new QualifiedMemberAccess (lt1.Value, lt2.Value, lt1.Location);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

member_name
	: simple_name_expr
	| namespace_or_type_expr DOT IDENTIFIER opt_type_argument_list
	  {
	    // member_name
		var lt = (LocatedToken) $3;
		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

simple_name_expr
	: IDENTIFIER opt_type_argument_list
	  {
	    // simple_name_expr
		var lt = (LocatedToken) $1;
		$$ = new SimpleName (lt.Value, (TypeArguments)$2, lt.Location);
	  }
	;
	
//
// Generics arguments  (any type, without attributes)
//
opt_type_argument_list
	: /* empty */
	| OP_GENERICS_LT type_arguments OP_GENERICS_GT
	  {
		if (lang_version < LanguageVersion.ISO_2)
			FeatureIsNotAvailable (GetLocation ($1), "generics");	  
	  
		$$ = $2;
	  }
	| OP_GENERICS_LT error
	  {
		Error_TypeExpected (lexer.Location);
		$$ = new TypeArguments ();
	  }
	;

type_arguments
	: type
	  {
		TypeArguments type_args = new TypeArguments ();
		type_args.Add ((FullNamedExpression) $1);
		$$ = type_args;
	  }
	| type_arguments COMMA type
	  {
		TypeArguments type_args = (TypeArguments) $1;
		type_args.Add ((FullNamedExpression) $3);
		$$ = type_args;
	  }	  
	;

//
// Generics parameters (identifiers only, with attributes), used in type or method declarations
//
type_declaration_name
	: IDENTIFIER
	  {
		lexer.parsing_generic_declaration = true;
	  }
	  opt_type_parameter_list
	  {
		lexer.parsing_generic_declaration = false;
		var lt = (LocatedToken) $1;
		$$ = CreateFullMemberName (lt, (TypeParameters)$3);
	  }
	;

member_declaration_name
	: method_declaration_name
	  {
	  	MemberName mn = (MemberName)$1;
	  	if (mn.TypeParameters != null)
	  		syntax_error (mn.Location, string.Format ("Member `{0}' cannot declare type arguments",
	  			mn.GetSignatureForError ()));
	  }
	;

method_declaration_name
	: type_declaration_name
/*	
	| explicit_interface IDENTIFIER opt_type_parameter_list
	  {
		lexer.parsing_generic_declaration = false;	  
		var lt = (LocatedToken) $2;
		$$ = new MemberName (lt.Value, (TypeParameters) $3, (ATypeNameExpression) $1, lt.Location);
	  }
*/
	;
	
indexer_declaration_name
	: THIS
	  {
		lexer.parsing_generic_declaration = false;	  
		$$ = new MemberName (TypeDefinition.DefaultIndexerName, GetLocation ($1));
	  }
/*	  
	| explicit_interface THIS
	  {
		lexer.parsing_generic_declaration = false;
		$$ = new MemberName (TypeDefinition.DefaultIndexerName, null, (ATypeNameExpression) $1, GetLocation ($2));
	  }
*/
	;
/*
explicit_interface
	: IDENTIFIER opt_type_argument_list DOT
	  {
		var lt = (LocatedToken) $1;
		$$ = new CSharp.SimpleName (lt.Value, (TypeArguments) $2, lt.Location);
		lbag.AddLocation ($$, GetLocation ($3));
	  }
//	| qualified_alias_member IDENTIFIER opt_type_argument_list DOT
//	  {
//		var lt1 = (LocatedToken) $1;
//		var lt2 = (LocatedToken) $2;
//
//		$$ = new QualifiedAliasMember (lt1.Value, lt2.Value, (TypeArguments) $3, lt1.Location);
//		lbag.AddLocation ($$, GetLocation ($4));
//	  }
	| explicit_interface IDENTIFIER opt_type_argument_list DOT
	  {
		var lt = (LocatedToken) $2;
		$$ = new MemberAccess ((ATypeNameExpression) $1, lt.Value, (TypeArguments) $3, lt.Location);
		lbag.AddLocation ($$, GetLocation ($4));
	  }
	;
*/

opt_type_parameter_list
	: /* empty */
	| OP_GENERICS_LT type_parameters OP_GENERICS_GT
	  {
		if (lang_version < LanguageVersion.ISO_2)
			FeatureIsNotAvailable (GetLocation ($1), "generics");
	  
		$$ = $2;
		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
	  }
	;

type_parameters
	: type_parameter
	  {
		var tparams = new TypeParameters ();
		tparams.Add ((TypeParameter)$1);
		$$ = tparams;
	  }
	| type_parameters COMMA type_parameter
	  {
		var tparams = (TypeParameters) $1;
		tparams.Add ((TypeParameter)$3);
		$$ = tparams;
		lbag.AddLocation ($3, GetLocation ($3));
	  }	  
	;

type_parameter
	: opt_attributes opt_type_parameter_variance IDENTIFIER
	  {
		var lt = (LocatedToken)$3;
		$$ = new TypeParameter (new MemberName (lt.Value, lt.Location), (Attributes)$1, (Variance) $2);
  	  }
  	| error
  	  {
  	  	if (GetTokenName (yyToken) == "type")
			report.Error (81, GetLocation ($1), "Type parameter declaration must be an identifier not a type");
		else
			Error_SyntaxError (yyToken);
			
  	  	$$ = new TypeParameter (MemberName.Null, null, Variance.None);
  	  }
 	;

//
// All types where void is allowed
//
type_and_void
	: type_expression_or_array
	| VOID
	  {
		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
	  }
	;
	
member_type
	: type_and_void
	  {
		lexer.parsing_generic_declaration = true;
	  }
	;
	
//
// A type which does not allow `void' to be used
//
type
	: type_expression_or_array
	| VOID
	  {
	  	Expression.Error_VoidInvalidInTheContext (GetLocation ($1), report);
		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
	  }	
	;
	
simple_type
	: type_expression
	| VOID
	  {
	  	Expression.Error_VoidInvalidInTheContext (GetLocation ($1), report);
		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
	  }	
	;
	
parameter_type
	: type_expression_or_array
	| VOID
	  {
	  	report.Error (1536, GetLocation ($1), "Invalid parameter type `void'");
		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
	  }	
	;

type_expression_or_array
	: type_expression
	| type_expression rank_specifiers
	  {
	  	CheckIsPlayScript("arrays", GetLocation($2));
		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
	  }
	;
	
type_expression
	: namespace_or_type_expr opt_nullable
	  {
		if ($2 != null) {
			$$ = new ComposedCast ((ATypeNameExpression) $1, (ComposedTypeSpecifier) $2);
		} else {
//			var sn = $1 as SimpleName;
//			if (sn != null)
//				$$ = ConvertAsType(sn, $1);
//			else
				$$ = $1;
		}
	  }
	| STAR
	  {
	  	$$ = new UntypedTypeExpression (GetLocation ($1));
	  }
//	| namespace_or_type_expr pointer_stars
//	  {
//		$$ = new ComposedCast ((ATypeNameExpression) $1, (ComposedTypeSpecifier) $2);
//	  }
	| builtin_types opt_nullable
	  {
		if ($2 != null)
			$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
	  }
//	| builtin_types pointer_stars
//	  {
//		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
//	  }
//	| VOID pointer_stars
//	  {
//		$$ = new ComposedCast (new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1)), (ComposedTypeSpecifier) $2);
//	  }
	;

type_list
	: base_type_name
	  {
		var types = new List<FullNamedExpression> (2);
		types.Add ((FullNamedExpression) $1);
		$$ = types;
	  }
	| type_list COMMA base_type_name
	  {
		var types = (List<FullNamedExpression>) $1;
		types.Add ((FullNamedExpression) $3);
		$$ = types;
	  }
	;

base_type_name
	: type
	  {
		if ($1 is ComposedCast) {
			report.Error (1521, GetLocation ($1), "Invalid base type `{0}'", ((ComposedCast)$1).GetSignatureForError ());
		}
		$$ = $1;
	  }
	;
	
/*
 * replaces all the productions for isolating the various
 * simple types, but we need this to reuse it easily in variable_type
 */
builtin_types
	: INT		{ $$ = new TypeExpression (compiler.BuiltinTypes.Int, GetLocation ($1)); }
	| UINT		{ $$ = new TypeExpression (compiler.BuiltinTypes.UInt, GetLocation ($1)); }
	;

//
// Expressions, section 7.5
//


primary_expression
	: primary_expression_or_type
	| literal
//	| array_creation_expression
	| parenthesized_expression
	| default_value_expression
	| invocation_expression
	| element_access
	| this_access
	| base_access
	| post_increment_expression
	| post_decrement_expression
	| new_expression
	| anonymous_method_expression
	| array_creation
	| object_initializer
	| e4x_operators
	;

primary_expression_or_type
	: IDENTIFIER opt_type_argument_list
	  {
	    // primary_expression_or_type
		var lt = (LocatedToken) $1;
		$$ = new SimpleName (lt.Value, (TypeArguments)$2, lt.Location);	  
	  }
	| IDENTIFIER GENERATE_COMPLETION {
		var lt = (LocatedToken) $1;
	       $$ = new CompletionSimpleName (MemberName.MakeName (lt.Value, null), lt.Location);
	  }
	| member_access
	;

literal
	: boolean_literal
	| LITERAL
	| NULL			{ $$ = new NullLiteral (GetLocation ($1)); }
	;

boolean_literal
	: TRUE			{ $$ = new BoolLiteral (compiler.BuiltinTypes, true, GetLocation ($1)); }
	| FALSE			{ $$ = new BoolLiteral (compiler.BuiltinTypes, false, GetLocation ($1)); }
	;


//
// Here is the trick, tokenizer may think that parens is a special but
// parser is interested in open parens only, so we merge them.
// Consider: if (a)foo ();
//
open_parens_any
	: OPEN_PARENS
	| OPEN_PARENS_CAST
	;

// 
// Use this production to accept closing parenthesis or 
// performing completion
//
close_parens
	: CLOSE_PARENS
	| COMPLETE_COMPLETION
	;


parenthesized_expression
	: OPEN_PARENS expression CLOSE_PARENS
	  {
		$$ = new ParenthesizedExpression ((Expression) $2, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
	  }
	| OPEN_PARENS expression COMPLETE_COMPLETION
	  {
		$$ = new ParenthesizedExpression ((Expression) $2, GetLocation ($1));
	  }
	;
	
member_access
	: primary_expression DOT identifier_inside_body opt_type_argument_list
	  {
		var lt = (LocatedToken) $3;
		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| builtin_types DOT identifier_inside_body opt_type_argument_list
	  {
		var lt = (LocatedToken) $3;
		$$ = new MemberAccess ((Expression) $1, lt.Value, (TypeArguments) $4, lt.Location);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| SUPER DOT IDENTIFIER opt_type_argument_list
	  {
		var lt = (LocatedToken) $3;
		$$ = new MemberAccess (new BaseThis (GetLocation ($1)), lt.Value, (TypeArguments) $4, lt.Location);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| qualified_identifier identifier_inside_body opt_type_argument_list
	  {
		var lt1 = (LocatedToken) $1;
		var lt2 = (LocatedToken) $2;

		$$ = new QualifiedMemberAccess (lt1.Value, lt2.Value, lt1.Location);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| primary_expression DOT GENERATE_COMPLETION {
		$$ = new CompletionMemberAccess ((Expression) $1, null,GetLocation ($3));
	  }
	| primary_expression DOT IDENTIFIER GENERATE_COMPLETION {
		var lt = (LocatedToken) $3;
		$$ = new CompletionMemberAccess ((Expression) $1, lt.Value, lt.Location);
	  }
	| builtin_types DOT GENERATE_COMPLETION
	  {
		$$ = new CompletionMemberAccess ((Expression) $1, null, lexer.Location);
	  }
	| builtin_types DOT IDENTIFIER GENERATE_COMPLETION {
		var lt = (LocatedToken) $3;
		$$ = new CompletionMemberAccess ((Expression) $1, lt.Value, lt.Location);
 	  }
	;

e4x_operators
	: primary_expression DOT_AT IDENTIFIER
	  {
		var lt = (LocatedToken) $3;
		var ma = new E4XOperator (E4XOperator.Operator.ChildAttribute, (Expression) $1, lt.Value, lt.Location);
		lbag.AddLocation ($$, GetLocation ($2));
		$$ = ma;
	  }
	| primary_expression DOT_STAR
	  {
		var ma = new E4XOperator (E4XOperator.Operator.ChildAll, (Expression) $1, "any", GetLocation ($2));
		lbag.AddLocation ($$, GetLocation ($2));
		$$ = ma;
	  }
	| primary_expression DOTDOT IDENTIFIER
	  {
		var lt = (LocatedToken) $3;
		var ma = new E4XOperator (E4XOperator.Operator.Descendant, (Expression) $1, lt.Value, lt.Location);
		lbag.AddLocation ($$, GetLocation ($2));
		$$ = ma;
	  }
	| primary_expression DOTDOT_STAR
	  {
		var ma = new E4XOperator (E4XOperator.Operator.DescendantAll, (Expression) $1, "any", GetLocation ($2));
		lbag.AddLocation ($$, GetLocation ($2));
		$$ = ma;
	  }
/*
	| primary_expression DOUBLE_COLON IDENTIFIER
	  {
		var lt = (LocatedToken) $3;
		var ma = new E4XOperator (E4XOperator.Operator.Namespace, (Expression) $1, lt.Value, lt.Location);
		lbag.AddLocation ($$, GetLocation ($2));
		$$ = ma;
	  }
	| primary_expression DOUBLE_COLON OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET
	  {
		var ea = new E4XIndexer (E4XIndexer.Operator.Namespace, (Expression) $1, (Arguments) $4, GetLocation ($3));
		lbag.AddLocation (GetLocation ($3), GetLocation ($5));
		$$ = ea;
	  }
*/	  
	| primary_expression DOT_AT OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET
	  {
		var ea = new E4XIndexer (E4XIndexer.Operator.Attribute, (Expression) $1, (Arguments) $4, GetLocation ($3));
		lbag.AddLocation (GetLocation ($3), GetLocation ($5));
		$$ = ea;
	  }	  
	| primary_expression DOT open_parens_any expression CLOSE_PARENS
	  {
		var lt = (LocatedToken) $3;
		var ma = new AsXmlQueryExpression ((Expression) $1, (Expression) $4, lt.Location);
		lbag.AddLocation ($$, GetLocation ($2));
		$$ = ma;
	  }
	;

invocation_expression
	: SUPER open_parens_any opt_argument_list close_parens
	  {
		if (current_constructor == null) {
			report.ErrorPlayScript (1007, GetLocation ($1), "A super statement can be used only inside class instance constructors");
		} else {
			current_constructor.Initializer = EmptyExpressionStatement.Instance;
		}

 		$$ = new SuperBaseInitializer ((Arguments) $3, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
	  }
	| builtin_types open_parens_any opt_argument_list close_parens
	  {
		$$ = new Invocation ((Expression) $1, (Arguments) $3);
		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
	  }  
	| primary_expression open_parens_any opt_argument_list close_parens
	  {
		$$ = new Invocation ((Expression) $1, (Arguments) $3);
		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
	  }
	| primary_expression open_parens_any argument_list error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Invocation ((Expression) $1, (Arguments) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

object_initializer
	: init_open_brace opt_member_initializer_list init_close_brace
	  {
	  	$$ = new ObjectInitializer ((List<Expression>) $2, GetLocation ($1));
	  	lbag.AddLocation ($$, GetLocation ($1), GetLocation ($3));
	  }
	;

init_open_brace
	: OPEN_BRACE_INIT
	  {
      	oob_stack.Push (Lexer.AutoSemiInsertion);
        Lexer.AutoSemiInsertion = false;
	  }
	;

init_close_brace
 	: CLOSE_BRACE
 	  {
      	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
      	if (Lexer.AutoSemiInsertion)
	 	  	Lexer.AllowAutoSemiAfterToken(Token.CLOSE_BRACE, true);
 	  }
 	;
 	
init_close_brace_or_complete_completion
	: CLOSE_BRACE
 	  {
      	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
      	if (Lexer.AutoSemiInsertion)
	 	  	Lexer.AllowAutoSemiAfterToken(Token.CLOSE_BRACE, true);
 	  }
	| COMPLETE_COMPLETION
	; 	

opt_member_initializer_list
	: /* empty */		{ $$ = null; }
	| member_initializer_list
	  {
		$$ = $1;
	  }
	;

member_initializer_list
	: member_initializer
	  {
	  	var a = new List<Expression> ();
	  	a.Add ((Expression) $1);
	  	$$ = a;
	  }
	| member_initializer_list COMMA member_initializer
	  {
	  	var a = (List<Expression>)$1;
	  	a.Add ((Expression) $3);
	  	$$ = a;
	  }
	| member_initializer_list error {
	  	Error_SyntaxError (yyToken);
		$$ = $1;
	  }
	;

member_initializer
	: IDENTIFIER COLON initializer_value
	  {
	  	var lt = (LocatedToken) $1;
	  	$$ = new ElementInitializer (lt.Value, (Expression)$3, lt.Location);
	  	lbag.AddLocation ($$, GetLocation ($2));
	  }
	| AWAIT ASSIGN initializer_value
	  {
	  	var lt = (LocatedToken) Error_AwaitAsIdentifier ($1);
	  	$$ = new ElementInitializer (lt.Value, (Expression)$3, lt.Location);
	  	lbag.AddLocation ($$, GetLocation ($2));
	  }	  
	| LITERAL COLON initializer_value
	  {
	  	ILiteralConstant lit = $1 as ILiteralConstant;
		string nm;	  	
	  	if (lit is StringLiteral) {
			nm = ((StringLiteral)lit).Value;
		} else {
	  		if (parsing_playscript || !(lit is IntLiteral || lit is DoubleLiteral || lit is BoolLiteral)) {
			  	report.Error (7019, GetLocation ($1), "Must be identifier or string literal");
			  	nm = "err";
			 } else {
				nm = ((Constant)$1).GetValueAsLiteral();			 
			 }
		}
	  
	  	$$ = new ElementInitializer (nm, (Expression)$3, GetLocation($1));
	  	lbag.AddLocation ($$, GetLocation ($2));
	  } 
	| GENERATE_COMPLETION 
	  {
		$$ = new CompletionElementInitializer (null, GetLocation ($1));
	  }
	/* | non_assignment_expression opt_COMPLETE_COMPLETION  {
		CompletionSimpleName csn = $1 as CompletionSimpleName;
		if (csn == null)
			$$ = new CollectionElementInitializer ((Expression)$1);
		else
			$$ = new CompletionElementInitializer (csn.Prefix, csn.Location);
	  } 
	| OPEN_BRACE expression_list CLOSE_BRACE
	  {
		if ($2 == null)
			$$ = null;
		else
	  		$$ = new CollectionElementInitializer ((List<Expression>)$2, GetLocation ($1));
	  } 
	| OPEN_BRACE CLOSE_BRACE
	  {
	  	report.Error (1920, GetLocation ($1), "An element initializer cannot be empty");
		$$ = null;
	  } */  
	;

initializer_value
	: expression
	;

opt_argument_list
	: /* empty */		{ $$ = null; }
	| argument_list
	;

argument_list
	: argument_or_named_argument
	  { 
		Arguments list = new Arguments (4);
		list.Add ((Argument) $1);
		$$ = list;
	  }
	| argument_list COMMA argument
	  {
		Arguments list = (Arguments) $1;
		if (list [list.Count - 1] is NamedArgument)
			Error_NamedArgumentExpected ((NamedArgument) list [list.Count - 1]);
		
		list.Add ((Argument) $3);
		$$ = list;
	  }
	| argument_list COMMA named_argument
	  {
		Arguments list = (Arguments) $1;
		NamedArgument a = (NamedArgument) $3;
		for (int i = 0; i < list.Count; ++i) {
			NamedArgument na = list [i] as NamedArgument;
			if (na != null && na.Name == a.Name)
				report.Error (1740, na.Location, "Named argument `{0}' specified multiple times",
					na.Name);
		}
		
		list.Add (a);
		$$ = list;
	  }
	| argument_list COMMA error
	  {
	  	lexer.putback (')'); // TODO: Wrong but what can I do
		Error_SyntaxError (yyToken);
		$$ = $1;
	  }
	| COMMA error
	  {
	  	report.Error (839, GetLocation ($1), "An argument is missing");
	  	$$ = null;
	  }
	;

argument
	: expression
	  {
		$$ = new Argument ((Expression) $1);
	  }
	| non_simple_argument
	;

argument_or_named_argument
	: argument
	| named_argument
	;

non_simple_argument
	: REF variable_reference 
	  { 
		$$ = new Argument ((Expression) $2, Argument.AType.Ref);
		lbag.AddLocation ($$, GetLocation ($1));
	  }
	| OUT variable_reference 
	  { 
		$$ = new Argument ((Expression) $2, Argument.AType.Out);
		lbag.AddLocation ($$, GetLocation ($1));
	  }
//	| ARGLIST OPEN_PARENS argument_list CLOSE_PARENS
//	  {
//		$$ = new Argument (new Arglist ((Arguments) $3, GetLocation ($1)));
//		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
//	  }
//	| ARGLIST OPEN_PARENS CLOSE_PARENS
//	  {
//		$$ = new Argument (new Arglist (GetLocation ($1)));
//		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3));
//	  }	  
	;

variable_reference
	: expression
	;

element_access
	: primary_expression OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET	
	  {
		$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
		lbag.AddLocation ($$, GetLocation ($4));
	  }
	| primary_expression OPEN_BRACKET_EXPR expression_list_arguments error
	  {
		Error_SyntaxError (yyToken);
		$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
	  }
	| primary_expression OPEN_BRACKET_EXPR error
	  {
		Error_SyntaxError (yyToken);
		$$ = new ElementAccess ((Expression) $1, null, GetLocation ($2));
	  }
	| builtin_types OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET	
	  {
		$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
		lbag.AddLocation ($$, GetLocation ($4));
	  }
	| builtin_types OPEN_BRACKET_EXPR expression_list_arguments error
	  {
		Error_SyntaxError (yyToken);
		$$ = new ElementAccess ((Expression) $1, (Arguments) $3, GetLocation ($2));
	  }
	| builtin_types OPEN_BRACKET_EXPR error
	  {
		Error_SyntaxError (yyToken);
		$$ = new ElementAccess ((Expression) $1, null, GetLocation ($2));
	  }	  
	;

expression_list
	: expression
	  {
		var list = new List<Expression> (4);
		list.Add ((Expression) $1);
		$$ = list;
	  }
	| expression_list COMMA expression
	  {
		var list = (List<Expression>) $1;
		list.Add ((Expression) $3);
		$$ = list;
	  }
	| expression_list error {
	  	Error_SyntaxError (yyToken);
		$$ = $1;
	  }
	;
	
expression_list_arguments
	: expression_list_argument
	  {
		Arguments args = new Arguments (4);
		args.Add ((Argument) $1);
		$$ = args;
	  }
	| expression_list_arguments COMMA expression_list_argument
	  {
		Arguments args = (Arguments) $1;
		if (args [args.Count - 1] is NamedArgument && !($3 is NamedArgument))
			Error_NamedArgumentExpected ((NamedArgument) args [args.Count - 1]);
	  
		args.Add ((Argument) $3);
		$$ = args;	  
	  }
	;
	
expression_list_argument
	: expression
	  {
	  	$$ = new Argument ((Expression) $1);
	  }
	| named_argument
	;

this_access
	: THIS
	  {
		$$ = new This (GetLocation ($1));
	  }
	;

base_access
	: SUPER OPEN_BRACKET_EXPR expression_list_arguments CLOSE_BRACKET
	  {
	  	$$ = new ElementAccess (new BaseThis (GetLocation ($1)), (Arguments) $3, GetLocation ($2));
		lbag.AddLocation ($$, GetLocation ($4));
	  }
	| SUPER OPEN_BRACKET error
	  {
	  	Error_SyntaxError (yyToken);
		$$ = new ElementAccess (null, null, GetLocation ($2));
	  }
	;

post_increment_expression
	: primary_expression OP_INC
	  {
		$$ = new UnaryMutator (UnaryMutator.Mode.PostIncrement, (Expression) $1, GetLocation ($2));
	  }
	;

post_decrement_expression
	: primary_expression OP_DEC
	  {
		$$ = new UnaryMutator (UnaryMutator.Mode.PostDecrement, (Expression) $1, GetLocation ($2));
	  }
	;

new_expression
	: NEW type_expression opt_new_args
	  {
		$$ = new New ((Expression) $2, (Arguments) $3, GetLocation ($1));
//		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
	  }
	| NEW OP_LT type_expression OP_GT array_initializer
	  {
		$$ = new NewVector ((FullNamedExpression) $3, (ArrayInitializer) $5, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
	  }
	;

opt_new_args
	: /* empty */
	 {
	 	$$ = null;
	 }
	| OPEN_PARENS opt_argument_list CLOSE_PARENS
	  {
	  	$$ = $2;
	  }
	;

//anonymous_type_expression
//	: NEW OPEN_BRACE anonymous_type_parameters_opt_comma CLOSE_BRACE
//	  {
//		if (lang_version <= LanguageVersion.ISO_2)
//	  		FeatureIsNotAvailable (GetLocation ($1), "anonymous types");
//
//		$$ = new NewAnonymousType ((List<AnonymousTypeParameter>) $3, current_container, GetLocation ($1));
//		
//		// TODO: lbag comma location
//		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
//	  }
//	;

//anonymous_type_parameters_opt_comma
//	: anonymous_type_parameters_opt
//	| anonymous_type_parameters COMMA
//	;

//anonymous_type_parameters_opt
//	: { $$ = null; }
//	| anonymous_type_parameters
//	;

//anonymous_type_parameters
//	: anonymous_type_parameter
//	  {
//	  	var a = new List<AnonymousTypeParameter> (4);
//	  	a.Add ((AnonymousTypeParameter) $1);
//	  	$$ = a;
//	  }
//	| anonymous_type_parameters COMMA anonymous_type_parameter
//	  {
//	  	var a = (List<AnonymousTypeParameter>) $1;
//	  	a.Add ((AnonymousTypeParameter) $3);
//	  	$$ = a;
//	  }
//	;

//anonymous_type_parameter
//	: IDENTIFIER ASSIGN variable_initializer
//	  {
//		var lt = (LocatedToken)$1;
//	  	$$ = new AnonymousTypeParameter ((Expression)$3, lt.Value, lt.Location);
//	  	lbag.AddLocation ($$, GetLocation ($2));
//	  }
//	| IDENTIFIER
//	  {
//		var lt = (LocatedToken)$1;
//	  	$$ = new AnonymousTypeParameter (new SimpleName (lt.Value, lt.Location),
//	  		lt.Value, lt.Location);
//	  }
//	| member_access
//	  {
//	  	MemberAccess ma = (MemberAccess) $1;
//	  	$$ = new AnonymousTypeParameter (ma, ma.Name, ma.Location);
//	  }
//	| error
//	  {
//		report.Error (746, lexer.Location,
//			"Invalid anonymous type member declarator. Anonymous type members must be a member assignment, simple name or member access expression");
//		$$ = null;
//	  }
//	;

//opt_rank_specifier
//	: /* empty */
//	| rank_specifiers
//	;

rank_specifiers
	: rank_specifier
	| rank_specifier rank_specifiers
	  {
	  	((ComposedTypeSpecifier) $1).Next = (ComposedTypeSpecifier) $2;
	  	$$ = $1;
	  }
	;

rank_specifier
	: OPEN_BRACKET CLOSE_BRACKET
	  {
		$$ = ComposedTypeSpecifier.CreateArrayDimension (1, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| OPEN_BRACKET dim_separators CLOSE_BRACKET
	  {
		$$ = ComposedTypeSpecifier.CreateArrayDimension ((int)$2, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($3));
	  }
	;

dim_separators
	: COMMA
	  {
		$$ = 2;
	  }
	| dim_separators COMMA
	  {
		$$ = ((int) $1) + 1;
	  }
	;

array_creation
	: array_initializer
	  {
	  	$$ = new ArrayCreation ((ArrayInitializer) $1);
	  }
	;

array_initializer
	: init_open_bracket init_close_bracket
	  {
		$$ = new ArrayInitializer (null, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| init_open_bracket_expr variable_initializer_list opt_comma init_close_bracket
	  {
		$$ = new ArrayInitializer ((List<Expression>) $2, GetLocation ($1));
		if ($3 != null) {
			lbag.AddLocation ($$, GetLocation ($3), GetLocation ($4));
		} else {
			lbag.AddLocation ($$, GetLocation ($4));
		}
	  }
	;
	
init_open_bracket
	: OPEN_BRACKET
	  {
      	oob_stack.Push (Lexer.AutoSemiInsertion);
        Lexer.AutoSemiInsertion = false;
	  }
	;

init_open_bracket_expr
	: OPEN_BRACKET_EXPR
	  {
      	oob_stack.Push (Lexer.AutoSemiInsertion);
        Lexer.AutoSemiInsertion = false;
	  }
	;

init_close_bracket
 	: CLOSE_BRACKET
 	  {
      	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
 	  }
 	;	
	
variable_initializer_list
	: variable_initializer
	  {
		var list = new List<Expression> (4);
		list.Add ((Expression) $1);
		$$ = list;
	  }
	| variable_initializer_list COMMA variable_initializer
	  {
		var list = (List<Expression>) $1;
		list.Add ((Expression) $3);
		$$ = list;
	  }
	;
	
typeof_type_expression
	: type_and_void
	| error
	 {
	 	Error_TypeExpected (lexer.Location);
	 	$$ = null;
	 }
	;

qualified_identifier
	: IDENTIFIER DOUBLE_COLON
	  {
		$$ = $1;
	  }
	;

anonymous_method_expression
	: FUNCTION OPEN_PARENS
	  {
	  	valid_param_mod = 0;
	  }
	  opt_formal_parameter_list CLOSE_PARENS opt_anomymous_method_type
	  {
		valid_param_mod = 0;
		start_anonymous ((ParametersCompiled) $4, (FullNamedExpression) $6, GetLocation ($1));
	  }
	  block
	  {
		$$ = end_anonymous ((ParametersBlock) $8);
	  }
	;

opt_anomymous_method_type
	:
	  {
		Warning_NoTypeDeclaration (lexer.Location, "Anonymous function");
	  	$$ = new UntypedTypeExpression (lexer.Location);
	  }
	| COLON member_type
	  {
	  	$$ = $2;
	  }
	;

local_function_statement
	: FUNCTION IDENTIFIER OPEN_PARENS
	  {
	  	valid_param_mod = 0;
	  }
	  opt_formal_parameter_list CLOSE_PARENS opt_local_function_type
	  {
		valid_param_mod = 0;
		if ($7 == null) {
			var lt = (LocatedToken) $2;
			Warning_NoTypeDeclaration (lt.Location, string.Format ("Local function `{0}'", lt.Value));
	  		$7 = new UntypedTypeExpression (lexer.Location);
	  	}

		start_anonymous ((ParametersCompiled) $5, (FullNamedExpression) $7, GetLocation ($1));
	  }
	  block
	  {
		var lt = (LocatedToken) $2;
		var function = (LocalFunction) end_anonymous ((ParametersBlock) $9);
		var li = new LocalVariable (current_block, lt.Value, 0, lt.Location);

		INamedBlockVariable existing = null;
		if (current_block.ParametersBlock.TopBlock.GetLocalName (lt.Value, current_block, ref existing)) {
			report.ErrorPlayScript (1021, lt.Location, "Duplicate function `{0}' definition", lt.Value);
		} else {
			current_block.AddLocalName (li);
		}

		current_block.AddScopeStatement (new UntypedBlockVariable (li) {
			Initializer = function
		});
	
		$$ = new LocalFunctionDeclaration (function, lt.Value);
	  }
	;

opt_local_function_type
	: /* empty */
	| COLON member_type
	  {
	  	$$ = $2;
	  }
	;

with_statement
	: WITH open_parens_any expression CLOSE_PARENS block
	  {
	  	$$ = new With ((Expression) $3, (Block) $5, GetLocation ($1));
	  }
	;

default_value_expression
	: DEFAULT open_parens_any type CLOSE_PARENS
	  {
	  	CheckIsPlayScript("default values", GetLocation($1));
	  
		if (lang_version < LanguageVersion.ISO_2)
			FeatureIsNotAvailable (GetLocation ($1), "default value expression");

		$$ = new DefaultValueExpression ((Expression) $3, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($4));
	  }
	;

unary_expression
	: primary_expression
	| BANG prefixed_unary_expression
	  {
		$$ = new Unary (Unary.Operator.LogicalNot, (Expression) $2, GetLocation ($1));
	  }
	| TILDE prefixed_unary_expression
	  {
		$$ = new Unary (Unary.Operator.OnesComplement, (Expression) $2, GetLocation ($1));
	  }
//	| OPEN_PARENS_CAST type CLOSE_PARENS prefixed_unary_expression
//	  {
//		$$ = new Cast ((FullNamedExpression) $2, (Expression) $4, GetLocation ($1));
//		lbag.AddLocation ($$, GetLocation ($3));
//	  }
	| AWAIT prefixed_unary_expression
	  {
	  	CheckIsPlayScript("await", GetLocation($1));
	  	
		if (!async_block) {
			 if (current_anonymous_method is LambdaExpression) {
				report.Error (4034, GetLocation ($1),
					"The `await' operator can only be used when its containing lambda expression is marked with the `async' modifier");
			} else if (current_anonymous_method is AnonymousMethodExpression) {
				report.Error (4035, GetLocation ($1),
					"The `await' operator can only be used when its containing anonymous method is marked with the `async' modifier");
			} else {
				report.Error (4033, GetLocation ($1),
					"The `await' operator can only be used when its containing method is marked with the `async' modifier");
			}
		} else {
			current_block.Explicit.RegisterAsyncAwait ();
		}
		
		$$ = new Await ((Expression) $2, GetLocation ($1));
	  }
	| OP_AT prefixed_unary_expression
	  {
// TODO:		$$ = new Unary (Unary.Operator.AsE4xAttribute, (Expression) $2, GetLocation ($1));
	  }
	| TYPEOF prefixed_unary_expression
	  {
	  	$$ = new TypeOf ((Expression) $2, GetLocation ($1));
	  }
	| DELETE prefixed_unary_expression
	  {
		$$ = new Delete ((Expression) $2, GetLocation ($1));
	  } 
	| BANG error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Unary (Unary.Operator.LogicalNot, null, GetLocation ($1));
	  }
	| TILDE error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Unary (Unary.Operator.OnesComplement, null, GetLocation ($1));
	  }
//	| OPEN_PARENS_CAST type CLOSE_PARENS error
//	  {
//		Error_SyntaxError (yyToken);
//
//		$$ = new Cast ((FullNamedExpression) $2, null, GetLocation ($1));
//		lbag.AddLocation ($$, GetLocation ($3));
//	  }
	| AWAIT error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Await (null, GetLocation ($1));
	  }
//	| OP_AT error
//	  {
//		Error_SyntaxError (yyToken);

//		$$ = new Unary (Unary.Operator.AsE4xAttribute, null, GetLocation ($1));
//	  }    
	| DELETE error
	  {
		Error_SyntaxError (yyToken);
		
		$$ = new Delete (null, GetLocation ($1));
	  }	  
	;

	//
	// The idea to split this out is from Rhys' grammar
	// to solve the problem with casts.
	//
prefixed_unary_expression
	: unary_expression
	| PLUS prefixed_unary_expression
	  { 
	  	$$ = new Unary (Unary.Operator.UnaryPlus, (Expression) $2, GetLocation ($1));
	  } 
	| MINUS prefixed_unary_expression 
	  { 
		$$ = new Unary (Unary.Operator.UnaryNegation, (Expression) $2, GetLocation ($1));
	  }
	| OP_INC prefixed_unary_expression 
	  {
		$$ = new UnaryMutator (UnaryMutator.Mode.PreIncrement, (Expression) $2, GetLocation ($1));
	  }
	| OP_DEC prefixed_unary_expression 
	  {
		$$ = new UnaryMutator (UnaryMutator.Mode.PreDecrement, (Expression) $2, GetLocation ($1));
	  }
//	| STAR prefixed_unary_expression
//	  {
//		$$ = new Indirection ((Expression) $2, GetLocation ($1));
//	  }
	| BITWISE_AND prefixed_unary_expression
	  {
		$$ = new Unary (Unary.Operator.AddressOf, (Expression) $2, GetLocation ($1));
	  }
	| PLUS error
	  { 
		Error_SyntaxError (yyToken);

	  	$$ = new Unary (Unary.Operator.UnaryPlus, null, GetLocation ($1));
	  } 
	| MINUS error 
	  { 
		Error_SyntaxError (yyToken);

		$$ = new Unary (Unary.Operator.UnaryNegation, null, GetLocation ($1));
	  }
	| OP_INC error 
	  {
		Error_SyntaxError (yyToken);

		$$ = new UnaryMutator (UnaryMutator.Mode.PreIncrement, null, GetLocation ($1));
	  }
	| OP_DEC error 
	  {
		Error_SyntaxError (yyToken);

		$$ = new UnaryMutator (UnaryMutator.Mode.PreDecrement, null, GetLocation ($1));
	  }
//	| STAR error
//	  {
//		Error_SyntaxError (yyToken);
//
//		$$ = new Indirection (null, GetLocation ($1));
//	  }
	| BITWISE_AND error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Unary (Unary.Operator.AddressOf, null, GetLocation ($1));
	  }
	;

multiplicative_expression
	: prefixed_unary_expression
	| multiplicative_expression STAR prefixed_unary_expression
	  {
		$$ = new Binary (Binary.Operator.Multiply, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| multiplicative_expression DIV prefixed_unary_expression
	  {
		$$ = new Binary (Binary.Operator.Division, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| multiplicative_expression PERCENT prefixed_unary_expression 
	  {
		$$ = new Binary (Binary.Operator.Modulus, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| multiplicative_expression STAR error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.Multiply, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| multiplicative_expression DIV error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.Division, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| multiplicative_expression PERCENT error 
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.Modulus, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

additive_expression
	: multiplicative_expression
	| additive_expression PLUS multiplicative_expression 
	  {
		$$ = new Binary (Binary.Operator.Addition, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| additive_expression MINUS multiplicative_expression
	  {
		$$ = new Binary (Binary.Operator.Subtraction, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
  	  }
	| additive_expression OP_IN multiplicative_expression
	  {
		$$ = new In ((Expression) $1, (Expression) $3, GetLocation ($2));
	  }	  
	| additive_expression AS type
	  {
		$$ = new As ((Expression) $1, (Expression) $3, GetLocation ($2));
	  }
	| additive_expression IS type
	  {
		$$ = new Is ((Expression) $1, (Expression) $3, GetLocation ($2));
	  }	  
	| additive_expression PLUS error 
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.Addition, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| additive_expression MINUS error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.Subtraction, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| additive_expression OP_IN error
	  {
		Error_SyntaxError (yyToken);

		$$ = new In ((Expression) $1, null, GetLocation ($2));
	  }
	| additive_expression AS error
	  {
		Error_SyntaxError (yyToken);

		$$ = new As ((Expression) $1, null, GetLocation ($2));
	  }
	| additive_expression IS error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Is ((Expression) $1, null, GetLocation ($2));
	  }
	;

shift_expression
	: additive_expression
	| shift_expression OP_SHIFT_LEFT additive_expression
	  {
		$$ = new Binary (Binary.Operator.LeftShift, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| shift_expression OP_SHIFT_RIGHT additive_expression
	  {
		$$ = new Binary (Binary.Operator.RightShift, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| shift_expression OP_USHIFT_RIGHT additive_expression
	  {
		$$ = new Binary (Binary.Operator.UnsignedRightShift, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| shift_expression OP_SHIFT_LEFT error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.LeftShift, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| shift_expression OP_SHIFT_RIGHT error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.RightShift, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| shift_expression OP_USHIFT_RIGHT error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.UnsignedRightShift, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }	  
	; 

relational_expression
	: shift_expression
	| relational_expression OP_LT shift_expression
	  {
		$$ = new Binary (Binary.Operator.LessThan, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| relational_expression OP_GT shift_expression
	  {
		$$ = new Binary (Binary.Operator.GreaterThan, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| relational_expression OP_LE shift_expression
	  {
		$$ = new Binary (Binary.Operator.LessThanOrEqual, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| relational_expression OP_GE shift_expression
	  {
		$$ = new Binary (Binary.Operator.GreaterThanOrEqual, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| relational_expression OP_LT error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.LessThan, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| relational_expression OP_GT error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.GreaterThan, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| relational_expression OP_LE error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.LessThanOrEqual, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| relational_expression OP_GE error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.GreaterThanOrEqual, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

equality_expression
	: relational_expression
	| equality_expression OP_EQ relational_expression
	  {
		$$ = new Binary (Binary.Operator.Equality, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| equality_expression OP_NE relational_expression
	  {
		$$ = new Binary (Binary.Operator.Inequality, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| equality_expression OP_REF_EQ relational_expression
	  {
		$$ = new Binary (Binary.Operator.ReferenceEquality, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| equality_expression OP_REF_NE relational_expression
	  {
		$$ = new Binary (Binary.Operator.ReferenceInequality, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	; 

and_expression
	: equality_expression
	| and_expression BITWISE_AND equality_expression
	  {
		$$ = new Binary (Binary.Operator.BitwiseAnd, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| and_expression BITWISE_AND error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.BitwiseAnd, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

exclusive_or_expression
	: and_expression
	| exclusive_or_expression CARRET and_expression
	  {
		$$ = new Binary (Binary.Operator.ExclusiveOr, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| exclusive_or_expression CARRET error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.ExclusiveOr, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

inclusive_or_expression
	: exclusive_or_expression
	| inclusive_or_expression BITWISE_OR exclusive_or_expression
	  {
		$$ = new Binary (Binary.Operator.BitwiseOr, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| inclusive_or_expression BITWISE_OR error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.BitwiseOr, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

conditional_and_expression
	: inclusive_or_expression
	| conditional_and_expression OP_AND inclusive_or_expression
	  {
		$$ = new Binary (Binary.Operator.LogicalAnd, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| conditional_and_expression OP_AND error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.LogicalAnd, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

conditional_or_expression
	: conditional_and_expression
	| conditional_or_expression OP_OR conditional_and_expression
	  {
		$$ = new Binary (Binary.Operator.LogicalOr, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| conditional_or_expression OP_OR error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Binary (Binary.Operator.LogicalOr, (Expression) $1, null);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;
	
null_coalescing_expression
	: conditional_or_expression
	| conditional_or_expression OP_COALESCING null_coalescing_expression
	  {
	  	CheckIsPlayScript("?? operator", GetLocation($2));
	  
		if (lang_version < LanguageVersion.ISO_2)
			FeatureIsNotAvailable (GetLocation ($2), "null coalescing operator");
			
		$$ = new Nullable.NullCoalescingOperator ((Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

conditional_expression
	: null_coalescing_expression
	| null_coalescing_expression INTERR expression COLON expression
	  {
		$$ = new Conditional (new BooleanExpression ((Expression) $1), (Expression) $3, (Expression) $5, GetLocation ($2));
		lbag.AddLocation ($$, GetLocation ($4));
	  }
	| null_coalescing_expression INTERR expression error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Conditional (new BooleanExpression ((Expression) $1), (Expression) $3, null, GetLocation ($2));
	  }
	| null_coalescing_expression INTERR expression COLON error
	  {
		Error_SyntaxError (yyToken);

		$$ = new Conditional (new BooleanExpression ((Expression) $1), (Expression) $3, null, GetLocation ($2));
		lbag.AddLocation ($$, GetLocation ($4));
	  }
	;

assignment_expression
	: prefixed_unary_expression ASSIGN expression
	  {
	  	Expression target = (Expression) $1;
	  	Expression source = (Expression) $3;

		$$ = new SimpleAssign (target, source);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_MULT_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.Multiply, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_DIV_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.Division, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_MOD_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.Modulus, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_ADD_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.Addition, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_SUB_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.Subtraction, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_SHIFT_LEFT_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.LeftShift, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_SHIFT_RIGHT_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.RightShift, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_USHIFT_RIGHT_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.UnsignedRightShift, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_AND_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.BitwiseAnd, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression LOGICAL_AND_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.LogicalAnd, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_OR_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.BitwiseOr, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression LOGICAL_OR_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.LogicalOr, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| prefixed_unary_expression OP_XOR_ASSIGN expression
	  {
		$$ = new CompoundAssign (Binary.Operator.ExclusiveOr, (Expression) $1, (Expression) $3);
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

expression_or_error
	: expression
	| error
	  {
		Error_SyntaxError (yyToken);
		$$ = null;
	  }
	;

expression
	: assignment_expression 
	| non_assignment_expression
	;
	
non_assignment_expression
	: conditional_expression
	| query_expression
	;

constant_expression
	: expression
	;

boolean_expression
	: expression
	  {
		$$ = new BooleanExpression ((Expression) $1);
	  }
	;

//
// 10 classes
//
class_declaration
	: opt_attributes
	  opt_modifiers
	  opt_partial
	  CLASS
	  {
		lexer.ConstraintsParsing = true;
		lexer.AutoSemiInsertion = false;
	  }
	  type_declaration_name
	  {
		Class c = new Class (current_container, (MemberName) $6, (Modifiers) $2, (Attributes) $1, true);

		if (((c.ModFlags & Modifiers.STATIC) != 0) && lang_version == LanguageVersion.ISO_1) {
			FeatureIsNotAvailable (c.Location, "static classes");
		}
			
	    bool is_partial = IsPartial($1) || $3 != null;
		push_current_container (c, is_partial);
	  }
	  opt_class_extends
	  opt_class_implements
	  opt_type_parameter_constraints_clauses
	  {
		lexer.ConstraintsParsing = false;

		if ($10 != null)
			current_container.SetConstraints ((List<Constraints>) $10);
		lbag.AddMember (current_container, mod_locations, GetLocation ($4));

		if (doc_support) {
			current_container.PartialContainer.DocComment = Lexer.consume_doc_comment ();
			Lexer.doc_state = XmlCommentState.Allowed;
		}
		
		lexer.parsing_modifiers = true;
		lexer.DynamicParsing = false;
	  }
	  OPEN_BRACE
	  {
		lexer.AutoSemiInsertion = true;		
	  }
	  opt_class_member_declarations CLOSE_BRACE opt_semicolon
	  {
		lexer.DynamicParsing = true;	  
		--lexer.parsing_declaration;
		if (doc_support)
			Lexer.doc_state = XmlCommentState.Allowed;

		lbag.AppendToMember (current_container, GetLocation ($12), GetLocation ($15), GetLocation ($16));
		$$ = pop_current_class ();
	  }
	;	

opt_partial
	: /* empty */
	  { $$ = null; }
	| PARTIAL
	  { $$ = $1; } // location
	;

opt_modifiers
	: /* empty */
	  {
	    mod_locations = null;
		$$ = ModifierNone;
		lexer.parsing_modifiers = false;
	  }
	| modifiers
	  {
		lexer.parsing_modifiers = false;		
	  }
	;

modifiers
	: modifier
	  {
		$$ = $1 ?? ModifierNone;
	  }
	| modifiers modifier
	  {
	  	if ($2 == null) {
			var m1 = (Modifiers) $1;

			if ((m1 & Modifiers.AccessibilityMask) != 0) {
				report.ErrorPlayScript (1003, GetLocation ($2),
					"Access specifiers are not allowed with namespace attributes.");
			}
	  	} else {
			var m1 = (Modifiers) $1;
			var m2 = (Modifiers) $2;

			if ((m1 & m2) != 0) {
				report.ErrorPlayScript (1127, lexer.Location - ModifiersExtensions.Name (m2).Length,
					"Attribute `{0}' was specified multiple times.", ModifiersExtensions.Name (m2));
			} else if ((m2 & Modifiers.AccessibilityMask) != 0 && (m1 & Modifiers.AccessibilityMask) != 0 &&
				((m2 | m1 & Modifiers.AccessibilityMask) != (Modifiers.PROTECTED | Modifiers.INTERNAL))) {
				report.ErrorPlayScript (1154, lexer.Location - ModifiersExtensions.Name (m2).Length,
					"Only one of public, private, protected, or internal can be specified on a definition.");
			}
			
			$$ = m1 | m2;
		}
	  }
	;

modifier
/*	: NEW
	  {
		$$ = Modifiers.NEW;
		StoreModifierLocation ($$, GetLocation ($1));
		
		if (current_container.Kind == MemberKind.Namespace)
			report.Error (1530, GetLocation ($1), "Keyword `new' is not allowed on namespace elements");
	  }
*/
	: PUBLIC
	  {
		$$ = Modifiers.PUBLIC;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
	| PROTECTED
	  {
		$$ = Modifiers.PROTECTED;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
	| INTERNAL
	  {
		$$ = Modifiers.INTERNAL;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
	| PRIVATE
	  {
		$$ = Modifiers.PRIVATE;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
	| ABSTRACT
	  {
		$$ = Modifiers.ABSTRACT;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
	| FINAL
	  {
		$$ = (Modifiers)0; // Modifiers.SEALED;  // The semantics for SEALED and FINAL don't quite match.  Ignore FINAL for right now. (BEN)
		StoreModifierLocation ($$, GetLocation ($1));
	  }
	| STATIC
	  {
		$$ = Modifiers.STATIC;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
//	| READONLY
//	  {
//		$$ = Modifiers.READONLY;
//		StoreModifierLocation ($$, GetLocation ($1));
//	  }
	| VIRTUAL
	  {
		$$ = Modifiers.VIRTUAL;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
	| OVERRIDE
	  {
		$$ = Modifiers.OVERRIDE;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
	| NATIVE
	  {
		$$ = Modifiers.EXTERN;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
	| VOLATILE
	  {
		$$ = Modifiers.VOLATILE;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
//	| UNSAFE
//	  {
//		$$ = Modifiers.UNSAFE;
//		StoreModifierLocation ($$, GetLocation ($1));
//		if (!settings.Unsafe)
//			Error_UnsafeCodeNotAllowed (GetLocation ($1));
//	  }
	| ASYNC
	  {
		$$ = Modifiers.ASYNC;
		StoreModifierLocation ($$, GetLocation ($1));
	  }
	| DYNAMIC
	  {
	    $$ = Modifiers.DYNAMIC;
	    StoreModifierLocation ($$, GetLocation ($1));
	  }
	| IDENTIFIER
	  {
		if (namespace_modifier != null)
			report.ErrorPlayScript (1162, GetLocation ($1), "Only one namespace attribute can be used per definition");
		else
			namespace_modifier = (LocatedToken) $1;

		$$ = null;
	  }
	;
	
opt_class_extends
	: /* empty */
	| EXTENDS base_type_name
	 {
		current_type.AddBaseType ((FullNamedExpression) $2);
	 }
	| EXTENDS base_type_name error
	  {
		Error_SyntaxError (yyToken);

		current_type.AddBaseType ((FullNamedExpression) $2);
	  }
	;
	
opt_class_implements
	: /* empty */
	| IMPLEMENTS type_list
	 {
		current_type.AddBaseTypes ((List<FullNamedExpression>) $2);
	 }
	| IMPLEMENTS type_list error
	  {
		Error_SyntaxError (yyToken);

		current_type.AddBaseTypes ((List<FullNamedExpression>) $2);
	  }
	;	

opt_type_parameter_constraints_clauses
	: /* empty */
	| type_parameter_constraints_clauses 
	  {
		$$ = $1;
	  }
	;

type_parameter_constraints_clauses
	: type_parameter_constraints_clause
	  {
		var constraints = new List<Constraints> (1);
		constraints.Add ((Constraints) $1);
		$$ = constraints;
	  }
	| type_parameter_constraints_clauses type_parameter_constraints_clause
	  {
		var constraints = (List<Constraints>) $1;
		Constraints new_constraint = (Constraints)$2;

		foreach (Constraints c in constraints) {
			if (new_constraint.TypeParameter.Value == c.TypeParameter.Value) {
				report.Error (409, new_constraint.Location,
					"A constraint clause has already been specified for type parameter `{0}'",
					new_constraint.TypeParameter.Value);
			}
		}

		constraints.Add (new_constraint);
		$$ = constraints;
	  }
	; 

type_parameter_constraints_clause
	: WHERE IDENTIFIER COLON type_parameter_constraints
	  {
		var lt = (LocatedToken) $2;
		$$ = new Constraints (new SimpleMemberName (lt.Value, lt.Location), (List<FullNamedExpression>) $4, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($3));
	  }
	| WHERE IDENTIFIER error
	  {
		Error_SyntaxError (yyToken);
	  
		var lt = (LocatedToken) $2;
		$$ = new Constraints (new SimpleMemberName (lt.Value, lt.Location), null, GetLocation ($1));
	  }
	; 

type_parameter_constraints
	: type_parameter_constraint
	  {
		var constraints = new List<FullNamedExpression> (1);
		constraints.Add ((FullNamedExpression) $1);
		$$ = constraints;
	  }
	| type_parameter_constraints COMMA type_parameter_constraint
	  {
		var constraints = (List<FullNamedExpression>) $1;
		var prev = constraints [constraints.Count - 1] as SpecialContraintExpr;
		if (prev != null && (prev.Constraint & SpecialConstraint.Constructor) != 0) {			
			report.Error (401, GetLocation ($2), "The `new()' constraint must be the last constraint specified");
		}
		
		prev = $3 as SpecialContraintExpr;
		if (prev != null) {
			if ((prev.Constraint & (SpecialConstraint.Class | SpecialConstraint.Struct)) != 0) {
				report.Error (449, prev.Location, "The `class' or `struct' constraint must be the first constraint specified");			
			} else {
			 	prev = constraints [0] as SpecialContraintExpr;
			 	if (prev != null && (prev.Constraint & SpecialConstraint.Struct) != 0) {			
					report.Error (451, GetLocation ($3), "The `new()' constraint cannot be used with the `struct' constraint");
				}
			}
		}

		constraints.Add ((FullNamedExpression) $3);
		$$ = constraints;
	  }
	;

type_parameter_constraint
	: type
	  {
		if ($1 is ComposedCast)
			report.Error (706, GetLocation ($1), "Invalid constraint type `{0}'", ((ComposedCast)$1).GetSignatureForError ());
	  
	  	$$ = $1;
	  }
	| NEW OPEN_PARENS CLOSE_PARENS
	  {
		$$ = new SpecialContraintExpr (SpecialConstraint.Constructor, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($2), GetLocation ($3));
	  }
	| CLASS
	  {
		$$ = new SpecialContraintExpr (SpecialConstraint.Class, GetLocation ($1));
	  }
	| STRUCT
	  {
		$$ = new SpecialContraintExpr (SpecialConstraint.Struct, GetLocation ($1));
	  }
	;

opt_type_parameter_variance
	: /* empty */
	  {
		$$ = Variance.None;
	  }
	| type_parameter_variance
	  {
		if (lang_version <= LanguageVersion.V_3)
			FeatureIsNotAvailable (lexer.Location, "generic type variance");
		
		$$ = $1;
	  }
	;

type_parameter_variance
	: OUT
	  {
		$$ = Variance.Covariant;
	  }
	| IN
	  {
		$$ = Variance.Contravariant;
	  }
	;

//
// Statements (8.2)
//

//
// A block is "contained" on the following places:
//	method_body
//      operator_declaration
//      
block
	: OPEN_BRACE  
	  {
		++lexer.parsing_block;
		lexer.AutoSemiInsertion = true;
		start_block (GetLocation ($1));
	  } 
	  opt_statement_list block_end
	  {
  		$$ = $4;
	  }
	;
/*	
//
// An optional config block is "contained" on the following places:
//	method_body
//      
config_block
	: opt_block_config OPEN_BRACE  
	  {
		++lexer.parsing_block;
		start_block (GetLocation ($2));
	  } 
	  opt_statement_list block_end
	  {
	    if (is_config_enabled) {
	      // This block should be included
  		  $$ = $5;
  		} else {
  		  // This block should not be included.. create an empty block
  		  start_block (GetLocation ($2));
  		  $$ = end_block (GetLocation ($5));
  		}
	  }
	;
*/
//opt_block_config
//	: /* empty */
//	| IDENTIFIER DOUBLE_COLON IDENTIFIER
//	  {
//	    var lt1 = (LocatedToken) $1;
//	    var lt2 = (LocatedToken) $3;
//        is_config_enabled = file.IsConditionalDefined (lt1.Value + "_" + lt2.Value);
//	  }
//	;

block_end 
	: CLOSE_BRACE 
	  {
	  	Lexer.AutoSemiInsertion = true;
	 	--lexer.parsing_block;
		$$ = end_block (GetLocation ($1));
	  }
	| COMPLETE_COMPLETION
	  {
	  	Lexer.AutoSemiInsertion = true;
	 	--lexer.parsing_block;
		$$ = end_block (lexer.Location);
	  }
	;


block_prepared
	: OPEN_BRACE
	  {
		++lexer.parsing_block;
		current_block.StartLocation = GetLocation ($1);
	  }
	  opt_statement_list CLOSE_BRACE 
	  {
	  	Lexer.AutoSemiInsertion = true;
		--lexer.parsing_block;
		$$ = end_block (GetLocation ($4));
	  }
	;

opt_statement_list
	: /* empty */
	| statement_list 
	;

statement_list
	: statement
	| statement_list statement
	;

statement
	: block_variable_declaration
	  {
		current_block.AddStatement ((Statement) $1);
	  }
	| valid_declaration_statement
	  {
		current_block.AddStatement ((Statement) $1);
	  }
	| labeled_statement
	| error
	  {
		Error_SyntaxError (yyToken);
		$$ = null;
	  }
	;

//
// The interactive_statement and its derivatives are only 
// used to provide a special version of `expression_statement'
// that has a side effect of assigning the expression to
// $retval
//
interactive_statement_list
	: interactive_statement
	| interactive_statement_list interactive_statement
	;

interactive_statement
	: block_variable_declaration
	  {
		current_block.AddStatement ((Statement) $1);
	  }
	| interactive_valid_declaration_statement
	  {
		current_block.AddStatement ((Statement) $1);
	  }
	| labeled_statement
	;

valid_declaration_statement
	: block
	| empty_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement		  
	| try_statement
	| local_function_statement
	| with_statement
	;

interactive_valid_declaration_statement
	: block
	| empty_statement
    | interactive_expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement		  
	| try_statement
	| local_function_statement
	;

embedded_statement
	: valid_declaration_statement
	| block_variable_declaration
	  {
	  	  if (parsing_playscript) {
			  report.Error (1023, GetLocation ($1), "An embedded statement may not be a declaration or labeled statement");
			  $$ = null;
		  } else {
		  	  // NOTE: This is actually allowed in PlayScript.  We'll turn it off in ASX though as it's error prone.
		  	  $$ = $1;
		  }
	  }
	| labeled_statement
	  {
		  report.Error (1023, GetLocation ($1), "An embedded statement may not be a declaration or labeled statement");
		  $$ = null;
	  }
	| error
	  {
		Error_SyntaxError (yyToken);
		$$ = new EmptyStatement (GetLocation ($1));
	  }
	;

empty_statement
	: SEMICOLON
	  {
	    Lexer.AutoSemiInsertion = true;
		// Uses lexer.Location because semicolon location is not kept in quick mode
		$$ = new EmptyStatement (lexer.Location);
	  }
	;

labeled_statement
	: identifier_inside_body COLON 
	  {
		var lt = (LocatedToken) $1;
		LabeledStatement labeled = new LabeledStatement (lt.Value, current_block, lt.Location);
		lbag.AddLocation (labeled, GetLocation ($2));
		current_block.AddLabel (labeled);
		current_block.AddStatement (labeled);
	  }
	  statement
	;

use_namespace_statement
	: USE NAMESPACE IDENTIFIER stmnt_end_semicolon
	  {
		var lt = (LocatedToken) $3;
		$$ = new UseNamespace (lt.Value, GetLocation ($1));		
	  }
	;

variable_type
	: variable_type_simple
	| variable_type_simple rank_specifiers
	  {
		if ($1 is VarExpr)
			$1 = new SimpleName ("var", ((VarExpr) $1).Location);
	  
		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
	  }
	;

/* 
 * The following is from Rhys' grammar:
 * > Types in local variable declarations must be recognized as 
 * > expressions to prevent reduce/reduce errors in the grammar.
 * > The expressions are converted into types during semantic analysis.
 */
variable_type_simple
	: primary_expression_or_type opt_nullable
	  { 
		// Ok, the above "primary_expression" is there to get rid of
		// both reduce/reduce and shift/reduces in the grammar, it should
		// really just be "type_name".  If you use type_name, a reduce/reduce
		// creeps up.  If you use namespace_or_type_name (which is all we need
		// really) two shift/reduces appear.
		// 

		// So the super-trick is that primary_expression
		// can only be either a SimpleName or a MemberAccess. 
		// The MemberAccess case arises when you have a fully qualified type-name like :
		// Foo.Bar.Blah i;
		// SimpleName is when you have
		// Blah i;
		
		Expression expr = (Expression) $1;
		if ($2 == null) {
//			SimpleName sn = expr as SimpleName;
//			if (sn != null)
//				$$ = ConvertAsType(sn, $1);
//			else
				$$ = $1;
		} else if (expr is ATypeNameExpression) {
			$$ = new ComposedCast ((ATypeNameExpression)expr, (ComposedTypeSpecifier) $2);
		} else {
			Error_ExpectingTypeName (expr);
			$$ = null;
		}
	  }
//	| primary_expression_or_type pointer_stars
//	  {
//		ATypeNameExpression expr = $1 as ATypeNameExpression;
//
//		if (expr != null) {
//			$$ = new ComposedCast (expr, (ComposedTypeSpecifier) $2);
//		} else {
//			Error_ExpectingTypeName ((Expression)$1);
//			$$ = expr;
//		}
//	  }
	| builtin_types opt_nullable
	  {
		if ($2 == null)
			$$ = $1;
		else
			$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
	  }
//	| builtin_types pointer_stars
//	  {
//		$$ = new ComposedCast ((FullNamedExpression) $1, (ComposedTypeSpecifier) $2);
//	  }
//	| VOID pointer_stars
//	  {
//		$$ = new ComposedCast (new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1)), (ComposedTypeSpecifier) $2);
//	  }	  
	| VOID
	  {
		Expression.Error_VoidInvalidInTheContext (GetLocation ($1), report);
		$$ = new TypeExpression (compiler.BuiltinTypes.Void, GetLocation ($1));
	  }
	;
	
//pointer_stars
//	: pointer_star
//	| pointer_star pointer_stars
//	  {
//	  	((ComposedTypeSpecifier) $1).Next = (ComposedTypeSpecifier) $2;
//	  	$$ = $1;
//	  }	  
//	;

//pointer_star
//	: STAR
//	  {
//		$$ = ComposedTypeSpecifier.CreatePointer (GetLocation ($1));
//	  }
//	;

identifier_inside_body
	: IDENTIFIER
	| AWAIT
	  {
		if (async_block) {
			report.Error (4003, GetLocation ($1), "`await' cannot be used as an identifier within an async method or lambda expression");
			$$ = new LocatedToken ("await", GetLocation ($1));
		}
	  }
	;

stmnt_end_semicolon
	: SEMICOLON
	  {
	  	Lexer.AutoSemiInsertion = true;
	  }
	;

block_variable_declaration
	: variable_declaration stmnt_end_semicolon
	| block_constant_declaration stmnt_end_semicolon
	;

variable_declaration
	: VAR identifier_inside_body COLON type 
	  {
		var lt = (LocatedToken) $2;
		var li = GetOrCreateLocalVariable (current_block, lt.Value, 0, (FullNamedExpression) $4, lt.Location);
		current_variable = new BlockVariable ((FullNamedExpression) $4, li);
	  }
	  opt_local_variable_initializer opt_variable_declarators
	  {
		$$ = current_variable;
		current_variable = null;
	  }
	| VAR identifier_inside_body 
	  {
		var lt = (LocatedToken) $2;
		var li = GetOrCreateLocalVariable (current_block, lt.Value, 0, null, lt.Location);
		current_variable = new UntypedBlockVariable (li);

		Warning_NoTypeDeclaration (lt.Location, string.Format ("Variable `{0}'", lt.Value));
	  }
	  opt_local_variable_initializer opt_variable_declarators
	  {
		$$ = current_variable;
		current_variable = null;
	  }
	;

block_constant_declaration
	: CONST identifier_inside_body COLON type 
	  {
		var lt = (LocatedToken) $2;
		var li = GetOrCreateLocalVariable (current_block, lt.Value, LocalVariable.Flags.Constant, null, lt.Location);
		current_variable = new BlockConstant ((FullNamedExpression) $4, li);
	  }
	  const_variable_initializer opt_const_declarators
	  {
		$$ = current_variable;
		current_variable = null;
		lbag.AddLocation ($$, GetLocation ($1));
	  }
	;

opt_local_variable_initializer
	: /* empty */
	| ASSIGN block_variable_initializer
	  {
		current_variable.Initializer = (Expression) $2;
		// TODO: lbag
	  }
	| error
	  {
	  	if (yyToken == Token.OPEN_BRACKET_EXPR) {
			report.Error (650, lexer.Location,
				"Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type");
		} else {
			Error_SyntaxError (yyToken);
		}
	  }
	;

opt_variable_declarators
	: /* empty */
	| variable_declarators
	;
	
opt_using_or_fixed_variable_declarators
	: /* empty */
	| variable_declarators
	  {
		foreach (var d in current_variable.Declarators) {
			if (d.Initializer == null)
				Error_MissingInitializer (d.Variable.Location);
		}
	  }
	;	
	
variable_declarators
	: variable_declarator
	| variable_declarators variable_declarator
	;
	
variable_declarator
	: COMMA identifier_inside_body
	  {
		var lt = (LocatedToken) $2;	  
		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
			/*current_variable.Variable.DeclFlags*/ 0, current_variable.TypeExpression, lt.Location);
		var d = new BlockVariableDeclarator (li, null);
		current_variable.AddDeclarator (d);
	  	lbag.AddLocation (d, GetLocation ($1));
	  }
	| COMMA identifier_inside_body ASSIGN block_variable_initializer
	  {
		var lt = (LocatedToken) $2;	  
		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
			/*current_variable.Variable.DeclFlags*/ 0, current_variable.TypeExpression, lt.Location);
		var d = new BlockVariableDeclarator (li, (Expression) $4);
		current_variable.AddDeclarator (d);
	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($3));
	  }
	| COMMA identifier_inside_body COLON type
	  {
		var lt = (LocatedToken) $2;	  
		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
			/*current_variable.Variable.DeclFlags*/ 0, (FullNamedExpression) $4, lt.Location);
		var d = new BlockVariableDeclarator (li, null, (FullNamedExpression) $4);
//		d.Location = GetLocation($2);
		current_variable.AddDeclarator (d);
	  	lbag.AddLocation (d, GetLocation ($1));
	  }
	| COMMA identifier_inside_body COLON type ASSIGN block_variable_initializer
	  {
		var lt = (LocatedToken) $2;	  
		var li = GetOrCreateLocalVariable (current_variable.Variable.Block, lt.Value, 
			/*current_variable.Variable.DeclFlags*/ 0, (FullNamedExpression) $4, lt.Location);
		var d = new BlockVariableDeclarator (li, (Expression) $6, (FullNamedExpression) $4);
//		d.Location = GetLocation($2);
		current_variable.AddDeclarator (d);
	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($5));
	  }		  
	;
	
const_variable_initializer
	: /* empty */
	  {
		report.Error (145, lexer.Location, "A const field requires a value to be provided");
	  }
	| ASSIGN constant_initializer_expr 
	  {
		current_variable.Initializer = (Expression) $2;
	  }
	;
	
opt_const_declarators
	: /* empty */
	| const_declarators
	;
	
const_declarators
	: const_declarator
	| const_declarators const_declarator
	;
	
const_declarator
	: COMMA identifier_inside_body ASSIGN constant_initializer_expr
	  {
		var lt = (LocatedToken) $2;	  
		var li = GetOrCreateLocalVariable (current_block, lt.Value, 
			LocalVariable.Flags.Constant, current_variable.TypeExpression, lt.Location);
		var d = new BlockVariableDeclarator (li, (Expression) $4);
		current_variable.AddDeclarator (d);
	  	lbag.AddLocation (d, GetLocation ($1), GetLocation ($3));
	  }
	;
	
block_variable_initializer
	: variable_initializer
//	| STACKALLOC simple_type OPEN_BRACKET_EXPR expression CLOSE_BRACKET
//	  {
//		$$ = new StackAlloc ((Expression) $2, (Expression) $4, GetLocation ($1));
//		lbag.AddLocation ($$, GetLocation ($3), GetLocation ($5));
//	  }
//	| STACKALLOC simple_type
//	  {
//		report.Error (1575, GetLocation ($1), "A stackalloc expression requires [] after type");
//		$$ = new StackAlloc ((Expression) $2, null, GetLocation ($1));		
//	  }
	;

expression_statement
	: statement_expression stmnt_end_semicolon
	  {
		$$ = $1;
		lbag.AddStatement ($$, GetLocation ($2));
	  }
	| statement_expression COMPLETE_COMPLETION { $$ = $1; }
	| statement_expression CLOSE_BRACE
	  {
		$$ = $1;
		report.Error (1002, GetLocation ($2), "; expected");
		lexer.putback ('}');
	  }
	;

interactive_expression_statement
	: interactive_statement_expression SEMICOLON { $$ = $1; }
	| interactive_statement_expression COMPLETE_COMPLETION { $$ = $1; }
	;

	//
	// We have to do the wrapping here and not in the case above,
	// because statement_expression is used for example in for_statement
	//
statement_expression
	: expression
	  {
		ExpressionStatement s = $1 as ExpressionStatement;
		if (s == null) {
			var expr = $1 as Expression;
			if (expr == null) {
				$$ = new StatementErrorExpression (expr);
			} else {
				// Expressions as statements are allowed
				$$ = new StatementFromExpression (expr);
			}
		} else {
			$$ = new StatementExpression (s);
		}
	  }
	;

interactive_statement_expression
	: expression
	  {
		Expression expr = (Expression) $1;
		$$ = new StatementExpression (new OptionalAssign (expr, lexer.Location));
	  }
	| error
	  {
		Error_SyntaxError (yyToken);
		$$ = new EmptyStatement (GetLocation ($1));
	  }
	;
	
selection_statement
	: if_statement
	| switch_statement
	; 

stmnt_close_parens
	: CLOSE_PARENS
	  {
	  	Lexer.AutoSemiInsertionAfter = 1;
	  }
	;
	
stmnt_else
	: ELSE
	  {
	  	Lexer.AutoSemiInsertionAfter = 1;
	  }
	;	

if_statement
	: IF open_parens_any boolean_expression stmnt_close_parens 
	  embedded_statement
	  { 
		if ($5 is EmptyStatement)
			Warning_EmptyStatement (GetLocation ($5));
		
		$$ = new If ((BooleanExpression) $3, (Statement) $5, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
	  }
	| IF open_parens_any boolean_expression stmnt_close_parens
	  embedded_statement stmnt_else embedded_statement
	  {
		$$ = new If ((BooleanExpression) $3, (Statement) $5, (Statement) $7, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4), GetLocation ($6));
		
		if ($5 is EmptyStatement)
			Warning_EmptyStatement (GetLocation ($5));
		if ($7 is EmptyStatement)
			Warning_EmptyStatement (GetLocation ($7));
	  }
	| IF open_parens_any boolean_expression error
	  {
		Error_SyntaxError (yyToken);
		
		$$ = new If ((BooleanExpression) $3, null, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($2));
	  }
	;

switch_statement
	: SWITCH open_parens_any expression CLOSE_PARENS OPEN_BRACE
	  {
	    Lexer.AutoSemiInsertion = true;
		start_block (GetLocation ($5));
	  }
	  opt_switch_sections CLOSE_BRACE
	  {
		$$ = new Switch ((Expression) $3, (ExplicitBlock) current_block.Explicit, GetLocation ($1));	
		end_block (GetLocation ($8));
		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
	  }
	| SWITCH open_parens_any expression error
	  {
		Error_SyntaxError (yyToken);
	  
		$$ = new Switch ((Expression) $3, null, GetLocation ($1));	
		lbag.AddStatement ($$, GetLocation ($2));
	  }
	;

opt_switch_sections
	: /* empty */ 		
      {
		report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
	  }
	| switch_labels
      {
		report.Warning (1522, 1, current_block.StartLocation, "Empty switch block"); 
	  }
	| switch_sections opt_switch_labels
	;

switch_sections
	: switch_section 
	| switch_sections switch_section
	| error
	  {
		Error_SyntaxError (yyToken);
	  } 
	;

switch_section
	: switch_labels statement_list 
	;

opt_switch_labels
	: /* empty */
	| switch_labels
	;

switch_labels
	: switch_label 
	  {
	  	var label = (SwitchLabel) $1;
	  	label.SectionStart = true;
		current_block.AddStatement (label);
	  }
	| switch_labels switch_label 
	  {
		current_block.AddStatement ((Statement) $2);
	  }
	;

switch_label
	: CASE constant_expression COLON
	 {
	 	$$ = new SwitchLabel ((Expression) $2, GetLocation ($1));
	 	lbag.AddLocation ($$, GetLocation ($3));
	  	Lexer.AutoSemiInsertionAfter = 1;	 	
	 }
	| CASE constant_expression error
	  {
		Error_SyntaxError (yyToken);
		$$ = new SwitchLabel ((Expression) $2, GetLocation ($1));
	  }
	| DEFAULT_COLON
	  {
		$$ = new SwitchLabel (null, GetLocation ($1));
	  	Lexer.AutoSemiInsertionAfter = 1;		
	  }
	;

iteration_statement
	: while_statement
	| do_statement
	| for_statement
	| foreach_statement
	;

while_statement
	: WHILE open_parens_any boolean_expression stmnt_close_parens embedded_statement
	  {
		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
			Warning_EmptyStatement (GetLocation ($5));
	  
		$$ = new While ((BooleanExpression) $3, (Statement) $5, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
	  }
	| WHILE open_parens_any boolean_expression error
	  {
		Error_SyntaxError (yyToken);
		
		$$ = new While ((BooleanExpression) $3, null, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($2));
	  }
	;

stmnt_do
	: DO
	  {
	    Lexer.AutoSemiInsertionAfter = 1;
	  }
	;
	
do_while_stmnt_close_parens
	: CLOSE_PARENS
	  {
	    Lexer.AutoSemiInsertion = true;
	  }
	;

do_statement
	: stmnt_do embedded_statement WHILE open_parens_any boolean_expression do_while_stmnt_close_parens stmnt_end_semicolon
	  {
	    Lexer.AutoSemiInsertion = true;
	    
		$$ = new Do ((Statement) $2, (BooleanExpression) $5, GetLocation ($1), GetLocation ($3));
		lbag.AddStatement ($$, GetLocation ($3), GetLocation ($4), GetLocation ($6), GetLocation ($7));
	  }
	| stmnt_do embedded_statement error
	  {
	    Lexer.AutoSemiInsertion = true;
	    
		Error_SyntaxError (yyToken);
		$$ = new Do ((Statement) $2, null, GetLocation ($1), Location.Null);
	  }
	| stmnt_do embedded_statement WHILE open_parens_any boolean_expression error
	  {
	    Lexer.AutoSemiInsertion = true;

		Error_SyntaxError (yyToken);
	  
		$$ = new Do ((Statement) $2, (BooleanExpression) $5, GetLocation ($1), GetLocation ($3));
		lbag.AddStatement ($$, GetLocation ($3), GetLocation ($4));
	  }
	;

for_statement
	: FOR open_parens_any
	  {
		start_block (GetLocation ($2));
		current_block.IsCompilerGenerated = true;
		lexer.ForInParsing = true;
		$$ = new Tuple<Location,Location>(GetLocation($0), GetLocation($1));
	  }
	  for_statement_cont
	  {
		$$ = $4;
	  }
	;
	
// Has to use be extra rule to recover started block
for_statement_cont
	: for_initializer IN
	  {
	    lexer.ForInParsing = false;
	  } 
	  expression stmnt_close_parens embedded_statement
	  {
		if ($6 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
			Warning_EmptyStatement (GetLocation ($6));

		var locations = (Tuple<Location,Location>) $0;

		if ($1 is StatementList) {
			report.ErrorPlayScript (1200, GetLocation ($1), "Invalid for-in initializer, only 1 expression expected");
		}

		$$ = new ForIn ((Statement) $1, (Expression) $4, (Statement) $6, current_block, locations.Item1);
		lbag.AddStatement ($$, locations.Item2, GetLocation ($2), GetLocation ($5));
				
		end_block (GetLocation ($5));
	  }	
	| opt_for_initializer SEMICOLON
	  {
	    lexer.ForInParsing = false;
	  
		var locations = (Tuple<Location,Location>) $0;

		For f = new For (locations.Item1);
		current_block.AddStatement (f);
		
		f.Initializer = (Statement) $1;

		// Pass the "For" object to the iterator_part4
		oob_stack.Push (f);
		
		$$ = f;
	  }
	  for_condition_and_iterator_part
	  embedded_statement
	  {
		var locations = (Tuple<Location,Location>) $4;
		oob_stack.Pop ();
		if ($5 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
			Warning_EmptyStatement (GetLocation ($5));
	  
		For f = ((For) $3);
		f.Statement = (Statement) $5;
		lbag.AddStatement (f, current_block.StartLocation, GetLocation ($2), GetLocation (locations.Item1), GetLocation (locations.Item2));

		$$ = end_block (GetLocation ($2));
	  }
	| error
	  {
		lexer.ForInParsing = false;	  
		Lexer.AutoSemiInsertion = true;
		Error_SyntaxError (yyToken);
		$$ = end_block (current_block.StartLocation);
	  }
	;

for_condition_and_iterator_part
	: opt_for_condition SEMICOLON
	  {
		For f = (For) oob_stack.Peek ();
		f.Condition = (BooleanExpression) $1;
	  }
	  for_iterator_part {
		$$ = new Tuple<Location,Location> (GetLocation ($2), (Location) $4);
	  }

	// Handle errors in the case of opt_for_condition being followed by
	// a close parenthesis
	| opt_for_condition close_parens_close_brace {
		Lexer.AutoSemiInsertion = true;
		report.Error (1525, GetLocation ($2), "Unexpected symbol `}'");
		For f = (For) oob_stack.Peek ();
		f.Condition = (BooleanExpression) $1;
		$$ = new Tuple<Location,Location> (GetLocation ($2), GetLocation ($2));
	  }
	;

for_iterator_part
	: opt_for_iterator stmnt_close_parens {
	  	For f = (For) oob_stack.Peek ();
		f.Iterator = (Statement) $1;
		$$ = GetLocation ($2);
	  }
	| opt_for_iterator CLOSE_BRACE {
		Lexer.AutoSemiInsertion = true;
		report.Error (1525, GetLocation ($2), "Unexpected symbol expected ')'");
		For f = (For) oob_stack.Peek ();
		f.Iterator = (Statement) $1;
		$$ = GetLocation ($2);
	  }
	; 

close_parens_close_brace 
	: CLOSE_PARENS
	| CLOSE_BRACE { lexer.putback ('}'); }
	;

opt_for_initializer
	: /* empty */		{ $$ = new EmptyStatement (lexer.Location); }
	| for_initializer	
	;

for_initializer
	: variable_declaration
	| statement_expression_list
	;

opt_for_condition
	: /* empty */		{ $$ = null; }
	| boolean_expression
	;

opt_for_iterator
	: /* empty */		{ $$ = new EmptyStatement (lexer.Location); }
	| for_iterator
	;

for_iterator
	: statement_expression_list
	;

statement_expression_list
	: statement_expression
	| statement_expression_list COMMA statement_expression
	  {
	  	var sl = $1 as StatementList;
	  	if (sl == null) {
	  		sl = new StatementList ((Statement) $1, (Statement) $3);
			lbag.AddStatement (sl, GetLocation ($2));
	  	} else {
	  		sl.Add ((Statement) $3);
	  		lbag.AppendTo (sl, GetLocation ($2));
	  	}
	  		
		$$ = sl;
	  }
	;

foreach_statement
	: FOR_EACH 
	  {
		lexer.ForInParsing = true;
	  } 
	  open_parens_any for_initializer IN
	  {
	  	lexer.ForInParsing = false;
	  } 
	  expression stmnt_close_parens 
	  {
		start_block (GetLocation ($3));
		current_block.IsCompilerGenerated = true;
	  } 
	  embedded_statement
	  {
		if ($10 is EmptyStatement && lexer.peek_token () == Token.OPEN_BRACE)
			Warning_EmptyStatement (GetLocation ($10));

		if ($4 is StatementList) {
			report.ErrorPlayScript (1200, GetLocation ($4), "Invalid for-in initializer, only 1 expression expected");
		}

		$$ = new ForEach ((Statement) $4, (Expression) $7, (Statement) $10, current_block, GetLocation ($1));
				
		end_block (GetLocation ($5));
	  }
	;

jump_statement
	: break_statement
	| continue_statement
	| goto_statement
	| return_statement
	| throw_statement
	| yield_statement
	| use_namespace_statement
	;

break_statement
	: BREAK stmnt_end_semicolon
	  {
		$$ = new Break (GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($2));
	  }
	;

continue_statement
	: CONTINUE stmnt_end_semicolon
	  {
		$$ = new Continue (GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($2));
	  }
	| CONTINUE error
	  {
		Error_SyntaxError (yyToken);
		$$ = new Continue (GetLocation ($1));
	  }
	;

goto_statement
	: GOTO identifier_inside_body stmnt_end_semicolon 
	  {
		var lt = (LocatedToken) $2;
		$$ = new Goto (lt.Value, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
	  }
	| GOTO CASE constant_expression stmnt_end_semicolon
	  {
		$$ = new GotoCase ((Expression) $3, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
	  }
	| GOTO DEFAULT stmnt_end_semicolon 
	  {
		$$ = new GotoDefault (GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
	  }
	; 

return_statement
	: RETURN opt_expression stmnt_end_semicolon
	  {
		$$ = new Return ((Expression) $2, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($3));
	  }
	| RETURN expression error
	  {
	    Lexer.AutoSemiInsertion = true;
		Error_SyntaxError (yyToken);
		$$ = new Return ((Expression) $2, GetLocation ($1));
	  }
	| RETURN error
	  {
	    Lexer.AutoSemiInsertion = true;
		Error_SyntaxError (yyToken);
		$$ = new Return (null, GetLocation ($1));
	  }
	;

throw_statement
	: THROW opt_expression stmnt_end_semicolon
	  {
		$$ = new Throw ((Expression) $2, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($3));
	  }
	| THROW error
	  {
	    Lexer.AutoSemiInsertion = true;
		Error_SyntaxError (yyToken);
		$$ = new Throw (null, GetLocation ($1));
	  }
	;

yield_statement 
	: identifier_inside_body RETURN opt_expression stmnt_end_semicolon
	  {
		var lt = (LocatedToken) $1;
		string s = lt.Value;
		if (s != "yield"){
			report.Error (1003, lt.Location, "; expected");
		} else if ($3 == null) {
			report.Error (1627, GetLocation ($4), "Expression expected after yield return");
		} else if (lang_version == LanguageVersion.ISO_1){
			FeatureIsNotAvailable (lt.Location, "iterators");
		}
		
		current_block.Explicit.RegisterIteratorYield ();
		$$ = new Yield ((Expression) $3, lt.Location);
		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($4));
	  }
	| identifier_inside_body RETURN expression error
	  {
	    Lexer.AutoSemiInsertion = true;
	  
		Error_SyntaxError (yyToken);

		var lt = (LocatedToken) $1;
		string s = lt.Value;
		if (s != "yield"){
			report.Error (1003, lt.Location, "; expected");
		} else if ($3 == null) {
			report.Error (1627, GetLocation ($4), "Expression expected after yield return");
		} else if (lang_version == LanguageVersion.ISO_1){
			FeatureIsNotAvailable (lt.Location, "iterators");
		}
		
		current_block.Explicit.RegisterIteratorYield ();
		$$ = new Yield ((Expression) $3, lt.Location);
		lbag.AddStatement ($$, GetLocation ($2));
	  }
	| identifier_inside_body BREAK stmnt_end_semicolon
	  {
		var lt = (LocatedToken) $1;
		string s = lt.Value;
		if (s != "yield"){
			report.Error (1003, lt.Location, "; expected");
		} else if (lang_version == LanguageVersion.ISO_1){
			FeatureIsNotAvailable (lt.Location, "iterators");
		}
		
		current_block.Explicit.RegisterIteratorYield ();
		$$ = new YieldBreak (lt.Location);
		lbag.AddStatement ($$, GetLocation ($2), GetLocation ($3));
	  }
	;

opt_expression
	: /* empty */
	| expression
	;

try_statement
	: TRY block catch_clauses
	  {
		$$ = new TryCatch ((Block) $2, (List<Catch>) $3, GetLocation ($1), false);
	  }
	| TRY block FINALLY block
	  {
		$$ = new TryFinally ((Statement) $2, (Block) $4, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($3));
	  }
	| TRY block catch_clauses FINALLY block
	  {
		$$ = new TryFinally (new TryCatch ((Block) $2, (List<Catch>) $3, Location.Null, true), (Block) $5, GetLocation ($1));
		lbag.AddStatement ($$, GetLocation ($4));
	  }
	| TRY block error
	  {
		Error_SyntaxError (1524, yyToken);
		$$ = new TryCatch ((Block) $2, null, GetLocation ($1), false);
	  }
	;

catch_clauses
	: catch_clause 
	  {
		var l = new List<Catch> (2);

		l.Add ((Catch) $1);
		$$ = l;
	  }
	| catch_clauses catch_clause
	  {
		var l = (List<Catch>) $1;
		
		Catch c = (Catch) $2;
		if (l [l.Count - 1].IsGeneral) {
			report.Error (1017, c.loc, "Try statement already has an empty catch block");
		}
		
		l.Add (c);
		$$ = l;
	  }
	;

opt_identifier
	: /* empty */
	| identifier_inside_body
	;

catch_clause 
	: CATCH block
	  {
		$$ = new Catch ((Block) $2, GetLocation ($1));
	  }
	| CATCH open_parens_any IDENTIFIER COLON type CLOSE_PARENS
	  {
		start_block (GetLocation ($2));
		var c = new Catch (current_block, GetLocation ($1));
		c.TypeExpression = (FullNamedExpression) $5;

		var lt = (LocatedToken) $3;
		c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
//TODO:		c.Variable.TypeExpr = c.TypeExpression;
		current_block.AddLocalName (c.Variable);
		
		lbag.AddLocation (c, GetLocation ($2), GetLocation ($6));
		$$ = c;
	  }
	  block_prepared
	  {
		$$ = $7;
	  }
	| CATCH open_parens_any error
	  {
	  	if (yyToken == Token.CLOSE_PARENS) {
			report.Error (1015, lexer.Location,
				"A type that derives from `System.Exception', `object', or `string' expected");
		} else {
			Error_SyntaxError (yyToken);
		}
		
		$$ = new Catch (null, GetLocation ($1));
	  }
	| CATCH open_parens_any type opt_identifier CLOSE_PARENS error
	  {
		Error_SyntaxError (yyToken);

		// Required otherwise missing block could not be detected because
		// start_block is run early
		var c = new Catch (null, GetLocation ($1));
		c.TypeExpression = (FullNamedExpression) $3;

		if ($4 != null) {
			var lt = (LocatedToken) $4;
			c.Variable = new LocalVariable (current_block, lt.Value, lt.Location);
		}

		lbag.AddLocation (c, GetLocation ($2), GetLocation ($5));

		$$ = c;
	  }
	;

// LINQ

query_expression
	: first_from_clause query_body 
	  {
		lexer.query_parsing = false;
			
		Linq.AQueryClause from = $1 as Linq.AQueryClause;
			
		from.Tail.Next = (Linq.AQueryClause)$2;
		$$ = from;
		
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  }
	| nested_from_clause query_body
	  {
		Linq.AQueryClause from = $1 as Linq.AQueryClause;
			
		from.Tail.Next = (Linq.AQueryClause)$2;
		$$ = from;
		
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  }	

	// Bubble up COMPLETE_COMPLETION productions
	| first_from_clause COMPLETE_COMPLETION {
	        lexer.query_parsing = false;
		$$ = $1;

		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  }
	| nested_from_clause COMPLETE_COMPLETION {
	        $$ = $1;
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  }
	;
	
first_from_clause
	: FROM_FIRST identifier_inside_body IN expression
	  {
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  
		var lt = (LocatedToken) $2;
		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
		$$ = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$4, rv, GetLocation ($1)));
	  }
	| FROM_FIRST type identifier_inside_body IN expression
	  {
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  
		var lt = (LocatedToken) $3;
		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
		$$ = new Linq.QueryExpression (
			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$5, rv, GetLocation ($1)) {
				IdentifierType = (FullNamedExpression)$2
			}
		);
	  }
	;

nested_from_clause
	: FROM identifier_inside_body IN expression
	  {
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  
		var lt = (LocatedToken) $2;
		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
		$$ = new Linq.QueryExpression (new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$4, rv, GetLocation ($1)));
	  }
	| FROM type identifier_inside_body IN expression
	  {
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  
		var lt = (LocatedToken) $3;
		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
		$$ = new Linq.QueryExpression (
			new Linq.QueryStartClause ((Linq.QueryBlock)current_block, (Expression)$5, rv, GetLocation ($1)) {
				IdentifierType = (FullNamedExpression)$2
			}
		);
	  }
	;
	
from_clause
	: FROM identifier_inside_body IN
	  {
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  }
	  expression_or_error
	  {
		var lt = (LocatedToken) $2;
		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
		$$ = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)$5, GetLocation ($1));
		
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
		
		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
	  }	  
	| FROM type identifier_inside_body IN
	  {
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  }
	  expression_or_error
	  {
		var lt = (LocatedToken) $3;
		var sn = new Linq.RangeVariable (lt.Value, lt.Location);

		$$ = new Linq.SelectMany ((Linq.QueryBlock)current_block, sn, (Expression)$6, GetLocation ($1)) {
			IdentifierType = (FullNamedExpression)$2
		};
		
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
		
		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
	  }
	;	

query_body
	: query_body_clauses select_or_group_clause opt_query_continuation 
	  {
	  	Linq.AQueryClause head = (Linq.AQueryClause)$2;
		
		if ($3 != null)
			head.Next = (Linq.AQueryClause)$3;
				
		if ($1 != null) {
			Linq.AQueryClause clause = (Linq.AQueryClause)$1;
			clause.Tail.Next = head;
			head = clause;
		}
		
		$$ = head;
	  }
	| select_or_group_clause opt_query_continuation
	  {
	  	Linq.AQueryClause head = (Linq.AQueryClause)$2;

		if ($1 != null) {
			Linq.AQueryClause clause = (Linq.AQueryClause)$1;
			clause.Tail.Next = head;
			head = clause;
		}
		
		$$ = head;
	  }
	| query_body_clauses COMPLETE_COMPLETION
	| query_body_clauses error
	  {
		report.Error (742, GetLocation ($2), "Unexpected symbol `{0}'. A query body must end with select or group clause", GetSymbolName (yyToken));
		$$ = $1;
	  }
	| error
	  {
		Error_SyntaxError (yyToken);
		$$ = null;
	  }
	;
	
select_or_group_clause
	: SELECT
	  {
	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  }
	  expression_or_error
	  {
		$$ = new Linq.Select ((Linq.QueryBlock)current_block, (Expression)$3, GetLocation ($1));

		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  }
	| GROUP
	  {
	  	if (linq_clause_blocks == null)
	  		linq_clause_blocks = new Stack<Linq.QueryBlock> ();
	  		
	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  	linq_clause_blocks.Push ((Linq.QueryBlock)current_block);
	  }
	  expression_or_error
	  {
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  }
	  BY expression_or_error
	  {
		$$ = new Linq.GroupBy ((Linq.QueryBlock)current_block, (Expression)$3, linq_clause_blocks.Pop (), (Expression)$6, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($5));
		
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  }
	;
	
query_body_clauses
	: query_body_clause
	| query_body_clauses query_body_clause
	  {
		((Linq.AQueryClause)$1).Tail.Next = (Linq.AQueryClause)$2;
		$$ = $1;
	  }
	;
	
query_body_clause
	: from_clause
	| let_clause 
	| where_clause
	| join_clause
	| orderby_clause
	;
	
let_clause
	: LET identifier_inside_body ASSIGN 
	  {
	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  }
	  expression_or_error
	  {
		var lt = (LocatedToken) $2;
		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
	  	$$ = new Linq.Let ((Linq.QueryBlock) current_block, sn, (Expression)$5, GetLocation ($1));
		lbag.AddLocation ($$, GetLocation ($3));
	  	
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
		
		((Linq.QueryBlock)current_block).AddRangeVariable (sn);
	  }
	;

where_clause
	: WHERE
	  {
	  	current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  }
	  expression_or_error
	  {
		$$ = new Linq.Where ((Linq.QueryBlock)current_block, (Expression)$3, GetLocation ($1));

		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  }
	;
	
join_clause
	: JOIN identifier_inside_body IN
	  {
		if (linq_clause_blocks == null)
			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
	  		
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
	  }
	  expression_or_error ON
	  {
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;

		current_block = new Linq.QueryBlock (current_block, lexer.Location);
		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
	  }
	  expression_or_error EQUALS
	  {
		current_block.AddStatement (new ContextualReturn ((Expression) $8));
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;

		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  }
	  expression_or_error opt_join_into
	  {
		current_block.AddStatement (new ContextualReturn ((Expression) $11));
		current_block.SetEndLocation (lexer.Location);
	  
		var outer_selector = linq_clause_blocks.Pop ();
		var block = linq_clause_blocks.Pop ();

		var lt = (LocatedToken) $2;	
		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
		Linq.RangeVariable into;
		
		if ($12 == null) {
			into = sn;
	  		$$ = new Linq.Join (block, sn, (Expression)$5, outer_selector, (Linq.QueryBlock) current_block, GetLocation ($1));
			lbag.AddLocation ($$, GetLocation ($3), GetLocation ($6), GetLocation ($9));
		} else {
			//
			// Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions
			//
			var parent = block.Parent;
			while (parent is Linq.QueryBlock) {
				parent = parent.Parent;
			}
			current_block.Parent = parent;
			
			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
		
			lt = (LocatedToken) $12;
			into = new Linq.RangeVariable (lt.Value, lt.Location);

			$$ = new Linq.GroupJoin (block, sn, (Expression)$5, outer_selector, (Linq.QueryBlock) current_block, into, GetLocation ($1));	
			lbag.AddLocation ($$, GetLocation ($3), GetLocation ($6), GetLocation ($9), GetLocation ($12));
		}

		current_block = block.Parent;
		((Linq.QueryBlock)current_block).AddRangeVariable (into);
	  }
	| JOIN type identifier_inside_body IN
	  {
		if (linq_clause_blocks == null)
			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
	  		
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
	  }
	  expression_or_error ON
	  {
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;

		current_block = new Linq.QueryBlock (current_block, lexer.Location);
		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);
	  }
	  expression_or_error EQUALS
	  {
		current_block.AddStatement (new ContextualReturn ((Expression) $9));
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;

		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  }
	  expression_or_error opt_join_into
	  {
		current_block.AddStatement (new ContextualReturn ((Expression) $12));
		current_block.SetEndLocation (lexer.Location);
	  
		var outer_selector = linq_clause_blocks.Pop ();
		var block = linq_clause_blocks.Pop ();
		
		var lt = (LocatedToken) $3;
		var sn = new Linq.RangeVariable (lt.Value, lt.Location);
		Linq.RangeVariable into;
		
		if ($13 == null) {
			into = sn;		
	  		$$ = new Linq.Join (block, sn, (Expression)$6, outer_selector, (Linq.QueryBlock) current_block, GetLocation ($1)) {
	  			IdentifierType = (FullNamedExpression)$2
	  		};
		} else {
			//
			// Set equals right side parent to beginning of linq query, it is not accessible therefore cannot cause name collisions
			//
			var parent = block.Parent;
			while (parent is Linq.QueryBlock) {
				parent = parent.Parent;
			}
			current_block.Parent = parent;
		
			((Linq.QueryBlock)current_block).AddRangeVariable (sn);
		
			lt = (LocatedToken) $13;
			into = new Linq.RangeVariable (lt.Value, lt.Location); // TODO:
			
			$$ = new Linq.GroupJoin (block, sn, (Expression)$6, outer_selector, (Linq.QueryBlock) current_block, into, GetLocation ($1)) {
	  			IdentifierType = (FullNamedExpression)$2
	  		};			
		}
		
		current_block = block.Parent;
		((Linq.QueryBlock)current_block).AddRangeVariable (into);		
	  }
	;
	
opt_join_into
	: /* empty */
	| INTO identifier_inside_body
	  {
		$$ = $2;
	  }
	;
	
orderby_clause
	: ORDERBY
	  {
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  }
	  orderings
	  {
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  
		$$ = $3;
	  }
	;
	
orderings
	: order_by
	| order_by COMMA
	  {
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
	  }
	  orderings_then_by
	  {
		((Linq.AQueryClause)$1).Next = (Linq.AQueryClause)$4;
		$$ = $1;
	  }
	;
	
orderings_then_by
	: then_by
	| orderings_then_by COMMA
	 {
		current_block.SetEndLocation (lexer.Location);
		current_block = current_block.Parent;
	  
		current_block = new Linq.QueryBlock ((Linq.QueryBlock) current_block, lexer.Location);	 
	 }
	 then_by
	 {
		((Linq.AQueryClause)$1).Tail.Next = (Linq.AQueryClause)$4;
		$$ = $1;
	 }
	;	
	
order_by
	: expression
	  {
		$$ = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
	  }
	| expression ASCENDING
	  {
		$$ = new Linq.OrderByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| expression DESCENDING
	  {
		$$ = new Linq.OrderByDescending ((Linq.QueryBlock) current_block, (Expression)$1);	
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	;

then_by
	: expression
	  {
		$$ = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
	  }
	| expression ASCENDING
	  {
		$$ = new Linq.ThenByAscending ((Linq.QueryBlock) current_block, (Expression)$1);	
		lbag.AddLocation ($$, GetLocation ($2));
	  }
	| expression DESCENDING
	  {
		$$ = new Linq.ThenByDescending ((Linq.QueryBlock) current_block, (Expression)$1);	
		lbag.AddLocation ($$, GetLocation ($2));
	  }	
	;


opt_query_continuation
	: /* empty */
	| INTO identifier_inside_body
	  {
		// query continuation block is not linked with query block but with block
		// before. This means each query can use same range variable names for
		// different identifiers.

		current_block.SetEndLocation (GetLocation ($1));
		current_block = current_block.Parent;
	
		current_block = new Linq.QueryBlock (current_block, lexer.Location);
		
		if (linq_clause_blocks == null)
			linq_clause_blocks = new Stack<Linq.QueryBlock> ();
	  		
		linq_clause_blocks.Push ((Linq.QueryBlock) current_block);		
	  }
	  query_body
	  {
		var current_block = linq_clause_blocks.Pop ();	  
		var lt = (LocatedToken) $2;
		var rv = new Linq.RangeVariable (lt.Value, lt.Location);
  		$$ = new Linq.QueryStartClause ((Linq.QueryBlock)current_block, null, rv, GetLocation ($1)) {
  			next = (Linq.AQueryClause)$4
  		};
	  }
	;
	
//
// Support for using the compiler as an interactive parser
//
// The INTERACTIVE_PARSER token is first sent to parse our
// productions;  If the result is a Statement, the parsing
// is repeated, this time with INTERACTIVE_PARSE_WITH_BLOCK
// to setup the blocks in advance.
//
// This setup is here so that in the future we can add 
// support for other constructs (type parsing, namespaces, etc)
// that do not require a block to be setup in advance
//

interactive_parsing
	: EVAL_STATEMENT_PARSER EOF 
	| EVAL_USING_DECLARATIONS_UNIT_PARSER package_directives opt_COMPLETE_COMPLETION
	| EVAL_STATEMENT_PARSER
	 { 
		current_container = current_type = new Class (current_container, new MemberName ("<InteractiveExpressionClass>"), Modifiers.PUBLIC, null);

		// (ref object retval)
		Parameter [] mpar = new Parameter [1];
		mpar [0] = new Parameter (new TypeExpression (compiler.BuiltinTypes.Object, Location.Null), "$retval", Parameter.Modifier.REF, null, Location.Null);

		ParametersCompiled pars = new ParametersCompiled (mpar);
		var mods = Modifiers.PUBLIC | Modifiers.STATIC;
		if (settings.Unsafe)
			mods |= Modifiers.UNSAFE;

		current_local_parameters = pars;
		var method = new CSharp.Method (
			current_type,
			new TypeExpression (compiler.BuiltinTypes.Void, Location.Null),
			mods,
			new MemberName ("Host"),
			pars,
			null /* attributes */);
			
		current_type.AddMember (method);

		// Always set to true when in ineractive mode
		is_config_enabled = true; 
		
		oob_stack.Push (method);
		++lexer.parsing_block;
		start_block (lexer.Location);
	  }		
	  interactive_statement_list opt_COMPLETE_COMPLETION
	  {
		--lexer.parsing_block;
		Method method = (Method) oob_stack.Pop ();

		method.Block = (ToplevelBlock) end_block(lexer.Location);

		InteractiveResult = (Class) pop_current_class ();
		current_local_parameters = null;
	  } 
	| EVAL_COMPILATION_UNIT_PARSER interactive_compilation_unit
	;

interactive_compilation_unit
	: opt_extern_alias_directives opt_package_directives
	| opt_extern_alias_directives opt_package_directives package_declaration
	;

opt_COMPLETE_COMPLETION
	: /* nothing */
	| COMPLETE_COMPLETION
	;

//close_brace_or_complete_completion
//	: CLOSE_BRACE
//	| COMPLETE_COMPLETION
//	;
	
//
// XML documentation code references micro parser
//
documentation_parsing
	: DOC_SEE doc_cref
	  {
		module.DocumentationBuilder.ParsedName = (MemberName) $2;
	  }
	;

doc_cref
	: doc_type_declaration_name opt_doc_method_sig
	  {
		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)$2;
	  }
	| builtin_types opt_doc_method_sig
	  {
		module.DocumentationBuilder.ParsedBuiltinType = (TypeExpression)$1;
		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)$2;
		$$ = null;
	  }
	| builtin_types DOT IDENTIFIER opt_doc_method_sig
	  {
		module.DocumentationBuilder.ParsedBuiltinType = (TypeExpression)$1;
		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)$4;
		var lt = (LocatedToken) $3;
		$$ = new MemberName (lt.Value);
	  }
	| doc_type_declaration_name DOT THIS
	  {
		$$ = new MemberName ((MemberName) $1, MemberCache.IndexerNameAlias, Location.Null);
	  }
	| doc_type_declaration_name DOT THIS OPEN_BRACKET
	  {
		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
	  }
	  opt_doc_parameters CLOSE_BRACKET
	  {
		module.DocumentationBuilder.ParsedParameters = (List<DocumentationParameter>)$6;
		$$ = new MemberName ((MemberName) $1, MemberCache.IndexerNameAlias, Location.Null);
	  }
	| EXPLICIT OPERATOR type opt_doc_method_sig
	  {
		var p = (List<DocumentationParameter>)$4 ?? new List<DocumentationParameter> (1);
		p.Add (new DocumentationParameter ((FullNamedExpression) $3));
		module.DocumentationBuilder.ParsedParameters = p;
		module.DocumentationBuilder.ParsedOperator = Operator.OpType.Explicit;
		$$ = null;
	  }
	| IMPLICIT OPERATOR type opt_doc_method_sig
	  {
		var p = (List<DocumentationParameter>)$4 ?? new List<DocumentationParameter> (1);
		p.Add (new DocumentationParameter ((FullNamedExpression) $3));
		module.DocumentationBuilder.ParsedParameters = p;
		module.DocumentationBuilder.ParsedOperator = Operator.OpType.Implicit;
		$$ = null;
	  }	  
	| OPERATOR overloadable_operator opt_doc_method_sig
	  {
		var p = (List<DocumentationParameter>)$3 ?? new List<DocumentationParameter> (1);
		module.DocumentationBuilder.ParsedParameters = p;
		module.DocumentationBuilder.ParsedOperator = (Operator.OpType) $2;
		$$ = null;
	  }
	;
	
doc_type_declaration_name
	: type_declaration_name
	| doc_type_declaration_name DOT type_declaration_name
	  {
		$$ = new MemberName (((MemberName) $1), (MemberName) $3);
	  }
	;
	
opt_doc_method_sig
	: /* empty */
	| OPEN_PARENS
	  {
		valid_param_mod = ParameterModifierType.Ref | ParameterModifierType.Out;
	  }
	  opt_doc_parameters CLOSE_PARENS
	  {
		$$ = $3;
	  }
	;
	
opt_doc_parameters
	: /* empty */
	  {
		$$ = new List<DocumentationParameter> (0);
	  }
	| doc_parameters
	;
	
doc_parameters
	: doc_parameter
	  {
		var parameters = new List<DocumentationParameter> ();
		parameters.Add ((DocumentationParameter) $1);
		$$ = parameters;
	  }
	| doc_parameters COMMA doc_parameter
	  {
		var parameters = $1 as List<DocumentationParameter>;
		parameters.Add ((DocumentationParameter) $3);
		$$ = parameters;
	  }
	;
	
doc_parameter
	: opt_parameter_modifier parameter_type
	  {
		if ($1 != null)
			$$ = new DocumentationParameter ((Parameter.Modifier) $1, (FullNamedExpression) $2);
		else
			$$ = new DocumentationParameter ((FullNamedExpression) $2);
	  }
	;
	
%%

// <summary>
//  A class used to hold info about an operator declarator
// </summary>
class OperatorDeclaration {
	public readonly Operator.OpType optype;
	public readonly FullNamedExpression ret_type;
	public readonly Location location;

	public OperatorDeclaration (Operator.OpType op, FullNamedExpression ret_type, Location location)
	{
		optype = op;
		this.ret_type = ret_type;
		this.location = location;
	}
}

void Error_ExpectingTypeName (Expression expr)
{
	if (expr is Invocation){
		report.Error (1002, expr.Location, "Expecting `;'");
	} else {
		expr.Error_InvalidExpressionStatement (report);
	}
}

void Error_ParameterModifierNotValid (string modifier, Location loc)
{
	report.Error (631, loc, "The parameter modifier `{0}' is not valid in this context",
			              modifier);
}

void Error_DuplicateParameterModifier (Location loc, Parameter.Modifier mod)
{
	report.Error (1107, loc, "Duplicate parameter modifier `{0}'",
  		Parameter.GetModifierSignature (mod));
}

void Error_TypeExpected (Location loc)
{
	report.Error (1031, loc, "Type expected");
}

void Error_UnsafeCodeNotAllowed (Location loc)
{
	report.Error (227, loc, "Unsafe code requires the `unsafe' command line option to be specified");
}

void Warning_EmptyStatement (Location loc)
{
	report.Warning (642, 3, loc, "Possible mistaken empty statement");
}

void Warning_NoTypeDeclaration  (Location loc, string member)
{
	report.WarningPlayScript (1009, loc, "{0} has no type declaration", member);
}

void Error_NamedArgumentExpected (NamedArgument a)
{
	report.Error (1738, a.Location, "Named arguments must appear after the positional arguments");
}

void Error_MissingInitializer (Location loc)
{
	report.Error (210, loc, "You must provide an initializer in a fixed or using statement declaration");
}

object Error_AwaitAsIdentifier (object token)
{
	if (async_block) {
		report.Error (4003, GetLocation (token), "`await' cannot be used as an identifier within an async method or lambda expression");
		return new LocatedToken ("await", GetLocation (token));
	}

	return token;
}

void push_current_container (TypeDefinition tc, object partial_token)
{
	if (module.Evaluator != null){
		tc.Definition.Modifiers = tc.ModFlags = (tc.ModFlags & ~Modifiers.AccessibilityMask) | Modifiers.PUBLIC;
		if (undo == null)
			undo = new Undo ();

		undo.AddTypeContainer (current_container, tc);
	}
	
	if (is_config_enabled) {
		if (partial_token != null)
			current_container.AddPartial (tc);
		else
			current_container.AddTypeContainer (tc);
	}
	
	is_config_enabled = true;
		
	++lexer.parsing_declaration;
	current_container = tc;
	current_type = tc;
}

TypeContainer pop_current_class ()
{
	var retval = current_container;

	current_container = current_container.Parent;
	current_type = current_type.Parent as TypeDefinition;

	return retval;
}

[System.Diagnostics.Conditional ("FULL_AST")]
void StoreModifierLocation (object token, Location loc)
{
	if (lbag == null)
		return;

	if (mod_locations == null)
  		mod_locations = new List<Tuple<Modifiers, Location>> ();

	mod_locations.Add (Tuple.Create ((Modifiers) token, loc));
}

string CheckAttributeTarget (string a, Location l)
{
	switch (a) {
	case "assembly" : case "module" : case "field" : case "method" : case "param" : case "property" : case "type" :
			return a;
	}

	report.Warning (658, 1, l,
		 "`{0}' is invalid attribute target. All attributes in this attribute section will be ignored", a);
	return string.Empty;
}

bool IsPartial (object a)
{
	var attrs = a as Attributes;
	if (attrs == null)
		return false;
	foreach (var attr in attrs.Attrs) {
		if (attr.TypeExpression.Name == "Partial")
			return true;
	}
	return false;
}

static bool IsUnaryOperator (Operator.OpType op)
{
	switch (op) {
		
	case Operator.OpType.LogicalNot: 
	case Operator.OpType.OnesComplement: 
	case Operator.OpType.Increment:
	case Operator.OpType.Decrement:
	case Operator.OpType.True: 
	case Operator.OpType.False: 
	case Operator.OpType.UnaryPlus: 
	case Operator.OpType.UnaryNegation:
		return true;
	}
	return false;
}

void syntax_error (Location l, string msg)
{
	report.Error (1003, l, "Syntax error, " + msg);
}

Tokenizer lexer;

public Tokenizer Lexer {
	get {
		return lexer;
	}
}		   

public PlayScriptParser (SeekableStreamReader reader, CompilationSourceFile file, ParserSession session)
	: this (reader, file, file.Compiler.Report, session)
{
}

public PlayScriptParser (SeekableStreamReader reader, CompilationSourceFile file, Report report, ParserSession session)
{
	this.file = file;
	current_container = current_namespace = file;
	
	this.module = file.Module;
	this.compiler = file.Compiler;
	this.settings = compiler.Settings;
	this.report = report;
	
	lang_version = settings.Version;
	yacc_verbose_flag = settings.VerboseParserFlag;
	doc_support = settings.DocumentationFile != null;
	lexer = new Tokenizer (reader, file, session);
	oob_stack = new Stack<object> ();
	lbag = session.LocationsBag;
	use_global_stacks = session.UseJayGlobalArrays;
	parameters_bucket = session.ParametersStack;
}

public void parse ()
{
	eof_token = Token.EOF;
	
	try {
		if (yacc_verbose_flag > 1)
			yyparse (lexer, new yydebug.yyDebugSimple ());
		else
			yyparse (lexer);
			
		Tokenizer tokenizer = lexer as Tokenizer;
		tokenizer.cleanup ();		
	} catch (Exception e){
	  	if (e is yyParser.yyUnexpectedEof) {
			Error_SyntaxError (yyToken);
			UnexpectedEOF = true;
			return;
		}
			
		if (e is yyParser.yyException) {
			if (report.Errors == 0)
				report.Error (-25, lexer.Location, "Parsing error");
		} else {
			// Used by compiler-tester to test internal errors
			if (yacc_verbose_flag > 0 || e is FatalException)
				throw;
		
			report.Error (589, lexer.Location, "Internal compiler error during parsing" + e);
		}
	}
}

void CheckToken (int error, int yyToken, string msg, Location loc)
{
	if (yyToken >= Token.FIRST_KEYWORD && yyToken <= Token.LAST_KEYWORD)
		report.Error (error, loc, "{0}: `{1}' is a keyword", msg, GetTokenName (yyToken));
	else
		report.Error (error, loc, msg);
}

string ConsumeStoredComment ()
{
	string s = tmpComment;
	tmpComment = null;
	Lexer.doc_state = XmlCommentState.Allowed;
	return s;
}

void FeatureIsNotAvailable (Location loc, string feature)
{
	report.FeatureIsNotAvailable (compiler, loc, feature);
}

Location GetLocation (object obj)
{
	var lt = obj as LocatedToken;
	if (lt != null)
		return lt.Location;
		
	var mn = obj as MemberName;
	if (mn != null)
		return mn.Location;
		
	var expr = obj as Expression;
	if (expr != null)
		return expr.Location;

	return lexer.Location;
}

void start_block (Location loc)
{
	if (current_block == null) {
		current_block = new ToplevelBlock (compiler, current_local_parameters, loc);
		parsing_anonymous_method = false;
	} else if (parsing_anonymous_method) {
		current_block = new ParametersBlock (current_block, current_local_parameters, loc);
		parsing_anonymous_method = false;
	} else {
		current_block = new ExplicitBlock (current_block, loc, Location.Null);
	}
}

Block
end_block (Location loc)
{
	Block retval = current_block.Explicit;
	retval.SetEndLocation (loc);
	current_block = retval.Parent;
	return retval;
}

void start_anonymous (ParametersCompiled parameters, FullNamedExpression returnType, Location loc)
{
	oob_stack.Push (current_anonymous_method);
	oob_stack.Push (current_local_parameters);
	oob_stack.Push (current_variable);
	oob_stack.Push (Lexer.AutoSemiInsertion);

	current_local_parameters = parameters;
	current_anonymous_method = new LocalFunction (returnType, loc);

	// Force the next block to be created as a ToplevelBlock
	parsing_anonymous_method = true;
}

/*
 * Completes the anonymous method processing, if lambda_expr is null, this
 * means that we have a Statement instead of an Expression embedded 
 */
AnonymousMethodExpression end_anonymous (ParametersBlock anon_block)
{
	AnonymousMethodExpression retval;

	current_anonymous_method.Block = anon_block;
	retval = current_anonymous_method;

	Lexer.AutoSemiInsertion = (bool) oob_stack.Pop ();
	current_variable = (BlockVariable) oob_stack.Pop ();
	current_local_parameters = (ParametersCompiled) oob_stack.Pop ();
	current_anonymous_method = (AnonymousMethodExpression) oob_stack.Pop ();

	return retval;
}

static TypeDefinition GetTypeDefinition (TypeContainer container)
{
	var td = container as TypeDefinition;
	if (td != null)
		return td;

	Package pkg = (Package) container;
	return pkg.GetGlobalsTypeDefinition ();

}

void Error_SyntaxError (int token)
{
	Error_SyntaxError (0, token);
}

void Error_SyntaxError (int error_code, int token)
{
	Error_SyntaxError (error_code, token, "Unexpected symbol");
}

void Error_SyntaxError (int error_code, int token, string msg)
{
	Lexer.CompleteOnEOF = false;

	// An error message has been reported by tokenizer
	if (token == Token.ERROR)
		return;
	
	// Avoid duplicit error message after unterminated string literals
	if (token == Token.LITERAL && lexer.Location.Column == 0)
		return;

	string symbol = GetSymbolName (token);
	string expecting = GetExpecting ();
	var loc = lexer.Location - symbol.Length;
	
	if (error_code == 0) {
		if (expecting == "`identifier'") {
			if (token > Token.FIRST_KEYWORD && token < Token.LAST_KEYWORD) {
				report.Error (1041, loc, "Identifier expected, `{0}' is a keyword", symbol);
				return;
			}
			
			error_code = 1001;
			expecting = "identifier";
		} else if (expecting == "`)'") {
			error_code = 1026;
		} else {
			error_code = 1525;
		}
	}
	
	if (string.IsNullOrEmpty (expecting))
		report.Error (error_code, loc, "{1} `{0}'", symbol, msg);
	else
		report.Error (error_code, loc, "{2} `{0}', expecting {1}", symbol, expecting, msg);	  
}

void CheckIsPlayScript(string elem, Location loc) 
{
	if (!parsing_playscript) {
		report.Error (7035, loc, "`{0}' only supported in PlayScript", elem);
	}

}

MemberName CreateFullMemberName (LocatedToken lt, TypeParameters tparams = null)
{
	if (namespace_modifier != null) {
		var res = new NamespaceMemberName (namespace_modifier.Value, lt.Value, lt.Location);
		namespace_modifier = null;
		return res;
	}

	return new MemberName (lt.Value, tparams, lt.Location);
}

/*
object ConvertAsType(SimpleName sn, object e)
{
	if (sn.Name == "Object") 
		return new TypeExpression (compiler.BuiltinTypes.Dynamic, GetLocation (e));
	else if (sn.Name == "Boolean") 
		return new TypeExpression (compiler.BuiltinTypes.Bool, GetLocation (e));
	else if (sn.Name == "Number")
		return new TypeExpression (compiler.BuiltinTypes.Double, GetLocation (e));
	else if (sn.Name == "String")
		return new TypeExpression (compiler.BuiltinTypes.String, GetLocation (e));
	else if (sn.Name == "void")
		return new TypeExpression (compiler.BuiltinTypes.Void, GetLocation (e));
	else if (sn.Name == "Function")
		return new TypeExpression (compiler.BuiltinTypes.Delegate, GetLocation (e));
	else if (sn.Name == "Class")
		return new TypeExpression (compiler.BuiltinTypes.Type, GetLocation (e));
	else
		return e;
}
*/

Expression MakeMonoSimdType(string typeName, Location loc)
{
	return new MemberAccess(new MemberAccess(new SimpleName("Mono", loc), "Simd", loc), typeName, loc);
}

LocalVariable GetOrCreateLocalVariable(Block block, string name, LocalVariable.Flags flags, FullNamedExpression typeExpr, Location loc)
{
	INamedBlockVariable existing = null;
	LocalVariable li = null;

/*
	if (!parsing_playscript) {
		if (block.ParametersBlock.TopBlock.GetLocalName (name, block, ref existing)) {
			if (existing is LocalVariable) {
				li = existing as LocalVariable;
				if (li.TypeExpr != null && existing.TypeExpr != null && li.TypeExpr.Equals (existing.TypeExpr)) {
					report.Warning (7138, 1, loc, "Variable is declared more than once.");
					li.DeclFlags |= LocalVariable.Flags.AsIgnoreMultiple;
					return li;
				}
			}
		}
	}
*/	
	li = new LocalVariable(block, name, flags, loc);
//	li.TypeExpr = typeExpr;

	block.AddLocalName (li);
	
	return li;
}

string GetExpecting ()
{
	int [] tokens = yyExpectingTokens (yyExpectingState);
	var names = new List<string> (tokens.Length);
	bool has_type = false;
	bool has_identifier = false;
	for (int i = 0; i < tokens.Length; i++){
		int token = tokens [i];
		has_identifier |= token == Token.IDENTIFIER;
		
		string name = GetTokenName (token);
		if (name == "<internal>")
			continue;
			
		has_type |= name == "type";
		if (names.Contains (name))
			continue;
		
		names.Add (name);
	}

	//
	// Too many tokens to enumerate
	//
	if (names.Count > 8)
		return null;

	if (has_type && has_identifier)
		names.Remove ("identifier");

	if (names.Count == 1)
		return "`" + GetTokenName (tokens [0]) + "'";
	
	StringBuilder sb = new StringBuilder ();
	names.Sort ();
	int count = names.Count;
	for (int i = 0; i < count; i++){
		bool last = i + 1 == count;
		if (last)
			sb.Append ("or ");
		sb.Append ('`');
		sb.Append (names [i]);
		sb.Append (last ? "'" : count < 3 ? "' " : "', ");
	}
	return sb.ToString ();
}


string GetSymbolName (int token)
{
	switch (token){
	case Token.LITERAL:
		return "Literal " + ((Constant)lexer.Value).GetValue ().ToString ();
	case Token.IDENTIFIER:
	case Token.IDENTIFIER_CONFIG:
		return "Identifier " + ((LocatedToken)lexer.Value).Value ?? "";
	case Token.BOOL:
		return "bool";
	case Token.BOOLEAN:
		return "boolean";
	case Token.BYTE:
		return "byte";
	case Token.CHAR:
		return "char";
	case Token.VOID:
		return "void";
	case Token.DECIMAL:
		return "decimal";
	case Token.DOUBLE:
		return "double";
	case Token.DOUBLE2:
		return "double2";
	case Token.DOUBLE3:
		return "double3";
	case Token.DOUBLE4:
		return "double4";
	case Token.DYNAMIC:
		return "dynamic";
	case Token.FLOAT:
		return "float";
	case Token.FLOAT2:
		return "float2";
	case Token.FLOAT3:
		return "float3";
	case Token.FLOAT4:
		return "float4";
	case Token.INT:
		return "int";
	case Token.LONG:
		return "long";
	case Token.SBYTE:
		return "sbyte";
	case Token.SHORT:
		return "short";
	case Token.STRING:
		return "string";
	case Token.UINT:
		return "uint";
	case Token.ULONG:
		return "ulong";
	case Token.USHORT:
		return "ushort";
	case Token.OBJECT:
		return "object";
		
	case Token.PLUS:
		return "+";
	case Token.UMINUS:
	case Token.MINUS:
		return "-";
	case Token.BANG:
		return "!";
	case Token.BITWISE_AND:
		return "&";
	case Token.BITWISE_OR:
		return "|";
	case Token.LOGICAL_AND_ASSIGN:
		return "&&=";
	case Token.LOGICAL_OR_ASSIGN:
		return "||=";
	case Token.STAR:
		return "*";
	case Token.PERCENT:
		return "%";
	case Token.DIV:
		return "/";
	case Token.CARRET:
		return "^";
	case Token.OP_INC:
		return "++";
	case Token.OP_DEC:
		return "--";
	case Token.OP_SHIFT_LEFT:
		return "<<";
	case Token.OP_SHIFT_RIGHT:
		return ">>";
	case Token.OP_USHIFT_RIGHT:
		return ">>>";
	case Token.OP_LT:
		return "<";
	case Token.OP_GT:
		return ">";
	case Token.OP_LE:
		return "<=";
	case Token.OP_GE:
		return ">=";
	case Token.OP_EQ:
		return "==";
	case Token.OP_REF_EQ:
		return "===";
	case Token.OP_NE:
		return "!=";
	case Token.OP_AND:
		return "&&";
	case Token.OP_OR:
		return "||";
	case Token.OP_PTR:
		return "->";
	case Token.OP_IN:
		return "in";
	case Token.OP_COALESCING:	
		return "??";
	case Token.OP_MULT_ASSIGN:
		return "*=";
	case Token.OP_DIV_ASSIGN:
		return "/=";
	case Token.OP_MOD_ASSIGN:
		return "%=";
	case Token.OP_ADD_ASSIGN:
		return "+=";
	case Token.OP_SUB_ASSIGN:
		return "-=";
	case Token.OP_SHIFT_LEFT_ASSIGN:
		return "<<=";
	case Token.OP_SHIFT_RIGHT_ASSIGN:
		return ">>=";
	case Token.OP_USHIFT_RIGHT_ASSIGN:
		return ">>>=";
	case Token.OP_AND_ASSIGN:
		return "&=";
	case Token.OP_XOR_ASSIGN:
		return "^=";
	case Token.OP_OR_ASSIGN:
		return "|=";
	}

	return GetTokenName (token);
}

static string GetTokenName (int token)
{
	switch (token){
	case Token.ABSTRACT:
		return "abstract";
	case Token.AS:
		return "as";
	case Token.ASYNC:
		return "async";
	case Token.SUPER:
		return "super";
	case Token.BREAK:
		return "break";
	case Token.CASE:
		return "case";
	case Token.CATCH:
		return "catch";
	case Token.CLASS:
		return "class";
	case Token.CONST:
		return "const";
	case Token.CONTINUE:
		return "continue";
	case Token.DEFAULT:
		return "default";
	case Token.DELETE:
		return "delete";
	case Token.DO:
		return "do";
	case Token.EACH:
		return "each";
	case Token.ELSE:
		return "else";
	case Token.EXPLICIT:
		return "explicit";
	case Token.EXTENDS:
		return "extends";
	case Token.EXTERN:
		return "extern";
	case Token.FALSE:
		return "false";
	case Token.FINAL:
		return "final";
	case Token.FINALLY:
		return "finally";
	case Token.FIXED:
		return "fixed";
	case Token.FOR:
		return "for";
	case Token.FOR_EACH:
		return "for each";
	case Token.FUNCTION:
		return "function";
	case Token.FUNCTION_GET:
		return "function get";
	case Token.FUNCTION_SET:
		return "function set";
	case Token.GOTO:
		return "goto";
	case Token.IF:
		return "if";
	case Token.IMPLEMENTS:
		return "implements";
	case Token.IMPLICIT:
		return "implicit";
	case Token.IMPORT:
		return "import";
	case Token.IN:
		return "in";
	case Token.INDEXER:
		return "indexer";
	case Token.INSTANCEOF:
		return "instanceof";
	case Token.INTERFACE:
		return "interface";
	case Token.INTERNAL:
		return "internal";
	case Token.IS:
		return "is";
	case Token.NAMESPACE:
		return "namespace";
	case Token.NATIVE:
		return "native";
	case Token.NEW:
		return "new";
	case Token.NULL:
		return "null";
	case Token.OPERATOR:
		return "operator";
	case Token.OUT:
		return "out";
	case Token.OVERRIDE:
		return "override";
	case Token.OVERLOAD:
		return "overload";
	case Token.PRIVATE:
		return "private";
	case Token.PROPERTY:
		return "property";
	case Token.PROTECTED:
		return "protected";
	case Token.PUBLIC:
		return "public";
	case Token.READONLY:
		return "readonly";
	case Token.REF:
		return "ref";
	case Token.RETURN:
		return "return";
	case Token.STATIC:
		return "static";
	case Token.STRUCT:
		return "struct";
	case Token.SWITCH:
		return "switch";
	case Token.THIS:
		return "this";
	case Token.THROW:
		return "throw";
	case Token.TRUE:
		return "true";
	case Token.TRY:
		return "try";
	case Token.TYPEOF:
		return "typeof";
	case Token.UNSAFE:
		return "unsafe";
	case Token.USE:
		return "use";
	case Token.USING:
		return "using";
	case Token.VAR:
		return "var";
	case Token.VIRTUAL:
		return "virtual";
	case Token.VOLATILE:
		return "volatile";
	case Token.WHERE:
		return "where";
	case Token.WHILE:
		return "while";
	case Token.PARTIAL:
		return "partial";
	case Token.ARROW:
		return "=>";
	case Token.FROM:
	case Token.FROM_FIRST:
		return "from";
	case Token.JOIN:
		return "join";
	case Token.ON:
		return "on";
	case Token.EQUALS:
		return "equals";
	case Token.SELECT:
		return "select";
	case Token.GROUP:
		return "group";
	case Token.BY:
		return "by";
	case Token.LET:
		return "let";
	case Token.ORDERBY:
		return "orderby";
	case Token.ASCENDING:
		return "ascending";
	case Token.DESCENDING:
		return "descending";
	case Token.INTO:
		return "into";
	case Token.GET:
		return "get";
	case Token.SET:
		return "set";
	case Token.OPEN_BRACE:
	case Token.OPEN_BRACE_INIT:
		return "{";
	case Token.CLOSE_BRACE:
		return "}";
	case Token.OPEN_BRACKET:
	case Token.OPEN_BRACKET_EXPR:
		return "[";
	case Token.CLOSE_BRACKET:
		return "]";
	case Token.OPEN_PARENS_CAST:
	case Token.OPEN_PARENS_LAMBDA:
	case Token.OPEN_PARENS:
		return "(";
	case Token.CLOSE_PARENS:
		return ")";
	case Token.DOT:
		return ".";
	case Token.DOT_AT:
		return ".@";
	case Token.DOT_STAR:
		return ".*";
	case Token.DOTDOT:
		return "..";
	case Token.DOTDOT_AT:
		return "..@";
	case Token.DOTDOT_STAR:
		return "..*";
	case Token.DOTDOTDOT:
		return "...";
	case Token.COMMA:
		return ",";
	case Token.DEFAULT_COLON:
		return "default:";
	case Token.COLON:
		return ":";
	case Token.SEMICOLON:
		return ";";
	case Token.TILDE:
		return "~";
		
	case Token.PLUS:
	case Token.UMINUS:
	case Token.MINUS:
	case Token.BANG:
	case Token.OP_LT:
	case Token.OP_GT:
	case Token.BITWISE_AND:
	case Token.BITWISE_OR:
	case Token.STAR:
	case Token.PERCENT:
	case Token.DIV:
	case Token.CARRET:
	case Token.OP_INC:
	case Token.OP_DEC:
	case Token.OP_SHIFT_LEFT:
	case Token.OP_SHIFT_RIGHT:
	case Token.OP_LE:
	case Token.OP_GE:
	case Token.OP_EQ:
	case Token.OP_NE:
	case Token.OP_AND:
	case Token.OP_OR:
	case Token.OP_PTR:
	case Token.OP_COALESCING:	
	case Token.OP_MULT_ASSIGN:
	case Token.OP_DIV_ASSIGN:
	case Token.OP_MOD_ASSIGN:
	case Token.OP_ADD_ASSIGN:
	case Token.OP_SUB_ASSIGN:
	case Token.OP_SHIFT_LEFT_ASSIGN:
	case Token.OP_SHIFT_RIGHT_ASSIGN:
	case Token.OP_AND_ASSIGN:
	case Token.OP_XOR_ASSIGN:
	case Token.OP_OR_ASSIGN:
	case Token.OP_AT:
		return "<operator>";

	case Token.BOOL:
	case Token.BYTE:
	case Token.CHAR:
	case Token.VOID:
	case Token.DECIMAL:
	case Token.DOUBLE:
	case Token.FLOAT:
	case Token.INT:
	case Token.LONG:
	case Token.SBYTE:
	case Token.SHORT:
	case Token.STRING:
	case Token.UINT:
	case Token.ULONG:
	case Token.USHORT:
	case Token.OBJECT:
		return "type";
	
	case Token.ASSIGN:
		return "=";
	case Token.OP_GENERICS_LT:
	case Token.GENERIC_DIMENSION:
		return ".<";
	case Token.OP_GENERICS_GT:
		return ">";
	case Token.INTERR:
	case Token.INTERR_NULLABLE:
		return "?";
	case Token.DOUBLE_COLON:
		return "::";
	case Token.LITERAL:
		return "value";
	case Token.IDENTIFIER:
	case Token.AWAIT:
		return "identifier";

	case Token.EOF:
		return "end-of-file";

		// All of these are internal.
	case Token.NONE:
	case Token.ERROR:
	case Token.FIRST_KEYWORD:
	case Token.EVAL_COMPILATION_UNIT_PARSER:
	case Token.EVAL_USING_DECLARATIONS_UNIT_PARSER:
	case Token.EVAL_STATEMENT_PARSER:
	case Token.LAST_KEYWORD:
	case Token.GENERATE_COMPLETION:
	case Token.COMPLETE_COMPLETION:
		return "<internal>";

		// A bit more robust.
	default:
		return yyNames [token];
        }
}

/* end end end */
}
