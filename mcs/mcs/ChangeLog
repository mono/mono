2002-11-08  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (LookupType): Added a negative-hit hashtable for
	the Type lookups, as we perform quite a number of lookups on
	non-Types.  This can be removed once we can deterministically tell
	whether we have a type or a namespace in advance.

	But this might require special hacks from our corlib.

	* TODO: updated.

	* ecore.cs (TryImplicitIntConversion): Handle conversions to float
	and double which avoids a conversion from an integer to a double.

	* expression.cs: tiny optimization, avoid calling IsConstant,
	because it effectively performs the lookup twice.

2002-11-06  Miguel de Icaza  <miguel@ximian.com>

	But a bogus return here to keep the semantics of the old code
	until the Mono runtime is fixed.
	
	* pending.cs (GetMissingInterfaces): New method used to remove all
	the interfaces that are already implemented by our parent
	classes from the list of pending methods. 

	* interface.cs: Add checks for calls after ResolveTypeExpr.

2002-11-05  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Class.Emit): Report warning 67: event not used if the
	warning level is beyond 3.

	* ecore.cs (Expression.ConvertExplicit): Missed a check for expr
	being a NullLiteral.

	* cs-parser.jay: Fix, Gonzalo reverted the order of the rank
	specifiers. 

	* class.cs (TypeContainer.GetClassBases): Cover a missing code
	path that might fail if a type can not be resolved.

	* expression.cs (Binary.Emit): Emit unsigned versions of the
	operators. 

	* driver.cs: use error 5.
	
2002-11-02  Gonzalo Paniagua Javier <gonzalo@gnome-db.org>

	* cs-parser.jay: simplified a rule and 5 SR conflicts dissapeared.

2002-11-01  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay (switch_section): A beautiful patch from Martin
	Baulig that fixed 33094.

2002-10-31  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (PropertyExpr.DoResolveLValue, PropertyExpr.DoResolve):
	Check whether the base is abstract and report an error if so.

	* expression.cs (IndexerAccess.DoResolveLValue,
	IndexerAccess.DoResolve): ditto. 

	(Invocation.DoResolve): ditto.
	
	(Invocation.FullMethodDesc): Improve the report string.

	* statement.cs (Block): Eliminate IsVariableDefined as it is
	basically just a wrapper for GetVariableInfo.

	* ecore.cs (SimpleName): Use new 

	* support.cs (ReflectionParamter.ParameterType): We unwrap the
	type, as we return the actual parameter ref/unref state on a
	different call.

2002-10-30  Miguel de Icaza  <miguel@ximian.com>

	* support.cs: Return proper flags REF/OUT fixing the previous
	commit.  

	* expression.cs: Reverted last patch, that was wrong.  Is_ref is
	not used to mean `ref' but `ref or out' in ParameterReference
	
	* delegate.cs (FullDelegateDesc): use ParameterDesc to get the
	full type signature instead of calling TypeManger.CSharpName
	ourselves. 

	* support.cs (InternalParameters.ParameterDesc): Do not compare
	directly to the modflags, because REF/OUT will actually be bitsets
	if set. 

	* delegate.cs (VerifyMethod): Check also the modifiers.

	* cs-tokenizer.cs: Fix bug where floating point values with an
	exponent where a sign was missing was ignored.

	* driver.cs: Allow multiple assemblies to be specified in a single
	/r: argument

2002-10-28  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Ugly.  We had to add a multiplicative_expression,
	because identifiers after a parenthesis would end up in this kind
	of production, and we needed to desamiguate it for having casts
	like:

		(UserDefinedType *) xxx

2002-10-24  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (RealMemberLookup): when we deal with a subclass,
	we should set on the Bindingflags.NonPublic, but not turn on
	private_ok.  private_ok controls whether a Private member is
	returned (this is chekced on the filter routine), while the
	BindingFlags.NonPublic just controls whether private/protected
	will be allowed.   This fixes the problem part of the problem of
	private properties being allowed to be used in derived classes.

	* expression.cs (BaseAccess): Provide an DoResolveLValue method,
	so we can call the children DoResolveLValue method (this will
	properly signal errors on lvalue assignments to base properties)
	
	* ecore.cs (PropertyExpr.ResolveAccessors): If both setter and
	getter are null, and we have a property info, we know that this
	happened because the lookup failed, so we report an error 122 for
	protection level violation.

	We also silently return if setter and getter are null in the
	resolve functions, this condition only happens if we have flagged
	the error before.  This is the other half of the problem. 

	(PropertyExpr.ResolveAccessors): Turns out that PropertyInfo does
	not have accessibility information, that is why we were returning
	true in the filter function in typemanager.cs.

	To properly report 122 (property is inaccessible because of its
	protection level) correctly, we report this error in ResolveAccess
	by failing if both the setter and the getter are lacking (ie, the
	lookup failed). 

	DoResolve and DoLResolve have been modified to check for both
	setter/getter being null and returning silently, the reason being
	that I did not want to put the knowledge about this error in upper
	layers, like:

	int old = Report.Errors;
	x = new PropertyExpr (...);
	if (old != Report.Errors)
		return null;
	else
	        return x;

	So the property expr is returned, but it is invalid, so the error
	will be flagged during the resolve process. 

	* class.cs: Remove InheritablePropertySignatureCompare from the
	class, as we no longer depend on the property signature to compute
	whether it is possible to implement a method or not.

	The reason is that calling PropertyInfo.GetGetMethod will return
	null (in .NET, in Mono it works, and we should change this), in
	cases where the Get Method does not exist in that particular
	class.

	So this code:

	class X { public virtual int A { get { return 1; } } }
	class Y : X { }
	class Z : Y { public override int A { get { return 2; } } }

	Would fail in Z because the parent (Y) would not have the property
	defined.  So we avoid this completely now (because the alternative
	fix was ugly and slow), and we now depend exclusively on the
	method names.

	(PropertyBase.CheckBase): Use a method-base mechanism to find our
	reference method, instead of using the property.

	* typemanager.cs (GetPropertyGetter, GetPropertySetter): These
	routines are gone now.

	* typemanager.cs (GetPropertyGetter, GetPropertySetter): swap the
	names, they were incorrectly named.

	* cs-tokenizer.cs: Return are more gentle token on failure. 

	* pending.cs (PendingImplementation.InterfaceMethod): This routine
	had an out-of-sync index variable, which caused it to remove from
	the list of pending methods the wrong method sometimes.

2002-10-22  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (PropertyExpr): Do not use PropertyInfo.CanRead,
	CanWrite, because those refer to this particular instance of the
	property, and do not take into account the fact that we can
	override single members of a property.

	Constructor requires an EmitContext.  The resolution process does
	not happen here, but we need to compute the accessors before,
	because the resolution does not always happen for properties.
	
	* typemanager.cs (RealMemberLookup): Set private_ok if we are a
	subclass, before we did not update this flag, but we did update
	bindingflags. 

	(GetAccessors): Drop this routine, as it did not work in the
	presence of partially overwritten set/get methods. 

	Notice that this broke the cs1540 detection, but that will require
	more thinking. 
	
2002-10-22  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* class.cs:
	* codegen.cs:
	* driver.cs: issue a warning instead of an error if we don't support
	debugging for the platform. Also ignore a couple of errors that may
	arise when trying to write the symbols. Undo my previous patch.

2002-10-22  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* driver.cs: ignore /debug switch except for Unix platforms.

2002-10-23  Nick Drochak  <ndrochak@gol.com>

	* makefile: Remove mcs2.exe and mcs3.exe on 'make clean'

2002-10-21  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Do not make mcs-debug conditional, so we do not break
	builds that use it.

	* statement.cs (UsageVector.MergeChildren): I would like Martin to
	review this patch.  But basically after all the children variables
	have been merged, the value of "Breaks" was not being set to
	new_breaks for Switch blocks.  I think that it should be set after
	it has executed.  Currently I set this to the value of new_breaks,
	but only if new_breaks is FlowReturn.ALWAYS, which is a bit
	conservative, but I do not understand this code very well.

	I did not break anything in the build, so that is good ;-)

	* cs-tokenizer.cs: Also allow \r in comments as a line separator.

2002-10-20  Mark Crichton  <crichton@gimp.org>

        * cfold.cs: Fixed compile blocker.  Really fixed it this time.

2002-10-20  Nick Drochak  <ndrochak@gol.com>

	* cfold.cs: Fixed compile blocker.

2002-10-20  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: I was chekcing the key, not the file.

2002-10-19  Ravi Pratap  <ravi@ximian.com>

	* ecore.cs (UserDefinedConversion): Get rid of the bogus error
	message that we were generating - we just need to silently return
	a null.

2002-10-19  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Event.Define): Change my previous commit, as this
	breaks the debugger.  This is a temporary hack, as it seems like
	the compiler is generating events incorrectly to begin with.

	* expression.cs (Binary.ResolveOperator): Added support for 
	"U operator - (E x, E y)"

	* cfold.cs (BinaryFold): Added support for "U operator - (E x, E
	y)".

	* ecore.cs (FieldExpr.AddressOf): We had a special code path for
	init-only variables, but this path did not take into account that
	there might be also instance readonly variables.  Correct this
	problem. 

	This fixes bug 32253

	* delegate.cs (NewDelegate.DoResolve): Catch creation of unsafe
	delegates as well.

	* driver.cs: Change the extension for modules to `netmodule'

	* cs-parser.jay: Improved slightly the location tracking for
	the debugger symbols.

	* class.cs (Event.Define): Use Modifiers.FieldAttr on the
	modifiers that were specified instead of the hardcoded value
	(FamAndAssem).  This was basically ignoring the static modifier,
	and others.  Fixes 32429.

	* statement.cs (Switch.SimpleSwitchEmit): Simplified the code, and
	fixed a bug in the process (32476)

	* expression.cs (ArrayAccess.EmitAssign): Patch from
	hwang_rob@yahoo.ca that fixes bug 31834.3

2002-10-18  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Make the module extension .netmodule.

2002-10-16  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Report an error if the resource file is not found
	instead of crashing.

	* ecore.cs (PropertyExpr.EmitAssign): Pass IsBase instead of
	false, like Emit does.

2002-10-16  Nick Drochak  <ndrochak@gol.com>

	* typemanager.cs: Remove unused private member.  Also reported mcs
	bug to report this as a warning like csc.

2002-10-15  Martin Baulig  <martin@gnome.org>

	* statement.cs (Statement.Emit): Made this a virtual method; emits
	the line number info and calls DoEmit().
	(Statement.DoEmit): New protected abstract method, formerly knows
	as Statement.Emit().

	* codegen.cs (EmitContext.Mark): Check whether we have a symbol writer.

2002-10-11  Miguel de Icaza  <miguel@ximian.com>

	* class.cs: Following the comment from 2002-09-26 to AddMethod, I
	have fixed a remaining problem: not every AddXXXX was adding a
	fully qualified name.  

	Now everyone registers a fully qualified name in the DeclSpace as
	being defined instead of the partial name.  

	Downsides: we are slower than we need to be due to the excess
	copies and the names being registered this way.  

	The reason for this is that we currently depend (on the corlib
	bootstrap for instance) that types are fully qualified, because
	we dump all the types in the namespace, and we should really have
	types inserted into the proper namespace, so we can only store the
	basenames in the defined_names array.

2002-10-10  Martin Baulig  <martin@gnome.org>

	* expression.cs (ArrayAccess.EmitStoreOpcode): Reverted the patch
	from bug #31834, see the bug report for a testcase which is
	miscompiled.

2002-10-10  Martin Baulig  <martin@gnome.org>

	* codegen.cs (EmitContext.Breaks): Removed, we're now using the
	flow analysis code for this.

	* statement.cs (Do, While, For): Tell the flow analysis code about
	infinite loops.
	(FlowBranching.UsageVector): Added support for infinite loops.
	(Block.Resolve): Moved the dead code elimination here and use flow
	analysis to do it.

2002-10-09  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Field.Define): Catch cycles on struct type
	definitions. 

	* typemanager.cs (IsUnmanagedtype): Do not recursively check
	fields if the fields are static.  We only need to check instance
	fields. 

	* expression.cs (As.DoResolve): Test for reference type.

	* statement.cs (Using.ResolveExpression): Use
	ConvertImplicitRequired, not ConvertImplicit which reports an
	error on failture
	(Using.ResolveLocalVariableDecls): ditto.

	* expression.cs (Binary.ResolveOperator): Report errors in a few
	places where we had to.

	* typemanager.cs (IsUnmanagedtype): Finish implementation.

2002-10-08  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Use StoreFromPtr instead of extracting the type
	and then trying to use Stelem.  Patch is from hwang_rob@yahoo.ca

	* ecore.cs (ImplicitReferenceConversion): It is possible to assign
	an enumeration value to a System.Enum, but System.Enum is not a
	value type, but an class type, so we need to box.

	(Expression.ConvertExplicit): One codepath could return
	errors but not flag them.  Fix this.  Fixes #31853

	* parameter.cs (Resolve): Do not allow void as a parameter type.

2002-10-06  Martin Baulig  <martin@gnome.org>

	* statemenc.cs (FlowBranching.SetParameterAssigned): Don't crash
	if it's a class type and not a struct.  Fixes #31815.

2002-10-06  Martin Baulig  <martin@gnome.org>

	* statement.cs: Reworked the flow analysis code a bit to make it
	usable for dead code elimination.

2002-10-06  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* cs-parser.jay: allow empty source files. Fixes bug #31781.

2002-10-04  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ComposedCast.DoResolveType): A quick workaround
	to fix the test 165, will investigate deeper.

2002-10-04  Martin Baulig  <martin@gnome.org>

	* statement.cs (FlowBranching.UsageVector.MergeChildren): Make
	finally blocks actually work.
	(Try.Resolve): We don't need to create a sibling for `finally' if
	there is no finally block.

2002-10-04  Martin Baulig  <martin@gnome.org>

	* class.cs (Constructor.Define): The default accessibility for a
	non-default constructor is private, not public.

2002-10-04  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Constructor): Make AllowedModifiers public, add
	EXTERN.

	* cs-parser.jay: Perform the modifiers test here, as the
	constructor for the Constructor class usually receives a zero
	because of the way we create it (first we create, later we
	customize, and we were never checking the modifiers).

	* typemanager.cs (Typemanager.LookupTypeDirect): This new function
	is a version of LookupTypeReflection that includes the type-name
	cache.  This can be used as a fast path for functions that know
	the fully qualified name and are only calling into *.GetType() to
	obtain a composed type.

	This is also used by TypeManager.LookupType during its type
	composition.

	(LookupType): We now also track the real type name, as sometimes
	we can get a quey for the real type name from things like
	ComposedCast.  This fixes bug 31422.
	
	* expression.cs (ComposedCast.Resolve): Since we are obtaining a
	complete type fullname, it does not have to go through the type
	resolution system to obtain the composed version of the type (for
	obtaining arrays or pointers).
	
	(Conditional.Emit): Use the EmitBoolExpression to
	generate nicer code, as requested by Paolo.

	(ArrayCreation.CheckIndices): Use the patch from
	hwang_rob@yahoo.ca to validate the array initializers. 

2002-10-03  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (ConstructorInitializer.Emit): simplify code by using
	Invocation.EmitCall, and at the same time, fix the bugs in calling
	parent constructors that took variable arguments. 

	* ecore.cs (Expression.ConvertNumericExplicit,
	Expression.ImplicitNumericConversion): Remove the code that
	manually wrapped decimal (InternalTypeConstructor call is now gone
	as well).

	* expression.cs (Cast.TryReduce): Also handle decimal types when
	trying to perform a constant fold on the type.

	* typemanager.cs (IsUnmanagedtype): Partially implemented.

	* parameter.cs: Removed ResolveAndDefine, as it was not needed, as
	that only turned off an error report, and did nothing else. 

2002-10-02  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Handle and ignore /fullpaths

2002-10-01  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Binary.ResolveOperator): Catch the case where
	DoNumericPromotions returns true, 

	(Binary.DoNumericPromotions): Simplify the code, and the tests.

2002-09-27  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (EventExpr.Emit): Instead of emitting an exception,
	report error 70.

2002-09-26  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (ConvertNumericExplicit): It is not enough that the
	conversion exists, but it is also required that the conversion be
	performed.  This manifested in "(Type64Enum) 2".  

	* class.cs (TypeManager.AddMethod): The fix is not to change
	AddEnum, because that one was using a fully qualified name (every
	DeclSpace derivative does), but to change the AddMethod routine
	that was using an un-namespaced name.  This now correctly reports
	the duplicated name.

	Revert patch until I can properly fix it.  The issue
	is that we have a shared Type space across all namespaces
	currently, which is wrong.

	Options include making the Namespace a DeclSpace, and merge
	current_namespace/current_container in the parser.

2002-09-25  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Improve error reporting when we get a different
	kind of expression in local_variable_type and
	local_variable_pointer_type. 

	Propagate this to avoid missleading errors being reported.

	* ecore.cs (ImplicitReferenceConversion): treat
	TypeManager.value_type as a target just like object_type.   As
	code like this:

	ValueType v = 1;

	Is valid, and needs to result in the int 1 being boxed before it
	is assigned to the value type v.

	* class.cs (TypeContainer.AddEnum): Use the basename, not the name
	to validate the enumeration name.

	* expression.cs (ArrayAccess.EmitAssign): Mimic the same test from
	EmitDynamicInitializers for the criteria to use Ldelema.  Thanks
	to hwang_rob@yahoo.ca for finding the bug and providing a patch.

	* ecore.cs (TryImplicitIntConversion): When doing an
	implicit-enumeration-conversion, check if the type is 64-bits and
	perform a conversion before passing to EnumConstant.

2002-09-23  Miguel de Icaza  <miguel@ximian.com>

	* decl.cs (Error_AmbiguousTypeReference); New routine used to
	report ambiguous type references.  Unlike the MS version, we
	report what the ambiguity is.   Innovation at work ;-)

	(DeclSpace.FindType): Require a location argument to
	display when we display an ambiguous error.

	* ecore.cs: (SimpleName.DoResolveType): Pass location to FindType.

	* interface.cs (GetInterfaceTypeByName): Pass location to FindType.

	* expression.cs (EmitDynamicInitializers): Apply patch from
	hwang_rob@yahoo.ca that fixes the order in which we emit our
	initializers. 

2002-09-21  Martin Baulig  <martin@gnome.org>

	* delegate.cs (Delegate.VerifyApplicability): Make this work if the
	delegate takes no arguments.

2002-09-20  Miguel de Icaza  <miguel@ximian.com>

	* constant.cs: Use Conv_U8 instead of Conv_I8 when loading longs
	from integers.

	* expression.cs: Extract the underlying type.

	* ecore.cs (StoreFromPtr): Use TypeManager.IsEnumType instad of IsEnum

	* decl.cs (FindType): Sorry about this, fixed the type lookup bug.

2002-09-19  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer.DefineType): We can not use the nice
	PackingSize with the size set to 1 DefineType method, because it
	will not allow us to define the interfaces that the struct
	implements.

	This completes the fixing of bug 27287

	* ecore.cs (Expresion.ImplicitReferenceConversion): `class-type S'
	means also structs.  This fixes part of the problem. 
	(Expresion.ImplicitReferenceConversionExists): ditto.

	* decl.cs (DeclSparce.ResolveType): Only report the type-not-found
	error if there were no errors reported during the type lookup
	process, to avoid duplicates or redundant errors.  Without this
	you would get an ambiguous errors plus a type not found.  We have
	beaten the user enough with the first error.  

	(DeclSparce.FindType): Emit a warning if we have an ambiguous
	reference. 

	* ecore.cs (SimpleName.DoResolveType): If an error is emitted
	during the resolution process, stop the lookup, this avoids
	repeated error reports (same error twice).

	* rootcontext.cs: Emit a warning if we have an ambiguous reference.

	* typemanager.cs (LookupType): Redo the type lookup code to match
	the needs of System.Reflection.  

	The issue is that System.Reflection requires references to nested
	types to begin with a "+" sign instead of a dot.  So toplevel
	types look like: "NameSpace.TopLevelClass", and nested ones look
	like "Namespace.TopLevelClass+Nested", with arbitrary nesting
	levels. 

2002-09-19  Martin Baulig  <martin@gnome.org>

	* codegen.cs (EmitContext.EmitTopBlock): If control flow analysis
	says that a method always returns or always throws an exception,
	don't report the CS0161.

	* statement.cs (FlowBranching.UsageVector.MergeChildren): Always
	set `Returns = new_returns'.

2002-09-19  Martin Baulig  <martin@gnome.org>

	* expression.cs (MemberAccess.ResolveMemberAccess): When resolving
	to an enum constant, check for a CS0176.

2002-09-18  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer.CheckPairedOperators): Now we check
	for operators that must be in pairs and report errors.

	* ecore.cs (SimpleName.DoResolveType): During the initial type
	resolution process, when we define types recursively, we must
	check first for types in our current scope before we perform
	lookups in the enclosing scopes.

	* expression.cs (MakeByteBlob): Handle Decimal blobs.

	(Invocation.VerifyArgumentsCompat): Call
	TypeManager.TypeToCoreType on the parameter_type.GetElementType.
	I thought we were supposed to always call this, but there are a
	few places in the code where we dont do it.

2002-09-17  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Add support in -linkres and -resource to specify the
	name of the identifier.

2002-09-16  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (StandardConversionExists): Sync with the conversion
	code: allow anything-* to void* conversions.

	(FindMostSpecificSource): Use an Expression argument
	instead of a Type, because we might be handed over a Literal which
	gets a few more implicit conversions that plain types do not.  So
	this information was being lost.

	Also, we drop the temporary type-holder expression when not
	required.

2002-09-17  Martin Baulig  <martin@gnome.org>

	* class.cs (PropertyBase.CheckBase): Don't check the base class if
	this is an explicit interface implementation.

2002-09-17  Martin Baulig  <martin@gnome.org>

	* class.cs (PropertyBase.CheckBase): Make this work for indexers with
	different `IndexerName' attributes.

	* expression.cs (BaseIndexerAccess): Rewrote this class to use IndexerAccess.
	(IndexerAccess): Added special protected ctor for BaseIndexerAccess and
	virtual CommonResolve().

2002-09-16  Miguel de Icaza  <miguel@ximian.com>

	* enum.cs (LookupEnumValue): Use the EnumConstant declared type,
	and convert that to the UnderlyingType.

	* statement.cs (Foreach.Resolve): Indexers are just like variables
	or PropertyAccesses.

	* cs-tokenizer.cs (consume_string): Track line numbers and columns
	inside quoted strings, we were not doing this before.

2002-09-16  Martin Baulig  <martin@gnome.org>

	* ecore.cs (MethodGroupExpr.DoResolve): If we have an instance expression,
	resolve it.  This is needed for the definite assignment check of the
	instance expression, fixes bug #29846.
	(PropertyExpr.DoResolve, EventExpr.DoResolve): Likewise.

2002-09-16  Nick Drochak  <ndrochak@gol.com>

	* parameter.cs: Fix compile error.  Cannot reference static member
	from an instance object.  Is this an mcs bug?

2002-09-14  Martin Baulig  <martin@gnome.org>

	* decl.cs (MemberCache.SetupCacheForInterface): Don't add an interface
	multiple times.  Fixes bug #30295, added test-166.cs.

2002-09-14  Martin Baulig  <martin@gnome.org>

	* statement.cs (Block.Emit): Don't emit unreachable code.
	(Switch.SimpleSwitchEmit, Switch.TableSwitchEmit): Check for missing
	`break' statements.
	(Goto.Emit, Continue.Emit): Set ec.Breaks = true.

2002-09-14  Martin Baulig  <martin@gnome.org>

	* parameter.cs (Parameter.Attributes): Make this work if Modifier.ISBYREF
	is set.

2002-09-14  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.IsNestedChildOf): This must return false
	if `type == parent' since in this case `type.IsSubclassOf (parent)' will
	be false on the ms runtime.

2002-09-13  Martin Baulig  <martin@gnome.org>

	* ecore.cs (SimpleName.SimpleNameResolve): Include the member name in
	the CS0038 error message.

2002-09-12  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (CheckedExpr, UnCheckedExpr): If we have a
	constant inside, return it.

2002-09-12  Martin Baulig  <martin@gnome.org>

	* cfold.cs (ConstantFold.DoConstantNumericPromotions): Check whether an
	implicit conversion can be done between enum types.

	* enum.cs (Enum.LookupEnumValue): If the value is an EnumConstant,
	check whether an implicit conversion to the current enum's UnderlyingType
	exists and report an error if not.

	* codegen.cs (CodeGen.Init): Delete the symbol file when compiling
	without debugging support.

	* delegate.cs (Delegate.CloseDelegate): Removed, use CloseType instead.
	Fixes bug #30235.  Thanks to Ricardo Fernández Pascual.

2002-09-12  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.IsNestedChildOf): New method.

	* ecore.cs (IMemberExpr.DeclaringType): New property.
	(SimpleName.SimpleNameResolve): Check whether we're accessing a
	nonstatic member of an outer type (CS0038).

2002-09-11  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Activate the using-error detector at warning level
	4 (at least for MS-compatible APIs).

	* namespace.cs (VerifyUsing): Small buglett fix.

	* pending.cs (PendingImplementation): pass the container pointer. 

	* interface.cs (GetMethods): Allow for recursive definition.  Long
	term, I would like to move every type to support recursive
	definitions, not the current ordering mechanism that we have right
	now.

	The situation is this: Attributes are handled before interfaces,
	so we can apply attributes to interfaces.  But some attributes
	implement interfaces, we will now handle the simple cases
	(recursive definitions will just get an error).  

	* parameter.cs: Only invalidate types at the end if we fail to
	lookup all types.  

2002-09-09  Martin Baulig  <martin@gnome.org>

	* ecore.cs (PropertyExpr.Emit): Also check for
	TypeManager.system_int_array_get_length so this'll also work when
	compiling corlib.  Fixes #30003.

2002-09-09  Martin Baulig  <martin@gnome.org>

	* expression.cs (ArrayCreation.MakeByteBlob): Added support for enums
	and throw an exception if we can't get the type's size.  Fixed #30040,
	added test-165.cs.

2002-09-09  Martin Baulig  <martin@gnome.org>

	* ecore.cs (PropertyExpr.DoResolve): Added check for static properies.

	* expression.cs (SizeOf.DoResolve): Sizeof is only allowed in unsafe
	context.  Fixes bug #30027.

	* delegate.cs (NewDelegate.Emit): Use OpCodes.Ldvirtftn for
	virtual functions.  Fixes bug #30043, added test-164.cs.

2002-09-08  Ravi Pratap  <ravi@ximian.com>

	* attribute.cs : Fix a small NullRef crash thanks to my stupidity.

2002-09-08  Nick Drochak  <ndrochak@gol.com>

	* driver.cs: Use an object to get the windows codepage since it's not a
	static property.

2002-09-08  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (For.Emit): for infinite loops (test == null)
	return whether there is a break inside, not always "true".

	* namespace.cs (UsingEntry): New struct to hold the name of the
	using definition, the location where it is defined, and whether it
	has been used in a successful type lookup.
	
	* rootcontext.cs (NamespaceLookup): Use UsingEntries instead of
	strings.

	* decl.cs: ditto.

2002-09-06  Ravi Pratap  <ravi@ximian.com>

	* attribute.cs : Fix incorrect code which relied on catching
	a NullReferenceException to detect a null being passed in
	where an object was expected.

2002-09-06  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Try): flag the catch variable as assigned

	* expression.cs (Cast): Simplified by using ResolveType instead of
	manually resolving.

	* statement.cs (Catch): Fix bug by using ResolveType.

2002-09-06  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (BetterConversion): Special case for when we have
	a NullLiteral as the argument and we have to choose between string
	and object types - we choose string the way csc does.

	* attribute.cs (Attribute.Resolve): Catch the
	NullReferenceException and report error #182 since the Mono
	runtime no more has the bug and having this exception raised means
	we tried to select a constructor which takes an object and is
	passed a null.

2002-09-05  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Invocation.OverloadResolve): Flag a nicer error
	message (1502, 1503) when we can't locate a method after overload
	resolution. This is much more informative and closes the bug
	Miguel reported.

	* interface.cs (PopulateMethod): Return if there are no argument
	types. Fixes a NullReferenceException bug.

	* attribute.cs (Attribute.Resolve): Ensure we allow TypeOf
	expressions too. Previously we were checking only in one place for
	positional arguments leaving out named arguments.

	* ecore.cs (ImplicitNumericConversion): Conversion from underlying
	type to the enum type is not allowed. Remove code corresponding to
	that.

	(ConvertNumericExplicit): Allow explicit conversions from
	the underlying type to enum type. This precisely follows the spec
	and closes a bug filed by Gonzalo.
	
2002-09-04  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* compiler.csproj:
	* compiler.csproj.user: patch from Adam Chester (achester@bigpond.com).

2002-09-03  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (SwitchLabel.ResolveAndReduce): In the string case,
	it was important that we stored the right value after the
	reduction in `converted'.

2002-09-04  Martin Baulig  <martin@gnome.org>

	* location.cs (Location.SymbolDocument): Use full pathnames for the
	source files.

2002-08-30  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ComposedCast): Use DeclSparce.ResolveType instead
	of the expression resolve mechanism, because that will catch the
	SimpleName error failures.

	(Conditional): If we can not resolve the
	expression, return, do not crash.

2002-08-29  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* cs-tokenizer.cs:
	(location): display token name instead of its number.

2002-08-28  Martin Baulig  <martin@gnome.org>

	* expression.cs (Binary.ResolveOperator): Don't silently return
	but return an error if an operator cannot be applied between two
	enum types.

2002-08-28  Martin Baulig  <martin@gnome.org>

	* class.cs (Constructor.Define): Set the permission attributes
	correctly instead of making all constructors public.

2002-08-28  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.DoResolve): Do a TypeManager.MemberLook
	for private members before reporting a CS0103; if we find anything,
	it's a CS0122.

2002-08-28  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.FilterWithClosure): It's not enough
	to check whether `closure_start_type == closure_invocation_type',
	we also need to check whether `m.DeclaringType == closure_invocation_type'
	before bypassing the permission checks.  We might be accessing
	protected/private members from the base class.
	(TypeManager.RealMemberLookup): Only set private_ok if private
	members were requested via BindingFlags.NonPublic.

	* ecore.cs (MethodGroupExpr.IsExplicitImpl): New property.

	* expression.cs (MemberAccess.ResolveMemberAccess): Set
	MethodGroupExpr.IsExplicitImpl if appropriate.
	(Invocation.DoResolve): Don't report the CS0120 for explicit
	interface implementations.

2002-08-27  Martin Baulig  <martin@gnome.org>

	* expression.cs (Invocation.DoResolve): If this is a static
	method and we don't have an InstanceExpression, we must report
	a CS0120.

2002-08-25  Martin Baulig  <martin@gnome.org>

	* expression.cs (Binary.ResolveOperator): Don't allow `!=' and
	`==' between a valuetype and an object.

2002-08-25  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (TypeExpr): Provide a ToString method.

2002-08-24  Martin Baulig  <martin@gnome.org>

	* codegen.cs (CodeGen.InitMonoSymbolWriter): The symbol file is
	now called proggie.dbg and it's a binary file.

2002-08-23  Martin Baulig  <martin@gnome.org>

	* decl.cs (MemberCache.AddMethods): Ignore varargs methods.

2002-08-23  Martin Baulig  <martin@gnome.org>

	* struct.cs (MyStructInfo.ctor): Make this work with empty
	structs; it's not allowed to use foreach() on null.

2002-08-23  Martin Baulig  <martin@gnome.org>

	* codegen.cs (CodeGen.InitMonoSymbolWriter): Tell the symbol
	writer the full pathname of the generated assembly.

2002-08-23  Martin Baulig  <martin@gnome.org>

	* statements.cs (FlowBranching.UsageVector.MergeChildren):
	A `finally' block never returns or breaks; improved handling of
	unreachable code.

2002-08-23  Martin Baulig  <martin@gnome.org>

	* statement.cs (Throw.Resolve): Allow `throw null'.

2002-08-23  Martin Baulig  <martin@gnome.org>

	* expression.cs (MemberAccess.ResolveMemberAccess): If this is an
	EventExpr, don't do a DeclaredOnly MemberLookup, but check whether
	`ee.EventInfo.DeclaringType == ec.ContainerType'.  The
	MemberLookup would return a wrong event if this is an explicit
	interface implementation and the class has an event with the same
	name.

2002-08-23  Martin Baulig  <martin@gnome.org>

	* statement.cs (Block.AddChildVariableNames): New public method.
	(Block.AddChildVariableName): Likewise.
	(Block.IsVariableNameUsedInChildBlock): Likewise.
	(Block.AddVariable): Check whether a variable name has already
	been used in a child block.

	* cs-parser.jay (declare_local_variables): Mark all variable names
	from the current block as being used in a child block in the
	implicit block.

2002-08-23  Martin Baulig  <martin@gnome.org>

	* codegen.cs (CodeGen.InitializeSymbolWriter): Abort if we can't
	find the symbol writer.

	* driver.cs: csc also allows the arguments to /define being
	separated by commas, not only by semicolons.

2002-08-23  Martin Baulig  <martin@gnome.org>

	* interface.cs (Interface.GetMembers): Added static check for events.

2002-08-15  Martin Baulig  <martin@gnome.org>

	* class.cs (MethodData.EmitDestructor): In the Expression.MemberLookup
	call, use ec.ContainerType.BaseType as queried_type and invocation_type.

	* ecore.cs (Expression.MemberLookup): Added documentation and explained
	why the MethodData.EmitDestructor() change was necessary.

2002-08-20  Martin Baulig  <martin@gnome.org>

	* class.cs (TypeContainer.FindMembers): Added static check for events.

	* decl.cs (MemberCache.AddMembers): Handle events like normal members.

	* typemanager.cs (TypeHandle.GetMembers): When queried for events only,
	use Type.GetEvents(), not Type.FindMembers().

2002-08-20  Martin Baulig  <martin@gnome.org>

	* decl.cs (MemberCache): Added a special method cache which will
	be used for method-only searched.  This ensures that a method
	search will return a MethodInfo with the correct ReflectedType for
	inherited methods.	

2002-08-20  Martin Baulig  <martin@gnome.org>

	* decl.cs (DeclSpace.FindMembers): Made this public.

2002-08-20  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* delegate.cs: fixed build on windows.
	[FIXME:  Filed as bug #29150: MCS must report these errors.]

2002-08-19  Ravi Pratap  <ravi@ximian.com>

	* ecore.cs (StandardConversionExists): Return a false
	if we are trying to convert the void type to anything else
	since that is not allowed.

	* delegate.cs (DelegateInvocation.DoResolve): Ensure that
	we flag error 70 in the event an event is trying to be accessed
	directly from outside the declaring type.

2002-08-20  Martin Baulig  <martin@gnome.org>

	* typemanager.cs, decl.cs: Moved MemberList, IMemberContainer and
	MemberCache from typemanager.cs to decl.cs.

2002-08-19  Martin Baulig  <martin@gnome.org>

	* class.cs (TypeContainer): Implement IMemberContainer.
	(TypeContainer.DefineMembers): Create the MemberCache.
	(TypeContainer.FindMembers): Do better BindingFlags checking; only
	return public members if BindingFlags.Public was given, check
	whether members are static.

2002-08-16  Martin Baulig  <martin@gnome.org>

	* decl.cs (DeclSpace.Define): Splitted this in Define and
	DefineMembers.  DefineMembers is called first and initializes the
	MemberCache.

	* rootcontext.cs (RootContext.DefineMembers): New function.  Calls
	DefineMembers() on all our DeclSpaces.

	* class.cs (TypeContainer.Define): Moved all code to DefineMembers(),
	but call DefineMembers() on all nested interfaces.  We call their
	Define() in our new Define() function.

	* interface.cs (Interface): Implement IMemberContainer.
	(Interface.Define): Moved all code except the attribute stuf to
	DefineMembers().
	(Interface.DefineMembers): Initialize the member cache.

	* typemanager.cs (IMemberFinder): Removed this interface, we don't
	need this anymore since we can use MemberCache.FindMembers directly.

2002-08-19  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (MemberCache): When creating the cache for an
	interface type, add all inherited members.
	(TypeManager.MemberLookup_FindMembers): Changed `ref bool searching'
	to `out bool used_cache' and documented it.
	(TypeManager.MemberLookup): If we already used the cache in the first
	iteration, we don't need to do the interfaces check.

2002-08-19  Martin Baulig  <martin@gnome.org>

	* decl.cs (DeclSpace.FindMembers): New abstract method.  Moved this
	here from IMemberFinder and don't implement this interface anymore.
	(DeclSpace.MemberCache): Moved here from IMemberFinder.

	* typemanager.cs (IMemberFinder): This interface is now only used by
	classes which actually support the member cache.
	(TypeManager.builder_to_member_finder): Renamed to builder_to_declspace
	since we only put DeclSpaces into this Hashtable.
	(MemberLookup_FindMembers): Use `builder_to_declspace' if the type is
	a dynamic type and TypeHandle.GetTypeHandle() otherwise.

2002-08-16  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (ICachingMemberFinder): Removed.
	(IMemberFinder.MemberCache): New property.
	(TypeManager.FindMembers): Merged this with RealFindMembers().
	This function will never be called from TypeManager.MemberLookup()
	so we can't use the cache here, just the IMemberFinder.
	(TypeManager.MemberLookup_FindMembers): Check whether the
	IMemberFinder has a MemberCache and call the cache's FindMembers
	function.
	(MemberCache): Rewrote larger parts of this yet another time and
	cleaned it up a bit.

2002-08-15  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs (LoadArgs): Support quoting.

	(Usage): Show the CSC-like command line arguments.

	Improved a few error messages.

2002-08-15  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (IMemberContainer.Type): New property.
	(IMemberContainer.IsInterface): New property.

	The following changes are conditional to BROKEN_RUNTIME, which is
	defined at the top of the file.

	* typemanager.cs (MemberCache.MemberCache): Don't add the base
	class'es members, but add all members from TypeHandle.ObjectType
	if we're an interface.
	(MemberCache.AddMembers): Set the Declared flag if member.DeclaringType
	is the current type.
	(MemberCache.CacheEntry.Container): Removed this field.
	(TypeHandle.GetMembers): Include inherited members.

2002-08-14  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* typemanager.cs: fixed compilation and added a comment on a field that
	is never used.

2002-08-15  Martin Baulig  <martin@gnome.org>

	* class.cs (ConstructorInitializer.Resolve): In the
	Expression.MemberLookup call, use the queried_type as
	invocation_type.

	* typemanager.cs (IMemberContainer.GetMembers): Removed the `bool
	declared' attribute, it's always true.
	(IMemberContainer.Parent, IMemberContainer.Name): New properties.
	(TypeManager.MemberLookup_FindMembers): [FIXME FIXME FIXME] Added
	temporary wrapper for FindMembers which tells MemberLookup whether
	members from the base classes are included in the return value.
	This will go away soon.
	(TypeManager.MemberLookup): Use this temporary hack here; once the
	new MemberCache is completed, we don't need to do the DeclaredOnly
	looping here anymore since the MemberCache will take care of this.
	(TypeManager.IsSubclassOrNestedChildOf): Allow `type == parent'.
	(MemberCache): When creating the MemberCache for a class, get
	members from the current class and all its base classes.
	(MemberCache.CacheEntry.Container): New field.  This is a
	temporary hack until the Mono runtime is fixed to distinguish
	between ReflectedType and DeclaringType.  It allows us to use MCS
	with both the MS runtime and the unfixed Mono runtime without
	problems and without accecting performance.
	(MemberCache.SearchMembers): The DeclaredOnly looping from
	TypeManager.MemberLookup is now done here.	

2002-08-14  Martin Baulig  <martin@gnome.org>

	* statement.cs (MyStructInfo.MyStructInfo): Don't call
	Type.GetFields on dynamic types but get the fields from the
	corresponding TypeContainer.
	(MyStructInfo.GetStructInfo): Added check for enum types.

	* typemanager.cs (MemberList.IsSynchronized): Implemented.
	(MemberList.SyncRoot): Implemented.
	(TypeManager.FilterWithClosure): No need to check permissions if
	closure_start_type == closure_invocation_type, don't crash if
	closure_invocation_type is null.

2002-08-13  Martin Baulig  <martin@gnome.org>

	Rewrote TypeContainer.FindMembers to use a member cache.  This
	gives us a speed increase of about 35% for the self-hosting MCS
	build and of about 15-20% for the class libs (both on GNU/Linux).

	* report.cs (Timer): New class to get enhanced profiling.  This
	whole class is "TIMER" conditional since it remarkably slows down
	compilation speed.

	* class.cs (MemberList): New class.  This is an IList wrapper
	which we're now using instead of passing MemberInfo[]'s around to
	avoid copying this array unnecessarily.
	(IMemberFinder.FindMember): Return a MemberList, not a MemberInfo [].
	(ICachingMemberFinder, IMemberContainer): New interface.
	(TypeManager.FilterWithClosure): If `criteria' is null, the name
	has already been checked, otherwise use it for the name comparision.
	(TypeManager.FindMembers): Renamed to RealMemberFinder and
	provided wrapper which tries to use ICachingMemberFinder.FindMembers
	if possible.  Returns a MemberList, not a MemberInfo [].
	(TypeHandle): New class, implements IMemberContainer.  We create
	one instance of this class per type, it contains a MemberCache
	which is used to do the member lookups.
	(MemberCache): New class.  Each instance of this class contains
	all members of a type and a name-based hash table.
	(MemberCache.FindMembers): This is our new member lookup
	function.  First, it looks up all members of the requested name in
	the hash table.  Then, it walks this list and sorts out all
	applicable members and returns them.

2002-08-13  Martin Baulig  <martin@gnome.org>

	In addition to a nice code cleanup, this gives us a performance
	increase of about 1.4% on GNU/Linux - not much, but it's already
	half a second for the self-hosting MCS compilation.

	* typemanager.cs (IMemberFinder): New interface.  It is used by
	TypeManager.FindMembers to call FindMembers on a TypeContainer,
	Enum, Delegate or Interface.
	(TypeManager.finder_to_member_finder): New PtrHashtable.
	(TypeManager.finder_to_container): Removed.
	(TypeManager.finder_to_delegate): Removed.
	(TypeManager.finder_to_interface): Removed.
	(TypeManager.finder_to_enum): Removed.

	* interface.cs (Interface): Implement IMemberFinder.

	* delegate.cs (Delegate): Implement IMemberFinder.

	* enum.cs (Enum): Implement IMemberFinder.

	* class.cs (TypeContainer): Implement IMemberFinder.

2002-08-12  Martin Baulig  <martin@gnome.org>

	* ecore.cs (TypeExpr.DoResolveType): Mark this as virtual.

2002-08-12  Martin Baulig  <martin@gnome.org>

	* ecore.cs (ITypeExpression): New interface for expressions which
	resolve to a type.
	(TypeExpression): Renamed to TypeLookupExpression.
	(Expression.DoResolve): If we're doing a types-only lookup, the
	expression must implement the ITypeExpression interface and we
	call DoResolveType() on it.
	(SimpleName): Implement the new ITypeExpression interface.
	(SimpleName.SimpleNameResolve): Removed the ec.OnlyLookupTypes
	hack, the situation that we're only looking up types can't happen
	anymore when this method is called.  Moved the type lookup code to
	DoResolveType() and call it.
	(SimpleName.DoResolveType): This ITypeExpression interface method
	is now doing the types-only lookup.
	(TypeExpr, TypeLookupExpression): Implement ITypeExpression.
	(ResolveFlags): Added MaskExprClass.

	* expression.cs (MemberAccess): Implement the ITypeExpression
	interface.
	(MemberAccess.DoResolve): Added support for a types-only lookup
	when we're called via ITypeExpression.DoResolveType().
	(ComposedCast): Implement the ITypeExpression interface.

	* codegen.cs (EmitContext.OnlyLookupTypes): Removed.  Call
	Expression.Resolve() with ResolveFlags.Type instead.

2002-08-12  Martin Baulig  <martin@gnome.org>

	* interface.cs (Interface.Define): Apply attributes.

	* attribute.cs (Attribute.ApplyAttributes): Added support for
	interface attributes.

2002-08-11  Martin Baulig  <martin@gnome.org>

	* statement.cs (Block.Emit): Only check the "this" variable if we
	do not always throw an exception.

	* ecore.cs (PropertyExpr.DoResolveLValue): Implemented, check
	whether the property has a set accessor.

2002-08-11  Martin Baulig  <martin@gnome.org>

	Added control flow analysis support for structs.

	* ecore.cs (ResolveFlags): Added `DisableFlowAnalysis' to resolve
	with control flow analysis turned off.
	(IVariable): New interface.
	(SimpleName.SimpleNameResolve): If MemberAccess.ResolveMemberAccess
	returns an IMemberExpr, call DoResolve/DoResolveLValue on it.
	(FieldExpr.DoResolve): Resolve the instance expression with flow
	analysis turned off and do the definite assignment check after the
	resolving when we know what the expression will resolve to.

	* expression.cs (LocalVariableReference, ParameterReference):
	Implement the new IVariable interface, only call the flow analysis
	code if ec.DoFlowAnalysis is true.
	(This): Added constructor which takes a Block argument.  Implement
	the new IVariable interface.
	(MemberAccess.DoResolve, MemberAccess.DoResolveLValue): Call
	DoResolve/DoResolveLValue on the result of ResolveMemberLookup().
	This does the definite assignment checks for struct members.

	* class.cs (Constructor.Emit): If this is a non-static `struct'
	constructor which doesn't have any initializer, call
	Block.AddThisVariable() to tell the flow analysis code that all
	struct elements must be initialized before control returns from
	the constructor.

	* statement.cs (MyStructInfo): New public class.
	(UsageVector.this [VariableInfo vi]): Added `int field_idx'
	argument to this indexer.  If non-zero, check an individual struct
	member, not the whole struct.
	(FlowBranching.CheckOutParameters): Check struct members.
	(FlowBranching.IsVariableAssigned, SetVariableAssigned): Added
	overloaded versions of these methods which take an additional
	`int field_idx' argument to check struct members.
	(FlowBranching.IsParameterAssigned, SetParameterAssigned): Added
	overloaded versions of these methods which take an additional
	`string field_name' argument to check struct member.s
	(VariableInfo): Implement the IVariable interface.
	(VariableInfo.StructInfo): New public property.  Returns the
	MyStructInfo instance of the variable if it's a struct or null.
	(Block.AddThisVariable): New public method.  This is called from
	Constructor.Emit() for non-static `struct' constructor which do
	not have any initializer.  It creates a special variable for the
	"this" instance variable which will be checked by the flow
	analysis code to ensure that all of the struct's fields are
	initialized before control returns from the constructor.
	(UsageVector): Added support for struct members.  If a
	variable/parameter is a struct with N members, we reserve a slot
	in the usage vector for each member.  A struct is considered fully
	initialized if either the struct itself (slot 0) or all its
	members are initialized.

2002-08-08  Martin Baulig  <martin@gnome.org>

	* driver.cs (Driver.MainDriver): Only report an error CS5001
	if there were no compilation errors.

	* codegen.cs (EmitContext.EmitContext): Use the DeclSpace's
	`UnsafeContext' property to determine whether the parent is in
	unsafe context rather than checking the parent's ModFlags:
	classes nested in an unsafe class are unsafe as well.

2002-08-08  Martin Baulig  <martin@gnome.org>

	* statement.cs (UsageVector.MergeChildren): Distinguish between
	`Breaks' and `Returns' everywhere, don't set `Breaks' anymore if
	we return.  Added test17() and test18() to test-154.cs.

2002-08-08  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.FilterWithClosure): If we have
	Family access, make sure the invoking type isn't a subclass of the
	queried type (that'd be a CS1540).

	* ecore.cs (Expression.MemberLookup): Added overloaded version of
	this method which takes an additional `Type invocation_type'.

	* expression.cs (BaseAccess.DoResolve): Use the base type as
	invocation and query type.
	(MemberAccess.DoResolve): If the lookup failed and we're about to
	report a CS0122, try a lookup with the ec.ContainerType - if this
	succeeds, we must report a CS1540.

2002-08-08  Martin Baulig  <martin@gnome.org>

	* ecore.cs (IMemberExpr): Added `bool IsInstance' property.
	(MethodGroupExpr): Implement the IMemberExpr interface.

	* expression (MemberAccess.ResolveMemberAccess): No need to have
	any special code for MethodGroupExprs anymore, they're now
	IMemberExprs.	

2002-08-08  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.FilterWithClosure): Check Assembly,
	Family, FamANDAssem and FamORAssem permissions.
	(TypeManager.IsSubclassOrNestedChildOf): New public method.

2002-08-08  Martin Baulig  <martin@gnome.org>

	* statement.cs (FlowBranchingType): Added LOOP_BLOCK.
	(UsageVector.MergeChildren): `break' breaks unless we're in a switch
	or loop block.

Thu Aug 8 10:28:07 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* driver.cs: implemented /resource option to embed managed resources.

2002-08-07  Martin Baulig  <martin@gnome.org>

	* class.cs (FieldBase.Initializer): Renamed to `init' and made private.
	(FieldBase.HasFieldInitializer): New public property.
	(FieldBase.GetInitializerExpression): New public method.  Resolves and
	returns the field initializer and makes sure it is only resolved once.
	(TypeContainer.EmitFieldInitializers): Call
	FieldBase.GetInitializerExpression to get the initializer, this ensures
	that it isn't resolved multiple times.

	* codegen.cs (EmitContext): Added `bool IsFieldInitialier'.  This tells
	the resolving process (SimpleName/MemberLookup) that we're currently
	emitting a field initializer (which must not access any instance members,
	this is an error CS0236).

	* ecore.cs (SimpleName.Error_ObjectRefRequired): Added EmitContext
	argument, if the `IsFieldInitializer' flag is set, we must report and
	error CS0236 and not an error CS0120.	

2002-08-07  Martin Baulig  <martin@gnome.org>

	* ecore.cs (IMemberExpr): New public interface.
	(FieldExpr, PropertyExpr, EventExpr): Implement IMemberExpr.
	(SimpleName.SimpleNameResolve): Call MemberAccess.ResolveMemberAccess
	if the expression is an IMemberExpr.

	* expression.cs (MemberAccess.ResolveMemberAccess): Allow `left'
	to be null, implicitly default to `this' if we're non-static in
	this case.  Simplified the code a lot by using the new IMemberExpr
	interface.  Also fixed bug #28176 here.

2002-08-06  Martin Baulig  <martin@gnome.org>

	* cs-parser.jay (SimpleLookup): Removed.  We need to create
	ParameterReferences during semantic analysis so that we can do a
	type-only search when resolving Cast, TypeOf and SizeOf.
	(block): Pass the `current_local_parameters' to the Block's
	constructor.

	* class.cs (ConstructorInitializer): Added `Parameters parameters'
	argument to the constructor.
	(ConstructorInitializer.Resolve): Create a temporary implicit
	block with the parameters.

	* ecore.cs (SimpleName.SimpleNameResolve): Resolve parameter
	references here if we aren't doing a type-only search.

	* statement.cs (Block): Added constructor which takes a
	`Parameters parameters' argument.
	(Block.Parameters): New public property.

	* support.cs (InternalParameters.Parameters): Renamed `parameters'
	to `Parameters' and made it public readonly.

2002-08-06  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.Warning): Made this public as well.

	* report.cs (Report.Debug): Print the contents of collections.

2002-08-06  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.ResolveFlags): New [Flags] enum.  This is
	used to tell Resolve() which kinds of expressions it may return.
	(Expression.Resolve): Added overloaded version of this method which
	takes a `ResolveFlags flags' argument.  This can be used to tell
	Resolve() which kinds of expressions it may return.  Reports a
	CS0118 on error.
	(Expression.ResolveWithSimpleName): Removed, use Resolve() with
	ResolveFlags.SimpleName.
	(Expression.Error118): Added overloaded version of this method which
	takes a `ResolveFlags flags' argument.  It uses the flags to determine
	which kinds of expressions are allowed.

	* expression.cs (Argument.ResolveMethodGroup): New public method.
	Resolves an argument, but allows a MethodGroup to be returned.
	This is used when invoking a delegate.

	* TODO: Updated a bit.

2002-08-06  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	Fixed compilation with csc.

	* ecore.cs: Expression.Error made public. Is this correct? Should
	Warning be made public too?

	* expression.cs: use ea.Location instead of ea.loc.
	[FIXME:  Filed as bug #28607: MCS must report these errors.]

2002-08-06  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.loc): Moved the location here instead of
	duplicating it in all derived classes.
	(Expression.Location): New public property.
	(Expression.Error, Expression.Warning): Made them non-static and
	removed the location argument.
	(Expression.Warning): Added overloaded version which takes an
	`int level' argument.
	(Expression.Error118): Make this non-static and removed the
	expression and location arguments.
	(TypeExpr): Added location argument to the constructor.

	* expression.cs (StaticCallExpr): Added location argument to
	the constructor.
	(Indirection, PointerArithmetic): Likewise.
	(CheckedExpr, UnCheckedExpr): Likewise.
	(ArrayAccess, IndexerAccess, UserCast, ArrayPtr): Likewise.
	(StringPtr): Likewise.


2002-08-05  Martin Baulig  <martin@gnome.org>

	* expression.cs (BaseAccess.DoResolve): Actually report errors.

	* assign.cs (Assign.DoResolve): Check whether the source
	expression is a value or variable.

	* statement.cs (Try.Resolve): Set ec.InTry/InCatch/InFinally
	while resolving the corresponding blocks.

	* interface.cs (Interface.GetInterfaceTypeByName): Actually report
	an error, don't silently return null.

	* statement.cs (Block.AddVariable): Do the error reporting here
	and distinguish between CS0128 and CS0136.
	(Block.DoResolve): Report all unused labels (warning CS0164).
	(LabeledStatement): Pass the location to the constructor.
	(LabeledStatement.HasBeenReferenced): New property.
	(LabeledStatement.Resolve): Set it to true here.

	* statement.cs (Return.Emit): Return success even after reporting
	a type mismatch error (CS0126 or CS0127), this is what csc does and
	it avoids confusing the users with any consecutive errors.

2002-08-05  Martin Baulig  <martin@gnome.org>

	* enum.cs (Enum.LookupEnumValue): Catch circular definitions.

	* const.cs (Const.LookupConstantValue): Catch circular definitions.

	* expression.cs (MemberAccess.DoResolve): Silently return if an
	error has already been reported.

	* ecore.cs (Expression.MemberLookupFinal): Silently return if an
	error has already been reported.

2002-08-05  Martin Baulig  <martin@gnome.org>

	* statement.cs (UsageVector): Only initialize the `parameters'
	vector if we actually have any "out" parameters.

2002-08-05  Martin Baulig  <martin@gnome.org>

	* expression.cs (Binary.ResolveOperator): When combining delegates,
	they must have the same type.

2002-08-05  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.GetArgumentTypes): Don't call
	PropertyInfo.GetIndexParameters() on dynamic types, this doesn't
	work with the ms runtime and we also don't need it: if we're a
	PropertyBuilder and not in the `indexer_arguments' hash, then we
	are a property and not an indexer.

	* class.cs (TypeContainer.AsAccessible): Use Type.IsArray,
	Type.IsPointer and Type.IsByRef instead of Type.HasElementType
	since the latter one doesn't work with the ms runtime.

2002-08-03  Martin Baulig  <martin@gnome.org>

	Fixed bugs #27998 and #22735.

	* class.cs (Method.IsOperator): New public field.
	(Method.CheckBase): Report CS0111 if there's already a method
	with the same parameters in the current class.  Report CS0508 when
	attempting to change the return type of an inherited method.
	(MethodData.Emit): Report CS0179 if a method doesn't have a body
	and it's not marked abstract or extern.
	(PropertyBase): New abstract base class for Property and Indexer.
	(PropertyBase.CheckBase): Moved here from Property and made it work
	for indexers.
	(PropertyBase.Emit): Moved here from Property.Emit, Indexer.Emit is
	the same so we can reuse it there.
	(Property, Indexer): Derive from PropertyBase.
	(MethodSignature.inheritable_property_signature_filter): New delegate
	to find properties and indexers.

	* decl.cs (MemberCore.CheckMethodAgainstBase): Added `string name'
	argument and improved error reporting.

	* parameter.cs (Parameters.GetEmptyReadOnlyParameters): Renamed to
	EmptyReadOnlyParameters and made it a property.

	* typemanager.cs (TypeManager.GetArgumentTypes): Added overloaded
	version of this method which takes a `PropertyInfo indexer'.
	(TypeManager.RegisterIndexer): New method.

	* class.cs: Added myself as author of this file :-)

2002-08-03  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* class.cs: fixed compilation on windoze.

2002-08-03  Martin Baulig  <martin@gnome.org>

	* interface.cs (Interface.GetInterfaceBases): Check whether all
	base interfaces are at least as accessible than the current one.

	* class.cs (TypeContainer.GetClassBases): Check whether base types
	are at least as accessible than the current type.
	(TypeContainer.AsAccessible): Implemented and made non-static.
	(MemberBase.CheckParameters): Report errors if the accessibility
	checks fail.

	* delegate.cs (Delegate.Delegate): The default visibility is
	internal for top-level types and private for nested types.
	(Delegate.Define): Report errors if the accessibility checks fail.

	* enum.cs (Enum.Enum): The default visibility is internal for
	top-level types and private for nested types.
	(Enum.DefineType): Compute the correct visibility.

	* modifiers.cs (Modifiers.TypeAttr): Added a version of this
	function which takes a `bool is_toplevel' instead of a TypeContainer.

	* typemanager.cs (TypeManager.IsBuiltinType): `void' is also a
	builtin type.

2002-08-02  Martin Baulig  <martin@gnome.org>

	* expression.cs (LocalVariableReferenc): Added constructor which
	takes additional `VariableInfo vi' and `bool is_readonly' arguments.
	(LocalVariableReference.IsReadOnly): New property.
	(LocalVariableReference.DoResolveLValue): Report a CS1604 if the
	variable is readonly, use our own readonly flag to do this; you can
	use the new constructor to get a writable reference to a read-only
	variable.

	* cs-parser.jay (foreach_statement, using_statement): Get a writable
	reference to the local variable.

2002-08-01  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs (ResolveCore): Also include System.Exception

	* statement.cs (Block.Emit): Do not emit the dead-code warnings if
	we reach an EmptyStatement.

	(Catch.DoResolve, Throw.DoResolve): Throwing the System.Exception
	is also fine.

	* expression.cs (Binary.ResolveOperator): Check error result in
	two places.

	use brtrue/brfalse directly and avoid compares to null.

2002-08-02  Martin Baulig  <martin@gnome.org>

	* class.cs (TypeContainer.Define): Define all nested interfaces here.
	Fixes bug #28407, added test-155.cs.

2002-08-01  Martin Baulig  <martin@gnome.org>

	* class.cs (Event.EmitDefaultMethod): Make this work with static
	events.  Fixes #28311, added verify-3.cs.

2002-08-01  Martin Baulig  <martin@gnome.org>

	* statement.cs (ForeachHelperMethods): Added `enumerator_type' and
	`is_disposable' fields.
	(Foreach.GetEnumeratorFilter): Set `hm.enumerator_type' and
	`hm.is_disposable' if we're using the collection pattern.
	(Foreach.EmitCollectionForeach): Use the correct type for the
	enumerator's local variable, only emit the try/finally block if
	necessary (fixes #27713).

2002-08-01  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.report118): Renamed to Error118 and made
	it public static.

	* statement.cs (Throw.Resolve): Check whether the expression is of
	the correct type (CS0118) and whether the type derives from
	System.Exception (CS0155).
	(Catch.Resolve): New method.  Do the type lookup here and check
	whether it derives from System.Exception (CS0155).
	(Catch.CatchType, Catch.IsGeneral): New public properties.

	* typemanager.cs (TypeManager.exception_type): Added.

2002-07-31  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Updated About function.

2002-07-31  Martin Baulig  <martin@gnome.org>

	Implemented Control Flow Analysis.

	* codegen.cs (EmitContext.DoFlowAnalysis): New public variable.
	(EmitContext.CurrentBranching): Added.
	(EmitContext.StartFlowBranching): Added.
	(EmitContext.EndFlowBranching): Added.
	(EmitContext.KillFlowBranching): Added.
	(EmitContext.IsVariableAssigned): Added.
	(EmitContext.SetVariableAssigned): Added.
	(EmitContext.IsParameterAssigned): Added.
	(EmitContext.SetParameterAssigned): Added.
	(EmitContext.EmitTopBlock): Added `InternalParameters ip' argument.
	Added control flow analysis stuff here.

	* expression.cs (Unary.DoResolve): If the operator is Oper.AddressOf,
	resolve the expression as lvalue.
	(LocalVariableReference.DoResolve): Check whether the variable has
	already been assigned.
	(ParameterReference.DoResolveLValue): Override lvalue resolve to mark
	the parameter as assigned here.
	(ParameterReference.DoResolve): Check whether the parameter has already
	been assigned.
	(Argument.Resolve): If it's a `ref' or `out' argument, resolve the
	expression as lvalue.

	* statement.cs (FlowBranching): New class for the flow analysis code.
	(Goto): Resolve the label in Resolve, not in Emit; added flow analysis.
	(LabeledStatement.IsDefined): New public property.
	(LabeledStatement.AddUsageVector): New public method to tell flow
	analyis that the label may be reached via a forward jump.
	(GotoCase): Lookup and resolve the label in Resolve, not in Emit; added
	flow analysis.
	(VariableInfo.Number): New public field.  This is used by flow analysis
	to number all locals of a block.
	(Block.CountVariables): New public property.  This is the number of
	local variables in this block (including the locals from all parent
	blocks).
	(Block.EmitMeta): Number all the variables.

	* statement.cs: Added flow analysis support to all classes.

2002-07-31  Martin Baulig  <martin@gnome.org>

	* driver.cs: Added "--mcs-debug" argument if MCS_DEBUG is defined.
	To get debugging messages, compile mcs with /define:MCS_DEBUG and
	then use this argument.

	* report.cs (Report.Debug): Renamed to conditional to "MCS_DEBUG".

	* makefile.gnu (MCS_FLAGS): Include $(MCS_DEFINES), the user may
	use this to specify /define options.

2002-07-29  Martin Baulig  <martin@gnome.org>

	* statement.cs (Fixed): Moved all code that does variable lookups
	and resolvings from Emit to Resolve.

	* statement.cs (For): Moved all code that does variable lookups
	and resolvings from Emit to Resolve.

	* statement.cs (Using): Moved all code that does variable lookups
	and resolvings from Emit to Resolve.

2002-07-29  Martin Baulig  <martin@gnome.org>

	* attribute.cs (Attribute.Resolve): Explicitly catch a
	System.NullReferenceException when creating the
	CustromAttributeBuilder and report a different warning message.

2002-07-29  Martin Baulig  <martin@gnome.org>

	* support.cs (ParameterData.ParameterName): Added method to
	get the name of a parameter.

	* typemanager.cs (TypeManager.IsValueType): New public method.

2002-07-29  Martin Baulig  <martin@gnome.org>

	* parameter.cs (Parameter.Modifier): Added `ISBYREF = 8'.  This
	is a flag which specifies that it's either ref or out.
	(Parameter.GetParameterInfo (DeclSpace, int, out bool)): Changed
	the out parameter to `out Parameter.Modifier mod', also set the
	Parameter.Modifier.ISBYREF flag on it if it's either ref or out.

	* support.cs (InternalParameters.ParameterModifier): Distinguish
	between Parameter.Modifier.OUT and Parameter.Modifier.REF, set the
	Parameter.Modifier.ISBYREF flag if it's either ref or out.

	* expression.cs (Argument.GetParameterModifier): Distinguish
	between Parameter.Modifier.OUT and Parameter.Modifier.REF, set the
	Parameter.Modifier.ISBYREF flag if it's either ref or out.

2002-07-29  Martin Baulig  <martin@gnome.org>

	* expression.cs (ParameterReference.ParameterReference): Added
	`Location loc' argument to the constructor.

	* cs-parser.jay: Pass location to ParameterReference.

2002-07-28  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Try): Initialize the location.

	* cs-parser.jay: pass location to Try.

	* expression.cs (Unary.Reduce): Change the prototype to return
	whether a constant fold could be performed or not.  The result is
	returned in an out parameters.  In the case of Indirection and
	AddressOf, we want to perform the full tests.

2002-07-26  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Statement.Emit): Flag dead code.

2002-07-27  Andrew Birkett  <andy@nobugs.org>

	* expression.cs (Unary.Reduce): Handle AddressOf and Indirection.

2002-07-27  Martin Baulig  <martin@gnome.org>

	* class.cs (MethodData.Define): Put back call to
	TypeManager.AddMethod(), accidentally commented this out.

	* report.cs (Debug): New public method to print debugging information,
	this is `[Conditional ("DEBUG")]'.

2002-07-26  Martin Baulig  <martin@gnome.org>

	* cs-parser.jay (CSharpParser): Added `Stack switch_stack'.
	(switch_statement): Push the current_block to the switch_stack and
	pop it again when we're done with the switch.
	(switch_section): The new block is a child of the current_block.
	Fixes bug #24007, added test-152.cs.

2002-07-27  Martin Baulig  <martin@gnome.org>

	* expression.cs (Invocation.EmitArguments): When calling a varargs
	function with only its fixed arguments, we need to pass an empty
	array.

2002-07-27  Martin Baulig  <martin@gnome.org>

	Mono 0.13 has been released.

2002-07-25  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Rename --resource to --linkres, because that is what
	we do currently, we dont support --resource yet.

	* cs-tokenizer.cs: Fix test for reporting endif mismatches.

2002-07-25  Martin Baulig  <martin@gnome.org>

	* class.cs (MethodData): New public class.  This is a `method builder'
	class for a method or one accessor of a Property/Indexer/Event.
	(MethodData.GetMethodFlags): Moved here from MemberBase.
	(MethodData.ApplyAttributes): Likewise.
	(MethodData.ApplyObsoleteAttribute): Likewise.
	(MethodData.ApplyConditionalAttribute): Likewise.
	(MethodData.ApplyDllImportAttribute): Likewise.
	(MethodData.CheckAbstractAndExternal): Likewise.
	(MethodData.Define): Formerly knows as MemberBase.DefineMethod().
	(MethodData.Emit): Formerly known as Method.Emit().
	(MemberBase): Moved everything which was specific to a single
	accessor/method to MethodData.
	(Method): Create a new MethodData and call Define() and Emit() on it.
	(Property, Indexer, Event): Create a new MethodData objects for each
	accessor and call Define() and Emit() on them.

2002-07-25  Martin Baulig  <martin@gnome.org>

	Made MethodCore derive from MemberBase to reuse the code from there.
	MemberBase now also checks for attributes.

	* class.cs (MethodCore): Derive from MemberBase, not MemberCore.
	(MemberBase.GetMethodFlags): Moved here from class Method and marked
	as virtual.
	(MemberBase.DefineAccessor): Renamed to DefineMethod(), added
	`CallingConventions cc' and `Attributes opt_attrs' arguments.
	(MemberBase.ApplyAttributes): New virtual method; applies the
	attributes to a method or accessor.
	(MemberBase.ApplyObsoleteAttribute): New protected virtual method.
	(MemberBase.ApplyConditionalAttribute): Likewise.
	(MemberBase.ApplyDllImportAttribute): Likewise.
	(MemberBase.CheckAbstractAndExternal): Likewise.
	(MethodCore.ParameterTypes): This is now a property instead of a
	method, it's initialized from DoDefineParameters().
	(MethodCore.ParameterInfo): Removed the set accessor.
	(MethodCore.DoDefineParameters): New protected virtual method to
	initialize ParameterTypes and ParameterInfo.
	(Method.GetReturnType): We can now simply return the MemberType.
	(Method.GetMethodFlags): Override the MemberBase version and add
	the conditional flags.
	(Method.CheckBase): Moved some code from Define() here, call
	DoDefineParameters() here.
	(Method.Define): Use DoDefine() and DefineMethod() from MemberBase
	here to avoid some larger code duplication.
	(Property.Emit, Indexer.Emit): Call CheckAbstractAndExternal() to
	ensure that abstract and external accessors don't declare a body.

	* attribute.cs (Attribute.GetValidPieces): Make this actually work:
	`System.Attribute.GetCustomAttributes (attr.Type)' does a recursive
	lookup in the attribute's parent classes, so we need to abort as soon
	as we found the first match.
	(Attribute.Obsolete_GetObsoleteMessage): Return the empty string if
	the attribute has no arguments.

	* typemanager.cs (TypeManager.AddMethod): Now takes a MemberBase instead
	of a Method.

2002-07-24  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* cs-parser.jay: reverted previous patch.

2002-07-24  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* cs-parser.jay: fixed bug #22119.

2002-07-24  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* attribute.cs: fixed compilation. The error was:
	"attribute.cs(571,17): error CS0177: The out parameter 'is_error' must 
	be assigned to before control leaves the current method."
	[FIXME:  Filed as bug #28186: MCS must report this error.]

2002-07-25  Martin Baulig  <martin@gnome.org>

	* attribute.cs (Attribute.Conditional_GetConditionName): New static
	method to pull the condition name ouf of a Conditional attribute.
	(Attribute.Obsolete_GetObsoleteMessage): New static method to pull
	the obsolete message and error flag out of an Obsolete attribute.

	* class.cs (Method.GetMethodFlags): New public method to get the
	TypeManager.MethodFlags for this method.
	(Method.ApplyConditionalAttribute, Method.ApplyObsoleteAttribute): New
	private methods.
	(Method.Define): Get and apply the Obsolete and Conditional attributes;
	if we're overriding a virtual function, set the new private variable
	`parent_method'; call the new TypeManager.AddMethod().

	* typemanager.cs (TypeManager.AddMethod): New static method.  Stores
	the MethodBuilder and the Method in a PtrHashtable.
	(TypeManager.builder_to_method): Added for this purpose.
	(TypeManager.MethodFlags): Added IsObsoleteError.
	(TypeManager.GetMethodFlags): Added `Location loc' argument.  Lookup
	Obsolete and Conditional arguments in MethodBuilders.  If we discover
	an Obsolete attribute, emit an appropriate warning 618 / error 619 with
	the message from the attribute.

2002-07-24  Martin Baulig  <martin@gnome.org>

	* cs-tokenizer.cs: Eat up trailing whitespaces and one-line comments in
	preprocessor directives, ensure that the argument to #define/#undef is
	exactly one identifier and that it's actually an identifier.

	Some weeks ago I did a `#define DEBUG 1' myself and wondered why this
	did not work ....

2002-07-24  Martin Baulig  <martin@gnome.org>

	* statement.cs (Foreach.ForeachHelperMethods): Added `Type element_type',
	initialize it to TypeManager.object_type in the constructor.
	(Foreach.GetEnumeratorFilter): Set `hm.element_type' to the return type
	of the `hm.get_current' method if we're using the collection pattern.
	(Foreach.EmitCollectionForeach): Use `hm.element_type' as the source type
	for the explicit conversion to make it work when we're using the collection
	pattern and the `Current' property has a different return type than `object'.
	Fixes #27713.

2002-07-24  Martin Baulig  <martin@gnome.org>

	* delegate.cs (Delegate.VerifyMethod): Simply return null if the method
	does not match, but don't report any errors.  This method is called in
	order for all methods in a MethodGroupExpr until a matching method is
	found, so we don't want to bail out if the first method doesn't match.
	(NewDelegate.DoResolve): If none of the methods in the MethodGroupExpr
	matches, report the 123.  Fixes #28070.

2002-07-24  Martin Baulig  <martin@gnome.org>

	* expression.cs (ArrayAccess.EmitStoreOpcode): Moved the
	TypeManager.TypeToCoreType() to the top of the method so the
	following equality checks will work.  Fixes #28107.

2002-07-24  Martin Baulig  <martin@gnome.org>

	* cfold.cs (ConstantFold.DoConstantNumericPromotions): "If either
	operand is of type uint, and the other operand is of type sbyte,
	short or int, the operands are converted to type long." -
	Actually do what this comment already told us.  Fixes bug #28106,
	added test-150.cs.

2002-07-24  Martin Baulig  <martin@gnome.org>

	* class.cs (MethodBase): New abstract class.  This is now a base
	class for Property, Indexer and Event to avoid some code duplication
	in their Define() and DefineMethods() methods.
	(MethodBase.DoDefine, MethodBase.DefineAccessor): Provide virtual
	generic methods for Define() and DefineMethods().
	(FieldBase): Derive from MemberBase, not MemberCore.
	(Property): Derive from MemberBase, not MemberCore.
	(Property.DefineMethod): Moved all the code from this method to the
	new MethodBase.DefineAccessor(), just call it with appropriate
	argumetnts.
	(Property.Define): Call the new Property.DoDefine(), this does some
	sanity checks and we don't need to duplicate the code everywhere.
	(Event): Derive from MemberBase, not MemberCore.
	(Event.Define): Use the new MethodBase.DefineAccessor() to define the
	accessors, this will also make them work with interface events.
	(Indexer): Derive from MemberBase, not MemberCore.
	(Indexer.DefineMethod): Removed, call MethodBase.DefineAccessor() insstead.
	(Indexer.Define): Use the new MethodBase functions.

	* interface.cs (InterfaceEvent.InterfaceEvent): Added `Location loc'
	argument to the constructor.
	(Interface.FindMembers): Added support for interface events.
	(Interface.PopluateEvent): Implemented.

	Added test-149.cs for this.  This also fixes bugs #26067 and #24256.

2002-07-22  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer.AddMethod): Adding methods do not use IsValid,
	but this is required to check for a method name being the same as
	the containing class.  

	Handle this now.

2002-07-22  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* interface.cs: initialize variable.

2002-07-23  Martin Baulig  <martin@gnome.org>

	Implemented the IndexerName attribute in interfaces.

	* class.cs (TypeContainer.DefineIndexers): Don't set the indexer
	name if this is an explicit interface implementation.
	(Indexer.InterfaceIndexerName): New public variable.  If we're
	implementing an interface indexer, this is the IndexerName in that
	interface.  Otherwise, it's the IndexerName.
	(Indexer.DefineMethod): If we're implementing interface indexer,
	set InterfaceIndexerName.  Use the new Pending.IsInterfaceIndexer
	and Pending.ImplementIndexer methods.
	(Indexer.Define): Also define the PropertyBuilder if we're
	implementing an interface indexer and this is neither an explicit
	interface implementation nor do the IndexerName match the one in
	the interface.

	* pending.cs (TypeAndMethods): Added `MethodInfo [] need_proxy'.
	If a method is defined here, then we always need to create a proxy
	for it.  This is used when implementing interface indexers.
	(Pending.IsInterfaceIndexer): New public method.
	(Pending.ImplementIndexer): New public method.
	(Pending.InterfaceMethod): Added `MethodInfo need_proxy' argument.
	This is used when implementing interface indexers to define a proxy
	if necessary.
	(Pending.VerifyPendingMethods): Look in the `need_proxy' array and
	define a proxy if necessary.

	* interface.cs (Interface.IndexerName): New public variable.
	(Interface.PopulateIndexer): Set the IndexerName.
	(Interface.DefineIndexers): New private method.  Populate all the
	indexers and make sure their IndexerNames match.

	* typemanager.cs (IndexerPropertyName): Added support for interface
	indexers.

2002-07-22  Martin Baulig  <martin@gnome.org>

	* codegen.cs (EmitContext.HasReturnLabel): New public variable.
	(EmitContext.EmitTopBlock): Always mark the ReturnLabel and emit a
	ret if HasReturnLabel.
	(EmitContext.TryCatchLevel, LoopBeginTryCatchLevel): New public
	variables.

	* statement.cs (Do.Emit, While.Emit, For.Emit, Foreach.Emit): Save
	and set the ec.LoopBeginTryCatchLevel.
	(Try.Emit): Increment the ec.TryCatchLevel while emitting the block.
	(Continue.Emit): If the ec.LoopBeginTryCatchLevel is smaller than
	the current ec.TryCatchLevel, the branch goes out of an exception
	block.  In this case, we need to use Leave and not Br.

2002-07-22  Martin Baulig  <martin@gnome.org>

	* statement.cs (Try.Emit): Emit an explicit ret after the end of the
	block unless the block does not always return or it is contained in
	another try { ... } catch { ... } block.  Fixes bug #26506.
	Added verify-1.cs to the test suite.

2002-07-22  Martin Baulig  <martin@gnome.org>

	* statement.cs (Switch.TableSwitchEmit): If we don't have a default,
	then we do not always return.  Fixes bug #24985.

2002-07-22  Martin Baulig  <martin@gnome.org>

	* expression.cs (Invocation.OverloadedResolve): Do the BetterFunction()
	lookup on a per-class level; ie. walk up the class hierarchy until we
	found at least one applicable method, then choose the best among them.
	Fixes bug #24463 and test-29.cs.

2002-07-22  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.ArrayContainsMethod): Don't check the
	return types of the methods.  The return type is not part of the
	signature and we must not check it to make the `new' modifier work.
	Fixes bug #27999, also added test-147.cs.
	(TypeManager.TypeToCoreType): Added TypeManager.type_type.

	* expression.cs (Invocation.DoResolve): Call TypeManager.TypeToCoreType()
	on the method's return type.

2002-07-21  Martin Baulig  <martin@gnome.org>

	* assign.cs: Make this work if the rightmost source is a constant and
	we need to do an implicit type conversion.  Also adding a few more tests
	to test-38.cs which should have caught this.

	* makefile.gnu: Disable debugging, there's already the mcs-mono2.exe
	target in the makefile for this.  The makefile.gnu is primarily intended
	for end-users who don't want to debug the compiler.

2002-07-21  Martin Baulig  <martin@gnome.org>

	* assign.cs: Improved the Assign class so it can now handle embedded
	assignments (X = Y = Z = something).  As a side-effect this'll now also
	consume less local variables.  test-38.cs now passes with MCS, added
	a few new test cases to that test.

2002-07-20  Martin Baulig  <martin@gnome.org>

	* expression.cs (Binary.EmitBranchable): Emit correct unsigned branch
	instructions.  Fixes bug #27977, also added test-146.cs.

2002-07-19  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* cs-tokenizer.cs: fixed getHex ().

2002-07-19  Martin Baulig  <martin@gnome.org>

	* expression.cs (Invocation.EmitParams): Use TypeManager.LookupType(),
	not Type.GetType() to lookup the array type.  This is needed when
	we're constructing an array of a user-defined type.
	(ArrayAccess.EmitDynamicInitializers): Only emit the Ldelema for
	single-dimensional arrays, but also for single-dimensial arrays of
	type decimal.

2002-07-19  Martin Baulig  <martin@gnome.org>

	* expression.cs (New.DoEmit): Create a new LocalTemporary each time
	this function is called, it's not allowed to share LocalBuilders
	among ILGenerators.

2002-07-19  Martin Baulig  <martin@gnome.org>

	* expression.cs (Argument.Resolve): Report an error 118 when trying
	to pass a type as argument.

2002-07-18  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.ImplicitNumericConversion): Don't emit a
	Conv_R_Un for the signed `long' type.

2002-07-15  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (MemberAccess.DoResolve): Do not reuse the field
	`expr' for the temporary result, as that will fail if we do
	multiple resolves on the same expression.

2002-07-05  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (SimpleNameResolve): Use ec.DeclSpace instead of
	ec.TypeContainer for looking up aliases. 

	* class.cs (TypeContainer): Remove LookupAlias from here.

	* decl.cs (DeclSpace); Move here.

2002-07-01  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (FindMembers): Only call filter if the constructor
	bulider is not null.

	Also handle delegates in `NestedTypes' now.  Now we will perform
	type lookups using the standard resolution process.  This also
	fixes a bug.

	* decl.cs (DeclSpace.ResolveType): New type resolution routine.
	This uses Expressions (the limited kind that can be parsed by the
	tree) instead of strings.

	* expression.cs (ComposedCast.ToString): Implement, used to flag
	errors since now we have to render expressions.

	(ArrayCreation): Kill FormElementType.  Use ComposedCasts in
	FormArrayType. 

	* ecore.cs (SimpleName.ToString): ditto.

	* cs-parser.jay: Instead of using strings to assemble types, use
	Expressions to assemble the type (using SimpleName, ComposedCast,
	MemberAccess).  This should fix the type lookups in declarations,
	because we were using a different code path for this.

	* statement.cs (Block.Resolve): Continue processing statements
	even when there is an error.

2002-07-17  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Event.Define): Also remove the `remove' method from
	the list of pending items.

	* expression.cs (ParameterReference): Use ldarg.N (0..3) to
	generate more compact code. 

2002-07-17  Martin Baulig  <martin@gnome.org>

	* const.cs (Const.LookupConstantValue): Add support for constant
	`unchecked' and `checked' expressions.
	Also adding test case test-140.cs for this.

2002-07-17  Martin Baulig  <martin@gnome.org>

	* statement.cs (Foreach.GetEnumeratorFilter): When compiling corlib,
	check whether mi.ReturnType implements the IEnumerator interface; the
	`==' and the IsAssignableFrom() will fail in this situation.

2002-07-16  Ravi Pratap  <ravi@ximian.com>

	* ecore.cs (SimpleName.SimpleNameResolve) : Apply Gonzalo's fix 
	here too.

2002-07-16  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* expression.cs: fixed bug #27811.

2002-07-14  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ParameterReference.AddressOf): Patch from Paolo
	Molaro: when we are a ref, the value already contains a pointer
	value, do not take the address of it.

2002-07-14 Rafael Teixeira <rafaelteixeirabr@hotmail.com>
	* removed mb-parser.jay and mb-tokenizer.cs

Sat Jul 13 19:38:03 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* expression.cs: check against the building corlib void type.

Sat Jul 13 19:35:58 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* ecore.cs: fix for valuetype static readonly fields: when 
	initializing them, we need their address, not the address of a copy.

Sat Jul 13 17:32:53 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* typemanager.cs: register also enum_type in corlib.

Sat Jul 13 15:59:47 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* class.cs: allow calling this (but not base) initializers in structs.

Sat Jul 13 15:12:06 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* ecore.cs: make sure we compare against the building base types
	in GetTypeSize ().

Sat Jul 13 15:10:32 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* typemanager.cs: fix TypeToCoreType() to handle void and object
	(corlib gets no more typerefs after this change).

2002-07-12  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ArrayCreation.EmitArrayArguments): use
	Conv.Ovf.U4 for unsigned and Conv.Ovf.I4 for signed.

	(ArrayAccess.LoadArrayAndArguments): Use Conv_Ovf_I and
	Conv_Ovf_I_Un for the array arguments.  Even if C# allows longs as
	array indexes, the runtime actually forbids them.

	* ecore.cs (ExpressionToArrayArgument): Move the conversion code
	for array arguments here.

	* expression.cs (EmitLoadOpcode): System.Char is a U2, use that
	instead of the default for ValueTypes.

	(New.DoEmit): Use IsValueType instead of
	IsSubclassOf (value_type)
	(New.DoResolve): ditto.
	(Invocation.EmitCall): ditto.

	* assign.cs (Assign): ditto.

	* statement.cs (Unsafe): Ok, so I got the semantics wrong.
	Statements *are* currently doing part of their resolution during
	Emit.  

	Expressions do always resolve during resolve, but statements are
	only required to propagate resolution to their children.

2002-07-11  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs (CSCParseOption): Finish the /r: and /lib: support.

	(LoadAssembly): Do not add the dll if it is already specified
	
	(MainDriver): Add the System directory to the link path at the end,
	after all the other -L arguments. 

	* expression.cs (ArrayAccess.EmitLoadOpcode): I was using the
	wrong opcode for loading bytes and bools (ldelem.i1 instead of
	ldelem.u1) and using the opposite for sbytes.

	This fixes Digger, and we can finally run it.

	* driver.cs (UnixParseOption): Move the option parsing here.  
	(CSCParseOption): Implement CSC-like parsing of options.

	We now support both modes of operation, the old Unix way, and the
	new CSC-like way.  This should help those who wanted to make cross
	platform makefiles.

	The only thing broken is that /r:, /reference: and /lib: are not
	implemented, because I want to make those have the same semantics
	as the CSC compiler has, and kill once and for all the confussion
	around this.   Will be doing this tomorrow.

	* statement.cs (Unsafe.Resolve): The state is checked during
	resolve, not emit, so we have to set the flags for IsUnsfe here.

2002-07-10  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (MemberAccess.ResolveMemberAccess): Since we can
	not catch the Error_ObjectRefRequired in SimpleName (as it is
	possible to have a class/instance variable name that later gets
	deambiguated), we have to check this here. 	

2002-07-10  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer.GetFieldFromEvent): Move away from here,
	make static and put into Expression.

	(Event.Define): Register the private field of the event with the 
	TypeManager so that GetFieldFromEvent can get at it.

	(TypeManager.RegisterPrivateFieldOfEvent): Implement to
	keep track of the private field associated with an event which
	has no accessors.

	(TypeManager.GetPrivateFieldOfEvent): Implement to get at the
	private field.

	* ecore.cs (GetFieldFromEvent): RE-write to use the above methods.
	
2002-07-10  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Binary.EmitBranchable): this routine emits the
	Binary expression in a branchable context.  This basically means:
	we need to branch somewhere, not just get the value on the stack.

	This works together with Statement.EmitBoolExpression.

	* statement.cs (Statement.EmitBoolExpression): Use
	EmitBranchable. 

2002-07-09  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (For): Reduce the number of jumps in loops.

	(For): Implement loop inversion for the For statement.

	(Break): We can be breaking out of a Try/Catch controlled section
	(foreach might have an implicit try/catch clause), so we need to
	use Leave instead of Br.

	* ecore.cs (FieldExpr.AddressOf): Fix for test-139 (augmented
	now).  If the instace expression supports IMemoryLocation, we use
	the AddressOf method from the IMemoryLocation to extract the
	address instead of emitting the instance.

	This showed up with `This', as we were emitting the instance
	always (Emit) instead of the Address of This.  Particularly
	interesting when This is a value type, as we dont want the Emit
	effect (which was to load the object).
	
2002-07-08  Miguel de Icaza  <miguel@ximian.com>

	* attribute.cs: Pass the entry point to the DefinePInvokeMethod

	* statement.cs (Checked): Set the CheckedState during the resolve
	process too, as the ConvCast operations track the checked state on
	the resolve process, and not emit.

	* cs-parser.jay (namespace_member_declaration): Flag that we have
	found a declaration when we do.  This is used to flag error 1529

	* driver.cs: Report ok when we display the help only.

2002-07-06  Andrew Birkett  <adb@tardis.ed.ac.uk>

	* cs-tokenizer.cs (xtoken): Improve handling of string literals.

2002-07-04  Miguel de Icaza  <miguel@ximian.com>

	* cs-tokenizer.cs (define): We also have to track locally the
	defines.  AllDefines is just used for the Conditional Attribute,
	but we also need the local defines for the current source code. 

2002-07-03  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (While, For, Do): These loops can exit through a
	Break statement, use this information to tell whether the
	statement is the last piece of code.

	(Break): Flag that we break.

	* codegen.cs (EmitContexts): New `Breaks' state variable.

2002-07-03  Martin Baulig  <martin@gnome.org>

	* class.cs (TypeContainer.MethodModifiersValid): Allow override
	modifiers in method declarations in structs.  Otherwise, you won't
	be able to override things like Object.Equals().

2002-07-02  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Method, Property, Indexer): Do not allow the public
	modifier to be used in explicit interface implementations.

	(TypeContainer.MethodModifiersValid): Catch virtual, abstract and
	override modifiers in method declarations in structs

2002-07-02   Andrew Birkett <adb@tardis.ed.ac.uk>

	* cs-tokenizer.cs (adjust_int, adjust_real): Do not abort on
	integer or real overflow, report an error

2002-07-02  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.InitCoreTypes): When compiling
	corlib, dynamically call AssemblyBuilder.SetCorlibTypeBuilders()
	to tell the runtime about our newly created System.Object and
	System.ValueType types.

2002-07-02  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (This): Use Stobj/Ldobj when we are a member of a
	struct instead of Ldarg/Starg.

2002-07-02  Martin Baulig  <martin@gnome.org>

	* expression.cs (Indirection.Indirection): Call
	TypeManager.TypeToCoreType() on `expr.Type.GetElementType ()'.

2002-07-02  Martin Baulig  <martin@gnome.org>

	* expression.cs (ArrayAccess.EmitStoreOpcode): If the type is a
	ValueType, call TypeManager.TypeToCoreType() on it.
	(Invocations.EmitParams): Call TypeManager.TypeToCoreType() on
	the OpCodes.Newarr argument.

2002-07-02  Martin Baulig  <martin@gnome.org>

	* expression.cs (Invocation.EmitCall): When compiling corlib,
	replace all calls to the system's System.Array type to calls to
	the newly created one.

	* typemanager.cs (TypeManager.InitCodeHelpers): Added a few more
	System.Array methods.
	(TypeManager.InitCoreTypes): When compiling corlib, get the methods
	from the system's System.Array type which must be replaced.

Tue Jul 2 19:05:05 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* typemanager.cs: load unverifiable_code_ctor so we can build
	corlib using the correct type. Avoid using GetTypeCode() with
	TypeBuilders.
	* rootcontext.cs: uses TypeManager.unverifiable_code_ctor and
	TypeManager.object_type to allow building corlib.

Tue Jul 2 19:03:19 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* ecore.cs: handle System.Enum separately in LoadFromPtr().

2002-07-01  Martin Baulig  <martin@gnome.org>

	* class.cs: Make the last change actually work, we need to check
	whether `ifaces != null' to avoid a crash.

Mon Jul 1 16:15:03 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* class.cs: when we build structs without fields that implement
	interfaces, we need to add the interfaces separately, since there is
	no API to both set the size and add the interfaces at type creation
	time.

Mon Jul 1 14:50:47 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* expression.cs: the dimension arguments to the array constructors
	need to be converted if they are a long.

Mon Jul 1 12:26:12 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* class.cs: don't emit ldarg.0 if there is no parent constructor
	(fixes showstopper for corlib).

2002-06-29  Martin Baulig  <martin@gnome.org>

	MCS now compiles corlib on GNU/Linux :-)

	* attribute.cs (Attribute.ApplyAttributes): Treat Accessors like Method,
	ie. check for MethodImplOptions.InternalCall.

	* class.cs (TypeContainer.DefineType): When compiling corlib, both parent
	and TypeManager.attribute_type are null, so we must explicitly check
	whether parent is not null to find out whether it's an attribute type.
	(Property.Emit): Always call Attribute.ApplyAttributes() on the GetBuilder
	and SetBuilder, not only if the property is neither abstract nor external.
	This is necessary to set the MethodImplOptions on the accessor methods.
	(Indexer.Emit): Call Attribute.ApplyAttributes() on the GetBuilder and
	SetBuilder, see Property.Emit().

	* rootcontext.cs (RootContext.PopulateTypes): When compiling corlib, don't
	populate "System.Object", "System.ValueType" and "System.Attribute" since
	they've already been populated from BootCorlib_PopulateCoreTypes().

2002-06-29  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.ImplicitReferenceConversionExists): If expr
	is the NullLiteral, we also need to make sure that target_type is not
	an enum type.	

2002-06-29  Martin Baulig  <martin@gnome.org>

	* rootcontext.cs (RootContext.ResolveCore): We must initialize
	`TypeManager.multicast_delegate_type' and `TypeManager.delegate_type'
	before calling BootstrapCorlib_ResolveDelegate ().

2002-06-27  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* statement.cs: fixed build-breaker. All tests passed ok.

2002-06-27  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.VerifyUnManaged): Added explicit check
	for System.Decimal when compiling corlib.

2002-06-27  Martin Baulig  <martin@gnome.org>

	* statement.cs (Switch.TableSwitchEmit): Make this work with empty
	switch blocks which contain nothing but a default clause.

2002-06-26  Andrew  <adb@tardis.ed.ac.uk>

       * ../errors/cs1501-3.cs: Added new test for struct ctr typechecks.

2002-06-27  Martin Baulig  <martin@gnome.org>

	* ecore.cs (PropertyExpr.PropertyExpr): Call
	TypeManager.TypeToCoreType() on the `pi.PropertyType'.

	* typemanager.cs (TypeManager.TypeToCoreType): Return if the type
	is already a TypeBuilder.

2002-06-27  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.ImplicitReferenceConversionExists): Use
	`target_type == TypeManager.array_type', not IsAssignableFrom() in
	the "from an array-type to System.Array" case.  This makes it work
	when compiling corlib.

2002-06-27  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.SimpleNameResolve): If the expression is a
	non-static PropertyExpr, set its InstanceExpression.  This makes
	the `ICollection.Count' property work in System/Array.cs.

2002-06-25  Andrew Birkett  <adb@tardis.ed.ac.uk>

	* driver.cs: Made error handling more consistent.  Errors now
	tracked by Report class, so many methods which used to return int
	now return void.  Main() now prints success/failure and 
	errors/warnings message.

	Renamed '--probe' compiler argument to '--expect-error'.  Removed
	the magic number return values (123 and 124).  Now, if the
	expected error occurs, the compiler exits with success (exit value
	0).  If the compilation completes without seeing that particular
	error, the compiler exits with failure (exit value 1).  The
	makefile in mcs/errors has been changed to handle the new behaviour.

	* report.cs: Made 'expected error' number a property and renamed
	it from 'Probe' to 'ExpectedError'.

	* genericparser.cs: Removed error handling support, since it is
	now all done by Report class.

	* cs-parser.jay, mb-parser.jay: Errors are tracked by Report
	class, so parse() no longer returns an int.

	* namespace.cs: Use Report.Error instead of GenericParser.error

2002-06-22  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer.AddMethod, TypeContainer.AddIndexer,
	TypeContainer.AddOperator): At the front of the list put the
	explicit implementations, so they get resolved/defined first. 

2002-06-21  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer.VerifyImplements): Verifies that a given
	interface type is implemented by this TypeContainer.  Used during
	explicit interface implementation.

	(Property.Define, Indexer.Define, Method.Define): Validate that
	the given interface in the explicit implementation is one of the
	base classes for the containing type.

	Also if we are explicitly implementing an interface, but there is
	no match in the pending implementation table, report an error.

	(Property.Define): Only define the property if we are
	not explicitly implementing a property from an interface.  Use the
	correct name also for those properties (the same CSC uses,
	although that is really not needed).
	
	(Property.Emit): Do not emit attributes for explicitly implemented
	properties, as there is no TypeBuilder.

	(Indexer.Emit): ditto.

	Hiding then means that we do not really *implement* a pending
	implementation, which makes code fail.

2002-06-22  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.Constantify): Call TypeManager.TypeToCoreType() on
	the return value of Object.GetType().  [FIXME: we need to do this whenever
	we get a type back from the reflection library].

Fri Jun 21 13:37:57 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* typemanager.cs: make ExpandInterfaces() slip duplicated interfaces.

2002-06-20  Miguel de Icaza  <miguel@ximian.com>

	* attribute.cs: Return null if we can not look up the type.

	* class.cs (TypeContainer.GetClassBases): Use ExpandInterfaces on
	the interface types found.

	* interface.cs (Interface.GetInterfaceBases): Use ExpandInterfaces on the
	interface types found.

	* typemanager.cs (GetInterfaces): Make this routine returns alll
	the interfaces and work around the lame differences between
	System.Type and System.Reflection.Emit.TypeBuilder in the results
	result for GetInterfaces.
	
	(ExpandInterfaces): Given an array of interface types, expand and
	eliminate repeated ocurrences of an interface.  This expands in
	context like: IA; IB : IA; IC : IA, IB; the interface "IC" to
	be IA, IB, IC.
	
2002-06-21  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.EnumToUnderlying): It's now safe to call this function
	on System.Enum.

2002-06-21  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (TypeManager.TypeToCoreType): New function.  When compiling corlib
	and called with one of the core types, return the corresponding typebuilder for
	that type.

	* expression.cs (ArrayAccess.DoResolve): Call TypeManager.TypeToCoreType() on the
	element type.

2002-06-21  Martin Baulig  <martin@gnome.org>

	* ecore.cs (Expression.ExplicitReferenceConversionExists): Use
	`target_type.IsArray' instead of `target_type.IsSubclassOf (TypeManager.array_type)'.
	(Expression.ConvertReferenceExplicit): Likewise.

	* expression.cs (ElementAccess.DoResolve): Likewise.
	(ElementAccess.DoResolveLValue): Likewise.

2002-06-10  Martin Baulig  <martin@gnome.org>

	* interface.cs (Interface.PopulateIndexer): When creating the setter, we need to
	add the "value" parameter to the parameter list.

	* statement.cs (Fixed.Emit): Pass the return value of the child block's Emit()
	to our caller.

2002-06-19  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ArrayCreation.ExpressionToArrayArgument): Convert
	the argument to an int, uint, long or ulong, per the spec.  Also
	catch negative constants in array creation.

Thu Jun 20 17:56:48 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* class.cs: do not allow the same interface to appear twice in
	the definition list.

Wed Jun 19 22:33:37 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* ecore.cs: don't use ldlen with System.Array.

Wed Jun 19 20:57:40 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* ecore.cs: stobj requires a type argument. Handle indirect stores on enums.

Wed Jun 19 20:17:59 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* modifiers.cs: produce correct field attributes for protected
	internal. Easy fix so miguel can work on ther harder stuff:-)

2002-06-18  Miguel de Icaza  <miguel@ximian.com>

	* pending.cs: New file.  Move the code from class.cs here.
	Support clearning the pending flag for all methods (when not doing
	explicit interface implementation).

Tue Jun 18 10:36:22 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* rootcontext.cs: added a couple more types needed to bootstrap.

2002-06-17  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (GetConstructor): Use DeclaredOnly to look the
	constructor in the type, instead of any constructor in the type
	hierarchy.  Thanks to Paolo for finding this bug (it showed up as
	a bug in the Mono runtime when applying the params attribute). 

2002-06-16  Rafael Teixeira  <rafaelteixeirabr@hotmail.com>
	* changed namespace.cs to use "GenericParser.error(...)" instead of "CSharpParser.error(...)"

2002-06-14  Rachel Hestilow  <hestilow@ximian.com>

	* expression.cs (Unary.ResolveOperator): Use TypeManager
	to resolve the type.
	
2002-06-13  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (enum_member_declaration): Pass in the attributes
	attached.

	* enum.cs (AddEnumMember): Add support to store the attributes associated 
	with each member too.

	* attribute.cs (CheckAttribute, ApplyAttributes): Update to handle
	field builders too - this takes care of the enum member case.

2002-06-10  Rachel Hestilow  <hestilow@ximian.com>

	* typemanager.cs (TypeManager.VerifyUnManaged): Allow
	address-of operator on both value types and pointers.
	
2002-06-10  Martin Baulig  <martin@gnome.org>

	* interface.cs (Interface.PopulateIndexer): Add the indexer's
	PropertyBuilder to the `property_builders' list.

	* expression.cs (Indexers.GetIndexersForTypeOrInterface): New private method.
	(Indexers.GetIndexersForType): Call GetIndexersForTypeOrInterface() on the
	`lookup_type' and all its interfaces.  Unfortunately, Type.FindMembers() won't
	find any indexers which are inherited from an interface.

2002-06-09  Martin Baulig  <martin@gnome.org>

	* const.cs (Const.LookupConstantValue): Convert `Expr' to a literal of
	the same type as the constant if necessary.  There's also a test-130.cs
	for this.

	* enum.cs (Enum.ChangeEnumType): Moved to typemanager.cs and made public.

	* typemanager.cs (TypeManager.ChangeType): Previously known as
	Enum.ChangeEnumType().

2002-06-09  Martin Baulig  <martin@gnome.org>

	* expression.cs (Cast.TryReduce): Added support for consts.

2002-06-08  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Accessor): Hold attributes information so we can pass
	it along.

	* cs-parser.jay (get_accessor_declaration, set_accessor_declaration):
	Modify to pass in attributes attached to the methods.

	(add_accessor_declaration, remove_accessor_declaration): Ditto.

	* attribute.cs (ApplyAttributes, CheckAttribute): Update accordingly
	to handle the Accessor kind :-)

	* class.cs (Property.Emit, Event.Emit): Apply attributes to the accessors
	
2002-06-08  Martin Baulig  <martin@gnome.org>

	* expression.cs (Unary.TryReduceNegative): Added support for
	ULongConstants.

2002-06-08  Martin Baulig  <martin@gnome.org>

	* enum.cs (Enum.LookupEnumValue): Don't report an error if the
	name can't be found in the `defined_names' - the caller will do a
	MemberLookup in this case and thus find methods in System.Enum
	such as Enum.IsDefined().

2002-06-08  Martin Baulig  <martin@gnome.org>

	* enum.cs (Enum.ChangeEnumType): This is a custom version of
	Convert.ChangeType() which works with TypeBuilder created types.
	(Enum.LookupEnumValue, Enum.Define): Use it here.

	* class.cs (TypeContainer.RegisterRequiredImplementations): Added
	`TypeBuilder.BaseType != null' check.
	(TypeContainer.FindMembers): Only lookup parent members if we
	actually have a parent.
	(Method.EmitDestructor): Added `ec.ContainerType.BaseType != null' check.
	(ConstructorInitializer.Resolve): Likewise.

	* interface.cs (Interface.FindMembers): Added
	`TypeBuilder.BaseType != null' check.

	* rootcontext.cs (RootContext.ResolveCore): Added
	"System.Runtime.CompilerServices.IndexerNameAttribute" to
	classes_second_stage.

	* typemanager.cs (TypeManager.InitCoreTypes): Don't initialize
	debug_type and trace_type when compiling with --nostdlib.	

2002-06-07  Martin Baulig  <martin@gnome.org>

	* class.cs (TypeContainer): Added `have_nonstatic_fields' field.
	(AddField): Set it to true when adding a non-static field.
	(DefineType): Use `have_nonstatic_fields' to find out whether we
	have non-static fields, not `Fields != null'.

2002-06-02  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (SimpleNameResolve): Removed simple bug (we were
	dereferencing a null on the static-field code path)

2002-05-30  Martin Baulig  <martin@gnome.org>

	* codegen.cs (InitMonoSymbolWriter): Added `string[] args' argument
	to take command line arguments.  Use reflection to call the new
	custom `Initialize' function on the symbol writer and pass it the
	command line arguments.

	* driver.cs (--debug-args): New command line argument to pass command
	line arguments to the symbol writer.

2002-05-28  Miguel de Icaza  <miguel@ximian.com>

	* assign.cs (DoResolve): Forgot to do the implicit conversion to
	the target type for indexers and properties.  Thanks to Joe for
	catching this.

2002-05-27  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (MethodFlags): returns the method flags
	(Obsolete/ShouldIgnore) that control warning emission and whether
	the invocation should be made, or ignored. 

	* expression.cs (Invocation.Emit): Remove previous hack, we should
	not do this on matching a base type, we should do this based on an attribute

	Only emit calls to System.Diagnostics.Debug and
	System.Diagnostics.Trace if the TRACE and DEBUG defines are passed
	on the command line.

	* rootcontext.cs: Global settings for tracing and debugging.

	* cs-tokenizer.cs (define): New utility function to track
	defines.   Set the global settings for TRACE and DEBUG if found.

2002-05-25  Ravi Pratap  <ravi@ximian.com>

	* interface.cs (Populate*): Pass in the TypeContainer as well as
	the DeclSpace as parameters so that we can create EmitContexts and
	then use that to apply attributes etc.

	(PopulateMethod, PopulateEvent, PopulateProperty)
	(PopulateIndexer): Apply attributes everywhere.

	* attribute.cs (CheckAttribute): Include InterfaceMethod, InterfaceEvent
	etc.

	(ApplyAttributes): Update accordingly.

	We now apply interface attributes for all members too.

2002-05-26  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Indexer.Define); Correctly check if we are explicit
	implementation (instead of checking the Name for a ".", we
	directly look up if the InterfaceType was specified).

	Delay the creation of the PropertyBuilder.

	Only create the PropertyBuilder if we are not an explicit
	interface implementation.   This means that explicit interface
	implementation members do not participate in regular function
	lookups, and hence fixes another major ambiguity problem in
	overload resolution (that was the visible effect).

	(DefineMethod): Return whether we are doing an interface
	implementation. 
	
	* typemanager.cs: Temporary hack until we get attributes in
	interfaces (Ravi is working on that) and we get IndexerName
	support in interfaces.

	* interface.cs: Register the indexers as properties.

	* attribute.cs (Attribute.Resolve): Catch the error, and emit a
	warning, I have verified that this is a bug in the .NET runtime
	(JavaScript suffers of the same problem).

	* typemanager.cs (MemberLookup): When looking up members for
	interfaces, the parent of an interface is the implicit
	System.Object (so we succeed in searches of Object methods in an
	interface method invocation.  Example:  IEnumerable x;  x.ToString
	()) 

2002-05-25  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Event): Events should also register if they do
	implement the methods that an interface requires.

	* typemanager.cs (MemberLookup); use the new GetInterfaces
	method. 

	(GetInterfaces): The code used to lookup interfaces for a type is
	used in more than one place, factor it here. 

	* driver.cs: Track the errors at the bottom of the file, we kept
	on going.

	* delegate.cs (NewDelegate.Emit): We have to emit a null as the
	instance if the method we are calling is static!

2002-05-24  Miguel de Icaza  <miguel@ximian.com>

	* attribute.cs (ApplyAttributes): Make this function filter out
	the IndexerName attribute (as that attribute in reality is never
	applied) and return the string constant for the IndexerName
	attribute. 

	* class.cs (TypeContainer.Emit): Validate that all the indexers
	have the same IndexerName attribute, and if so, set the
	DefaultName attribute on the class. 

	* typemanager.cs: The return value might contain other stuff (not
	only methods).  For instance, consider a method with an "Item"
	property and an Item method.

	* class.cs: If there is a problem with the parameter types,
	return. 

2002-05-24  Ravi Pratap  <ravi@ximian.com>

	* ecore.cs (ImplicitConversionExists): Wrapper function which also
	looks at user defined conversion after making a call to 
	StandardConversionExists - we need this for overload resolution.

	* expression.cs : Update accordingly the various method calls.

	This fixes 2 bugs filed against implicit user defined conversions 

2002-05-22  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs: Track the result of the assignment.

2002-05-21  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (MemberAccess): Improved error reporting for
	inaccessible members.

2002-05-22  Martin Baulig  <martin@gnome.org>

	* makefile (mcs-mono2.exe): New target.  This is mcs compiled with
	itself with debugging support.

2002-05-22  Martin Baulig  <martin@gnome.org>

	* typemanager.cs ("System.Runtime.InteropServices.StructLayoutAttribute"):
	Removed, this isn't needed anymore.

2002-05-20  Martin Baulig  <martin@gnome.org>

	* typemanager.cs (InitEnumUnderlyingTypes): "System.Char" can't
	be underlying type for an enum.

2002-05-20  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (InitEnumUnderlyingTypes): New helper function
	that splits out the loading of just the core types.

	* rootcontext.cs (ResolveCore): Split the struct resolution in
	two, so we can load the enumeration underlying types before any
	enums are used.

	* expression.cs (Is): Bandaid until we fix properly Switch (see
	bug #24985 for details).

	* typemanager.cs (ImplementsInterface): The hashtable will contain
	a null if there are no interfaces implemented.

2002-05-18  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay (indexer_declarator): It is fine to have array
	parameters

2002-05-17  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs: (RegisterBuilder): New function used to register
	TypeBuilders that implement interfaces.  Since
	TypeBuilder.GetInterfaces (as usual) does not work with lame
	Reflection.Emit. 
	(AddUserType): register interfaces.

	(ImplementsInterface): Use the builder_to_ifaces hash if we are
	dealing with TypeBuilder.  Also, arrays are showing up as
	SymbolTypes, which are not TypeBuilders, but whose GetInterfaces
	methods can not be invoked on them!

	* ecore.cs (ExplicitReferenceConversionExists): Made public.
	(ImplicitReferenceConversionExists): Split out from
	StandardConversionExists. 

	* expression.cs (As): We were only implementing one of the three
	cases for the as operator.  We now implement them all.
	(Is): Implement the various other cases for Is as well.

	* typemanager.cs (CACHE): New define used to control if we want or
	not the FindMembers cache.  Seems to have a negative impact on
	performance currently

	(MemberLookup): Nested types have full acess to
	enclosing type members

	Remove code that coped with instance/static returns for events, we
	now catch this in RealFindMembers.

	(RealFindMembers): only perform static lookup if the instance
	lookup did not return a type or an event.  

2002-05-17  Miguel de Icaza  <miguel@ximian.com>

	* assign.cs (CompoundAssign): We pass more semantic information
	now to Compound Assignments than we did before: now we have all
	the information at hand, and now we resolve the target *before* we
	do the expression expansion, which allows the "CacheValue" method
	to have the effect we intended (before, a [x] += 1 would generate
	two differen ArrayAccess expressions from the ElementAccess,
	during the resolution process).

	(CompoundAssign.DoResolve): Resolve target and original_source here.

2002-05-16  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ArrayAccess): dropped debugging information. 

	* typemanager.cs: Small bug fix: I was always returning i_members,
	instead of one of i_members or s_members (depending on which had
	the content).

	* assign.cs (IAssignMethod.CacheTemporaries): New method.  This
	method is invoked before any code generation takes place, and it
	is a mechanism to inform that the expression will be invoked more
	than once, and that the method should use temporary values to
	avoid having side effects

	(Assign.Emit): Call CacheTemporaries in the IAssignMethod.
	
	* ecore.cs (Expression.CacheTemporaries): Provide empty default
	implementation.

	* expression.cs (Indirection, ArrayAccess): Add support for
	CacheTemporaries in these two bad boys. 

	* ecore.cs (LoadFromPtr): figure out on our own if we need to use
	ldobj or ldind_ref.  
	(StoreFromPtr): Handle stobj as well.

	* expression.cs (UnaryMutator): Share more code.
	
	* typemanager.cs (FindMembers): Thanks to Paolo for tracking this
	down: I was not tracking the Filter function as well, which
	was affecting the results of the cache.

2002-05-15  Miguel de Icaza  <miguel@ximian.com>

	* attribute.cs: Remove the hack to handle the CharSet property on
	StructLayouts. 

2002-05-14  Miguel de Icaza  <miguel@ximian.com>

	* attribute.cs (DoResolve): More uglyness, we now only try to
	resolve the attribute partially, to extract the CharSet
	information (only if we are a StructLayout attribute).  Otherwise 

	(GetExtraTypeInfo): Add some code to conditionally kill in the
	future this.   I am more and more convinced that the .NET
	framework has special code to handle the attribute setting on
	certain elements.

	* expression.cs (IsParamsMethodApplicable): Revert my previous
	foreach change here, it was wrong.

2002-05-13  Miguel de Icaza  <miguel@ximian.com>

	* cs-tokenizer.cs: (pp_primary): Eat the ')' at the end.
	(pp_expr): do not abort on unknown input, just return.
	(eval): abort if there are pending chars.

	* attribute.cs (Attribute.Resolve): Positional parameters are
	optional.  Deal with that case.

	* class.cs (DefineType): Call Attribute.GetExtraTypeInfo to fetch
	the Ansi/Unicode/Auto information for the type.

	(TypeContainer.DefineType): instantiate the EmitContext here, as
	we will be using it during the type definition (to resolve
	attributes) and during the emit phase.

	* attribute.cs (Attribute.GetExtraTypeInfo): This routine is used
	to pull type information out of the attributes

	(Attribute.Resolve): track the constructor builder, and allow for
	multiple invocations (structs and classes will use this).

	* ecore.cs (MemberLookupFinal): new version with all the
	parameters customizable.

	* expression.cs (New.DoResolve): Use MemberLookupFinal to locate
	constructors.  Return if the result value is null (as the error
	would have been flagged already by MemberLookupFinal)

	Do not allow instances of abstract classes or interfaces to be
	created.
	
	* class.cs: (MethodSignature.InheritableMemberSignatureCompare):
	We have to compare the assembly property here when dealing with
	FamANDAssem and Assembly access modifiers, because we might be
	creating an assembly from *modules* (that means that we are not
	getting TypeBuilders for types defined in other modules that are
	part of this assembly).

	(Method.Emit): If the method is marked abstract and has a body,
	emit an error. 

	(TypeContainer.DefineMembers): If both the defined member and the
	parent name match are methods, then do not emit any warnings: let
	the Method.Define routine take care of flagging warnings.  But if
	there is a mismatch (method overrides something else, or method is
	overriwritten by something, then emit warning).

	(MethodSignature.MemberSignatureCompare): If the sig.ret_type is
	set to null, this means `do not check for the return type on the
	signature'. 

	(Method.Define): set the return type for the method signature to
	null, so that we get methods with the same name and parameters and
	different return types.  This is used to flag warning 114 (you are
	hiding a method, and you probably want to use the new/override
	keywords instead).

	* typemanager.cs (MemberLookup): Implemented proper access
	control, closing a long standing set of bug reports.  The problem
	was that the Framework only has two bits: Public and NonPublic,
	and NonPublic includes private and protected methods, but we need
	to enforce the FamANDAssem, FamOrAssem and Family. 

2002-05-11  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (GotoCase): Return true: Ammounts to giving up
	knowledge on whether we return or not, and letting the other case
	be responsible for it.

2002-05-10  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Do not load directories for each file processed, only
	do it if there is a pattern.

	* ecore.cs: Report readonly assigns here as well, as we might have
	been resolved only by MemberAccess.

	(SimpleName.SimpleNameResolve): Also be useful for LValue
	resolution.   We need this to propagate assign to local readonly variables

	* typemanager.cs: Use a ptrhashtable for the criteria, because we
	do not want to reuse potential criteria memory.

	* class.cs (MyEventBuilder): Set reflected_type;

	* ecore.cs (Constantify): Added support for constifying bools.

	(RootContext.LookupType): Added a cache for values looked up in
	the declaration space.

	* typemanager.cs (FindMembers): Now is a front-end to
	RealFindMembers, and provides a two-level hashtable-based cache to
	the request.  

	15% performance improvement: from 22.5 to 19.2 seconds.

	* expression.cs (IsParamsMethodApplicable): use foreach.
	(Invocation.DoResolve): ditto.
	(New.DoResolve): ditto.
	(ArrayCreation.DoResolve): ditto.

	* ecore.cs (FindMostEncompassingType): use foreach.

	* delegate.cs (NewDelegate.DoResolve): Use foreach

	* ecore.cs (Expression.FindMostSpecificSource): Use foreach.
	(RemoveMethods): use foreach.

	* expression.cs (Invocation.MakeUnionSet): Optimization: Use two
	nested foreach statements instead of for, and also break out of
	the inner loop once a match is found.
	
	(Invocation.OverloadResolve): Use foreach, simplify the code. 

2002-05-08  Miguel de Icaza  <miguel@ximian.com>

	* cfold.cs (BinaryFold): During an enumeration evaluation context,
	we actually unwrap the expression to allow for extra information
	to be extracted. 

	* expression.cs: Use Shr_Un on unsigned operations. 

2002-05-08  Ravi Pratap  <ravi@ximian.com>

	* ecore.cs (FindMostEncompass*): Fix trivial bug where the set of 
	applicable operators was not being considered correctly. This closes
	the bug Miguel reported.

Wed May 8 16:40:50 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* attribute.cs: check that the type derives from System.Attribute
	and report the correct error in that case (moved the duplicate code to
	its own method, too).

Wed May 8 11:50:31 CEST 2002 Paolo Molaro <lupus@ximian.com>

	* attribute.cs: lookup attribute type name as the spec says: first the
	bare attribute name and then name + "Attribute" (nant compiles with
	mcs after this fix).

2002-05-07  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Unary.TryReduceNegative): Ah!  Tricky!  Tricky!
	Because of the way we parse things, we should try to see if a
	UIntConstant can fit in an integer.

2002-05-07  Ravi Pratap  <ravi@ximian.com>

	* ecore.cs (GetConversionOperators): Do not pick up op_True operators
	when we are in an explicit context.

	(ConvertReferenceExplicit): When converting from Iface type S to Class
	T make sure the rules are implemented as an OR.

	* parameter.cs (ParameterType): Make it a property for now although the
	purpose really isn't anything immediate.
	
	* expression.cs (Is*Applicable): Do better checking on the parameter type
	of a ref/out parameter. The ones from the system assemblies are already 
	marked with the correct type so we don't need to do any correction.

	* ecore.cs (StandardConversionExists): Conversion from Interface types to 
	the object type is standard too so include that.

2002-05-06  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (StandardConversionExists): Augment with missing code:
	deal with IntConstant, LongConstants and Enumerations.

	* assign.cs: Report the error, instead of failing silently

	* rootcontext.cs (AddGlobalAttributes): Track attributes on the
	typecontainer that they are declared, because the
	typecontainer/namespace will have the list of using clauses that
	need to be applied.

	Assembly Attributes were escaping the normal registration
	mechanism. 

	(EmitCode): Apply attributes within an EmitContext that represents
	the container they were declared on.
	
	* cs-parser.jay: Track bases for structs.  How did I get this wrong?

2002-05-06  Ravi Pratap  <ravi@ximian.com>

	* ecore.cs (FindMostEncompassingType, FindMostEncompassedType):
	Revamp completely - make much cleaner as we now operate only
	on a set of Types.

	(FindMostSpecificSource, FindMostSpecificTarget): New methods
	to implement the logic detailed in the spec more correctly.

	(UserDefinedConversion): Update accordingly.

2002-05-06  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs: Return flow analysis information up.

	* cs-tokenizer.cs (adjust_real): Share code between LITERAL_DOUBLE
	and the default.

	(token): Do not consume an extra character before calling
	decimal_digits.

2002-05-06  Piers Haken	<piersh@friskit.com>

	* cs-parser.jay: add 'override' attribute to System.Object.Finalize

2002-05-06  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Constructor.Emit): Set the IsStatic flag in the
	EmitContext during the instance constructor initializer
	resolution, to stop access to instance variables.

	This is mandated by the spec, last paragraph of the `constructor
	initializers' section. 

2002-05-05  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay, class.cs (Accessor): new class used to represent
	an accessor (get or set).  In the past we used `null' to represent
	a missing accessor.  But this is ambiguous because there was no
	way to tell in abstract indexers/properties if one of them was
	specified.

	Now there is a way of addressing that.

	* expression.cs (Indexers.GetIndexersForType): Use TypeManager.MemberLookup
	instead of FindMembers.

	* class.cs (TypeContainer.EmitFieldInitializer): Do not typecast
	the result of Assign.Resolve as Assign, but rather as ExpressionStatement.

	* attribute.cs: Treat indexers and properties as the same in terms
	of applying attributes

	* ecore.cs (FindMostEncompassedType): Use statically initialized
	EmptyExpressions()s like we do elsewhere to avoid creating useless
	objects (and we take this out of the tight loop).

	(GetConversionOperators): Move the code to extract the actual
	operators to a separate routine to clean things up.

2002-05-04  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (FieldExpr): Remove un-needed tests for null, since now
	events are always registered FieldBuilders.
	
	* class.cs (FieldBase): New class shared by Fields 

	* delegate.cs: If we are a toplevel delegate, use our full name.
	If we are a nested delegate, then only use our tail name.

2002-05-02  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (IsApplicable): Ensure that we add the "&" to
	ref/out types before comparing it with the type of the argument.

	(IsParamsMethodApplicable): Ditto.

	(Argument.Type): Use TypeManager.LookupType instead of Type.GetType - 
	silly me ;-)

	* delegate.cs : Handle the case when we have more than one applicable
	method. Flag an error only when we finish checking all.

2002-05-02  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Add support for boolean static initializers.

2002-05-01  Miguel de Icaza  <miguel@ximian.com>

	* attribute.cs: Use proper cast for Events, since we use a MyEventBuilder.

	* parameter.cs (ComputeParameterTypes,
	ComputeAndDefineParameterTypes): Better error handling: now we
	clear the `types' cache if we fail during any of the type lookups.
	We also return the status code correctly to our caller

	* delegate.cs: If we fail to define a delegate, abort the extra
	steps. 

	* expression.cs (Binary.ResolveOperator): for
	operator==(object,object) and operator !=(object, object) we also
	have to verify that there is an implicit conversion from one to
	the other.

	(ArrayAccess.DoResolve): Array Access can operate on
	non-variables. 

2002-04-30  Miguel de Icaza  <miguel@ximian.com>

	* assign.cs (CompoundAssign): A new class used as a "flag" that
	the assignment actually is happening as part of a compound
	assignment operator.

	During compound assignment, a few new rules exist to enable things
	like:

	byte b |= 1 + 2

	From the spec:
	
	x op= y can be evaluated as x = (T) (x op y) (ie, an explicit cast
	to the type of x) if y is implicitly convertible to the type of x,
	and the operator is a builtin operator and the return type of the
	operator is explicitly convertible to the type of x. 

	* rootcontext.cs: Reset warning level to 2.  4 catches various
	"interesting" features in mcs, we must clean this up at some
	point, but currently am trying to kill other bugs ;-)

	* ecore.cs (SimpleName.SimpleNameResolve): Perform member lookups
	in container classes as well.  

	* expression.cs (Binary.ResolveOperator): Handle string case
	before anything else (as operator overloading does emit an error
	before doing anything else).

	This code could go away when we move to a table driven model, but
	i could not come up with a good plan last night.
	
2002-04-30  Lawrence Pit <loz@cable.a2000.nl>

	* typemanager.cs (CSharpName): reimplementation using regex.
	* class.cs: added null check for fields in Emit
	* rootcontext.cs: set warninglevel to 4

2002-04-29  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (CSharpName): reimplemented with Lupus
	suggestion.

2002-04-28  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (If): correclty implement Resolve, because we were
	not catching sem errors in there.  The same process is needed
	everywhere else. 
	(Return, StatementExpression, For, While, Do, Throw, Lock): Implement Resolve
	

	(Statement.Warning_DeadCodeFound): Factorize code.
	(While): Report dead code here too.

	(Statement): Added Resolve virtual method to allow
	for resolution split from the emit code.

2002-04-26  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (EmitBoolExpression): No longer try to resolve the
	expression here.    
	(MakeBoolean): New utility function that resolve, implicitly
	converts to boolean and tags the expression. 
	

	(If, Do): Implement dead code elimination.
	(While): Implement loop inversion

	(Do, While, For, If): Resolve the expression prior to calling our
	code generation.

2002-04-22  Lawrence Pit <loz@cable.a2000.nl>

	* class.cs:
	  - added method Report28 (warning: program has more than one entry point)
	  - added method IsEntryPoint, implements paragraph 10.1 of the spec
	  - modified method Method.Define, the part at the end of the method

	* rootcontext.cs: added static public Location EntryPointLocation;
	  
	* ../errors/cs0028.cs : Add test case for the above warning.		  

	* typemanager.cs:
	  - modified method CSharpName to allow arrays of primitive type to
	    be printed nicely (e.g. instead of System.Int32[][] it now prints
	    int[][])
	  - added method CSharpSignature: returns the signature of a method
	    in string format to be used in reporting errors, warnings, etc.

	* support.cs: InternalParameters.ParameterDesc variable tmp initialized
	with String.Empty.
	
2002-04-26  Ravi Pratap  <ravi@ximian.com>

	* delegate.cs (Define): Fix extremely silly bug where I was
	setting the type of the 'object' parameter of the BeginInvoke
	method to System.IAsyncResult instead of System.Object ;-)

2002-04-26  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (ConstructorInitializer.Resolve): Also use DeclaredOnly
	here. 

	(Constructor.Emit): return if we fail to initialize the
	constructor.  Another door closed!  

	* expression.cs (New.DoResolve): Improve error message (from -6 to
	1501).  Use DeclaredOnly lookup to find the exact constructor.

	* typemanager.cs (MemberLookup): If DeclaredOnly is set, do not
	loop.  This is useful.

	* cs-parser.jay: Adjust the default parameters so that destructors
	have the proper signature.

2002-04-26  Martin Baulig  <martin@gnome.org>

	* driver.cs (LoadAssembly): If `assembly' contains any characters
	which are only valid in path names and not in assembly names
	(currently slash, backslash and point), use Assembly.LoadFrom ()
	instead of Assembly.Load () on the `assembly' (before iteration
	over the link_paths).

2002-04-26  Martin Baulig  <martin@gnome.org>

	* cs-tokenizer.cs (is_hex): Correctly handle lowercase chars.

2002-04-25  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Property): use the new typemanager.MemberLookup

	(TypeContainer.MemberLookup): Implement using the
	TypeManager.MemberLookup now. 
	
	* typemanager.cs: Make MemberLookup a function of the TypeManager,
	and return MemberInfos, so that these can be used without an
	EmitContext (what we had before).

2002-04-24  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Fix the case where the argument to params if the
	type of the params.  I omitted handling this before.   Fixed

2002-04-22  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Call BootCorlib_PopulateCoreType

	* class.cs (Property.CheckBase): Check for properties only, not
	for all members. 

	* interface.cs: Temporary hack: try/catch around the
	CustomAttributeBuilder, because I am getting an exception that I
	do not understand.

	* rootcontext.cs (BootCorlib_PopulateCoreType): Populate some
	types whose definitions are required to be there (attributes are
	defined before standard types).

	Compute definitions as we boot the various types, as they are used
	immediately (value_type class will need object_type, but if we do
	not initialize object_type, we will pass a null, which will let
	the runtime pick the System.Object from the existing corlib, which
	is not what we want).

2002-04-22  Patrik Torstensson <totte@labs2.com>

	* cs-tokenizer.cs: fixed a number of trim() issues.

2002-04-22  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Argument.Type): Ensure that we return the correct
	type when we have out or ref parameters [in which case we 
	append a "&"].
	
2002-04-22  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Property, Indexer): Allow extern modifier in there. 

	* typemanager.cs (InitBaseTypes): Initializes object_type and
	value_type, since those will be used early on during the bootstrap
	process to compile corlib.

	(InitCoreTypes): Move code from here to InitBaseTypes.

2002-04-21  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (PropertyExpr): Optimize calls to Array::get_Length on
	single-dimension arrays as using the ldlen opcode.  

	Daniel Lewis discovered this optimization.  

	* typemanager.cs: Add signature for System.Array::get_Length

2002-04-20  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* statement.cs: report the error when the foreach does not apply to an
	array nor a collection.

2002-04-19  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Add implicit conversions to the operator ~.

	* constant.cs (DecimalConstant.Emit): Emit decimal value.

	* typemanager.cs: Locate the decimal constructor.

2002-04-17  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* attribute.cs: use the new property of TypeOf.
	* expression.cs: added 'get' property around typearg.

	These changes fix a build breaker reported by NickD. Is this the
	correct way to fix?  If not, please, revert my changes and make it
	work :-).

2002-04-17  Miguel de Icaza  <miguel@ximian.com>

	* attribute.cs: Add support for typeof in attribute invocations.
	I am not sure that this is right though.

2002-04-14  Duncan Mak  <duncan@ximian.com>

	* cfold.cs (BinaryFold): Catch DivideByZeroException in the
	Binary.Operator.Division case.

2002-04-13  Ravi Pratap  <ravi@ximian.com>

	* class.cs (DefineType): Ensure that we do a proper check on
	attribute types and also register it with the TypeManager.

	(TypeContainer.Targets): The default for attribute types is
	AttributeTargets.All.
	
	* attribute.cs (ApplyAttributes): Registering the attribute type
	is done elsewhere, not when we discover we have a Usage attribute.

2002-04-12  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (VerifyArgumentsCompat): Implement Miguel's suggestion
	and get rid of is_delegate parameter.

	* everywhere : update.
	
2002-04-12  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (compilation_unit): Revamp completely to use
	some new ideas that I got from Rhys' grammar to solve the problems
	with assembly level attributes.

	(outer_declaration): New grammar production.

	(attribute_sections): Add.

	(opt_attributes): Base on attribute_sections

	(namespace_declaration): Allow opt_attributes to tackle the case
	when we have assembly level attributes - we are clever in this
	regard now ;-)

	* attribute.cs (ApplyAttributes): Do not worry about assembly 
	attributes in the non-global context.

	* rootcontext.cs (AddGlobalAttributes): Go back to using this
	instead of SetGlobalAttributes.

	* class.cs, rootcontext.cs : Ensure we define and generate 
	attribute types before anything else.

	* attribute.cs (CheckAttribute and GetValidPlaces): Handle the exception
	and flag the new error -20 for the case when the attribute type
	does not have valid targets specified. csc does not catch this.

	* ../errors/errors.txt : update for error # -20

2002-04-11  Ravi Pratap  <ravi@ximian.com>

	* support.cs (InternalParameters.ParameterModifier): Do some null
	checking and return sane values.

	* class.cs (Method.Define): If we are a PInvoke method, ensure
	that we are static and extern. Report error # 601

	* ../errors/cs0601.cs : Add test case for the above error.

2002-04-07  Ravi Pratap  <ravi@ximian.com>

	* rootcontext.cs (attribute_types): We need to keep type of
	all attribute types separately and emit code for them first.

	(RegisterAttribute) : Implement.

	* class.cs (DefineType): Check if the current Type is a custom
	attribute type and register it accordingly.

	* rootcontext.cs (AddGlobalAttributes): Fix silly bug where we were
	adding the first attribute twice and rename to

	(SetGlobalAttributes): this.

	* rootcontext.cs (NamespaceLookup): Run through the aliases too and perform
	lookups.

	* attribute.cs (ApplyAttributes): Take an additional argument telling us
	if we are processing global arguments. Hmm, I am unsure of this.

2002-04-12  Gonzalo Paniagua Javier <gonzalo@ximian.com>

	* expression.cs: added static array of strings to avoid calling
	Enum.ToString () for Operator in Binary. Significant recover of
	performance.

2002-04-10  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (FindMembers): Allow the Builders of the various
	members to be null.  If they are skip them.  This only happens
	during the PInvoke declaration.

2002-04-09  Miguel de Icaza  <miguel@ximian.com>

	* parameter.cs (Parameters.ComputeParameterTypes): Flag the
	failure, so we do not keep going afterwards.

	* expression.cs: (Invocation.OverloadResolve): I believe Ravi
	wanted to pass `false' as the `is_delegate' argument.  If this is
	the case, why not use delegate_type == null to mean `is_delegate =
	false' and anything else as is_delegate = true.

Tue Apr  9 05:40:12  2002 Piers Haken <piersh@friskit.com>

	* statement.cs: fixed SimpleSwitchEmit to make 'goto case' goto the
	code for the section, not the beginning of the tests.

2002-04-08  Miguel de Icaza  <miguel@ximian.com>

	* cfold.cs: Handle operator + (Enum x, Underlying x) 

	* expression.cs (Binary): same.  Warn about errors where we have
	Enum/Enum in operator + as well.

Mon Apr  8 06:29:03  2002 Piers Haken <piersh@friskit.com>

	* statement.cs:
		- added support for switch(bool)
		- optimize loading of I8/U8 constants (ldc.i4, iconv_i8)
		- add TableSwitchEmit() to handle table-based switch statements

2002-04-05  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Invocation.OverloadResolve): Factor out code which
	does parameter compatibility checking with arguments so that we can 
	re-use the code even from Delegate.VerifyApplicability

	(VerifyArgumentsCompat): Move above code here.

	* delegate.cs (VerifyApplicability): Get rid of duplicate code
	and instead make a call to the above method.

2002-03-31  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (attribute_type): Corresponds to System.Attribute.
	We use it to keep track of classes which are attribute types.

2002-04-02  Miguel de Icaza  <miguel@ximian.com>

	* delegate.cs (Delegate.Define): Correctly define the types in the
	presence of fixed and array parameters.

	* class.cs (TypeContainers.FindMembers): Use NonPublic flag while
	doing FindMembers.

	* ecore.cs (Expression.MemberLookup): Reset binding flags to not
	include NonPublic after the first iteration.

	* class.cs (Indexer.CheckBase): Only check if both parents are
	non-null. 
	
	* cs-parser.jay (accessor_body): If empty, set to null.

	* ecore.cs (SimpleName.SimpleNameResolve): We did not have the
	same code path here to resolve constants names that we did have in
	MemberAccess.DoResolve.  There is too much code duplicated here.

2002-04-01  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs, makefile: Drop Statementcollection and just use ArrayLists

	* ecore.cs: Optimize UserDefinedConversion by minimizing the calls
	to MakeUnionSet.

	* cs-tokenizer.cs: Reuse a single StringBuilder for assembling
	tokens, numbers and strings.

	* ecore.cs (MethodGroupExpr): Make Emit warn about missing
	parenthesis.

	* delegate.cs: Use ComputeAndDefineParameterTypes for both the
	asyncronous parameters and the regular parameters.  

	* codegen.cs (CodeGen.Init): Use the constructor that allows us to
	specify the target directory.

	* expression.cs: (This.DoResolve): Simplify
	(As.Emit): Optimize, do not generate IsInst if the expression is
	always of the given type.

	(Is.DoResolve): Bug fix, we were reporting both always/never for
	the is expression.

	* (Invocation.MakeUnionSet): Simplify vastly and optimize, we were
	creating too many unnecessary arrays.

2002-03-31  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (EmitFieldInitializer): Use Assign expression to assign
	fields instead of rolling our own initializer.   Takes care of all
	implicit conversions, and drops unnecessary static checks/argument.

2002-03-31  Dick Porter  <dick@ximian.com>

	* driver.cs: use the GetDirectories() return values properly, and
	use "/" as path separator.

2002-03-30  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Unary): Optimize - - expr into expr.
	(Binary): Optimize a + (-b) into a -b.

	* codegen.cs (CodeGen): Made all methods static.

2002-03-29  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs: 

	* decl.cs: Rename `definition' into `TypeBuilder' and drop the
	TypeBuilder property.

	* cs-parser.jay: Drop the use of RecordXXX and use RecordDecl
	instead. 

	* tree.cs: Removed the various RecordXXXX, and replaced with a
	single RecordDecl.  Removed all the accessor methods, and just
	left a single access point Type 

	* enum.cs: Rename DefineEnum to DefineType.

	* decl.cs: New abstract method `DefineType' used to unify the
	Defines for Enumerations, Interfaces, TypeContainers and
	Delegates.

	(FindType): Moved LookupInterfaceOrClass here.  Moved the
	LookupBaseClasses method that used to live in class.cs and
	interface.cs here, and renamed to FindType.
	
	* delegate.cs: Implement DefineType.  Take advantage of the
	refactored pattern for locating the parent builder without taking
	the parent_builder argument (which we know does not work if we are
	nested, and triggering a toplevel definition).

2002-03-28  Miguel de Icaza  <miguel@ximian.com>

	* decl.cs (MemberCore.CheckMethodAgainstBase): Test if the
	accessibility of a member has changed during override and report
	an error if so.

	* class.cs (Method.Define, Property.Define): Only complain on
	overrides if the method is private, any other accessibility is
	fine (and since we just checked the permission is the same, we are
	good to go).

	* cs-tokenizer.cs: only line, region, endregion, if, endif, else
	and elif are processed always.  The other pre-processing
	directives are only processed if we are "taking" the path

2002-03-29  Martin Baulig  <martin@gnome.org>

	* class.cs (Method.Emit): Only emit symbolic debugging info if the
	current location is not Null.

	* codegen.cs (CodeGen.SaveSymbols): Split out symbol writing code into
	a separate method so we can profile it.

	* driver.cs (ShowTime): We need to use `(int) span.TotalSeconds' since
	`span.Seconds' are just seconds, but no minutes or hours.
	(MainDriver): Profile the CodeGen.SaveSymbols calls.

2002-03-28  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Method.Define), (Property.Define), (Indexer.Define):
	Remove the gratuitous set of Final:

				// If an interface implementation, then we can set Final.
				if (((flags & MethodAttributes.Abstract) == 0) &&
				    implementing.DeclaringType.IsInterface)
					flags |= MethodAttributes.Final;

        I do not know what I was smoking when I used that.
	

	* cs-parser.jay, delegate.cs: Make Delegate be a DeclSpace, first
	step into fixing the name resolution issues for delegates and
	unifying the toplevel name resolution.

2002-03-28  Martin Baulig  <martin@gnome.org>

	* class.cs (Method.Emit): If we have a symbol writer, call its
	OpenMethod(), CloseMethod() and SetMethodSourceRange() methods to
	tell it about the current method.

	* codegen.cs (EmitContext.Mark): New public method. Tell the symbol
	writer that we're going to emit the first byte of IL code for a new
	statement (a new source line).
	(EmitContext.EmitTopBlock): If we have a symbol writer, call
	EmitContext.Mark() before emitting any code.

	* location.cs (SymbolDocument): Return null when we're Null.

	* statement.cs (Statement): Moved the `Location loc' variable here.
	(Statement.EmitBoolExpression): If we have a symbol writer, call
	ec.Mark() before emitting any code to tell it that we're at the
	beginning of a new statement.
	(StatementExpression): Added `Location' argument to the constructor.
	(Block): Added public readonly variable `StartLocation' and public
	variable `EndLocation'.  The latter is to be set using SetEndLocation().
	(Block): Added constructor which takes a start and end location.
	(Block.SetEndLocation): New method. This sets the end location.
	(Block.EmitMeta): If we have a symbol writer, tell it the names of the
	local variables we create.
	(Block.Emit): If we have a symbol writer, call ec.Mark() before emitting
	each statement and do also mark the begin and end of the block.

	* cs-parser.jay (block : OPEN_BRACE): Use the new `Block' constructor to
	tell it the current lexer.Location, use Location.Null for the end of the
	block.
	(block : OPEN_BRACE opt_statement_list CLOSE_BRACE): When closing the
	current block, set its end location using SetEndLocation().
	(statement_expression): StatementExpression constructor now takes the
	lexer.Location as additional argument.
	(for_statement, declare_local_variables): Likewise.
	(declare_local_variables): When creating a new implicit block, use the
	new Block constructor and pass it the lexer.Location.

2002-03-28  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (Expression.MemberLookup): On interfaces, lookup
	members also on the parent interfaces recursively.

2002-03-27  Miguel de Icaza  <miguel@ximian.com>

	* report.cs: Use new formats, since Gonzalo finished the missing
	bits. 

	* expression.cs (Binary.ResolveOperator): added missing operator|
	operator& and operator^ for bool/bool.

	* cs-parser.jay: CheckDef now takes a Location argument that is
	used to report errors more precisly (instead of reporting the end
	of a definition, we try to track something which is a lot closer
	to the source of the problem).

	* cs-tokenizer.cs: Track global token use, so we can properly flag
	the use of #define/#undef after the first token has been seen.

	Also, rename the reportXXXX to Error_DescriptiveName

	* decl.cs (DeclSpace.IsTopLevel): Move property here from
	TypeContainer, so that Enum and Interface can use this too.

	* class.cs (TypeContainer.LookupInterfaceOrClass,
	GetInterfaceOrClass, GetClassBases, DefineType): Drop the
	`builder' argument.  Typically this was used to pass the parent
	builder (a ModuleBuilder or a TypeBuilder from whoever triggered
	the definition).  

	The problem is that a nested class could trigger the definition of
	a toplevel class, and the builder would be obviously wrong in that
	case. 

	So we drop this argument, and we compute dynamically the
	TypeBuilder/ModuleBuilder (the correct information was available
	to us anyways from DeclSpace.Parent)

	* interface.cs (Interface.DefineInterface): Drop builder
	parameter cleanup like class.cs

	* enum.cs (Enum.DefineEnum): Drop builder parameter.  Clean up
	like class.cs

	* statement.cs (Switch.EmitObjectInteger): Emit short/ushort
	values. 

	(Try.Emit): Propagate the returns value from the statement.

	(Return.Emit): Even if we are leavning 

	* driver.cs: Catch IOExpcetion for Directory.GetFiles as well.

	* modifiers.cs: Fix the computation of MethodAttributes flags.

Tue Mar 26 21:14:36 CET 2002 Paolo Molaro <lupus@ximian.com>

	* driver.cs: allow compilation of files that start with '/'.
	Add a default case when checking the argument of --target.

2002-03-25  Miguel de Icaza  <miguel@ximian.com>

	* interface.cs: Implement the same search algorithm for types in
	the interface code.

	* delegate.cs: Do not allow multiple definition.

	* Recovered ChangeLog that got accidentally amputated

	* interface.cs (Interface.DefineInterface): Prevent from double definitions.

	* rootcontext.cs: Load manually enum to allow core classes to
	contain enumerations.

	* enum.cs, ecore.cs, driver.cs, attribute.cs, class.cs, expression.cs:
	Update to new static methods in TypeManager.

	* typemanager.cs (GetMethod, GetConstructor): Use our
	implementation of FindMembers to find the members, since during
	corlib compilation, the types are TypeBuilders and GetMethod and
	GetConstructor do not work.

	Make all methods in TypeManager static.

	(InitCodeHelpers): Split the functionality from
	the InitCodeTypes function.

	* driver.cs: Call InitCodeHelpers after we have populated the
	types. 

	* cs-parser.jay (delegate_declaration): we did not used to compute
	the delegate name correctly for void delegates.

2002-03-24  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs (RootContext): Init the interface_resolve_order
	and type_container_resolve_order always.

	(ResolveCore, BootstrapCorlib_ResolveClass,
	BootstrapCorlib_ResolveStruct): New functions to bootstrap the
	compiler when compiling with --nostdlib

	* class.cs (TypeContainer.DefineType): Check that our parent is
	not null.  This test is most important when we are bootstraping
	the core types.

	* codegen.cs: Split out the symbol writing code.

2002-03-25  Martin Baulig  <martin@gnome.org>

	* driver.cs (-g): Made -g an alias for --debug.

2002-03-24  Martin Baulig  <martin@gnome.org>

	* codegen.cs (SymbolWriter): New public variable. Returns the
	current symbol writer.
	(CodeGen): Added `bool want_debugging_support' argument to the
	 constructor. If true, tell the ModuleBuild that we want debugging
	support and ask it for the ISymbolWriter.
	(Save): If we have a symbol writer, call it's Close() method after
	saving the assembly.

	* driver.c (--debug): New command line argument to create a
	debugger information file.

	* location.cs (SymbolDocument): New public property. Returns an
	ISymbolDocumentWriter object for the current source file or null
	if we don't have a symbol writer.

2002-03-21  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs (LoadAssembly): Correctly return when all the paths
	have been tried and not before.

	* statement.cs (Switch.Emit): return the actual coverage for this
	statement (returns/not-returns)

	(Switch.SimpleSwitchEmit): Do not generate jumps to the end of the
	switch of the statement if we are the last switch section.  That
	kills two problems: try/catch problems (we used to emit an empty
	nop at the end) and switch statements where all branches would
	return. 

2002-03-19  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Add default assemblies (the equivalent to the
	Microsoft CSC.RSP file)

	* cs-tokenizer.cs: When updating `cols and setting it to zero,
	also update tokens_seen and set it to false.

	* driver.cs: Implement --recurse for Mike.

	* driver.cs (SplitPathAndPattern): Small bug fix, I was not
	correctly splitting out the paths.

2002-03-18  Miguel de Icaza  <miguel@ximian.com>

	* interface.cs (Interface.PopulateProperty): Instead of using
	`parent' as the declaration space for the set parameters, use
	`this' 

	* support.cs (InternalParameters): InternalParameters constructor
	takes a DeclSpace instead of a TypeContainer.

	* expression.cs (ArrayCreation.EmitDynamicInitializers): If value
	types are being initialized, load the address of it before calling
	the function.  

	(New): Provide a mechanism to disable the generation of local
	value type temporaries when the caller will be providing us with
	an address to store it.

	(ArrayCreation.EmitDynamicInitializers): Use it.

2002-03-17  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Invocation.EmitArguments): Only probe for array
	property if there is more than one argument.  Sorry about that.

	* class.cs (Invocation.EmitArguments): Fix to emit arguments for
	empty param arrays.
	
	* class.cs (Method.LabelParameters): Fix incorrect code path that
	prevented the `ParamArrayAttribute' from being applied to the
	params attribute.

2002-03-16  Miguel de Icaza  <miguel@ximian.com>

	* support.cs (ReflectionParameters): Correctly compute whether the
	last argument is a params array.  Fixes the problem with
	string.Split ('a')

	* typemanager.cs: Make the assemblies array always be non-null
	(empty, but non-null)

	* tree.cs (RecordDecl): New function that abstracts the recording
	of names.  This reports error 101, and provides a pointer to the
	previous declaration.  Fixes a crash in the compiler.

	* cs-parser.jay (constructor_declaration): Update to new grammar,
	and provide a constructor_body that can be empty.

2002-03-15  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Add support for --resources.

	* expression.cs: (FetchGetMethod, FetchAddressMethod, EmitAssign):
	Make all types for the various array helper methods be integer.

	* ecore.cs (Expression.ConvertNumericExplicit): Pass the
	CheckState to ConvCast.

	(ConvCast): Now it takes a `checked' state argument, to avoid
	depending on the emit context for the conversion, and just using
	the resolve time setting.

	* expression.cs (ArrayCreation.EmitArrayArguments): New function,
	instead of Invocation.EmitArguments.  We do not emit the original
	arguments, instead we emit those which have been converted to
	unsigned int expressions.

	* statement.cs (Block.EmitMeta): Drop tracking of indexes.

	* codegen.cs: ditto.

	* expression.cs (LocalVariableReference): Drop the use of the
	Store function that depended on the variable index.

	* statement.cs (VariableInfo): Drop the `Idx' property from this
	class, as this is not taking into account the indexes for
	temporaries tat we generate during the execution, getting the
	indexes wrong.

	* class.cs: First emit class initializers, then call the parent
	constructor. 

	* expression.cs (Binary): Fix opcode emision.
	(UnaryMutator.EmitCode): Support checked code generation

	* ecore.cs (MemberLookup): TypeManager.FindMembers will return
	matches for events for both the Static and Instance scans,
	pointing to the same element.   Fix that.

2002-03-14  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs (ResolveTree): Always set the
	interface_resolve_order, because nested interfaces will be calling
	into us.

	* class.cs (GetInterfaceOrClass): Track the same resolution
	process used by TypeManager.LookupType.  This fixes the nested
	type lookups in class declarations (separate path from
	LookupType). 

	(TypeContainer.DefineType): Also define nested interfaces.
	(TypeContainer.RegisterOrder): New public function used to
	register the order in which child interfaces need to be closed.

	Nested interfaces need to be closed after their parents have been
	created. 
	
	* interface.cs (InterfaceAttr): Put all the logic for computing
	the interface attribute here. 

	(DefineInterface): Register our interface order with the
	RootContext or with the TypeContainer depending on the case.

2002-03-12  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: rework foreach statement to work with the new
	changes to the policy on SimpleNames.
	
	* report.cs: support Stacktrace on warnings as well.

	* makefile: drop --unsafe and /unsafe from the compile.

2002-03-13  Ravi Pratap  <ravi@ximian.com>

	* ecore.cs (StandardConversionExists): Modify to take an Expression
	as the first parameter. Ensure we do null -> reference type conversion
	checking.

	* Everywhere : update calls accordingly, making use of MyEmptyExpr to store
	temporary Expression objects.

Wed Mar 13 12:32:40 CET 2002 Paolo Molaro <lupus@ximian.com>

	* interface.cs: workaround bug in method overloading resolution
	(there is already a bugzilla bug for it).

2002-03-12  Miguel de Icaza  <miguel@ximian.com>

	We could also solve this problem by having a separate path for
	performing type lookups, instead of DoResolve, we could have a
	ResolveType entry point, and only participating pieces of the
	production (simplename, deref, array) would implement this. 
	
	* codegen.cs (EmitContext): New field OnlyLookupTypes used to
	signal SimpleName to only resolve type names and not attempt to
	resolve anything else.

	* expression.cs (Cast): Set the flag.

	* ecore.cs (SimpleName): Use the OnlyLookupTypes flag

	* class.cs: Only report 108 if there is no `new' modifier.

	* cs-parser.jay: rework foreach statement to work with the new
	changes to the policy on SimpleNames.
	
	* report.cs: support Stacktrace on warnings as well.

	* makefile: drop --unsafe and /unsafe from the compile.

2002-03-11  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (SimpleName.SimpleNameResolve): Perform local variable
	lookups here, instead of doing that at parse time.  This means
	that our grammar will not introduce `LocalVariableReferences' as
	expressions at this point.  That solves the problem of code like
	this:

	class X {
	   static void Main ()
	   { int X = 1;
	    { X x = null }}}

	This is only half the fix.  The full fix requires parameters to
	also be handled in this way.

	* Everywhere: Use ec.DeclSpace on calls to LookupType, as this
	makes the use more obvious of the DeclSpace.  The
	ec.TypeContainer.TypeBuilder is now only used to pull the
	TypeBuilder for it.

	My theory is that I can get rid of the TypeBuilder completely from
	the EmitContext, and have typecasts where it is used (from
	DeclSpace to where it matters).  

	The only pending problem is that the code that implements Aliases
	is on TypeContainer, and probably should go in DeclSpace.

	* ecore.cs (SimpleName.SimpleNameResolve): Perform local variable
	lookups here, instead of doing that at parse time.  This means
	that our grammar will not introduce `LocalVariableReferences' as
	expressions at this point.  That solves the problem of code like
	this:

	class X {
	   static void Main ()
	   { int X = 1;
	    { X x = null }}}

	This is only half the fix.  The full fix requires parameters to
	also be handled in this way.

	* class.cs (Property.DefineMethod): When implementing an interface
	method, set newslot, when implementing an abstract method, do not
	set the flag (before we tried never setting it, or always setting
	it, which is the difference).
	(Indexer.DefineMethod): same.
	(Method.DefineMethod): same.

	* ecore.cs: Only set the status used flag if we get back a Field.

	* attribute.cs: Temporary hack, so Paolo can keep working.

2002-03-08  Ravi Pratap  <ravi@ximian.com>

	* attribute.cs (Attribute.UnmanagedType): This is to keep track of
	the unmanaged type in the case we have a MarshalAs attribute.

	(Resolve): Handle the case when we are parsing the special MarshalAs
	attribute [we need to store the unmanaged type to use later]
	
	* typemanager.cs (marshal_as_attr_type): Built in type for the 
	MarshalAs Attribute.

	* attribute.cs (ApplyAttributes): Recognize the MarshalAs attribute 
	on parameters and accordingly set the marshalling info.
	
2002-03-09  Miguel de Icaza  <miguel@ximian.com>

	* class.cs: Optimizing slightly by removing redundant code after
	we switched to the `NoTypes' return value.
	(Property.DefineMethod): use NoTypes here too.

	This fixes the bug I introduced in my last batch of changes.

2002-03-05  Ravi Pratap  <ravi@ximian.com>

	* tree.cs (RecordEnum): Add. We now keep track of enums too.

	* class.cs (LookupInterfaceOrClass): Check against the list of recorded
	Enums since those are types too. 

	* cs-parser.jay (enum_declaration): Record enums as we parse them.
	
	* enum.cs (DefineEnum): Return if the TypeBuilder has already been defined 
	thanks to a call during the lookup process.

2002-03-07  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Foreach): Lots of work to accomodate a particular
	kind of foreach statement that I had not kept in mind.  It is
	possible to have foreachs on classes that provide a GetEnumerator
	method that return objects that implement the "pattern" for using
	a foreach, there is no need to support GetEnumerator
	specifically. 

	This is needed to compile nant.

	* decl.cs: Only report 114 if the member is not `Finalize' and if
	the warning level is at least 2.

	* class.cs: Moved the compare function from Method to
	MethodSignature. 

	(MethodSignature.InheritableMemberSignatureCompare): Add new
	filter function that is used to extract inheritable methods from a
	class. 

	(Method.Define): Use the new `inheritable_method_signature_filter'
	delegate

	* cs-tokenizer.cs (get_cmd_arg): Do not add white space to the
	command. 

2002-03-06  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (Expression.ConvertReferenceExplicit): Removed dead code.

	* cs-parser.jay: Add opt_semicolon to the interface declaration.

	* expression.cs: Pass location information to
	ConvertImplicitStandard. 

	* class.cs: Added debugging code to track return values from
	interfaces. 

2002-03-05  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Is.DoResolve): If either side of the `is' is an
	interface, do not flag the warning.

	* ecore.cs (ImplicitReferenceConversion): We need a separate test
	for interfaces

	* report.cs: Allow for --fatal to be used with --probe.
	
	* typemanager.cs (NoTypes): Move the definition for the empty Type
	array here. 

	* class.cs (TypeContainer.FindMembers): Also look for methods defined by
	properties. 
	(TypeContainer.DefineProxy): New function used to proxy to parent
	implementations when implementing interfaces.
	(TypeContainer.ParentImplements): used to lookup if our parent
	implements a public function that is required by an interface.
	(TypeContainer.VerifyPendingMethods): Hook this up.

	* typemanager.cs (TypeManager, AddModule, AddAssembly): Make the
	`modules' and `assemblies' arraylists into arrays.  We only grow
	these are the very early start up of the program, so this improves
	the speedof LookupType (nicely measured).

	* expression.cs (MakeByteBlob): Replaced unsafe code with
	BitConverter, as suggested by Paolo.

	* cfold.cs (ConstantFold.Binary): Special case: perform constant
	folding of string concatenation, but if either side is a string,
	and the other is not, then return null, and let the runtime use
	the concatenation on the string plus the object (using
	`Object.ToString'). 

2002-03-04  Miguel de Icaza  <miguel@ximian.com>

	Constant Folding has been implemented now.
	
	* expression.cs (Unary.Reduce): Do not throw an exception, catch
	the error instead on types that are not supported in one's
	complement. 

	* constant.cs (Constant and all children): New set of functions to
	perform implict and explicit conversions.
	
	* ecore.cs (EnumConstant): Implement the new functions to perform
	conversion by proxying to the child expression.

	* codegen.cs: (ConstantCheckState): Constant evaluation has its
	own separate setting that can not be turned off from the command
	line using --unchecked or --checked and is only controlled using
	the checked/unchecked statements and expressions.  This setting is
	used by the constant folder to flag errors.

	* expression.cs (CheckedExpr, UncheckedExpr): Set the
	ConstantCheckState as well.   

	During Resolve, they also have to flag the state, because the
	constant folder runs completely in the Resolve phase.

	* statement.cs (Checked, Unchecked): Set the ConstantCheckState as
	well.

2002-03-01  Miguel de Icaza  <miguel@ximian.com>

	* cfold.cs: New file, this file contains the constant folder.
	
	* ecore.cs (IMemoryLocation.AddressOf): Now takes an extra
	argument to track whether we are using the resulting address to
	load or store a value and provide better error messages. 

	(FieldExpr.Emit, FieldExpr.EmitAssign, FieldExpr.AddressOf): Use
	new AddressOf arguments.

	* statement.cs (Foreach.EmitCollectionForeach): Update

	* expression.cs (Argument.Emit): Call AddressOf with proper
	arguments to track usage.

	(New.DoEmit): Call AddressOf with new arguments.

	(Unary.Emit): Adjust AddressOf call.

2002-03-01  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (member_access): Change the case for pre-defined types
	to use a MemberAccess instead of a SimpleName. Thanks to Felix again for 
	this suggestion.

	* class.cs (Operator::Emit): If we are abstract or extern, we don't have
	a method body.

	* attribute.cs (CheckAttribute, ApplyAttribute): Ensure that we treat operators
	essentially like methods and apply attributes like MethodImplOptions to them too.

	* ecore.cs (SimpleName.SimpleNameResolve): Perform a check on ec.TypeContainer.TypeBuilder
	not being null.

	* codegen.cs (EmitContext): The constructor now takes in an extra argument specifying the
	DeclSpace as the distinction is important. We provide sane defaults as usually the TypeContainer
	is the DeclSpace.

	* Update code everywhere accordingly.

	* ecore.cs : Change references to ec.TypeContainer to ec.DeclSpace where appropriate.

	* cs-parser.jay (enum_declaration): Set the current namespace of the enum.

2002-02-28  Ravi Pratap  <ravi@ximian.com>

	* rootcontext.cs (LookupType): As we cycle through the chain of namespaces
	try performing lookups against those instead of jumping straight into using
	the 'using' clauses.

	(ImplicitParent): Add. Thanks to Felix Arrese-Igor for this idea.

	(LookupType): Perform lookups in implicit parents too.

	* class.cs (GetInterfaceOrClass): Modify to perform the exact same lookup
	sequence as RootContext.LookupType. 

	* rootcontext.cs (NamespaceLookup): Split out code from LookupType which tries 
	the various cases of namespace lookups into this method.

2002-03-01  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Add support for [Attribute ()] (empty arguments
	in positional arguments)

	* class.cs (Operator): Update the AllowedModifiers to contain
	extern. 

	* cs-parser.jay: Update operator declaration to allow for the
	operator body to be empty.

	* cs-tokenizer.cs: Added '\u' unicode support in strings and hex
	values. 

2002-02-27  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Method.Emit): Label parameters.

	* driver.cs: Return 1 or 0 as the program exit code.

2002-02-26  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Special case the `null' object when trying to
	auto-compute the type, as anything can be explicitly converted to
	that. 

	* ecore.cs (Expression.ConvertExplicit): Bug fix, thanks for
	spotting this Paolo.

	(Expression.ImplicitNumericConversion): Perform comparissions of
	the type using the underlying type in the case of an enumeration
	rather than using the enumeration type for the compare.

	Cope with the underlying == type case, which is not possible to
	catch before. 

	(Expression.ConvertNumericExplicit): Perform comparissions of
	the type using the underlying type in the case of an enumeration
	rather than using the enumeration type for the compare.

	* driver.cs: If the user does not supply an extension, assume .exe

	* cs-parser.jay (if_statement): Rewrote so that we can track the
	location for the if statement.

	* expression.cs (Binary.ConstantFold): Only concat strings when
	the operation is "+", not everything ;-)

	* statement.cs (Statement.EmitBoolExpression): Take a location
	argument. 
	(If, While, Do): Track location.

	* expression.cs (Binary.ResolveOperator): In the object + string
	case, I was missing a call to ConvertImplicit

2002-02-25  Ravi Pratap  <ravi@ximian.com>

	* parameter.cs (Parameter.ExternalType): Take in extra DeclSpace and
	Location arguments. Ensure we use RootContext.LookupType to do our work
	and not try to do a direct Type.GetType and ModuleBuilder.GetType

	* interface.cs (PopulateMethod): Handle the type of the parameter being
	null gracefully.

	* expression.cs (Invocation.BetterFunction): Handle the case when we 
	have a params method with no fixed arguments and a call is made with no
	arguments.

2002-02-25  Miguel de Icaza  <miguel@ximian.com>

	* cs-tokenizer.cs: Add support for the quote-escape-sequence in
	the verbatim-string-literal

	* support.cs (InternalParameters.ParameterModifier): handle null
	fixed parameters.
	(InternalParameters.ParameterType): ditto.

	* parameter.cs (VerifyArgs): Also check if the fixed parameter is
	duplicating the name of the variable parameter.
	(GetParameterByName): Fix bug where we were not looking up array
	paramters if they were the only present (thanks Paolo!).
	(GetParameterInfo): We only have an empty set of types if both
	fixed and array are set to null.
	(GetParameterInfo-idx): Handle FixedParameter == null

	* cs-parser.jay: Handle the case where there is no catch
	statements (missing null test).

2002-02-22  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs (MainDriver): Be conservative on our command line
	handling.

	Catch DirectoryNotFoundException when calling GetFiles.
	
	(SplitPathAndPattern): Used to split the input specification into
	a path and a pattern that we can feed to Directory.GetFiles.

2002-02-21  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Fixed): Implement the last case of the Fixed
	statement (string handling).

	* expression.cs (StringPtr): New class used to return a char * to
	a string;  Used by the Fixed statement.

	* typemanager.cs: Add char_ptr_type.  Add get_OffsetToStringData method.

	* expression.cs (Binary.ResolveOperator): Remove redundant
	MemberLookup pn parent type.
	Optimize union call, we do not need a union if the types are the same.
	(Unary.ResolveOperator): REmove redundant MemberLookup on parent
	type.

	Specialize the use of MemberLookup everywhere, instead of using
	the default settings. 

	(StackAlloc): Implement stackalloc keyword.

	* cs-parser.jay: Add rule to parse stackalloc.
	
	* driver.cs: Handle /h, /help, /?

	* expression.cs (MakeByteBlob): Removed the hacks we had in place
	before we supported unsafe code.
	
	* makefile: add --unsafe to the self compilation of mcs.

2002-02-20  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (PointerArithmetic): New class that is used to
	perform pointer arithmetic.
	(Binary.Resolve): Handle pointer arithmetic
	Handle pointer comparission.
	(ArrayPtr): Utility expression class that is used to take the
	address of an array.

	(ElementAccess): Implement array access for pointers
	
	* statement.cs (Fixed): Implement fixed statement for arrays, we
	are missing one more case before we are done.

	* expression.cs (Indirection): Implement EmitAssign and set the
	ExprClass to Variable.  This allows pointer dereferences to be
	treated as variables, and to have values assigned to them.
	
	* ecore.cs (Expression.StoreFromPtr): New utility function to
	store values dereferencing.

2002-02-20  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Binary.ResolveOperator): Ensure that we are
	not trying to operate on a void type - this fixes the reported
	bug.

	* decl.cs (CheckMethodAgainstBase): Do not allow overriding if
	the parent implementation is sealed.

	* ../errors/cs0239.cs : Add.

	* attribute.cs (ApplyAttributes): Handle Modulebuilders too.

	* typemanager.cs (unverifiable_code_type): Corresponds to 
	System.Security.UnverifiableCodeAttribute. We need to emit this for modules
	which have unsafe code in them.

	* rootcontext.cs (EmitCode): Emit the above attribute when we are in an 
	unsafe context.

2002-02-19  Miguel de Icaza  <miguel@ximian.com>

	* cs-tokenizer.cs: Add support for @"litreal strings"

	Make tokenizer accept pre-processor directives
	on any column (remove the old C-like limitation). 

	* rootcontext.cs (EmitCode): Emit any global attributes.
	(AddGlobalAttributes): Used to keep track of assembly attributes. 

	* attribute.cs (ApplyAttributes): Support AssemblyAttributes.

	* cs-parser.jay: Add support for global attributes.  

2002-02-17  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Indirection): New helper class.  Unary will
	create Indirection classes to be able to implement the
	IMemoryLocation interface on it.

2002-02-16  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay (fixed_statement): reference the right statement.

	* statement.cs (Fixed.Emit): Finish implementing the fixed
	statement for the &x case.

2002-02-14  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Property.Define, Method.Define): Remove newslot when
	`implementing'.  

	* modifiers.cs: My use of NewSlot when `Abstract' was set was
	wrong.  NewSlot should only be used if the `new' keyword is present.

	* driver.cs (GetSystemDir): Use CodeBase instead of FullName for
	locating our system dir.  Sorry about this.

2002-02-13  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs (GetSystemDir): Compute correctly the location of our
	system assemblies.  I was using the compiler directory instead of
	the library directory.

2002-02-13  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (BetterFunction): Put back in what Miguel commented out
	since it is the correct fix. The problem is elsewhere ;-)

	(IsParamsMethodApplicable): Fix bug where we were not checking that the fixed
	parameters of the parms method are themselves compatible or not !

	(StandardConversionExists): Fix very dangerous bug where we were forgetting
	to check that a class implements an interface before saying that an implicit
	conversion was allowed. Use ImplementsInterface to do the checking.

2002-02-13  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Method.Define): Track whether we are an explicit
	implementation or not.  And only call DefineMethodOverride if we
	are an explicit implementation.

	(Property.DefineMethod): Ditto.

2002-02-11  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (BetterFunction): Catch hideous bug which was
	 preventing us from detecting ambiguous calls due to implicit casts i.e
	cs0121.

2002-01-29  Miguel de Icaza  <miguel@ximian.com>

	* support.cs (Pair): Remove un-needed method.  I figured why I was
	getting the error in cs-parser.jay, the variable in a foreach loop
	is readonly, and the compiler does not really treat this as a variable.

	* cs-parser.jay (fixed_statement): Fix grammar.  Use ASSIGN
	instead of EQUALS in grammar.  

	* typemanager.cs (VerifyUnmanaged): Report correct error (208)

	* expression.cs (Unary.DoResolve): Check whether the argument is
	managed or not.

2002-01-28  Miguel de Icaza  <miguel@ximian.com>

	* support.cs: Api for Pair to set a value.  Despite the fact that
	the variables are public the MS C# compiler refuses to compile
	code that accesses the field if the variable is part of a foreach
	statement. 

	* statement.cs (Fixed): Begin implementation of the fixed
	statement.

	(Block.AddVariable): Return the VariableInfo on success and null
	on failure instead of true/false. 

	* cs-parser.jay (foreach): Catch errors on variables already
	defined (we were ignoring this value before) and properly unwind
	the block hierarchy

	(fixed_statement): grammar for the fixed statement.

2002-01-25  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (UnaryMutator.IsIncrementableNumber): Allow also
	pointer types to be incretemented.

	(SizeOf): Implement.

	* cs-parser.jay (pointer_member_access): Implement
	expr->IDENTIFIER production.

	* expression.cs (IndexerAccess.DoResolve, ArrayAccess.DoResolve,
	MemberAccess.DoResolve, Invocation.DoResolve): Check for pointers
	on safe contexts.

	(Unary): Implement indirection.

	* ecore.cs (Expression.UnsafeError): Reports error 214 (pointer
	use in non-unsafe context).

	(SimpleName.DoResolve): Check for pointers in field access on safe
	contexts. 

	(Expression.LoadFromPtr): Factor the load-indirect code in this
	function.  This was duplicated in UnboxCast and ParameterReference

2002-01-24  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ComposedCast): report an error if a pointer cast
	is used in a safe region.

	* ecore.cs (Expression.ConvertExplicit): Add rules for implicit
	pointer type casts in unsafe context.

	* codegen.cs (EmitContext): Set up IsUnsafe.

	* cs-parser.jay (non_expression_type): Add productions for pointer
	casts. 

	* expression.cs (Invocation.EmitCall): Remove chunk of buggy
	code.  We should not use force into static mode if the method is
	not virtual.  Fixes bug in MIS

	* statement.cs (Do.Emit, While.Emit, For.Emit,
	Statement.EmitBoolExpression): Add support to Do and While to
	propagate infinite loop as `I do return' semantics.

	Improve the For case to also test for boolean constants.

	* attribute.cs (Attribute.ApplyAttributes): Add ParameterBuilder
	to the list of attributes we can add.

	Remove `EmitContext' argument.

	* class.cs (Method.Define): Apply parameter attributes.
	(Constructor.Define): Apply parameter attributes.
	(MethodCore.LabelParameters): Move here the core of labeling
	parameters. 

	* support.cs (ReflectionParameters.ParameterModifier,
	InternalParameters.ParameterModifier): Use IsByRef on the type and
	only return the OUT bit for these parameters instead of in/out/ref
	flags.

	This is because I miss-understood things.  The ParameterInfo.IsIn
	and IsOut represent whether the parameter has the [In] and [Out]
	attributes set.  

2002-01-22  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (FieldExpr.Emit): Release temporaries.

	* assign.cs (LocalTemporary.Release): new function.

	* codegen.cs (EmitContext.GetTemporaryStorage,
	EmitContext.FreeTemporaryStorage): Rework the way we deal with
	temporary storage.  Now we can "put back" localbuilders when we
	are done with them

2002-01-21  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (FieldExpr.Emit): Handle initonly fields specially: we
	need to make a copy of the variable to generate verifiable code.

2002-01-19  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Compute dynamically the system directory.

	* ecore.cs (CopyNewMethods): reworked, exposed, made public.
	Slower, but more generally useful.  Used by the abstract
	registering implementation. 

	* expression.cs (ResolveMemberAccess): Reorder the way we evaluate
	the rules for the special rule on Type/instances.  First check if
	we have the same name, and if so, try that special static path
	rather than the instance path.
	
2002-01-18  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Emit 642 (warning: possible empty statement) for
	for, while and if.

	* class.cs (TypeBuilder.DefineType): Do not allow inheritance from
	Enum, ValueType, Delegate or Array for non-corlib compiles.

	* cs-tokenizer.cs: Catch long identifiers (645)

	* typemanager.cs (IndexerPropetyName): Ravi never tested this
	piece of code.

	* class.cs (TypeContainer.RegisterRequiredImplementations): Bug
	fix, we were returning too early, so we were not registering
	pending methods from abstract classes.

	Do not register pending methods if the class is abstract.

	* expression.cs (Conditional.DoResolve): Report circular implicit
	conversions when we neecd to compute it for conditional
	expressions. 

	(Is.DoResolve): If the expression is always of the provided type,
	flag warning 183.  If the expression can not ever be of the
	provided type flag warning 184.

	* class.cs: Catch 169 as well.

	* ecore.cs (FieldExpr): For now in AddressOf mark as assigned and
	read. 

2002-01-18  Nick Drochak  <ndrochak@gol.com>

	* makefile: remove path to beta2 csc.exe.  path to csc.exe must be in PATH instead.

2002-01-17  Miguel de Icaza  <miguel@ximian.com>

	* interface.cs: (PopulateMethod): Check for pointers being defined
	only if the unsafe context is active.
	(PopulateProperty): ditto.
	(PopulateIndexer): ditto.

	* class.cs (Method, Method.Define): Allow `unsafe' modifier to be
	specified.  If pointers are present, make sure that they are
	present in an unsafe context.
	(Constructor, Constructor.Define): ditto.
	(Field, Field.Define): ditto.
	(Property, Property.Define): ditto.
	(Event, Event.Define): ditto.

	* interface.cs (Interface.GetInterfaceTypeByName): Only lookup the
	hashtable if there are classes or structs defined.

	* expression.cs (LocalVariableReference.DoResolve): Simplify this
	code, as the constant resolution moved.

	* statement.cs (Block.EmitMeta): Resolve all constants as we emit
	the metadata, so we can flag error 133. 

	* decl.cs (MemberCore.UnsafeOK): New function to test that a
	pointer is being declared in an unsafe context.

2002-01-16  Miguel de Icaza  <miguel@ximian.com>

	* modifiers.cs (Modifiers.Check): Require a Location argument.
	Report error 227 for Unsafe use.

	* typemanager.cs: Remove IsPointerType, we should be using Type.IsPointer

	* statement.cs (For.Emit): If the test is null, then report that
	we do `return', as we wont reach anything afterwards.

	(Switch.SwitchGoverningType): Track the expression that matched
	the conversion.

	* driver.cs: Allow negative numbers as an error code to flag.

	* cs-parser.jay: Handle 1551.

	* namespace.cs: Add 1537 checking (repeated using alias namespaces).

2002-01-15  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Report 1518 (type declaration can only contain
	class, struct, interface, enum or delegate)

	(switch_label): Report 1523 (keywords `case' or `default' must
	preced code)

	(opt_switch_sections): Report 1522 (empty switch)

	* driver.cs: Report 1515 (response file specified multiple times)
	Report 1516 (Source file specified multiple times).

	* expression.cs (Argument.Resolve): Signal 1510

	(BaseAccess.Resolve, BaseIndexer.Resolve): Signal 1511 (base
	access not allowed in static code)

2002-01-11  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (IsPointerType): Utility method which we are going
	to need a lot.

	* ecore.cs (ImplicitReferenceConversion): A pointer type cannot be cast to
	the object type, so we take care of that.

	* expression.cs (FullMethodDesc): Also include the return type in descriptions.
	
	* support.cs (ParameterDesc): Fix minor bug which was causing params tags to be
	added to non-params parameters :-)

	* typemanager.cs (CSharpName): Include 'void' type too.	

	(void_ptr_type): Include in the set of core types.

	* ecore.cs (ConvertImplicit): Make use of ConvertImplicitStandard instead of 
	duplicating code.

	(ConvertImplicitStandard): Handle standard implicit pointer conversions when we have 
	an unsafe context.

	* cs-parser.jay (local_variable_pointer_type): Add support for 'void *' as I had 
	completely forgotten about it.

2002-01-10  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (pointer_type): Add. This begins our implementation
	of parsing rules for unsafe code.

	(unsafe_statement): Implement.

	(embedded_statement): Modify to include the above.

	* statement.cs (Unsafe): Implement new class for unsafe blocks.

	* codegen.cs (EmitContext.InUnsafe): Add. This determines
	if the current context is an unsafe one.

	* cs-parser.jay (local_variable_pointer_type): Since local variable types
	are handled differently, we need separate rules for them.

	(local_variable_declaration): Update to use local_variable_pointer_type
	to allow variable declarations of unmanaged pointer types.

	* expression.cs (Unary.ResolveOperator): Ensure that the '&' operator is used only
	in unsafe contexts.

	* ../errors/cs0214.cs : Add.

2002-01-16  Nick Drochak  <ndrochak@gol.com>

	* makefile: remove 'response' file when cleaning.

2002-01-15  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Report 1524.

2002-01-14  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (RegisterMethod): drop checking if we have
	registered this from here

2002-01-12  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Method.EmitDestructor): Implement calling our base
	destructor. 

	* statement.cs (Try.Emit): Fix to reset the InFinally to the old
	value of InFinally.

	* codegen.cs (EmitContext.EmitTopBlock): Destructors will call
	this routine and will wrap the call in a try/catch block.  Deal
	with the case.

2002-01-11  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (Expression.MemberLookup): instead of taking a
	parameter `same_type' that was used to tell whether we could
	access private members we compute our containing type from the
	EmitContext.

	(FieldExpr): Added partial support for volatile fields.  This does
	not work for volatile fields exposed from assemblies, as I can not
	figure out how to extract the modreq from it.

	Updated all the source files to use this.

	* codegen.cs (EmitContext): Compute ContainerType ahead of time,
	because it is referenced by MemberLookup very often. 

2002-01-09  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (IndexerPropertyName): If we have a TypeBuilder, use
	TypeBuilder.GetCustomAttributes to retrieve what we need.

	Get rid of redundant default_member_attr_type as this is the same as
	default_member_type which already exists.

	* interface.cs, attribute.cs : Update accordingly.
	
2002-01-08  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs: Enable IndexerPropertyName again.  It does not
	work for TYpeBuilders though.  Ravi, can you please fix this?

	* cs-tokenizer.cs: Accept _ as a name in pp-expressions.

	* expression.cs (Argument.Emit): Handle the case of ref objects
	being passed to ref functions;  

	(ParameterReference.EmitLoad): Loads the content of the pointer
	without dereferencing.

2002-01-07  Miguel de Icaza  <miguel@ximian.com>

	* cs-tokenizer.cs: Implemented the pre-processing expressions.

2002-01-08  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Indexer.DefineMethod): Incorporate the interface
	type in the name of the method if we are doing explicit interface
	implementation.

	* expression.cs (ConversionExists): Remove as it is completely obsolete.

	(BetterConversion): Fix extremely trivial bug where we were referring to
	ConversionExists instead of StandardConversionExists ! Hooray, things are fine
	again !

	* ../errors/bug16.cs : Add although we have fixed it.

2002-01-07  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (BaseIndexer): Begin implementation.

	* class.cs (TypeContainer.IsInterfaceMethod): Bug fix.

	* cs-parser.jay (indexer_declarator): Use qualified_identifier
	production directly to remove a shift/reduce, and implement
	explicit interface implementation.

	* cs-tokenizer.cs: Fix tokenizer, it was consuming one extra char
	after a floating point suffix.

	* expression.cs (DoNumericPromotions): Improved the conversion for
	uint/uint.  If we have a constant, we avoid doing a typecast to a
	larger type.

	* class.cs (Indexer): Implement explicit interface implementation
	for indexers.
	
Sat Jan 5 16:08:23 CET 2002 Paolo Molaro <lupus@ximian.com>

	* class.cs: make the default instance constructor public and hidebysig.

2001-01-03  Ravi Pratap  <ravi@ximian.com>

	* interface.cs (EmitDefaultMemberAttr): Make this helper method static
	so we can call it from elsewhere.

	* class.cs (TypeContainer.Emit): Emit the attribute here too. The rule is that
	we emit it internally if the class has a defined indexer; otherwise the user
	emits it by decorating the class definition with the DefaultMemberAttribute.

	* attribute.cs (ApplyAttributes): Perform checks to see that the DefaultMember
	attribute is not used on a type which defines an indexer.

	* cs-tokenizer.cs (get_cmd_arg): Ensure we trim whitespace and also include the tab
	character when we skip whitespace.

	* ../errors/cs0646.cs : Add.

2002-01-03  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (SimpleName.ResolveSimpleName): Report error 120
	again. 

	* makefile: Add practical target `mcs3.exe' which builds the third
	generation compiler. 

	* expression.cs (New): Fix structures constructor calling.

	* class.cs (Property, Method, Indexer): Emit Final flag on the
	method if we are an interface implementation and we are not
	abstract. 

	* ecore.cs (PropertyExpr): New public field `IsBase', tells
	whether this property is referencing a `base' method.

	* expression.cs (Invocation.EmitCall): take an extra argument:
	is_base, this is used to determine whether the `call' or
	`callvirt' opcode should be used.

	
	* delegate.cs: update EmitCall.

	* class.cs (Method.Define): Set NewSlot for the cases where we are
	not implementing an interface method.

	(Property.Define): ditto.

2002-01-02  Miguel de Icaza  <miguel@ximian.com>

	* cs-tokenizer.cs: (Tokenizer.escape): Escape '\r' as '\r' not as
	'r'.  Allows mcs to parse itself fully.

2002-01-02  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (ArrayCreation.num_automatic_initializers): Keep track
	of the number of initializers that require the InitializeArray method.

	(CheckIndices): Store the Expression in all cases - not the plain value. Also
	update the above field where necessary.

	(MakeByteBlob): Update accordingly.

	(DoEmit): Call EmitStaticInitializers only if the number of initializers is 
	greater than 2.

	(EmitDynamicInitializers): Update in accordance with the new optimization.

	(ArrayAccess.EmitStoreOpcode): Include char type along with short and ushort - the
	same OpCode applies.

	* cs-parser.jay : Fix some glaring errors I introduced.

2002-01-01  Ravi Pratap  <ravi@ximian.com> 

	* parameters.cs (AddVariable, AddConstant): Pass in current_local_parameters
	so that we can check for name clashes there too.

	* typemanager.cs (default_member_attr_type): The attribute that we need to emit
	for interface indexers.

	* interfaces.cs (Define): Emit the default member attribute.

	* expression.cs (MakeByteBlob): Fix extremely trivial bug where the wrong
	variable was being referred to while setting the value ;-)

2002-01-01  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (MakeByteBlob): Optimize: we do not need to fill
	byte-by-byte information when we know the data is zero.

	Make the block always a multiple of 4, because
	DefineInitializedData has a bug.

	* assign.cs: Fix, we should assign from the temporary, not from
	the source. 

	* expression.cs (MakeByteBlob): Fix my incorrect code.

2001-12-31  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (EnumToUnderlying): This function is used to get
	the underlying type from an enumeration, because it does not
	always work. 

	* constant.cs: Use the I4_S form for values between -128 and 127.

	* statement.cs (Block.LookupLabel): Looks up a label.
	(Block): Drop support for labeled blocks.

	(LabeledStatement): New kind of statement that represents a label
	only.

	(Goto): Finally implement this bad boy.
	
	* cs-parser.jay: Update to reflect new mechanism to implement
	labels.

2001-12-30  Miguel de Icaza  <miguel@ximian.com>

	* codegen.cs (EmitContext.This): a codegen property that keeps the
	a single instance of this instead of creating many different this
	instances. 

	* delegate.cs (Delegate.DoResolve): Update to use the property;

	* ecore.cs (SimpleName.SimpleNameResolve): Ditto

	* expression.cs (BaseAccess.DoResolve): Ditto.

2001-12-29  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (methodimpl_attr_type): Add to hold the type
	corresponding to System.Runtime.CompilerServices.MethodImplAttribute.

	(InitCoreTypes): Update accordingly.

	* attribute.cs (Resolve): Remember if the attribute is a MethodImplAttribute
	so we can quickly store the state.

	(ApplyAttributes): Set the correct implementation flags
	for InternalCall methods.

2001-12-29  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (EmitCall): if a method is not virtual, then do
	not use callvirt on it.

	(ArrayAccess.EmitAssign): storing non-builtin value types (ie,
	user defined stuff) requires the use of stobj, which takes an
	address on the stack instead of an array and an index.  So emit
	the Ldelema operation for it.

	(EmitStoreOpcode): Use stobj for valuetypes.

	(UnaryMutator.EmitCode): Use the right 1 value depending on
	whether we are dealing with int64/uint64, float or doubles.

	* class.cs (TypeContainer.AddConstructor): Fix the logic to define
	constructors that I implemented last night.

	(Constructor.IsDefault): Fix to work properly for static
	constructors.

	* cs-parser.jay (CheckDef): report method signature errors.
	Update error number 103 to be 132.

	* decl.cs: New AdditionResult enumeration value: MethodExists.
	Although we do this check for methods later on in the semantic
	analysis, catching repeated default constructors is so easy that
	we catch these here. 
	
	* expression.cs (Binary.DoNumericPromotions): Fix the uint64 type
	promotions code.

	(ParameterReference.EmitAssign, Emit): handle
	bools as bytes.

	(ArrayAccess.EmitLoadOpcode): Handle bool type here.
	(ArrayAccess.EmitStoreOpcode): ditto.

	* cs-tokenizer.cs (is_punct): Eliminated empty computation.

	* expression.cs (MakeByteBlob): Complete all the missing types
	(uint, short, ushort, byte, sbyte)

	* class.cs: Only init instance field initializers on instance
	constructors. 

	Rename `constructors' to instance_constructors. 

	(TypeContainer.AddConstructor): Only add constructors to the list
	if it is not static.

	Make sure that we handle default_static_constructor independently
	everywhere where we handle instance_constructors

2001-12-28  Miguel de Icaza  <miguel@ximian.com>

	* class.cs: Do not lookup or create a base initializer for a
	static constructor.

	(ConstructorInitializer.Resolve): use the proper type to lookup
	for constructors.

	* cs-parser.jay: Report error 1585 (modifiers between type and name).

	* enum.cs, interface.cs: Remove CloseType, this is taken care by
	in DeclSpace. 

	* decl.cs: CloseType is now an virtual method, the default
	implementation just closes this type.
	
2001-12-28  Ravi Pratap  <ravi@ximian.com>

	* attribute.cs (DefinePInvokeMethod): Set the implementation flags
	to PreserveSig by default. Also emit HideBySig on such methods.

	Basically, set the defaults to standard values.

	* expression.cs (Invocation.BetterFunction): We need to make sure that for each
	argument, if candidate is better, it can't be worse than the best !

	(Invocation): Re-write bits to differentiate between methods being
	applicable in their expanded form and their normal form - for params
	methods of course.

	Get rid of use_standard everywhere as only standard conversions are allowed
	in overload resolution. 

	More spec conformance.
	
2001-12-27  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Add --timestamp, to see where the compiler spends
	most of its time.

	* ecore.cs (SimpleName.DoResolve): Do not create an implicit
	`this' in static code.

	(SimpleName.DoResolve): Implement in terms of a helper function
	that allows static-references to be passed upstream to
	MemberAccess.

	(Expression.ResolveWithSimpleName): Resolve specially simple
	names when called by MemberAccess to implement the special
	semantics. 

	(Expression.ImplicitReferenceConversion): Handle conversions from
	Null to reference types before others, as Null's type is
	System.Object. 

	* expression.cs (Invocation.EmitCall): Handle the special case of
	calling methods declared on a reference type from a ValueType
	(Base classes System.Object and System.Enum)

	(MemberAccess.Resolve): Only perform lookups on Enumerations if
	the left hand side is a TypeExpr, not on every enumeration. 

	(Binary.Resolve): If types are reference types, then do a cast to
	object on operators != and == of both arguments.
	
	* typemanager.cs (FindMembers): Extract instance and static
	members if requested.

	* interface.cs (PopulateProperty): Use void_type instead of null
	as the return type for the setter method.

	(PopulateIndexer): ditto.

2001-12-27  Ravi Pratap  <ravi@ximian.com>

	* support.cs (ReflectionParameters): Fix minor bug where we
	were examining the wrong parameter for the ParamArray attribute.

	Cope with requests for the type of the parameter at position
	greater than the params parameter's. We now return the element
	type of the params array as that makes more sense.

	* expression.cs (Invocation.IsParamsMethodApplicable): Update 
	accordingly as we no longer have to extract the element type
	ourselves.

	(Invocation.OverloadResolve): Update.

2001-12-27  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Foreach.GetEnumeratorFilter): Do not compare
	against IEnumerator, test whether the return value is a descendant
	of the IEnumerator interface.

	* class.cs (Indexer.Define): Use an auxiliary method to implement
	the other bits of the method definition.  Begin support for
	explicit interface implementation.

	(Property.DefineMethod): Use TypeManager.void_type instead of null
	for an empty return value.

2001-12-26  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (MemberAccess.ResolveMemberAccess): if we are
	dealing with a FieldExpr which is composed of a FieldBuilder, in
	the code path we did extract the constant, but we should have
	obtained the underlying value to be able to cast it (otherwise we
	end up in an infinite loop, this is what Ravi was running into).

	(ArrayCreation.UpdateIndices): Arrays might be empty.

	(MemberAccess.ResolveMemberAccess): Add support for section
	14.5.4.1 that deals with the special case of E.I when E is a type
	and something else, that I can be a reference to a static member.

	(ArrayCreation.MakeByteBlob): It is not an error to not be able to
	handle a particular array type to create byte blobs, it is just
	something we dont generate byteblobs for.

	* cs-tokenizer.cs (get_cmd_arg): Ignore \r in commands and
	arguments. 

	* location.cs (Push): remove the key from the hashtable that we
	are about to add.   This happens for empty files.

	* driver.cs: Dispose files after we have parsed them.

	(tokenize): new function that only runs the tokenizer on its
	input, for speed testing.

2001-12-26  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Event.Define): Define the private field only if there
	are no accessors defined.

	* expression.cs (ResolveMemberAccess): If there is no associated
	field with the event, that means we have an event defined with its
	own accessors and we should flag error cs0070 since transforming
	ourselves into a field is not valid in that case.

	* ecore.cs (SimpleName.DoResolve): Same as above.

	* attribute.cs (DefinePInvokeMethod): Set the default calling convention
	and charset to sane values.

2001-12-25  Ravi Pratap  <ravi@ximian.com>

	* assign.cs (DoResolve): Perform check on events only if they 
	are being accessed outside the declaring type.

	* cs-parser.jay (event_declarations): Update rules to correctly
	set the type of the implicit parameter etc.

	(add_accessor, remove_accessor): Set current local parameters.

	* expression.cs (Binary): For delegate addition and subtraction,
	cast the return value from the method into the appropriate delegate
	type.

2001-12-24  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (RegisterDelegateData, GetDelegateData): Get rid
	of these as the workaround is unnecessary.

	* delegate.cs (NewDelegate.DoResolve): Get rid of bits which registered
	delegate data - none of that is needed at all.

	Re-write bits to extract the instance expression and the delegate method
	correctly.

	* expression.cs (Binary.ResolveOperator): Handle the '-' binary operator 
	on delegates too.

	* attribute.cs (ApplyAttributes): New method to take care of common tasks
	of attaching attributes instead of duplicating code everywhere.

	* everywhere : Update code to do attribute emission using the above method.

2001-12-23  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (IsParamsMethodApplicable): if there are not
	parameters, return immediately.

	* ecore.cs: The 0 literal can be implicity converted to an enum
	type. 

	(SimpleName.DoResolve): First lookup the type, then lookup the
	members. 

	(FieldExpr.Emit): If the InstanceExpression is a ValueType, we
	want to get its address.  If the InstanceExpression is not
	addressable, store the result in a temporary variable, then get
	the address of it.

	* codegen.cs: Only display 219 errors on warning level or above. 

	* expression.cs (ArrayAccess): Make it implement the
	IMemoryLocation interface.

	(Binary.DoResolve): handle the operator == (object a, object b)
	and operator != (object a, object b) without incurring into a
	BoxedCast (because 5 != o should never be performed).

	Handle binary enumerator operators.

	(EmitLoadOpcode): Use Ldelema if the object we are loading is a
	value type, otherwise use Ldelem_ref.

	Use precomputed names;

	(AddressOf): Implement address of

	* cs-parser.jay (labeled_statement): Fix recursive block
	addition by reworking the production.

	* expression.cs (New.DoEmit): New has a special case:
		
		 If we are dealing with a ValueType, we have a few
		 situations to deal with:
		
		    * The target of New is a ValueType variable, that is
		      easy, we just pass this as the variable reference
		
		    * The target of New is being passed as an argument,
		      to a boxing operation or a function that takes a
		      ValueType.
		
		      In this case, we need to create a temporary variable
		      that is the argument of New.


2001-12-23  Ravi Pratap  <ravi@ximian.com>

	* rootcontext.cs (LookupType): Check that current_type is not null before
	going about looking at nested types.

	* ecore.cs (EventExpr.EmitAddOrRemove): Rename from EmitAssign as we do
	not implement the IAssignMethod interface any more.

	* expression.cs (MemberAccess.ResolveMemberAccess): Handle EventExprs specially
	where we tranform them into FieldExprs if they are being resolved from within
	the declaring type.

	* ecore.cs (SimpleName.DoResolve): Do the same here.

	* assign.cs (DoResolve, Emit): Clean up code considerably. 

	* ../errors/bug10.cs : Add.

	* ../errors/cs0070.cs : Add.

	* typemanager.cs : Use PtrHashtable for Delegate data hashtable etc.

	* assign.cs : Get rid of EventIsLocal everywhere.
	
2001-12-23  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (ConvertIntLiteral): finished the implementation.

	* statement.cs (SwitchLabel): Convert the value we are using as a
	key before looking up the table.

2001-12-22  Miguel de Icaza  <miguel@ximian.com>

	* codegen.cs (EmitTopBlock): Require a Location argument now.

	* cs-parser.jay (constructor_declarator): We need to setup
	current_local_parameters before we parse the
	opt_constructor_initializer, to allow the variables to be bound
	to the constructor arguments.

	* rootcontext.cs (LookupType): First lookup nested classes in our
	class and our parents before we go looking outside our class.

	* expression.cs (ConstantFold): Extract/debox the values at the
	beginnning. 

	* rootcontext.cs (EmitCode): Resolve the constants first before we
	resolve the types.  This is not really needed, but it helps debugging.

	* statement.cs: report location.
	
	* cs-parser.jay: pass location to throw statement.

	* driver.cs: Small bug fix.

	* report.cs: Updated format to be 4-zero filled digits.

2001-12-22  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (CheckIndices): Fix minor bug where the wrong
	variable was being referred to ;-)

	(DoEmit): Do not call EmitStaticInitializers when the 
	underlying type is System.Object.

2001-12-21  Ravi Pratap  <ravi@ximian.com>

	* ecore.cs (EventExpr.Resolve): Implement to correctly set the type
	and do the usual workaround for SRE.

	* class.cs (MyEventBuilder.EventType): New member to get at the type
	of the event, quickly.

	* expression.cs (Binary.ResolveOperator): Handle delegate addition.

	* assign.cs (Assign.DoResolve): Handle the case when the target
	is an EventExpr and perform the necessary checks.

	* ecore.cs (EventExpr.EmitAssign): Implement the IAssignMethod
	interface.

	(SimpleName.MemberStaticCheck): Include check for EventExpr.

	(EventExpr): Set the type in the constructor itself since we 
	are meant to be born fully resolved.

	(EventExpr.Define): Revert code I wrote earlier.
		
	* delegate.cs (NewDelegate.Resolve): Handle the case when the MethodGroup's
	instance expression is null. The instance expression is a This in that case
	or a null, depending on whether it is a static method or not.

	Also flag an error if the reference to a method is ambiguous i.e the MethodGroupExpr
	refers to more than one method.

	* assign.cs (DoResolve): Check whether the event belongs to the same Type container
	and accordingly flag errors.

2001-12-21  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Throw.Emit): Add support for re-throwing exceptions.

2001-12-22  Miguel de Icaza  <miguel@ximian.com>

	* location.cs (ToString): Provide useful rutine.

2001-12-21  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (Expression.ConvertIntLiteral): Do not return Constant
	objects, return the actual integral boxed.

	* statement.cs (SwitchLabel): define an ILLabel for each
	SwitchLabel. 
	
	(Switch.CheckSwitch): If the value is a Literal, extract
	the underlying literal.
	
	Also in the unused hashtable we had, add the SwitchLabel so we can
	quickly look this value up.

	* constant.cs: Implement a bunch of new constants.  Rewrite
	Literal based on this.  Made changes everywhere to adapt to this.
	
	* expression.cs (Expression.MakeByteBlob): Optimize routine by
	dereferencing array only once, and also copes with enumrations.

	bytes are two bytes wide, not one.

	(Cast): Perform constant conversions.
	
	* ecore.cs (TryImplicitIntConversion): Return literals instead of
	wrappers to the literals here.

	* expression.cs (DoNumericPromotions): long literals can converted
	to ulong implicity (this is taken care of elsewhere, but I was
	missing this spot).

	* ecore.cs (Expression.Literalize): Make the return type Literal,
	to improve type checking.

	* rootcontext.cs: Lookup for nested classes in our class hierarchy.

2001-12-20  Miguel de Icaza  <miguel@ximian.com>

	* literal.cs: Revert code from ravi that checked the bounds.  The
	bounds are sane by the definition of the type itself. 

	* typemanager.cs: Fix implementation of ImplementsInterface.  We
	need to actually look up in our parent hierarchy for interfaces
	implemented. 

	* const.cs: Use the underlying type for enumerations

	* delegate.cs: Compute the basename for the delegate creation,
	that should fix the delegate test case, and restore the correct
	Type Lookup semantics in rootcontext

	* rootcontext.cs: Revert Ravi's last patch.  The correct way of
	referencing a nested type with the Reflection API is using the "+"
	sign. 

	* cs-parser.jay: Do not require EOF token at the end.

2001-12-20  Ravi Pratap  <ravi@ximian.com>

	* rootcontext.cs (LookupType): Concatenate type names with
	a '.' instead of a '+' The test suite passes again.

	* enum.cs (Enum.DefineEnum): Set RTSpecialName on the 'value__'
	field of the enumeration.

	* expression.cs (MemberAccess.ResolveMemberAccess): Add support for
	the case when the member is an EventExpr.

	* ecore.cs (EventExpr.InstanceExpression): Every event which is not
	static has an associated instance expression.

	* typemanager.cs (RegisterEvent): The usual workaround, now for events.

	(GetAddMethod, GetRemoveMethod): Workarounds, as usual.

	* class.cs (Event.Define): Register event and perform appropriate checks
	for error #111.

 	We define the Add and Remove methods even if the use provides none because
	in that case, we provide default implementations ourselves.

	Define a private field of the type of the event. This is done by the CSC compiler
	and we should be doing it too ;-)

	* typemanager.cs (delegate_combine_delegate_delegate, delegate_remove_delegate_delegate):
	More methods we use in code we generate.

	(multicast_delegate_type, delegate_type): Two separate types since the distinction
	is important.

	(InitCoreTypes): Update accordingly for the above.

	* class.cs (Event.Emit): Generate code for default accessors that we provide

	(EmitDefaultMethod): Do the job in the above.

	* delegate.cs (DefineDelegate): Use TypeManager.multicast_delegate_type in the 
	appropriate place.

2001-12-20  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Indexer.Define): Fix bug, we were setting both Get/Set
	builders even if we were missing one.

	* interface.cs, class.cs, enum.cs: When calling DefineNestedType
	pass the Basename as our class name instead of the Name.  The
	basename will be correctly composed for us.

	* parameter.cs (Paramters): Now takes a Location argument.

	* decl.cs (DeclSpace.LookupType): Removed convenience function and
	make all the code call directly LookupType in RootContext and take
	this chance to pass the Location information everywhere.

	* Everywhere: pass Location information.

2001-12-19  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Constructor.Define): Updated way of detecting the
	length of the parameters.

	(TypeContainer.DefineType): Use basename as the type name for
	nested types.

	(TypeContainer.Define): Do not recursively define types here, as
	definition is taken care in order by the RootContext.

	* tree.cs: Keep track of namespaces in a per-file basis.

	* parameter.cs (Parameter.ComputeSignature): Update to use
	DeclSpace. 

	(Parameters.GetSignature): ditto.

	* interface.cs (InterfaceMethod.GetSignature): Take a DeclSpace
	instead of a TypeContainer.

	(Interface.SemanticAnalysis): Use `this' instead of our parent to
	resolve names.  Because we need to be resolve in our context, not
	our parents.
	
	* driver.cs: Implement response files.

	* class.cs (TypeContainer.DefineType): If we are defined, do not
	redefine ourselves.
	
	(Event.Emit): Emit the code for add/remove handlers.
	(Event.Define): Save the MethodBuilders for add/remove.

	* typemanager.cs: Use pair here too.

	* cs-parser.jay: Replaced use of DictionaryEntry for Pair because
	DictionaryEntry requires the first argument to be non-null.  
	
	(enum_declaration): Compute full name for registering the
	enumeration.
	
	(delegate_declaration): Instead of using
	formal_parameter_list, use opt_formal_parameter_list as the list
	can be empty.

	* cs-tokenizer.cs (PropertyParsing): renamed from `properties'
	(EventParsing): New property that controls whether `add' and
	`remove' are returned as tokens or identifiers (for events);

2001-12-19  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Event.Define): Revamp use of EventBuilder completely. We now
	use MyEventBuilder only and let it wrap the real builder for us.

	(MyEventBuilder): Revamp constructor etc.

	Implement all operations that we perform on EventBuilder in precisely the same
	way here too.

	(FindMembers): Update to use the EventBuilder member.

	(Event.Emit): Update accordingly.

2001-12-18  Ravi Pratap  <ravi@ximian.com>

	* class.cs (MyEventBuilder.Set*): Chain to the underlying builder
	by calling the appropriate methods.

	(GetCustomAttributes): Make stubs as they cannot possibly do anything
	useful.

	(Event.Emit): Use MyEventBuilder everywhere - even to set attributes.

2001-12-17  Ravi Pratap  <ravi@ximian.com>

	* delegate.cs (Delegate.Populate): Check that the return type
	and various parameters types are indeed accessible.

	* class.cs (Constructor.Define): Same here.

	(Field.Define): Ditto.

	(Event.Define): Ditto.

	(Operator.Define): Check that the underlying Method defined itself
	correctly - so it's MethodBuilder should not be null.

	* delegate.cs (DelegateInvocation.DoResolve): Bale out if the type of the Instance
	expression happens to be null.

	* class.cs (MyEventBuilder): Workaround for SRE lameness. Implement various abstract
	members but as of now we don't seem to be able to do anything really useful with it.

	(FindMembers): Handle events separately by returning the MyEventBuilder of the event,
	not the EventBuilder.

2001-12-18  Miguel de Icaza  <miguel@ximian.com>

	* cs-tokenizer.cs: Add support for defines.
	Add support for #if, #elif, #else, #endif
	
	(eval_var): evaluates a variable.
	(eval): stubbed for evaluating functions.

	* cs-parser.jay: Pass the defines information

	* driver.cs: Add --define command line option.

	* decl.cs: Move MemberCore here.

	Make it the base class for DeclSpace.  This allows us to catch and
	report 108 and 109 for everything now.

	* class.cs (TypeContainer.Define): Extract all the members
	before populating and emit the warning 108 (new keyword required
	to override) instead of having each member implement this.

	(MemberCore.Define): New abstract method, we will be using this in
	the warning reporting engine in Populate.
	
	(Operator.Define): Adjust to new MemberCore protocol. 

	* const.cs (Const): This does not derive from Expression, it is a
	temporary object we use to create fields, it is a MemberCore. 

	* class.cs (Method.Define): Allow the entry point to be in a
	specific class.

	* driver.cs: Rewrite the argument handler to clean it up a bit.

	* rootcontext.cs: Made it just an auxiliary namespace feature by
	making everything static.

	* driver.cs: Adapt code to use RootContext type name instead of
	instance variable.

	* delegate.cs: Remove RootContext argument.

	* class.cs: (Struct, TypeContainer, Class): Remove RootContext
	argument. 

	* class.cs (Event.Define): The lookup can fail.
	
	* cs-tokenizer.cs: Begin implementation of pre-procesor. 

	* expression.cs: Resolve the this instance before invoking the code.

2001-12-17  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Add a production in element_access that allows
	the thing to become a "type" reference.  This way we can parse
	things like "(string [])" as a type.

	Note that this still does not handle the more complex rules of
	casts. 
	

	* delegate.cs (Delegate.Populate): Register the delegage constructor builder here. 

	* ecore.cs: (CopyNewMethods): new utility function used to
	assemble the list of methods from running FindMembers.

	(MemberLookup): Rework FindMembers so that 

2001-12-16  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer): Remove Delegates who fail to be
	defined.

	* delegate.cs (Populate): Verify that we dont get null return
	values.   TODO: Check for AsAccessible.

	* cs-parser.jay: Use basename to emit error 574 (destructor should
	have the same name as container class), not the full name.

	* cs-tokenizer.cs (adjust_int): Fit the integer in the best
	possible representation.  

	Also implements integer type suffixes U and L.

2001-12-15  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ArrayCreation.DoResolve): We need to do the
	argument resolution *always*.

	* decl.cs: Make this hold the namespace.  Hold the root context as
	well.
	(LookupType): Move here.

	* enum.cs, class.cs, interface.cs: Adapt to new hierarchy.

	* location.cs (Row, Name): Fixed the code, it was always returning
	references to the first file.

	* interface.cs: Register properties defined through interfaces.

	* driver.cs: Add support for globbing on the command line

	* class.cs (Field): Make it derive from MemberCore as well.
	(Event): ditto.

2001-12-15  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Event::Define): Check that the type of the event is a delegate
	type else flag error #66.

	Also, re-use TypeContainer.MethodModifiersValid here too as the rules are the
	same.

	* attribute.cs (DefinePInvokeMethod): Handle named arguments and process
	values of EntryPoint, CharSet etc etc.

	Pass in the values to TypeBuilder.DefinePInvokeMethod; determine Type etc neatly.

	* class.cs (FindMembers): If a method is in transit, its MethodBuilder will
	be null and we should ignore this. I am not sure if this is really clean. Apparently,
	there's no way of avoiding hitting this because the call is coming from SimpleName.DoResolve,
	which needs this to do its work.

	* ../errors/cs0066.cs : Add.

2001-12-14  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs: (GetPropertyGetter, GetPropertyGetter): New
	helper functions.

	* class.cs: (MethodSignature.MethodSignature): Removed hack that
	clears out the parameters field.
	(MemberSignatureCompare): Cleanup

	(MemberCore): New base class used to share code between MethodCore
	and Property.

	(RegisterRequiredImplementations) BindingFlags.Public requires
	either BindingFlags.Instace or Static.  Use instance here.

	(Property): Refactored code to cope better with the full spec.

	* parameter.cs (GetParameterInfo): Return an empty array instead
	of null on error.

	* class.cs (Property): Abstract or extern properties have no bodies.

	* parameter.cs (GetParameterInfo): return a zero-sized array.

	* class.cs (TypeContainer.MethodModifiersValid): Move all the
	method modifier validation to the typecontainer so we can reuse
	this on properties.

	(MethodCore.ParameterTypes): return an empty sized array of types.

	(Property.Define): Test property modifier validity.

	Add tests for sealed/override too.

	(Method.Emit): abstract or extern methods have no bodies.

2001-12-14  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Method.IsPInvoke): Get rid of it as it is an expensive
	thing.

	(Method::Define, ::Emit): Modify accordingly.

	* expression.cs (Invocation::OverloadResolve): Handle error # 121.

	(ArrayCreation::MakeByteBlob): Handle floats and doubles.

	* makefile: Pass in /unsafe.

2001-12-13  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (MakeKey): Kill routine.
	
	* class.cs (TypeContainer.Define): Correctly define explicit
	method implementations (they require the full interface name plus
	the method name).

	* typemanager.cs: Deply the PtrHashtable here and stop using the
	lame keys.  Things work so much better.

	This of course broke everyone who depended on `RegisterMethod' to
	do the `test for existance' test.  This has to be done elsewhere.

	* support.cs (PtrHashtable): A hashtable that avoid comparing with
	the object stupid Equals method (because, that like fails all over
	the place).  We still do not use it.

	* class.cs (TypeContainer.SetRequiredInterface,
	TypeContainer.RequireMethods): Killed these two routines and moved
	all the functionality to RegisterRequiredImplementations.

	(TypeContainer.RegisterRequiredImplementations): This routine now
	registers all the implementations required in an array for the
	interfaces and abstract methods.  We use an array of structures
	which can be computed ahead of time to reduce memory usage and we
	also assume that lookups are cheap as most classes will not
	implement too many interfaces.

	We also avoid creating too many MethodSignatures.

	(TypeContainer.IsInterfaceMethod): Update and optionally does not
	clear the "pending" bit if we find that there are problems with
	the declaration.

	(TypeContainer.VerifyPendingMethods): Update to report errors of
	methods that look like implementations but are not.

	(TypeContainer.Define): Add support for explicit interface method
	implementation. 
	
2001-12-12  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs: Keep track of the parameters here instead of
	being a feature of the TypeContainer.

	* class.cs: Drop the registration of parameters here, as
	InterfaceMethods are also interface declarations.

	* delegate.cs: Register methods with the TypeManager not only with
	the TypeContainer.  This code was buggy.

	* interface.cs: Full registation here.

2001-12-11  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Remove reducer for binary expressions, it can not
	be done this way.

	* const.cs: Put here the code that used to go into constant.cs

	* constant.cs: Put here the code for constants, this is a new base
	class for Literals.

	* literal.cs: Make Literal derive from Constant.

2001-12-09  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Return.Emit): Report error 157 if the user
	attempts to return from a finally block.

	(Return.Emit): Instead of emitting a return, jump to the end of
	the function.

	* codegen.cs (EmitContext): ReturnValue, ReturnLabel: new
	LocalBuilder to store the result of the function.  ReturnLabel is
	the target where we jump.
	

2001-12-09  Radek Doulik  <rodo@ximian.com>

	* cs-parser.jay: remember alias in current namespace

	* ecore.cs (SimpleName::DoResolve): use aliases for types or
	namespaces

	* class.cs (LookupAlias): lookup alias in my_namespace

	* namespace.cs (UsingAlias): add alias, namespace_or_type pair to
	aliases hashtable
	(LookupAlias): lookup alias in this and if needed in parent
	namespaces

2001-12-08  Miguel de Icaza  <miguel@ximian.com>

	* support.cs: 

	* rootcontext.cs: (ModuleBuilder) Made static, first step into
	making things static.  I need this to avoid passing the
	TypeContainer when calling ParameterType.

	* support.cs (InternalParameters.ParameterType): Remove ugly hack
	that did string manipulation to compute the type and then call
	GetType.  Use Parameter.ParameterType instead.

	* cs-tokenizer.cs: Consume the suffix for floating values.

	* expression.cs (ParameterReference): figure out whether this is a
	reference parameter or not.  Kill an extra variable by computing
	the arg_idx during emission.

	* parameter.cs (Parameters.GetParameterInfo): New overloaded
	function that returns whether a parameter is an out/ref value or not.

	(Parameter.ParameterType): The type of the parameter (base,
	without ref/out applied).
	
	(Parameter.Resolve): Perform resolution here.
	(Parameter.ExternalType): The full type (with ref/out applied).

	* statement.cs (Using.Emit, Using.EmitExpression): Implement
	support for expressions on the using statement.

2001-12-07  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Using.EmitLocalVariableDecls): Split the
	localvariable handling of the using statement.

	(Block.EmitMeta): Keep track of variable count across blocks.  We
	were reusing slots on separate branches of blocks.

	(Try.Emit): Emit the general code block, we were not emitting it. 

	Check the type of the declaration to be an IDisposable or
	something that can be implicity converted to it. 

	Emit conversions if required.

	* ecore.cs (EmptyExpression): New utility class.
	(Expression.ImplicitConversionExists): New utility function.

2001-12-06  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Using): Implement.

	* expression.cs (LocalVariableReference): Support read only variables.

	* statement.cs: Remove the explicit emit for the Leave opcode.
	(VariableInfo): Add a readonly field.

2001-12-05  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (ConvCast): new class used to encapsulate the various
	explicit integer conversions that works in both checked and
	unchecked contexts.

	(Expression.ConvertNumericExplicit): Use new ConvCast class to
	properly generate the overflow opcodes.

2001-12-04  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs: The correct type for the EmptyExpression is the
	element_type, not the variable type.  Ravi pointed this out.

2001-12-04  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Method::Define): Handle PInvoke methods specially
	by using DefinePInvokeMethod instead of the usual one.

	* attribute.cs (DefinePInvokeMethod): Implement as this is what is called
	above to do the task of extracting information and defining the method.
	
2001-12-04  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (ArrayCreation::EmitStaticInitializers): Get rid
	of the condition for string type.

	(Emit): Move that here. 

	(ArrayCreation::CheckIndices): Keep string literals in their expression
	form.

	(EmitDynamicInitializers): Handle strings appropriately.

2001-12-04  Miguel de Icaza  <miguel@ximian.com>

	* codegen.cs (EmitContext): Replace multiple variables with a
	single pointer to the current Switch statement.

	* statement.cs (GotoDefault, Switch): Adjust to cleaned up
	EmitContext.

2001-12-03  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs 

	* statement.cs (GotoDefault), cs-parser.jay: Implement `goto
	default'.
	
	(Foreach.Emit): Foreach on arrays was not setting
	up the loop variables (for break/continue).

	(GotoCase): Semi-implented.
	
2001-12-03  Ravi Pratap  <ravi@ximian.com>

	* attribute.cs (CheckAttribute): Handle system attributes by using
	Attribute.GetAttributes to examine information we need.

	(GetValidPlaces): Same here.

	* class.cs (Method::Define): Catch invalid use of extern and abstract together.

	* typemanager.cs (dllimport_type): Core type for System.DllImportAttribute.

	* class.cs (Method.IsPinvoke): Used to determine if we are a PInvoke method.

	(Method::Define): Set appropriate flags if we have a DllImport attribute.

	(Method::Emit): Handle the case when we are a PInvoke method.

2001-12-03  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Use ResolveWithSimpleName on compound names.

2001-12-02  Ravi Pratap  <ravi@ximian.com>

	* constant.cs (EmitConstant): Make sure we resolve the associated expression
	before trying to reduce it.

	* typemanager.cs (RegisterConstant, LookupConstant): Implement.

	* constant.cs (LookupConstantValue): Implement.

	(EmitConstant): Use the above in emitting the constant.

	* expression.cs (MemberAccess::ResolveMemberAccess): Handle constants
	that are user-defined by doing a LookupConstantValue on them.

	(SimpleName::DoResolve): When we have a FieldExpr, cope with constants
	too, like above.

2001-11-29  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (BaseAccess, BaseIndexer): Also split this out.

	(BaseAccess.DoResolve): Implement.

	(MemberAccess.DoResolve): Split this routine into a
	ResolveMemberAccess routine that can be used independently

2001-11-28  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Probe, Is, As): Split Probe in two classes Is and
	As that share bits of the implementation.  Is returns a boolean,
	while As returns the Type that is being probed.

2001-12-01  Ravi Pratap  <ravi@ximian.com>

	* enum.cs (LookupEnumValue): Re-write various bits, return an object value
	instead of a Literal - much easier.

	(EnumInTransit): Remove - utterly useless :-)

	(Populate): Re-write bits - remove duplicate code etc. The code is much neater now.

	* expression.cs (MemberLookup): Cope with user-defined enums when they are in transit.

	* enum.cs (LookupEnumValue): Auto-compute next values by going down the dependency
	chain when we have no associated expression.

2001-11-30  Ravi Pratap  <ravi@ximian.com>

	* constant.cs (Define): Use Location while reporting the errror.

	Also emit a warning when 'new' is used and there is no inherited
	member to hide.

	* enum.cs (EnumInTransit): Used to tell if an enum type is in the process of being 
	populated.

	(LookupEnumValue): Implement to lookup an enum member's value and define it
	if necessary.

	(Populate): Re-write accordingly to use the above routine.

2001-11-27  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (This): Fix prototype for DoResolveLValue to
	override the base class DoResolveLValue.

	* cs-parser.cs: Report errors cs574 and cs575 (destructor
	declarations) 

	* ecore.cs (FieldExpr.EmitAssign): Handle value types specially
	(we need to load the address of the field here).  This fixes
	test-22. 
	
	(FieldExpr.DoResolveLValue): Call the DoResolve
	function to initialize the Instance expression.
	
	* statement.cs (Foreach.Emit): Fix the bug where we did not invoke
	correctly the GetEnumerator operation on a value type.

	* cs-parser.jay: Add more simple parsing error catches.

	* statement.cs (Switch): Add support for string switches.
	Handle null specially.

	* literal.cs (NullLiteral): Make NullLiteral objects singletons. 

2001-11-28  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (local_constant_declaration): Use declare_local_constant.

	(declare_local_constant): New helper function.

	* statement.cs (AddConstant): Keep a separate record of constants

	(IsConstant): Implement to determine if a variable is a constant.

	(GetConstantExpression): Implement.

	* expression.cs (LocalVariableReference): Handle the case when it is a constant.

	* statement.cs (IsVariableDefined): Re-write.

2001-11-27  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer::FindMembers): Look for constants
	in the case when we are looking for MemberTypes.Field

	* expression.cs (MemberAccess::DoResolve): Check that in the
	case we are a FieldExpr and a Literal, we are not being accessed
	by an instance reference.

	* cs-parser.jay (local_constant_declaration): Implement.

	(declaration_statement): Implement for constant declarations.

2001-11-26  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Switch): Catch double defaults.

	(Switch): More work on the switch() statement
	implementation.  It works for integral values now, need to finish
	string support.


2001-11-24  Miguel de Icaza  <miguel@ximian.com>

	* ecore.cs (Expression.ConvertIntLiteral): New function to convert
	integer literals into other integer literals.  To be used by
	switch. 

2001-11-24  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (ArrayCreation): Get rid of ArrayExprs : we save
	some memory.

	(EmitDynamicInitializers): Cope with the above since we extract data
	directly from ArrayData now.

	(ExpectInitializers): Keep track of whether initializers are mandatory
	or not.

	(Bounds): Make it a hashtable to prevent the same dimension being 
	recorded for every element in that dimension.

	(EmitDynamicInitializers): Fix bug which prevented the Set array method
	from being found.

	Also fix bug which was causing the indices to be emitted in the reverse
	order.

2001-11-24  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ArrayCreation): Implement the bits that Ravi left
	unfinished.  They do not work, because the underlying code is
	sloppy.

2001-11-22  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Remove bogus fixme.

	* statement.cs (Switch, SwitchSection, SwithLabel): Started work
	on Switch statement.
	
2001-11-23  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (IsDelegateType, IsEnumType): Fix logic to determine
	the same. 
	
	* expression.cs (ArrayCreation::CheckIndices): Get rid of the require_constant
	parameter. Apparently, any expression is allowed. 

	(ValidateInitializers): Update accordingly.

	(CheckIndices): Fix some tricky bugs thanks to recursion.

	* delegate.cs (NewDelegate::DoResolve): Re-write large portions as 
	I was being completely brain-dead.

	(VerifyMethod, VerifyApplicability, VerifyDelegate): Make static
	and re-write acordingly.

	(DelegateInvocation): Re-write accordingly.

	* expression.cs (ArrayCreation::Emit): Handle string initialization separately.

	(MakeByteBlob): Handle types more correctly.

	* expression.cs (ArrayCreation:Emit): Write preliminary code to do
	initialization from expressions but it is incomplete because I am a complete
	Dodo :-|

2001-11-22  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (If.Emit): Fix a bug that generated incorrect code
	on If.  Basically, we have to return `true' (ie, we do return to
	our caller) only if both branches of the if return.

	* expression.cs (Binary.Emit): LogicalOr and LogicalAnd are
	short-circuit operators, handle them as short circuit operators. 

	(Cast.DoResolve): Resolve type.
	(Cast.Cast): Take an expression as the target type.

	* cs-parser.jay (cast_expression): Remove old hack that only
	allowed a limited set of types to be handled.  Now we take a
	unary_expression and we resolve to a type during semantic
	analysis.

	Use the grammar productions from Rhys to handle casts (this is
	not complete like Rhys syntax yet, we fail to handle that corner
	case that C# has regarding (-x), but we will get there.
	
2001-11-22  Ravi Pratap  <ravi@ximian.com>

	* class.cs (EmitFieldInitializer): Take care of the case when we have a
	field which is an array type.

	* cs-parser.jay (declare_local_variables): Support array initialization too.

	* typemanager.cs (MakeKey): Implement.

	(everywhere): Use the above appropriately.

	* cs-parser.jay (for_statement): Update for array initialization while
	declaring variables.

	* ecore.cs : The error message was correct, it's the variable's names that
	were misleading ;-) Make the code more readable.

	(MemberAccess::DoResolve): Fix the code which handles Enum literals to set
	the correct type etc.

	(ConvertExplicit): Handle Enum types by examining the underlying type.

2001-11-21  Ravi Pratap  <ravi@ximian.com>

	* parameter.cs (GetCallingConvention): Always return
	CallingConventions.Standard for now.

2001-11-22  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Binary.ResolveOperator): Update the values of `l'
	and `r' after calling DoNumericPromotions.

	* ecore.cs: Fix error message (the types were in the wrong order).

	* statement.cs (Foreach.ProbeCollectionType): Need to pass
	BindingFlags.Instance as well 

	* ecore.cs (Expression.TryImplicitIntConversion): Wrap the result
	implicit int literal conversion in an empty cast so that we
	propagate the right type upstream.

	(UnboxCast): new class used to unbox value types.
	(Expression.ConvertExplicit): Add explicit type conversions done
	by unboxing.

	(Expression.ImplicitNumericConversion): Oops, forgot to test for
	the target type before applying the implicit LongLiterals to ULong
	literal cast.

2001-11-21  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay (for_statement): Reworked the way For works: now
	we declare manually any variables that are introduced in
	for_initializer to solve the problem of having out-of-band code
	emition (that is what got for broken).

	(declaration_statement): Perform the actual variable declaration
	that used to be done in local_variable_declaration here.

	(local_variable_declaration): Do not declare anything, just pass
	the information on a DictionaryEntry

2001-11-20  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (ArrayCreation::CheckIndices): The story continues :-) Complete
	re-write of the logic to now make it recursive.

	(UpdateIndices): Re-write accordingly.

	Store element data in a separate ArrayData list in the above methods.

	(MakeByteBlob): Implement to dump the array data into a byte array.

2001-11-19  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (ArrayCreation): Factor out some code from ValidateInitializers
	into CheckIndices.

	* constant.cs (Define): Implement.

	(EmitConstant): Re-write fully.

	Pass in location info.

	* class.cs (Populate, Emit): Call Constant::Define and Constant::EmitConstant
	respectively.

	* cs-parser.jay (constant_declarator): Use VariableDeclaration instead of
	DictionaryEntry since we need location info too.

	(constant_declaration): Update accordingly.

	* expression.cs (ArrayCreation): Make ValidateInitializers simpler by factoring
	code into another method : UpdateIndices.

2001-11-18  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (ArrayCreation::ValidateInitializers): Update to perform
	some type checking etc.

2001-11-17  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (ArrayCreation::ValidateInitializers): Implement
	bits to provide dimension info if the user skips doing that.

	Update second constructor to store the rank correctly.

2001-11-16  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (ArrayCreation::ValidateInitializers): Poke around
	and try to implement.

	* ../errors/cs0150.cs : Add.

	* ../errors/cs0178.cs : Add.

2001-11-16  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs: Implement foreach on multi-dimensional arrays. 

	* parameter.cs (Parameters.GetParameterByName): Also lookup the
	name of the params argument.

	* expression.cs: Use EmitStoreOpcode to get the right opcode while
	initializing the array.

	(ArrayAccess.EmitStoreOpcode): move the opcode generation here, so
	we can use this elsewhere.

	* statement.cs: Finish implementation of foreach for single
	dimension arrays.

	* cs-parser.jay: Use an out-of-band stack to pass information
	around, I wonder why I need this.

	foreach_block: Make the new foreach_block the current_block.

	* parameter.cs (Parameters.GetEmptyReadOnlyParameters): New
	function used to return a static Parameters structure.  Used for
	empty parameters, as those are created very frequently.

	* cs-parser.jay, class.cs: Use GetEmptyReadOnlyParameters

2001-11-15  Ravi Pratap  <ravi@ximian.com>

	* interface.cs : Default modifier is private, not public. The
	make verify test passes again.

2001-11-15  Ravi Pratap  <ravi@ximian.com>

	* support.cs (ReflectionParameters): Fix logic to determine
	whether the last parameter is a params one. Test 9 passes again.

	* delegate.cs (Populate): Register the builders we define with
	RegisterParameterForBuilder. Test 19 passes again.

	* cs-parser.jay (property_declaration): Reference $6 instead
	of $$ to get at the location.

	(indexer_declaration): Similar stuff.

	(attribute): Ditto.

	* class.cs (Property): Register parameters for the Get and Set methods
	if they exist. Test 23 passes again.

	* expression.cs (ArrayCreation::Emit): Pass null for the method in the
	call to EmitArguments as we are sure there aren't any params arguments. 
	Test 32 passes again.

	* suppor.cs (ParameterDesc, ParameterModifier): Fix trivial bug causing
	IndexOutOfRangeException. 

	* class.cs (Property::Define): Register property using TypeManager.RegisterProperty
	Test 33 now passes again.
	
2001-11-15  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Kill horrendous hack ($??? = lexer.Location) that
	broke a bunch of things.  Will have to come up with a better way
	of tracking locations.

	* statement.cs: Implemented foreach for single dimension arrays.

2001-11-09  Miguel de Icaza  <miguel@ximian.com>

	* enum.cs (Enum.Emit): Delay the lookup of loc until we run into
	an error.  This removes the lookup from the critical path.

	* cs-parser.jay: Removed use of temporary_loc, which is completely
	broken. 

2001-11-14  Miguel de Icaza  <miguel@ximian.com>

	* support.cs (ReflectionParameters.ParameterModifier): Report
	whether the argument is a PARAMS argument or not.

	* class.cs: Set the attribute `ParamArrayAttribute' on the
	parameter argument.

	* typemanager.cs: Define param_array_type (ParamArrayAttribute)
	and cons_param_array_attribute (ConstructorInfo for
	ParamArrayAttribute)., 

	* codegen.cs: Emit the return using the `Return' statement, that
	way we can report the error correctly for missing return values. 

	* class.cs (Method.Emit): Clean up.

	* expression.cs (Argument.Resolve): Take another argument: the
	location where this argument is used.  Notice that this is not
	part of the "Argument" class as to reduce the size of the
	structure (we know the approximate location anyways).

	Test if the argument is a variable-reference, if not, then
	complain with a 206.

	(Argument.Emit): Emit addresses of variables.

	(Argument.FullDesc): Simplify.

	(Invocation.DoResolve): Update for Argument.Resolve.

	(ElementAccess.DoResolve): ditto.

	* delegate.cs (DelegateInvocation.Emit): Invocation of Invoke
	method should be virtual, as this method is always virtual.

	(NewDelegate.DoResolve): Update for Argument.Resolve.

	* class.cs (ConstructorInitializer.DoResolve): ditto.
	
	* attribute.cs (Attribute.Resolve): ditto.

2001-11-13  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Foreach.Emit): Use EmitAssign instead of Store.

	* expression.cs (ParameterReference): Drop IStackStorage and implement
	IAssignMethod instead. 

	(LocalVariableReference): ditto.
	
	* ecore.cs (FieldExpr): Drop IStackStorage and implement
	IAssignMethod instead. 

2001-11-13  Miguel de Icaza <miguel@ximian.com>

	* parameter.cs, expression.cs, class.cs, ecore.cs: Made all
	enumerations that are used in heavily used structures derive from
	byte in a laughable and pathetic attempt to reduce memory usage.
	This is the kind of pre-optimzations that you should not do at
	home without adult supervision.

	* expression.cs (UnaryMutator): New class, used to handle ++ and
	-- separatedly from the other unary operators.  Cleans up the
	code, and kills the ExpressionStatement dependency in Unary.

	(Unary): Removed `method' and `Arguments' from this class, making
	it smaller, and moving it all to SimpleCall, so I can reuse this
	code in other locations and avoid creating a lot of transient data
	strucutres when not required.

	* cs-parser.jay: Adjust for new changes.

2001-11-11  Miguel de Icaza  <miguel@ximian.com>

	* enum.cs (Enum.Populate): If there is a failure during
	definition, return

	* cs-parser.jay (opt_enum_base): we used to catch type errors
	here, but this is really incorrect.  The type error should be
	catched during semantic analysis.

2001-12-11  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (operator_declarator, conversion_operator_declarator): Set
	current_local_parameters as expected since I, in my stupidity, had forgotten
	to do this :-)

	* attribute.cs (GetValidPlaces): Fix stupid bug.

	* class.cs (Method::Emit): Perform check on applicability of attributes.

	(Constructor::Emit): Ditto.

	(Field::Emit): Ditto.

	(Field.Location): Store location information.

	(Property, Event, Indexer, Operator): Ditto.

	* cs-parser.jay (field_declaration): Pass in location for each field.

	* ../errors/cs0592.cs : Add.

2001-11-12  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (attribute_usage_type): New static member for System.AttributeUsage.

	(InitCoreTypes): Update accordingly.

	(RegisterAttrType, LookupAttr): Implement.

	* attribute.cs (Attribute.Targets, AllowMultiple, Inherited): New fields to hold
	info about the same.

	(Resolve): Update to populate the above as necessary.

	(Error592): Helper.

	(GetValidPlaces): Helper to the above.

	(CheckAttribute): Implement to perform validity of attributes on declarative elements.

	* class.cs (TypeContainer::Emit): Update attribute emission code to perform checking etc.

2001-11-12  Ravi Pratap  <ravi@ximian.com>

	* attribute.cs (Attribute::Resolve): Expand to handle named arguments too.

	* ../errors/cs0617.cs : Add.

2001-11-11  Ravi Pratap  <ravi@ximian.com>

	* enum.cs (Emit): Rename to Populate to be more consistent with what
	we expect it to do and when exactly it is called.

	* class.cs, rootcontext.cs : Update accordingly.

	* typemanager.cs (RegisterField, GetValue): Workarounds for the fact that
	FieldInfo.GetValue does not work on dynamic types ! S.R.E lameness strikes again !

	* enum.cs (Populate): Register fields with TypeManager.RegisterField.

	* expression.cs (MemberAccess.DoResolve): Adjust code to obtain the value
	of a fieldinfo using the above, when dealing with a FieldBuilder.

2001-11-10  Ravi Pratap  <ravi@ximian.com>

	* ../errors/cs0031.cs : Add.

	* ../errors/cs1008.cs : Add.

	* ../errrors/cs0543.cs : Add.

	* enum.cs (DefineEnum): Check the underlying type and report an error if not a valid
	enum type.

	(FindMembers): Implement.

	* typemanager.cs (FindMembers): Re-write to call the appropriate methods for
	enums and delegates too.

	(enum_types): Rename to builder_to_enum.

	(delegate_types): Rename to builder_to_delegate.

	* delegate.cs (FindMembers): Implement.

2001-11-09  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (IsEnumType): Implement.

	* enum.cs (Emit): Re-write parts to account for the underlying type
	better and perform checking etc.

	(GetNextDefaultValue): Helper to ensure we don't overshoot max value
	of the underlying type.

	* literal.cs (GetValue methods everywhere): Perform bounds checking and return
	value

	* enum.cs (error31): Helper to report error #31.

	* cs-parser.jay (enum_declaration): Store location of each member too.

	* enum.cs (member_to_location): New hashtable. 

	(AddEnumMember): Update location hashtable.

	(Emit): Use the location of each member while reporting errors.

2001-11-09  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: A for_initializer if is a
	local_variable_declaration really ammount to have an implicit
	block with the variable declaration and no initializer for for.

	* statement.cs (For.Emit): Cope with null initializers.

	This fixes the infinite loop on for initializers.

2001-11-08  Miguel de Icaza  <miguel@ximian.com>

	* enum.cs: More cleanup.

	* ecore.cs: Remove dead code.

	* class.cs (Property.Emit): More simplification.
	(Event.Emit): ditto.

	Reworked to have less levels of indentation.
	
2001-11-08  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Property): Emit attributes.

	(Field): Ditto.
	
	(Event): Ditto.

	(Indexer): Ditto.

	(Operator): Ditto.

	* enum.cs (Emit): Ditto.

	* rootcontext.cs (ResolveTree, EmitCode, CloseTypes): Do the same for
	Enums too.

	* class.cs (Field, Event, etc.): Move attribute generation into the
	Emit method everywhere.

	* enum.cs (Enum): Revamp to use the same definition semantics as delegates so
	we have a DefineEnum, CloseEnum etc. The previous way of doing things was not right
	as we had no way of defining nested enums !

	* rootcontext.cs : Adjust code accordingly.

	* typemanager.cs (AddEnumType): To keep track of enum types separately.

2001-11-07  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (EvalConstantExpression): Move into ecore.cs
	
	* enum.cs (Enum): Rename some members and make them public and readonly
	according to our convention.

	* modifiers.cs (EnumAttr): Implement as we need to set only visibility flags,
	nothing else.

	* enum.cs (Enum::Define): Use the above instead of TypeAttr.

	(Enum::Emit): Write a simple version for now which doesn't try to compute
	expressions. I shall modify this to be more robust in just a while.

	* class.cs (TypeContainer::Emit): Make sure we include Enums too.

	(TypeContainer::CloseType): Create the Enum types too.

	* attribute.cs (Resolve): Use the new Reduce method instead of EvalConstantExpression.

	* expression.cs (EvalConstantExpression): Get rid of completely.

	* enum.cs (Enum::Emit): Use the new expression reducer. Implement assigning
	user-defined values and other cases.

	(IsValidEnumLiteral): Helper function.

	* expression.cs (ExprClassfromMemberInfo): Modify to not do any literalizing 
	out there in the case we had a literal FieldExpr.

	(MemberAccess:DoResolve): Do the literalizing of the FieldExpr here.

	(Literalize): Revamp a bit to take two arguments.
	
	(EnumLiteral): New class which derives from Literal to wrap enum literals.
	
2001-11-06  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (compilation_unit): Remove extra opt_attributes for now.

	* expression.cs (ArrayCreation::ValidateInitializers): Implement.

	(Resolve): Use the above to ensure we have proper initializers.

2001-11-05  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Expression::EvalConstantExpression): New method to 
	evaluate constant expressions.

	* attribute.cs (Attribute::Resolve): Modify bits to use the above function.

2001-11-07  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ArrayCreation.Emit): Some bits to initialize data
	in an array.

	(Binary.ResolveOperator): Handle operator != (object a, object b)
	and operator == (object a, object b);

	(Binary.DoNumericPromotions): Indicate whether the numeric
	promotion was possible.

	(ArrayAccess.DoResolve, ArrayAccess.Emit, ArrayAccess.EmitAssign):
	Implement.  

	Made the ArrayAccess implement interface IAssignMethod instead of
	IStackStore as the order in which arguments are passed reflects
	this.

	* assign.cs: Instead of using expr.ExprClass to select the way of
	assinging, probe for the IStackStore/IAssignMethod interfaces.

	* typemanager.cs: Load InitializeArray definition.

	* rootcontext.cs (RootContext.MakeStaticData): Used to define
	static data that can be used to initialize arrays. 

2001-11-05  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Handle operator== and operator!= for booleans.

	(Conditioal.Reduce): Implement reducer for the ?: operator.

	(Conditional.Resolve): Implement dead code elimination.

	(Binary.Resolve): Catch string literals and return a new
	concatenated string.

	(Unary.Reduce): Implement reduction of unary expressions.

	* ecore.cs: Split out the expression core handling here.

	(Expression.Reduce): New method used to perform constant folding
	and CSE.  This is needed to support constant-expressions. 
	
	* statement.cs (Statement.EmitBoolExpression): Pass true and false
	targets, and optimize for !x.

2001-11-04  Ravi Pratap  <ravi@ximian.com>

	* attribute.cs (Attribute::Resolve): Implement guts. Note that resolution
	of an attribute gives us a CustomAttributeBuilder which we use accordingly to
	set custom atttributes.

	* literal.cs (Literal::GetValue): New abstract method to return the actual
	value of the literal, cast as an object.

	(*Literal): Implement GetValue method.

	* cs-parser.jay (positional_argument_list, named_argument_list): Add not just plain
	expressions to the arraylist but objects of type Argument.

	* class.cs (TypeContainer::Emit): Emit our attributes too.

	(Method::Emit, Constructor::Emit): Ditto.

	* cs-parser.jay (constructor_declaration): Set attributes too, which we seemed
	to be ignoring earlier.

2001-11-03  Ravi Pratap  <ravi@ximian.com>

	* attribute.cs (AttributeSection::Define): Implement to do the business
	of constructing a CustomAttributeBuilder.

	(Attribute): New trivial class. Increases readability of code.	

	* cs-parser.jay : Update accordingly.

	(positional_argument_list, named_argument_list, named_argument): New rules

	(attribute_arguments): Use the above so that we are more correct.
	
2001-11-02  Ravi Pratap  <ravi@ximian.com>
	
	* expression.cs (Invocation::IsParamsMethodApplicable): Implement
	to perform all checks for a method with a params parameter.

	(Invocation::OverloadResolve): Update to use the above method and therefore
	cope correctly with params method invocations.

	* support.cs (InternalParameters::ParameterDesc): Provide a desc for 
	params too.

	* class.cs (ConstructorInitializer::Resolve): Make sure we look for Non-public
	constructors in our parent too because we can't afford to miss out on 
	protected ones ;-)

	* attribute.cs (AttributeSection): New name for the class Attribute

	Other trivial changes to improve readability.

	* cs-parser.jay (opt_attributes, attribute_section etc.): Modify to
	use the new class names.
	
2001-11-01  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Method::Define): Complete definition for params types too

	(Indexer::Define): Ditto.

	* support.cs (InternalParameters::ParameterType, ParameterDesc, ParameterModifier):
	Cope everywhere with a request for info about the array parameter.

2001-11-01  Ravi Pratap  <ravi@ximian.com>

	* tree.cs (RecordNamespace): Fix up to check for the correct key.

	* cs-parser.jay (GetQualifiedIdentifier): New Helper method used in 
	local_variable_type to extract the string corresponding to the type.

	(local_variable_type): Fixup the action to use the new helper method.

	* codegen.cs : Get rid of RefOrOutParameter, it's not the right way to 
	go.

	* expression.cs : Clean out code which uses the above.

2001-10-31  Ravi Pratap  <ravi@ximian.com>
	
	* typemanager.cs (RegisterMethod): Check if we already have an existing key
	and bale out if necessary by returning a false.

	(RegisterProperty): Ditto.

	* class.cs (everywhere): Check the return value from TypeManager.RegisterMethod
	and print out appropriate error messages.

	* interface.cs (everywhere): Ditto.

	* cs-parser.jay (property_declaration, event_declaration, indexer_declaration): Pass
	location to constructor.

	* class.cs (Property, Event, Indexer): Update accordingly.

	* ../errors/cs111.cs : Added.

	* expression.cs (Invocation::IsApplicable): New static method to determine applicability
	of a method, as laid down by the spec.

	(Invocation::OverloadResolve): Use the above method.

2001-10-31  Ravi Pratap  <ravi@ximian.com>

	* support.cs (InternalParameters): Get rid of crap taking in duplicate info. We
	now take a TypeContainer and a Parameters object.

	(ParameterData): Modify return type of ParameterModifier method to be 
	Parameter.Modifier and not a string.

	(ReflectionParameters, InternalParameters): Update accordingly.

	* expression.cs (Argument::GetParameterModifier): Same here.

	* support.cs (InternalParameters::ParameterType): Find a better way of determining
	if we are a ref/out parameter. Actually, the type shouldn't be holding the '&'
	symbol in it at all so maybe this is only for now.

2001-10-30  Ravi Pratap  <ravi@ximian.com>

	* support.cs (InternalParameters): Constructor now takes an extra argument 
	which is the actual Parameters class.

	(ParameterDesc): Update to provide info on ref/out modifiers.

	* class.cs (everywhere): Update call to InternalParameters to pass in
	the second argument too.

	* support.cs (ParameterData): Add ParameterModifier, which is a method 
	to return the modifier info [ref/out etc]

	(InternalParameters, ReflectionParameters): Implement the above.

	* expression.cs (Argument::ParameterModifier): Similar function to return
	info about the argument's modifiers.

	(Invocation::OverloadResolve): Update to take into account matching modifiers 
	too.

	* class.cs (Indexer::Define): Actually define a Parameter object and put it onto
	a new SetFormalParameters object which we pass to InternalParameters.

2001-10-30  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (NewArray): Merge into the ArrayCreation class.

2001-10-29  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (NewArray): Merge classes NewBuiltinArray and 
	NewUserdefinedArray into one as there wasn't much of a use in having
	two separate ones.

	* expression.cs (Argument): Change field's name to ArgType from Type.

	(Type): New readonly property which returns the proper type, taking into 
	account ref/out modifiers.

	(everywhere): Adjust code accordingly for the above.

	* codegen.cs (EmitContext.RefOrOutParameter): New field to determine
	whether we are emitting for a ref or out parameter.

	* expression.cs (Argument::Emit): Use the above field to set the state.

	(LocalVariableReference::Emit): Update to honour the flag and emit the
	right stuff.

	* parameter.cs (Attributes): Set the correct flags for ref parameters.

	* expression.cs (Argument::FullDesc): New function to provide a full desc.

	* support.cs (ParameterData): Add method ParameterDesc to the interface.

	(ReflectionParameters, InternalParameters): Implement the above method.

	* expression.cs (Invocation::OverloadResolve): Use the new desc methods in
	reporting errors.

	(Invocation::FullMethodDesc): Ditto. 

2001-10-29  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Add extra production for the second form of array
	creation. 

	* expression.cs (ArrayCreation): Update to reflect the above
	change. 

	* Small changes to prepare for Array initialization.

2001-10-28  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (ImplementsInterface): interface might be null;
	Deal with this problem;

	Also, we do store negative hits on the cache (null values), so use
	this instead of calling t.GetInterfaces on the type everytime.

2001-10-28  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (IsBuiltinType): New method to help determine the same.

	* expression.cs (New::DoResolve): Get rid of array creation code and instead
	split functionality out into different classes.

	(New::FormArrayType): Move into NewBuiltinArray.

	(Invocation::EmitArguments): Get rid of the MethodBase argument. Appears
	quite useless.

	(NewBuiltinArray): New class to handle creation of built-in arrays.

	(NewBuiltinArray::DoResolve): Implement guts of array creation. Also take into
	account creation of one-dimensional arrays.

	(::Emit): Implement to use Newarr and Newobj opcodes accordingly.

	(NewUserdefinedArray::DoResolve): Implement.

	* cs-parser.jay (local_variable_type): Fix up to add the rank to the variable too.

	* typemanager.cs (AddModule): Used to add a ModuleBuilder to the list of modules
	we maintain inside the TypeManager. This is necessary to perform lookups on the
	module builder.

	(LookupType): Update to perform GetType on the module builders too.	

	* driver.cs (Driver): Add the ModuleBuilder to the list maintained by the TypeManager.

	* exprssion.cs (NewUserdefinedArray::Emit): Implement.

2001-10-23  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (New::DoResolve): Implement guts of array creation.

	(New::FormLookupType): Rename to FormArrayType and modify ever so slightly.
	
2001-10-27  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Fix bug I introduced lsat night that broke
	Delegates. 

	(Expression.Resolve): Report a 246 error (can not resolve name)
	if we find a SimpleName in the stream.
	
	(Expression.ResolveLValue): Ditto.
	
	(Expression.ResolveWithSimpleName): This function is a variant of
	ResolveName, this one allows SimpleNames to be returned without a
	warning.  The only consumer of SimpleNames is MemberAccess

2001-10-26  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Invocation::DoResolve): Catch SimpleNames that
	might arrive here.  I have my doubts that this is correct.

	* statement.cs (Lock): Implement lock statement.

	* cs-parser.jay: Small fixes to support `lock' and `using'

	* cs-tokenizer.cs: Remove extra space

	* driver.cs: New flag --checked, allows to turn on integer math
	checking. 

	* typemanger.cs: Load methodinfos for Threading.Monitor.Enter and
	Threading.Monitor.Exit 
	
2001-10-23  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (IndexerAccess::DoResolveLValue): Set the
	Expression Class to be IndexerAccess.

	Notice that Indexer::DoResolve sets the eclass to Value.

2001-10-22  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer::Emit): Emit code for indexers.

	* assign.cs (IAssignMethod): New interface implemented by Indexers
	and Properties for handling assignment.

	(Assign::Emit): Simplify and reuse code. 
	
	* expression.cs (IndexerAccess, PropertyExpr): Implement
	IAssignMethod, clean up old code. 

2001-10-22  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (ImplementsInterface): New method to determine if a type
	implements a given interface. Provides a nice cache too.

	* expression.cs (ImplicitReferenceConversion): Update checks to use the above
	method.

	(ConvertReferenceExplicit): Ditto.

	* delegate.cs (Delegate::Populate): Update to define the parameters on the 
	various methods, with correct names etc.

	* class.cs (Operator::OpType): New members Operator.UnaryPlus and 
	Operator.UnaryNegation.

	* cs-parser.jay (operator_declarator): Be a little clever in the case where
	we have a unary plus or minus operator.

	* expression.cs (Unary): Rename memebers of Operator enum to UnaryPlus and 
	UnaryMinus.

	* everywhere : update accordingly.

	* everywhere : Change Negate and BitComplement to LogicalNot and OnesComplement
	respectively.

	* class.cs (Method::Define): For the case where we are implementing a method
	inherited from an interface, we need to set the MethodAttributes.Final flag too. 
	Also set MethodAttributes.NewSlot and MethodAttributes.HideBySig.
	
2001-10-21  Ravi Pratap  <ravi@ximian.com>

	* interface.cs (FindMembers): Implement to work around S.R.E
	lameness.

	* typemanager.cs (IsInterfaceType): Implement.

	(FindMembers): Update to handle interface types too.

	* expression.cs (ImplicitReferenceConversion): Re-write bits which
	use IsAssignableFrom as that is not correct - it doesn't work.

	* delegate.cs (DelegateInvocation): Derive from ExpressionStatement
	and accordingly override EmitStatement.

	* expression.cs (ConvertReferenceExplicit): Re-write similary, this time
	using the correct logic :-)

2001-10-19  Ravi Pratap  <ravi@ximian.com>

	* ../errors/cs-11.cs : Add to demonstrate error -11 

2001-10-17  Miguel de Icaza  <miguel@ximian.com>

	* assign.cs (Assign::Resolve): Resolve right hand side first, and
	then pass this as a hint to ResolveLValue.
	
	* expression.cs (FieldExpr): Add Location information

	(FieldExpr::LValueResolve): Report assignment to readonly
	variable. 
	
	(Expression::ExprClassFromMemberInfo): Pass location information.

	(Expression::ResolveLValue): Add new method that resolves an
	LValue. 

	(Expression::DoResolveLValue): Default invocation calls
	DoResolve. 

	(Indexers): New class used to keep track of indexers in a given
	Type. 

	(IStackStore): Renamed from LValue, as it did not really describe
	what this did.  Also ResolveLValue is gone from this interface and
	now is part of Expression.

	(ElementAccess): Depending on the element access type
	
	* typemanager.cs: Add `indexer_name_type' as a Core type
	(System.Runtime.CompilerServices.IndexerNameAttribute)

	* statement.cs (Goto): Take a location.
	
2001-10-18  Ravi Pratap  <ravi@ximian.com>

	* delegate.cs (Delegate::VerifyDelegate): New method to verify
	if two delegates are compatible.

	(NewDelegate::DoResolve): Update to take care of the case when
	we instantiate a delegate from another delegate.

	* typemanager.cs (FindMembers): Don't even try to look up members
	of Delegate types for now.

2001-10-18  Ravi Pratap  <ravi@ximian.com>

	* delegate.cs (NewDelegate): New class to take care of delegate
	instantiation.

	* expression.cs (New): Split the delegate related code out into 
	the NewDelegate class.

	* delegate.cs (DelegateInvocation): New class to handle delegate 
	invocation.

	* expression.cs (Invocation): Split out delegate related code into
	the DelegateInvocation class.

2001-10-17  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (New::DoResolve): Implement delegate creation fully
	and according to the spec.

	(New::DoEmit): Update to handle delegates differently.

	(Invocation::FullMethodDesc): Fix major stupid bug thanks to me
	because of which we were printing out arguments in reverse order !

	* delegate.cs (VerifyMethod): Implement to check if the given method
	matches the delegate.

	(FullDelegateDesc): Implement.

	(VerifyApplicability): Implement.

	* expression.cs (Invocation::DoResolve): Update to accordingly handle
	delegate invocations too.

	(Invocation::Emit): Ditto.

	* ../errors/cs1593.cs : Added.

	* ../errors/cs1594.cs : Added.

	* delegate.cs (InstanceExpression, TargetMethod): New properties.

2001-10-16  Ravi Pratap  <ravi@ximian.com>

	* typemanager.cs (intptr_type): Core type for System.IntPtr

	(InitCoreTypes): Update for the same.

	(iasyncresult_type, asynccallback_type): Ditto.

	* delegate.cs (Populate): Fix to use System.Intptr as it is indeed
	correct.

	* typemanager.cs (AddDelegateType): Store a pointer to the Delegate class
	too.

	* delegate.cs (ConstructorBuilder, InvokeBuilder, ...): New members to hold
	the builders for the 4 members of a delegate type :-)

	(Populate): Define the BeginInvoke and EndInvoke methods on the delegate
	type.

	* expression.cs (New::DoResolve): Implement guts for delegate creation.

	* ../errors/errors.txt : Update for an error (-11) which only we catch :-)

2001-10-15  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Break::Emit): Implement.   
	(Continue::Emit): Implement.

	(For::Emit): Track old being/end loops;  Set Begin loop, ack end loop
	(While::Emit): Track old being/end loops;  Set Begin loop, ack end loop
	(Do::Emit): Track old being/end loops;  Set Begin loop, ack end loop
	(Foreach::Emit): Track old being/end loops;  Set Begin loop, ack
	end loop
	
	* codegen.cs (EmitContext::LoopEnd, EmitContext::LoopBegin): New
	properties that track the label for the current loop (begin of the
	loop and end of the loop).

2001-10-15  Ravi Pratap  <ravi@ximian.com>

	* delegate.cs (Emit): Get rid of it as there doesn't seem to be any ostensible
	use of emitting anything at all.

	* class.cs, rootcontext.cs : Get rid of calls to the same.

	* delegate.cs (DefineDelegate): Make sure the class we define is also sealed.

	(Populate): Define the constructor correctly and set the implementation
	attributes.

	* typemanager.cs (delegate_types): New hashtable to hold delegates that
	have been defined.

	(AddDelegateType): Implement.

	(IsDelegateType): Implement helper method.

	* delegate.cs (DefineDelegate): Use AddDelegateType instead of AddUserType.

	* expression.cs (New::DoResolve): Check if we are trying to instantiate a delegate type
	and accordingly handle it.

	* delegate.cs (Populate): Take TypeContainer argument.
	Implement bits to define the Invoke method. However, I still haven't figured out
	how to take care of the native int bit :-(

	* cs-parser.jay (delegate_declaration): Fixed the bug that I had introduced :-) 
	Qualify the name of the delegate, not its return type !

	* expression.cs (ImplicitReferenceConversion): Implement guts of implicit array
	conversion.

	(StandardConversionExists): Checking for array types turns out to be recursive.

	(ConvertReferenceExplicit): Implement array conversion.

	(ExplicitReferenceConversionExists): New method to determine precisely that :-)
	
2001-10-12  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (delegate_declaration): Store the fully qualified
	name as it is a type declaration.

	* delegate.cs (ReturnType, Name): Rename members to these. Make them 
	readonly.

	(DefineDelegate): Renamed from Define. Does the same thing essentially,
	as TypeContainer::DefineType.

	(Populate): Method in which all the definition of the various methods (Invoke)
	etc is done.

	(Emit): Emit any code, if necessary. I am not sure about this really, but let's
	see.
	
	(CloseDelegate): Finally creates the delegate.

	* class.cs (TypeContainer::DefineType): Update to define delegates.
	(Populate, Emit and CloseType): Do the same thing here too.

	* rootcontext.cs (ResolveTree, PopulateTypes, EmitCode, CloseTypes): Include
	delegates in all these operations.

2001-10-14  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: LocalTemporary: a new expression used to
	reference a temporary that has been created.

	* assign.cs: Handle PropertyAccess back here, so that we can
	provide the proper semantic access to properties.

	* expression.cs (Expression::ConvertReferenceExplicit): Implement
	a few more explicit conversions. 

	* modifiers.cs: `NEW' modifier maps to HideBySig.

	* expression.cs (PropertyExpr): Make this into an
	ExpressionStatement, and support the EmitStatement code path. 

	Perform get/set error checking, clean up the interface.

	* assign.cs: recognize PropertyExprs as targets, and if so, turn
	them into toplevel access objects.

2001-10-12  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: PropertyExpr::PropertyExpr: use work around the
	SRE.

	* typemanager.cs: Keep track here of our PropertyBuilders again to
	work around lameness in SRE.

2001-10-11  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (LValue::LValueResolve): New method in the
	interface, used to perform a second resolution pass for LValues. 
	
	(This::DoResolve): Catch the use of this in static methods.

	(This::LValueResolve): Implement.

	(This::Store): Remove warning, assigning to `this' in structures
	is 

	(Invocation::Emit): Deal with invocation of
	methods on value types.  We need to pass the address to structure
	methods rather than the object itself.  (The equivalent code to
	emit "this" for structures leaves the entire structure on the
	stack instead of a pointer to it). 

	(ParameterReference::DoResolve): Compute the real index for the
	argument based on whether the method takes or not a `this' pointer
	(ie, the method is static).

	* codegen.cs (EmitContext::GetTemporaryStorage): Used to store
	value types returned from functions when we need to invoke a
	method on the sturcture.
	

2001-10-11  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer::DefineType): Method to actually do the business of
	defining the type in the Modulebuilder or Typebuilder. This is to take
	care of nested types which need to be defined on the TypeBuilder using
	DefineNestedMethod.

	(TypeContainer::GetClassBases): Implement. Essentially the code from the 
	methods in RootContext, only ported to be part of TypeContainer.

	(TypeContainer::GetInterfaceOrClass): Ditto.

	(TypeContainer::LookupInterfaceOrClass, ::MakeFQN): Ditto.

	* interface.cs (Interface::DefineInterface): New method. Does exactly
	what RootContext.CreateInterface did earlier, only it takes care of nested types 
	too.

	(Interface::GetInterfaces): Move from RootContext here and port.

	(Interface::GetInterfaceByName): Same here.

	* rootcontext.cs (ResolveTree): Re-write.

	(PopulateTypes): Re-write.

	* class.cs (TypeContainer::Populate): Populate nested types too.
	(TypeContainer::Emit): Emit nested members too.

	* typemanager.cs (AddUserType): Do not make use of the FullName property,
	instead just use the name argument passed in as it is already fully
	qualified.

	(FindMembers): Check in the Builders to TypeContainer mapping instead of the name
	to TypeContainer mapping to see if a type is user-defined.

	* class.cs (TypeContainer::CloseType): Implement. 

	(TypeContainer::DefineDefaultConstructor): Use Basename, not Name while creating
	the default constructor.
	
	(TypeContainer::Populate): Fix minor bug which led to creating default constructors
	twice.

	(Constructor::IsDefault): Fix up logic to determine if it is the default constructor

	* interface.cs (CloseType): Create the type here.
	
	* rootcontext.cs (CloseTypes): Re-write to recursively close types by running through
	the hierarchy.

	Remove all the methods which are now in TypeContainer.

2001-10-10  Ravi Pratap  <ravi@ximian.com>

	* delegate.cs (Define): Re-write bits to define the delegate
	correctly.

2001-10-10  Miguel de Icaza  <miguel@ximian.com>

	* makefile: Renamed the compiler to `mcs.exe' instead of compiler.exe

	* expression.cs (ImplicitReferenceConversion): handle null as well
	as a source to convert to any reference type.

	* statement.cs (Return): Perform any implicit conversions to
	expected return type.  

	Validate use of return statement.  

	* codegen.cs (EmitContext): Pass the expected return type here.

	* class.cs (Method, Constructor, Property): Pass expected return
	type to EmitContext.

2001-10-09  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Make DoResolve take an EmitContext instead of a
	TypeContainer.

	Replaced `l' and `location' for `loc', for consistency.
	
	(Error, Warning): Remove unneeded Tc argument.

	* assign.cs, literal.cs, constant.cs: Update to new calling
	convention. 
	
	* codegen.cs: EmitContext now contains a flag indicating whether
	code is being generated in a static method or not.

	* cs-parser.jay: DecomposeQI, new function that replaces the old
	QualifiedIdentifier.  Now we always decompose the assembled
	strings from qualified_identifier productions into a group of
	memberaccesses.

2001-10-08  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs: Deal with field-less struct types correctly now
	by passing the size option to Define Type.

	* class.cs: Removed hack that created one static field. 

2001-10-07  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs: Moved most of the code generation here. 

2001-10-09  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (New::DoResolve): Revert changes for array creation, doesn't
	seem very right.

	(ElementAccess): Remove useless bits for now - keep checks as the spec
	says.

2001-10-08  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (ElementAccess::DoResolve): Remove my crap code
	and start performing checks according to the spec.

2001-10-07  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (type_suffix*): Remove - they are redundant. Use
	rank_specifiers instead.

	(rank_specifiers): Change the order in which the rank specifiers are stored

	(local_variable_declaration): Use opt_rank_specifier instead of type_suffixes.

	* expression.cs (ElementAccess): Implement the LValue interface too.
	
2001-10-06  Ravi Pratap  <ravi@ximian.com>
	
	* expression.cs (ConvertExplicitStandard): Add. Same as ConvertExplicit
	except that user defined conversions are not included.

	(UserDefinedConversion): Update to use the ConvertExplicitStandard to 
	perform the conversion of the return type, if necessary.

	(New::DoResolve): Check whether we are creating an array or an object
	and accordingly do the needful.

	(New::Emit): Same here.

	(New::DoResolve): Implement guts of array creation.

	(New::FormLookupType): Helper function.

2001-10-07  Miguel de Icaza  <miguel@ximian.com>

	* codegen.cs: Removed most of the code generation here, and move the
	corresponding code generation bits to the statement classes. 

	Added support for try/catch/finalize and throw.
	
	* cs-parser.jay: Added support for try/catch/finalize.

	* class.cs: Catch static methods having the flags override,
	virtual or abstract.

	* expression.cs (UserCast): This user cast was not really doing
	what it was supposed to do.  Which is to be born in fully resolved
	state.  Parts of the resolution were being performed at Emit time! 

	Fixed this code.

2001-10-05  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs: Implicity convert the result from UserCast.

2001-10-05  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Expression::FindMostEncompassingType): Fix bug which
	prevented it from working correctly. 

	(ConvertExplicit): Make the first try, a call to ConvertImplicitStandard, not
	merely ConvertImplicit.

2001-10-05  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs: Make the LookupTypeContainer function static,
	and not per-instance.  

	* class.cs: Make static FindMembers (the one that takes a Type
	argument). 

	* codegen.cs: Add EmitForeach here.

	* cs-parser.jay: Make foreach a toplevel object instead of the
	inline expansion, as we need to perform semantic analysis on it. 

2001-10-05  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Expression::ImplicitUserConversion): Rename to
	UserDefinedConversion.

	(Expression::UserDefinedConversion): Take an extra argument specifying 
	whether we look for explicit user conversions too.

	(Expression::ImplicitUserConversion): Make it a call to UserDefinedConversion.

	(UserDefinedConversion): Incorporate support for user defined explicit conversions.

	(ExplicitUserConversion): Make it a call to UserDefinedConversion
	with the appropriate arguments.

	* cs-parser.jay (cast_expression): Record location too.

	* expression.cs (Cast): Record location info.

	(Expression::ConvertExplicit): Take location argument.

	(UserImplicitCast): Change name to UserCast. Take an extra constructor argument
	to determine if we are doing explicit conversions.

	(UserCast::Emit): Update accordingly.

	(Expression::ConvertExplicit): Report an error if everything fails.

	* ../errors/cs0030.cs : Add.

2001-10-04  Miguel de Icaza  <miguel@ximian.com>

	* modifiers.cs: If the ABSTRACT keyword is present, also set the
	virtual and newslot bits. 

	* class.cs (TypeContainer::RegisterRequiredImplementations):
	Record methods we need.

	(TypeContainer::MakeKey): Helper function to make keys for
	MethodBases, since the Methodbase key is useless.

	(TypeContainer::Populate): Call RegisterRequiredImplementations
	before defining the methods.   

	Create a mapping for method_builders_to_methods ahead of time
	instead of inside a tight loop.

	(::RequireMethods):  Accept an object as the data to set into the
	hashtable so we can report interface vs abstract method mismatch.

2001-10-03  Miguel de Icaza  <miguel@ximian.com>

	* report.cs: Make all of it static.

	* rootcontext.cs: Drop object_type and value_type computations, as
	we have those in the TypeManager anyways.

	Drop report instance variable too, now it is a global.

	* driver.cs: Use try/catch on command line handling.

	Add --probe option to debug the error reporting system with a test
	suite. 

	* report.cs: Add support for exiting program when a probe
	condition is reached.

2001-10-03  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Binary::DoNumericPromotions): Fix the case when
	we do a forcible conversion regardless of type, to check if 
	ForceConversion returns a null.

	(Binary::error19): Use location to report error.

	(Unary::error23): Use location here too.

	* ../errors/cs0019.cs : Check in.

	* ../errors/cs0023.cs : Check in.

	* expression.cs (Expression.MemberLookup): Return null for a rather esoteric
	case of a non-null MethodInfo object with a length of 0 !

	(Binary::ResolveOperator): Flag error if overload resolution fails to find
	an applicable member - according to the spec :-)
	Also fix logic to find members in base types.

	(Unary::ResolveOperator): Same here.

	(Unary::report23): Change name to error23 and make first argument a TypeContainer
	as I was getting thoroughly confused between this and error19 :-)
	
	* expression.cs (Expression::ImplicitUserConversion): Re-write fully
	(::FindMostEncompassedType): Implement.
	(::FindMostEncompassingType): Implement.
	(::StandardConversionExists): Implement.

	(UserImplicitCast): Re-vamp. We now need info about most specific
	source and target types so that we can do the necessary conversions.

	(Invocation::MakeUnionSet): Completely re-write to make sure we form a proper
	mathematical union with no duplicates.

2001-10-03  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs (RootContext::PopulateTypes): Populate containers
	in order from base classes to child classes, so that we can in
	child classes look up in our parent for method names and
	attributes (required for handling abstract, virtual, new, override
	constructs: we need to instrospect our base class, and if we dont
	populate the classes in order, the introspection might be
	incorrect.  For example, a method could query its parent before
	the parent has any methods and would determine that the parent has
	no abstract methods (while it could have had them)).

	(RootContext::CreateType): Record the order in which we define the
	classes.

2001-10-02  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer::Populate): Also method definitions can
	fail now, keep track of this.

	(TypeContainer::FindMembers): Implement support for
	DeclaredOnly/noDeclaredOnly flag.

	(Constructor::Emit) Return the ConstructorBuilder.

	(Method::Emit) Return the MethodBuilder. 
	Check for abstract or virtual methods to be public.

	* rootcontext.cs (RootContext::CreateType): Register all the
	abstract methods required for the class to be complete and the
	interface methods that must be implemented. 

	* cs-parser.jay: Report error 501 (method requires body if it is
	not marked abstract or extern).

	* expression.cs (TypeOf::Emit): Implement.

	* typemanager.cs: runtime_handle_type, new global type.

	* class.cs (Property::Emit): Generate code for properties.

2001-10-02  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Unary::ResolveOperator): Find operators on base type
	too - we now conform exactly to the spec.

	(Binary::ResolveOperator): Same here.

	* class.cs (Operator::Define): Fix minor quirk in the tests.

	* ../errors/cs0215.cs : Added.

	* ../errors/cs0556.cs : Added.

	* ../errors/cs0555.cs : Added.

2001-10-01  Miguel de Icaza  <miguel@ximian.com>

	* cs-tokenizer.cs: Reimplemented Location to be a struct with a
	single integer which is really efficient

2001-10-01  Ravi Pratap  <ravi@ximian.com>

	*  expression.cs (Expression::ImplicitUserConversion): Use location
        even in the case when we are examining True operators.
 
        * class.cs (Operator::Define): Perform extensive checks to conform
        with the rules for operator overloading in the spec.

	* expression.cs (Expression::ImplicitReferenceConversion): Implement
	some of the other conversions mentioned in the spec.

	* typemanager.cs (array_type): New static member for the System.Array built-in
	type.

	(cloneable_interface): For System.ICloneable interface.

	* driver.cs (Driver::Driver): Initialize TypeManager's core types even before
	we start resolving the tree and populating types.

	* ../errors/errors.txt : Update for error numbers -7, -8, -9, -10
 
2001-10-01  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Expression::ExprClassFromMemberInfo,
	Expression::Literalize): Create literal expressions from
	FieldInfos which are literals.

	(ConvertNumericExplicit, ImplicitNumericConversion): Fix a few
	type casts, because they were wrong.  The test suite in tests
	caught these ones.

	(ImplicitNumericConversion): ushort to ulong requires a widening
	cast. 

	Int32 constant to long requires widening cast as well.

	* literal.cs (LongLiteral::EmitLong): Do not generate i4 constants
	for integers because the type on the stack is not i4.

2001-09-30  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (report118): require location argument. 

	* parameter.cs: Do not dereference potential null value.

	* class.cs: Catch methods that lack the `new' keyword when
	overriding a name.  Report warnings when `new' is used without
	anything being there to override.

	* modifiers.cs: Handle `NEW' as MethodAttributes.NewSlot.

	* class.cs: Only add constructor to hashtable if it is non-null
	(as now constructors can fail on define).

	(TypeManager, Class, Struct): Take location arguments.

	Catch field instance initialization in structs as errors.

	accepting_filter: a new filter for FindMembers that is static so
	that we dont create an instance per invocation.

	(Constructor::Define): Catch errors where a struct constructor is
	parameterless 

	* cs-parser.jay: Pass location information for various new
	constructs. 
	
	* delegate.cs (Delegate): take a location argument.

	* driver.cs: Do not call EmitCode if there were problesm in the
	Definition of the types, as many Builders wont be there. 

	* decl.cs (Decl::Decl): Require a location argument.

	* cs-tokenizer.cs: Handle properly hex constants that can not fit
	into integers, and find the most appropiate integer for it.

	* literal.cs: Implement ULongLiteral.

	* rootcontext.cs: Provide better information about the location of
	failure when CreateType fails.
	
2001-09-29  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs (RootContext::PopulateTypes): Populates structs
	as well.

	* expression.cs (Binary::CheckShiftArguments): Add missing type
	computation.
	(Binary::ResolveOperator): Add type to the logical and and logical
	or, Bitwise And/Or and Exclusive Or code paths, it was missing
	before.

	(Binary::DoNumericPromotions): In the case where either argument
	is ulong (and most signed types combined with ulong cause an
	error) perform implicit integer constant conversions as well.

2001-09-28  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (UserImplicitCast): Method should always be
	non-null. 
	(Invocation::BetterConversion): Simplified test for IntLiteral.

	(Expression::ImplicitNumericConversion): Split this routine out.
	Put the code that performs implicit constant integer conversions
	here. 

	(Expression::Resolve): Become a wrapper around DoResolve so we can
	check eclass and type being set after resolve.

	(Invocation::Badness): Remove this dead function

	(Binary::ResolveOperator): Do not compute the expensive argumnets
	unless we have a union for it.

	(Probe::Emit): Is needs to do an isinst and then
	compare against null.

	(::CanConvert): Added Location argument.  If the Location argument
	is null (Location.Null), then we do not report errors.  This is
	used by the `probe' mechanism of the Explicit conversion.  We do
	not want to generate an error for something that the user
	explicitly requested to be casted.  But the pipeline for an
	explicit cast first tests for potential implicit casts.

	So for now, if the Location is null, it means `Probe only' to
	avoid adding another argument.   Might have to revise this
	strategy later.

	(ClassCast): New class used to type cast objects into arbitrary
	classes (used in Explicit Reference Conversions).

	Implement `as' as well.

	Reverted all the patches from Ravi below: they were broken:

		* The use of `level' as a mechanism to stop recursive
		  invocations is wrong.  That was there just to catch the
		  bug with a strack trace but not as a way of addressing
		  the problem.

		  To fix the problem we have to *understand* what is going
		  on and the interactions and come up with a plan, not
		  just get things going.

		* The use of the type conversion cache that I proposed
		  last night had an open topic: How does this work across
		  protection domains.  A user defined conversion might not
		  be public in the location where we are applying the
		  conversion, a different conversion might be selected
		  (ie, private A->B (better) but public B->A (worse),
		  inside A, A->B applies, but outside it, B->A will
		  apply).

		* On top of that (ie, even if the above is solved),
		  conversions in a cache need to be abstract.  Ie, `To
		  convert from an Int to a Short use an OpcodeCast', not
		  `To convert from an Int to a Short use the OpcodeCast on
		  the variable 5' (which is what this patch was doing).
	
2001-09-28  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Invocation::ConversionExists): Re-write to use
	the conversion cache
	
	(Expression::ConvertImplicit): Automatic bailing out if level != 0. Also
	cache all conversions done, not just user-defined ones.

	(Invocation::BetterConversion): The real culprit. Use ConversionExists
	to determine if a conversion exists instead of acutually trying to 
	perform the conversion. It's faster too.

	(Expression::ConvertExplicit): Modify to use ConversionExists to check
	and only then attempt the implicit conversion.

2001-09-28  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (ConvertImplicit): Use a cache for conversions
	already found. Check level of recursion and bail out if necessary.
	
2001-09-28  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (string_concat_string_string, string_concat_object_object):
	Export standard methods that we expect for string operations.
	
	* statement.cs (Block::UsageWarning): Track usage of variables and
	report the errors for not used variables.

	* expression.cs (Conditional::Resolve, ::Emit): Implement ?:
	operator. 

2001-09-27  Miguel de Icaza  <miguel@ximian.com>

	* codegen.cs: remove unnneded code 

	* expression.cs: Removed BuiltinTypeAccess class

	Fix the order in which implicit conversions are
	done.  

	The previous fixed dropped support for boxed conversions (adding a
	test to the test suite now)

	(UserImplicitCast::CanConvert): Remove test for source being null,
	that code is broken.  We should not feed a null to begin with, if
	we do, then we should track the bug where the problem originates
	and not try to cover it up here.

	Return a resolved expression of type UserImplicitCast on success
	rather than true/false.  Ravi: this is what I was talking about,
	the pattern is to use a static method as a "constructor" for
	objects. 

	Also, do not create arguments until the very last minute,
	otherwise we always create the arguments even for lookups that
	will never be performed. 

	(UserImplicitCast::Resolve): Eliminate, objects of type
	UserImplicitCast are born in a fully resolved state. 
	
	* typemanager.cs (InitCoreTypes): Init also value_type
	(System.ValueType). 

	* expression.cs (Cast::Resolve): First resolve the child expression.

	(LValue): Add new method AddressOf to be used by
	the `&' operator.  

	Change the argument of Store to take an EmitContext instead of an
	ILGenerator, because things like FieldExpr need to be able to call
	their children expression to generate the instance code. 

	(Expression::Error, Expression::Warning): Sugar functions for
	reporting errors.

	(Expression::MemberLookup): Accept a TypeContainer instead of a
	Report as the first argument.

	(Expression::ResolvePrimary): Killed.  I still want to improve
	this as currently the code is just not right.

	(Expression::ResolveMemberAccess): Simplify, but it is still
	wrong. 

	(Unary::Resolve): Catch errors in AddressOf operators.

	(LocalVariableReference::Emit, ::Store, ::AddressOf): typecast
	index to a byte for the short-version, or the compiler will choose
	the wrong Emit call, which generates the wrong data.

	(ParameterReference::Emit, ::Store): same.

	(FieldExpr::AddressOf): Implement.
	
	* typemanager.cs: TypeManager: made public variable instead of
	property.
	
	* driver.cs: document --fatal.

	* report.cs (ErrorMessage, WarningMessage): new names for the old
	Error and Warning classes.

	* cs-parser.jay (member_access): Turn built-in access to types
	into a normal simplename

2001-09-27  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Invocation::BetterConversion): Fix to cope
	with q being null, since this was introducing a bug.

	* expression.cs (ConvertImplicit): Do built-in conversions first.

2001-09-27  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (UserImplicitCast::Resolve): Fix bug.

2001-09-27  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer::AddConstructor): Fix a stupid bug
	I had introduced long ago (what's new ?).

	* expression.cs (UserImplicitCast::CanConvert): Static method to do 
	the work of all the checking. 
	(ConvertImplicit): Call CanConvert and only then create object if necessary.
	(UserImplicitCast::CanConvert, ::Resolve): Re-write.

	(Unary::Operator): Rename Add and Subtract to Addition and Subtraction because
	that is the right way. 

	(Invocation::MakeUnionSet): Convenience function to make unions of sets for 
	overloading resolution. Use everywhere instead of cutting and pasting code.

	(Binary::ResolveOperator): Use MakeUnionSet.

	(UserImplicitCast::CanConvert, ::Resolve): Update to take care of the case when 
	we have to convert to bool types. Not complete yet.
	
2001-09-27  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (TypeManager::CSharpName): support ushort.

	* expression.cs (Expression::TryImplicitIntConversion): Attempts
	to provide an expression that performsn an implicit constant int
	conversion (section 6.1.6).
	(Expression::ConvertImplicitRequired): Reworked to include
	implicit constant expression conversions.

	(Expression::ConvertNumericExplicit): Finished.

	(Invocation::Emit): If InstanceExpression is null, then it means
	that we perform a call on this.
	
2001-09-26  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Unary::Emit): Remove some dead code.
	(Probe): Implement Resolve and Emit for `is'.
	(Expression::ConvertImplicitRequired): Attempt to do constant
	expression conversions here.  Maybe should be moved to
	ConvertImplicit, but I am not sure.
	(Expression::ImplicitLongConstantConversionPossible,
	Expression::ImplicitIntConstantConversionPossible): New functions
	that tell whether is it possible to apply an implicit constant
	expression conversion.

	(ConvertNumericExplicit): Started work on explicit numeric
	conversions.

	* cs-parser.jay: Update operator constants.

	* parameter.cs (Parameters::GetParameterInfo): Hook up VerifyArgs
	(Parameters::GetSignature): Hook up VerifyArgs here.
	(Parameters::VerifyArgs): Verifies that no two arguments have the
	same name. 

	* class.cs (Operator): Update the operator names to reflect the
	ones that the spec expects (as we are just stringizing the
	operator names).
	
	* expression.cs (Unary::ResolveOperator): Fix bug: Use
	MethodInfo's ReturnType instead of LookupMethodByBuilder as the
	previous usage did only work for our methods.
	(Expression::ConvertImplicit): Handle decimal implicit numeric
	conversions as well.
	(Expression::InternalTypeConstructor): Used to invoke constructors
	on internal types for default promotions.

	(Unary::Emit): Implement special handling for the pre/post
	increment/decrement for overloaded operators, as they need to have
	the same semantics as the other operators.

	(Binary::ResolveOperator): ditto.
	(Invocation::ConversionExists): ditto.
	(UserImplicitCast::Resolve): ditto.
	
2001-09-26  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Unary::Emit and Binary::Emit): If we have an overloaded
	operator, return after emitting body. Regression tests pass again !

	* expression.cs (ConvertImplicit): Take TypeContainer as first argument
	(Unary::ForceConversion, Binary::ForceConversion): Ditto.
	(Invocation::OverloadResolve): Ditto.
	(Invocation::BetterFunction, BetterConversion, ConversionExists): Ditto.

	* everywhere : update calls to the above methods accordingly.

2001-09-26  Miguel de Icaza  <miguel@ximian.com>

	* assign.cs (Assign): Make it inherit from ExpressionStatement.

	* expression.cs (ExpressionStatement): New base class used for
	expressions that can appear in statements, so that we can provide
	an alternate path to generate expression that do not leave a value
	on the stack.

	(Expression::Emit, and all the derivatives): We no longer return
	whether a value is left on the stack or not.  Every expression
	after being emitted leaves a single value on the stack.

	* codegen.cs (EmitContext::EmitStatementExpression): Use the
	facilties of ExpressionStatement if possible.

	* cs-parser.jay: Update statement_expression.

2001-09-25  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Change the wording of message

2001-09-25  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Binary::ResolveOperator): Had forgottten to set 
	the type of the expression to the return type of the method if
	we have an overloaded operator match ! The regression tests pass again !
	(Unary::ResolveOperator): Ditto.

	* expression.cs (Invocation::ConversionExists): Correct the member lookup
	to find "op_Implicit", not "implicit" ;-)
	(UserImplicitCast): New class to take care of user-defined implicit conversions.
	(ConvertImplicit, ForceConversion): Take TypeContainer argument

	* everywhere : Correct calls to the above accordingly.

	* expression.cs (UserImplicitCast::Resolve, ::Emit): Implement.
	(ConvertImplicit): Do user-defined conversion if it exists.

2001-09-24  Miguel de Icaza  <miguel@ximian.com>

	* assign.cs: track location.
	(Resolve): Use implicit conversions on assignment.

	* literal.cs: Oops.  Not good, Emit of short access values should
	pass (Bytes) or the wrong argument will be selected.

	* expression.cs (Unary::Emit): Emit code for -expr.
	
	(Unary::ResolveOperator): Handle `Substract' for non-constants
	(substract from zero from the non-constants).
	Deal with Doubles as well. 
	
	(Expression::ConvertImplicitRequired): New routine that reports an
	error if no implicit conversion exists. 

	(Invocation::OverloadResolve): Store the converted implicit
	expressions if we make them
	
2001-09-24  Ravi Pratap  <ravi@ximian.com>

	* class.cs (ConstructorInitializer): Take a Location argument.
	(ConstructorBaseInitializer): Same here.
	(ConstructorThisInitializer): Same here.

	* cs-parser.jay : Update all calls accordingly.

	* expression.cs (Unary, Binary, New): Take location argument.
	Update accordingly everywhere.

	* cs-parser.jay : Update all calls to the above to take a location
	argument.

	* class.cs : Ditto.

2001-09-24  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Invocation::BetterFunction): Take TypeContainer argument
	(Invocation::BetterConversion): Same here
	(Invocation::ConversionExists): Ditto.

	(Invocation::ConversionExists): Implement.

2001-09-22  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (OverloadResolve): Improve some more to catch errors 1502 and 1503
	Also take an additional TypeContainer argument.

	* All over : Pass in TypeContainer as argument to OverloadResolve.

	* typemanager.cs (CSharpName): Update to check for the string type and return
	that too.

	* expression.cs (Invocation::FullMethodDesc): New static method to return a string fully describing
	a given method.
	
2001-09-21  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Invocation::OverloadResolve): Re-write to conform more to the spec.
	(Invocation::BetterFunction): Implement.
	(Invocation::BetterConversion): Implement.
	(Invocation::ConversionExists): Skeleton, no implementation yet.

	Okay, things work fine !

2001-09-21  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs: declare and load enum_type, delegate_type and
	void_type. 

	* expression.cs (Expression::Emit): Now emit returns a value that
	tells whether a value is left on the stack or not.  This strategy
	might be reveted tomorrow with a mechanism that would address
	multiple assignments.
	(Expression::report118): Utility routine to report mismatches on
	the ExprClass.

	(Unary::Report23): Report impossible type/operator combination
	utility function.

	(Unary::IsIncrementableNumber): Whether the type can be
	incremented or decremented with add.
	(Unary::ResolveOperator): Also allow enumerations to be bitwise
	complemented. 
	(Unary::ResolveOperator): Implement ++, !, ~,

	(Invocation::Emit): Deal with new Emit convetion.
	
	* All Expression derivatives: Updated their Emit method to return
	whether they leave values on the stack or not.
	
	* codegen.cs (CodeGen::EmitStatement): Pop values left on the
	stack for expressions that are statements. 

2001-09-20  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (LValue): New interface.  Must be implemented by
	LValue objects.
	(LocalVariableReference, ParameterReference, FieldExpr): Implement
	LValue interface.
	
	* assign.cs (Assign::Emit, Assign::Resolve): Use new LValue
	interface for generating code, simplifies the code.

2001-09-20  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (everywhere): Comment out return statements in ::Resolve
	methods to avoid the warnings.

2001-09-20  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs (parse): Report error 2001 if we can not open the
	source file.

	* expression.cs (SimpleName::ResolveSimpleName): Error if we can
	not resolve it.

	* cs-parser.jay (QualifierIdentifier): Pass location to SimpleName
	object. 

	* statement.cs (Block::EmitMeta): Reuse the count across all the variables,
	otherwise nested blocks end up with the same index.

	* codegen.cs (CodeGen::EmitTopBlock): Pass initial sequence

	* expression.cs:  Instead of having FIXMEs in the Resolve
	functions, throw exceptions so it is obvious that we are facing a
	bug. 

	* cs-parser.jay (invocation_expression): Pass Location information.

	* codegen.cs (CodeGen::Save, CodeGen::CodeGen, CodeGen::Basename):
	Use a basename for those routines because .NET does not like paths
	on them. 

	* class.cs (TypeContainer::AddMethod): Do not call DefineName if the name was
	already defined.

2001-09-19  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (TypeManager::CoreLookupType): A function to make sure that we
	are loading the correct data types (throws an exception if not).
	(TypeManager::InitCoreTypes): Use CoreLookupType

	* expression.cs (Unary::ResolveOperator): return the child
	expression for expressions which are just +expr.
	(Unary::ResolveOperator): Return negative literals for -LITERAL
	expressions (otherwise they are Unary {Literal}).
	(Invocation::Badness): Take into account `Implicit constant
	expression conversions'.

	* literal.cs (LongLiteral): Implement long literal class.
	(IntLiteral): export the `Value' of the intliteral. 

2001-09-19  Ravi Pratap  <ravi@ximian.com>

	* expression.cs (Binary::Emit): Finally get the emission right ! Woo!

	* class.cs (Operator::Define): Change the methodname prefix to 'op_' 
	instead of 'Operator'

	* expression.cs (Binary::ResolveOperator): Update accordingly.
	(Unary::Operator): Change names to 'Add' and 'Subtract' instead 'Plus'
	and 'Minus'

	* cs-parser.jay (unary_expression): Update to use the new names.

	* gen-treedump.cs (GetUnary): Same here.

	* expression.cs (Unary::Resolve): Implement.
	(Binary::ResolveOperator): Re-write bits to quietly continue if no overloaded 
	operators are found instead of making noise ;-)
	(Unary::ResolveOperator): New method to do precisely the same thing which
	Binary::ResolveOperator does for Binary expressions.
	(Unary.method, .Arguments): Add.
	(Unary::OperName): Implement.	
	(Unary::ForceConversion): Copy and Paste !

	* class.cs (Operator::Define): Fix a small bug for the case when we have 
	a unary operator.

	* expression.cs (Unary::Emit): Implement. Need to find the right Opcodes
	for the inbuilt operators. Only overloading works for now ;-)

2001-09-18  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (CheckedExpr::Resolve, CheckedExpr::Emit,
	UnCheckedExpr::Resolve, UnCheckedExpr::Emit): Implement.

	* expression.cs (This::Emit): Implement. 
	(This::Resolve): Implement.
	(TypeOf:Resolve): Implement.
	(Expression::ResolveSimpleName): Add an implicit this to instance
	field references. 
	(MemberAccess::Resolve): Deal with Parameters and Fields. 
	Bind instance variable to Field expressions.
	(FieldExpr::Instance): New field used to track the expression that
	represents the object instance.
	(FieldExpr::Resolve): Track potential errors from MemberLookup not
	binding 
	(FieldExpr::Emit): Implement.

	* codegen.cs (EmitIf, EmitStatement, EmitBlock): Propagate whether
	the last instruction contains a return opcode to avoid generating
	the last `ret' instruction (this generates correct code, and it is
	nice to pass the peverify output).

	* class.cs (TypeContainer::EmitFieldInitializers): Implement field
	initializer for static and instance variables.
	(Constructor::Emit): Allow initializer to be null in the case of
	static constructors.  Only emit initializer for instance
	constructors. 

	(TypeContainer::FindMembers): Return a null array if there are no
	matches.

	Also fix the code for the MemberTypes.Method branch, as it was not
	scanning that for operators (or tried to access null variables before).

	* assign.cs (Assign::Emit): Handle instance and static fields. 

	* TODO: Updated.

	* driver.cs: Stop compilation if there are parse errors.

	* cs-parser.jay (constructor_declaration): Provide default base
	initializer for non-static constructors.
	(constructor_declarator): Do not provide a default base
	initializers if none was specified.
	Catch the fact that constructors should not have parameters.

	* class.cs: Do not emit parent class initializers for static
	constructors, that should be flagged as an error.

2001-09-18  Ravi Pratap  <ravi@ximian.com>

	* class.cs (RegisterMethodBuilder): Remove : it's unnecessary.
	Move back code into TypeContainer::Populate.

2001-09-18  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer::AddConstructor): Fix the check to
	compare against Name, not Basename. 
	(Operator::OpType): Change Plus and Minus to Add and Subtract.

	* cs-parser.jay : Update accordingly.

	* class.cs (TypeContainer::FindMembers): For the case where we are searching
	for methods, don't forget to look into the operators too.
	(RegisterMethodBuilder): Helper method to take care of this for
	methods, constructors and operators.
	(Operator::Define): Completely revamp.
	(Operator.OperatorMethod, MethodName): New fields.
	(TypeContainer::Populate): Move the registering of builders into
	RegisterMethodBuilder.
	(Operator::Emit): Re-write.

	* expression.cs (Binary::Emit): Comment out code path to emit method
	invocation stuff for the case when we have a user defined operator. I am
	just not able to get it right !
	
2001-09-17  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Expression::OverloadResolve): Drop TypeContainer
	argument. 

	(Expression::MemberLookup): Provide a version that allows to
	specify the MemberTypes and BindingFlags. 

	* statement.cs (Block::GetVariableInfo): Forgot to recurse here,
	so it was not fetching variable information from outer blocks.

	* modifiers.cs: (Modifiers::TypeAttr): Invert condition on
	Beforefieldinit as it was buggy.

	* rootcontext.cs (::LookupInterfaceOrClass): Removed an Error -200
	that Ravi put here.  

	* class.cs (Constructor::Emit): Only emit if block is not null.
	(TypeContainer::EmitDefaultConstructor): Removed routine, now we
	deal with this by semantically definining it as if the user had
	done it.

	(TypeContainer::FindMembers): Removed ad-hoc hack to deal with
	constructors as we now "emit" them at a higher level.

	(TypeContainer::DefineDefaultConstructor): Used to define the
	default constructors if none was provided.

	(ConstructorInitializer): Add methods Resolve and Emit. 
	
	* expression.cs: Cast to ConstructorInfo instead of MethodInfo

2001-09-17  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer::EmitDefaultConstructor): Register
	the default constructor builder with our hashtable for methodbuilders
	to methodcores.

	* expression.cs (Invocation::OverloadResolve): Add a check for pd == null
	and argument_count is 0 in which case we have a match.
	(Binary::ResolveOperator): More null checking and miscellaneous coding
	style cleanup.

2001-09-17  Ravi Pratap  <ravi@ximian.com>

	* rootcontext.cs (IsNameSpace): Compare against null.

	* everywhere : Correct spelling to 'Greater' and to 'Subtract'

	* class.cs (Operator::OpType): Change names to match the ones in Binary::Operator
	and Unary::Operator.

	* cs-parser.jay (operator_declaration, CheckBinaryOperator, CheckUnaryOperator): Update
	accordingly.

	* expression.cs (Binary::method): New member to hold the MethodBase for the case when
	we have overloaded operators.
	(Binary::ResolveOperator): Implement the part which does the operator overload
	resolution.

	* class.cs (Operator::Emit): Implement.
	(TypeContainer::Emit): Emit the operators we have too.

	* expression.cs (Binary::Emit): Update to emit the appropriate code for
	the case when we have a user-defined operator.
	
2001-09-17  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs: Fix bug: tree.Namespaces might be null.

2001-09-16  Ravi Pratap  <ravi@ximian.com>

	* class.cs (EmitStaticFieldInitializers, EmitFieldInitializers): Make public.
	(TypeContainer::EmitConstructor): Remove and move code into Contructor::Emit.
	(Constructor::Emit): Implement.
	(EmitStaticFieldInitializers, EmitFieldInitializers): Ensure we return immediately
	if we have no work to do. 
	(TypeContainer::Emit): Pass in TypeContainer as argument to the constructor's 
	Emit method.

	* interface.cs (Interface::InterfaceAttr): Re-write to be more correct and complete.
	(Interface::IsTopLevel): Add. Same as TypeContainer::IsTopLevel.

	* class.cs (TypeContainer::IsTopLevel): Modify to use parent.Parent instead
	of parent.parent.

2001-09-15  Ravi Pratap  <ravi@ximian.com>

	* tree.cs (Tree::namespaces): New hashtable to keep track of namespaces
	in the source.
	(Tree::RecordNamespace): Method to do what the name says ;-)
	(Tree::Namespaces): Property to get at the namespaces hashtable.

	* cs-parser.jay (namespace_declaration): Call RecordNamespace to 
	keep track.

	* rootcontext.cs (IsNamespace): Fixed it :-)

2001-09-14  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer::FindMembers): Add support for
	constructors. 
	(MethodCore): New class that encapsulates both the shared aspects
	of a Constructor and a Method.  
	(Method, Constructor): Factored pieces into MethodCore.

	* driver.cs: Added --fatal which makes errors throw exceptions.
	Load System assembly as well as part of the standard library.

	* report.cs: Allow throwing exceptions on errors for debugging.

	* modifiers.cs: Do not use `parent', instead use the real type
	container to evaluate permission settings.

	* class.cs: Put Ravi's patch back in.  He is right, and we will
	have to cope with the

2001-09-14  Ravi Pratap  <ravi@ximian.com>

	* modifiers.cs (TypeAttr, MethodAttr, FieldAttr): Map protected internal to
	FamORAssem, not FamANDAssem.
	
2001-09-14  Miguel de Icaza  <miguel@ximian.com>

	* driver.cs: Added --parse option that only parses its input files
	and terminates.

	* class.cs: Reverted last change from Ravi to IsTopLevel.  That is
	incorrect.  IsTopLevel is not used to tell whether an object is
	root_types or not (that can be achieved by testing this ==
	root_types).  But to see if this is a top-level *class* (not
	necessarly our "toplevel" container). 

2001-09-14  Ravi Pratap  <ravi@ximian.com>

	* enum.cs (Enum::Define): Modify to call the Lookup method on the
	parent instead of a direct call to GetType.

2001-09-14  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer::TypeAttr): Remove property code and move it into
	Modifiers.TypeAttr. This should just be a call to that method.

	* modifiers.cs (TypeAttr): Re-write and take an extra argument, the TypeContainer
	object so that we can determine if we are top-level or not.

	* delegate.cs (Delegate::Define): Update call to TypeAttr method to pass in the 
	TypeContainer too.

	* enum.cs (Enum::Define): Ditto.

	* modifiers.cs (FieldAttr): Re-write.

	* class.cs (TypeContainer::IsTopLevel): Change accessibility to public.
	(TypeContainer::HaveStaticConstructor): New property to provide access
	to precisely that info.

	* modifiers.cs (MethodAttr): Re-write.
	(EventAttr): Remove altogether as there seems to be no ostensible use for it.

	* class.cs (TypeContainer::IsTopLevel): Re-write. root_types doesn't seem to be the parent
	of top-level types as claimed.
	
2001-09-13  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (MemberLookup): Fruitless attempt to lookup
	constructors.  Maybe I need to emit default constructors?  That
	might be it (currently .NET emits this for me automatically).
	(Invocation::OverloadResolve): Cope with Arguments == null.
	(Invocation::EmitArguments): new function, shared by the new
	constructor and us.
	(Invocation::Emit): Handle static and instance methods.  Emit
	proper call instruction for virtual or non-virtual invocations.
	(New::Emit): Implement.
	(New::Resolve): Implement.
	(MemberAccess:Resolve): Implement.
	(MethodGroupExpr::InstanceExpression): used conforming to the spec
	to track instances.
	(FieldExpr::Resolve): Set type.

	* support.cs: Handle empty arguments.
		
	* cs-parser.jay (CompositeLookup, QualifierIdentifier,
	SimpleLookup): Auxiliary routines to help parse a qualifier
	identifier.  

	Update qualifier_identifier rule.

	* codegen.cs: Removed debugging messages.

	* class.cs: Make this a global thing, this acts just as a "key" to
	objects that we might have around.

	(Populate): Only initialize method_builders_to_methods once.

	* expression.cs (PropertyExpr): Initialize type from the
	PropertyType. 

	* codegen.cs (EmitContext::EmitBoolExpression): Use propper
	Resolve pattern.  Attempt to implicitly convert value to boolean.
	Emit code.

	* expression.cs: Set the type for the int32/int32 argument case.
	(Binary::ResolveOperator): Set the return type to boolean for
	comparission operators

	* typemanager.cs: Remove debugging print code.

	(Invocation::Resolve): resolve type.

	* class.cs: Allocate a MemberInfo of the correct size, as the code
	elsewhere depends on the test to reflect the correct contents.

	(Method::) Keep track of parameters, due to System.Reflection holes

	(TypeContainer::Populate): Keep track of MethodBuilders to Method
	mapping here.

	(TypeContainer::FindMembers): Use ArrayList and then copy an array
	of the exact size and return that.

	(Class::LookupMethodByBuilder): New function that maps
	MethodBuilders to its methods.  Required to locate the information
	on methods because System.Reflection bit us again.

	* support.cs: New file, contains an interface ParameterData and
	two implementations: ReflectionParameters and InternalParameters
	used to access Parameter information.  We will need to grow this
	as required.

	* expression.cs (Invocation::GetParameterData): implement a cache
	and a wrapper around the ParameterData creation for methods. 
	(Invocation::OverloadResolve): Use new code.

2001-09-13  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer::EmitField): Remove and move into 
	(Field::Define): here and modify accordingly.
	(Field.FieldBuilder): New member.
	(TypeContainer::Populate): Update accordingly.
	(TypeContainer::FindMembers): Implement.

2001-09-13  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs: (VariableInfo::VariableType): New field to be
	initialized with the full type once it is resolved. 

2001-09-12  Miguel de Icaza  <miguel@ximian.com>

	* parameter.cs (GetParameterInfo): Use a type cache to compute
	things only once, and to reuse this information

	* expression.cs (LocalVariableReference::Emit): Implement.
	(OpcodeCast::Emit): fix.

	(ParameterReference::Resolve): Implement.
	(ParameterReference::Emit): Implement.

	* cs-parser.jay: Fix bug introduced by Ravi, variable initializers
	that are expressions need to stay as Expressions.

	* typemanager.cs (CSharpName): Returns the C# name of a type if
	possible. 

	* expression.cs (Expression::ConvertImplicit): New function that
	implements implicit type conversions.

	(Expression::ImplicitReferenceConversion): Implements implicit
	reference conversions.

	(EmptyCast): New type for transparent casts.

	(OpcodeCast): New type for casts of types that are performed with
	a sequence of bytecodes.
	
	(BoxedCast): New type used for casting value types into reference
	types.  Emits a box opcode.

	(Binary::DoNumericPromotions): Implements numeric promotions of
	and computation of the Binary::Type.

	(Binary::EmitBranchable): Optimization.

	(Binary::Emit): Implement code emission for expressions.
	
	* typemanager.cs (TypeManager): Added two new core types: sbyte
	and byte.

2001-09-12  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer::FindMembers): Method which does exactly
	what Type.FindMembers does, only we don't have to use reflection. No
	implementation yet.

	* typemanager.cs (typecontainers): New hashtable to hold the corresponding
	typecontainer objects as we need to get at them.
	(TypeManager::AddUserType): Overload to take an extra argument, the TypeContainer.

	* rootcontext.cs : Correspondingly modify called to AddUserType to pass the
	typecontainer object.

	* expression.cs (MemberLookup): Modify signature to take a RootContext object instead
	of just a Report object.

2001-09-11  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Event::Define): Go back to using the prefixes "add_" and
	"remove_"
	(TypeContainer::Populate): Now define the delegates of the type too.
	(TypeContainer.Delegates): Property to access the list of delegates defined
	in the type.

	* delegates.cs (Delegate::Define): Implement partially.

	* modifiers.cs (TypeAttr): Handle more flags.

2001-09-11  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Indexer::Define): Fix for loop iteration condition to be just <
	and not <=
	(Operator::Define): Re-write logic to get types by using the LookupType method
	instead of blindly doing a Type.GetType ! How stupid can I get ;-) ?
 	(Indexer::Define): Ditto.
	(Event::Define): Ditto.
	(Property::Define): Ditto.
	
2001-09-10  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer::Populate): Now define operators too. 
	(TypeContainer.Operators): New property to access the list of operators
	in a type.
	(Operator.OperatorMethodBuilder): New member to hold the method builder
	for the operator we are defining.
	(Operator::Define): Implement.

2001-09-10  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Event::Define): Make the prefixes of the accessor methods
	addOn_ and removeOn_ 

	* genericparser.cs (GenericParser::error): Overloaded method to handle the case
	of the location being passed in too. Ideally, this should go later since all
	error reporting should be done through the Report object.

	* class.cs (TypeContainer.Indexers): New property to access the list of indexers.
	(Populate): Iterate thru the indexers we have and define them too.
	(Indexer.GetMethodBuilder, .SetMethodBuilder): New members to hold the method builders
	for the get and set accessors.
	(Indexer::Define): Implement.
	
2001-09-09  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (Binary::Resolve): Beginning of it.  I scratched
	my previous implementation, did not work.

	* typemanager.cs: Add a couple of missing types (the longs).

	* literal.cs: Use TypeManager.bool_type instead of getting it.

	* expression.cs (EventExpr): New kind of expressions.
	(Expressio::ExprClassFromMemberInfo): finish

2001-09-08  Miguel de Icaza  <miguel@ximian.com>

	* assign.cs: Emit stores to static fields differently.

2001-09-08  Ravi Pratap  <ravi@ximian.com>

	* Merge in changes and adjust code to tackle conflicts. Backed out my
	code in Assign::Resolve ;-) 

2001-09-08  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (CheckAttributeTarget): Modify call to error to use
	instead Report.Error and also pass in the location.
	(CSharpParser::Lexer): New readonly property to return the reference
	to the Tokenizer object.
	(declare_local_variables): Use Report.Error with location instead of plain 
	old error.
	(CheckDef): Ditto.

	* class.cs (Operator::CheckUnaryOperator): Move into cs-parser.jay.
	(Operator.CheckBinaryOperator): Ditto.

	* cs-parser.jay (operator_declarator): Update accordingly.

	* cs-parser.jay (CheckUnaryOperator): Modify to use Report.Error
	(CheckBinaryOperator): Same here.

	* rootcontext.cs (LookupType): Add an extra lookup which simply does a lookup
	on the name without any prefixes of namespace names etc. This is because we
	already might have something already fully qualified like 
	'System.Console.WriteLine'

	* assign.cs (Resolve): Begin implementation. Stuck ;-)

2001-09-07  Ravi Pratap  <ravi@ximian.com>

	* cs-tokenizer.cs (location): Return a string which also contains
	the file name.

	* expression.cs (ElementAccess): New class for expressions of the
	type 'element access.'
	(BaseAccess): New class for expressions of the type 'base access.'
	(CheckedExpr, UnCheckedExpr): New classes for Checked and Unchecked expressions
	respectively.
	
	* cs-parser.jay (element_access): Implement action.
	(base_access): Implement actions.
	(checked_expression, unchecked_expression): Implement.

	* cs-parser.jay (local_variable_type): Correct and implement.
	(type_suffixes, type_suffix_list, type_suffix): Implement actions.

	* cs-tokenizer.cs (real_type_suffix): Comment out the extra getchar.

	* cs-parser.jay (rank_specifiers): Remove space while concatenating the type's
	name and the specifiers.

	* interface.cs (InterfaceAttr): New property to return the corresponding TypeAttributes
	
	* rootcontext.cs (CreateInterface): Use the InterfaceAttr property instead of 
	making them all public ;-)

	* cs-parser.jay (error): Remove entirely as we have an implementation in the base
	class anyways.
	
2001-09-07  Miguel de Icaza  <miguel@ximian.com>

	* expression.cs (ExprClassFromMemberInfo): Return FieldExpr and
	PropertyExprs.
	(FieldExpr, PropertyExprs): New resolved expressions.
	(SimpleName::MemberStaticCheck): Perform static checks for access
	to non-static fields on static methods. Maybe this should be
	generalized for MemberAccesses. 
	(SimpleName::ResolveSimpleName): More work on simple name
	resolution. 

	* cs-parser.jay (primary_expression/qualified_identifier): track
	the parameter index.

	* codegen.cs (CodeGen::Save): Catch save exception, report error.
	(EmitContext::EmitBoolExpression): Chain to expression generation
	instead of temporary hack.
	(::EmitStatementExpression): Put generic expression code generation.

	* assign.cs (Assign::Emit): Implement variable assignments to
	local variables, parameters and fields.

2001-09-06  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs (Block::GetVariableInfo): New method, returns the
	VariableInfo for a variable name in a block.
	(Block::GetVariableType): Implement in terms of GetVariableInfo

	* literal.cs (IntLiteral::Emit, FloatLiteral::Emit,
	DoubleLiteral::Emit, CharLiteral::Emit, BoolLiteral::Emit): Implement

2001-09-06  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (operator_declaration): Continue on my quest : update
	to take attributes argument.
	(event_declaration): Ditto.
	(enum_declaration): Ditto.
	(indexer_declaration): Ditto.
	
	* class.cs (Operator::Operator): Update constructor accordingly.
	(Event::Event): Ditto.

	* delegate.cs (Delegate::Delegate): Same here.

	* enum.cs (Enum::Enum): Same here.
	
2001-09-05  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (CheckAttributeTarget): Update to use the right error number.

	* ../tests/cs0658.cs : New file to demonstrate error 0658.

	* attribute.cs (Attributes): New class to encapsulate all attributes which were
	being passed around as an arraylist.
	(Attributes::AddAttribute): Method to add attribute sections.

	* cs-parser.jay (opt_attributes): Modify actions to use the new Attributes class.
	(struct_declaration): Update accordingly.
	(constant_declaration): Update.
	(field_declaration): Update.
	(method_header): Update.
	(fixed_parameter): Update.
	(parameter_array): Ditto.
	(property_declaration): Ditto.
	(destructor_declaration): Ditto.
	
	* class.cs (Struct::Struct): Update constructors accordingly.
	(Class::Class): Ditto.
	(Field::Field): Ditto.
	(Method::Method): Ditto.
	(Property::Property): Ditto.
	(TypeContainer::OptAttribute): update property's return type.
	
	* interface.cs (Interface.opt_attributes): New member.
	(Interface::Interface): Update to take the extra Attributes argument.

	* parameter.cs (Parameter::Parameter): Ditto.

	* constant.cs (Constant::Constant): Ditto.

	* interface.cs (InterfaceMemberBase): New OptAttributes field.
	(InterfaceMemberBase::InterfaceMemberBase): Update constructor to take 
	the attributes as a parameter.
	(InterfaceProperty): Update constructor call.
	(InterfaceEvent): Ditto.
	(InterfaceMethod): Ditto.
	(InterfaceIndexer): Ditto.

	* cs-parser.jay (interface_indexer_declaration): Update call to constructor to 
	pass the attributes too.
	(interface_event_declaration): Ditto.
	(interface_property_declaration): Ditto.
	(interface_method_declaration): Ditto.
	(interface_declaration): Ditto.

2001-09-05  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (Method::Define): Track the "static Main" definition to
	create an entry point. 

	* rootcontext.cs (RootContext::EntryPoint): MethodInfo that holds the
	EntryPoint if we find it. 

	* codegen.cs (EmitContext::EmitInvocation): Emit invocations.
	(EmitContext::ig): Make this variable public.

	* driver.cs: Make the default output file be the first file name
	with the .exe extension.  

	Detect empty compilations

	Handle various kinds of output targets.  Handle --target and
	rename -t to --dumper.

	* expression.cs, literal.cs, assign.cs, constant.cs: All `Resolve'
	methods inherited from Expression return now an Expression.  This
	will is used during the tree rewriting as we resolve them during
	semantic analysis.

	(Expression::MemberLookup): Implements the MemberLookup (7.3) from
	the spec.  Missing entirely is the information about
	accessability of elements of it.

	(Expression::ExprClassFromMemberInfo): New constructor for
	Expressions that creates a fully initialized Expression based on
	a MemberInfo that is one of Eventinfo, FieldINfo, PropertyInfo or
	a Type.

	(Invocation::Resolve): Begin implementing resolution of invocations.
	
	* literal.cs (StringLiteral):  Implement Emit.

2001-09-05  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (error): Add new modifier because we are hiding an inherited
	member.
	
2001-09-04  Ravi Pratap  <ravi@ximian.com>

	* cs-parser.jay (attribute_arguments): Implement actions.
	(attribute): Fix bug in production. Implement action.
	(attribute_list): Implement.
	(attribute_target): Implement.
	(attribute_target_specifier, opt_target_specifier): Implement
	(CheckAttributeTarget): New method to check if the attribute target
	is valid.
	(attribute_section): Implement.
	(opt_attributes): Implement.

	* attribute.cs : New file to handle attributes.
	(Attribute): Class to hold attribute info.

	* cs-parser.jay (opt_attribute_target_specifier): Remove production
	(attribute_section): Modify production to use 2 different rules to 
	achieve the same thing. 1 s/r conflict down !
	Clean out commented, useless, non-reducing dimension_separator rules.
	
	* class.cs (TypeContainer.attributes): New member to hold list
	of attributes for a type.
	(Struct::Struct): Modify to take one more argument, the attribute list.
	(Class::Class): Ditto.
	(Field::Field): Ditto.
	(Method::Method): Ditto.
	(Property::Property): Ditto.
	
	* cs-parser.jay (struct_declaration): Update constructor call to
	pass in the attributes too.
	(class_declaration): Ditto.
	(constant_declaration): Ditto.
	(field_declaration): Ditto.
	(method_header): Ditto.
	(fixed_parameter): Ditto.
	(parameter_array): Ditto.
	(property_declaration): Ditto.

	* constant.cs (Constant::Constant): Update constructor similarly.
	Use System.Collections.

	* parameter.cs (Parameter::Parameter): Update as above.

2001-09-02  Ravi Pratap  <ravi@ximian.com>

	* class.cs (TypeContainer::AddDelegate): New method to add a delegate.
	(TypeContainer.delegates): New member to hold list of delegates.

	* cs-parser.jay (delegate_declaration): Implement the action correctly 
	this time as I seem to be on crack ;-)

2001-09-02  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs (RootContext::IsNamespace): new function, used to
	tell whether an identifier represents a namespace.

	* expression.cs (NamespaceExpr): A namespace expression, used only
	temporarly during expression resolution.
	(Expression::ResolveSimpleName, ::ResolvePrimary, ::ResolveName):
	utility functions to resolve names on expressions.

2001-09-01  Miguel de Icaza  <miguel@ximian.com>

	* codegen.cs: Add hook for StatementExpressions. 

	* class.cs: Fix inverted test for static flag in methods.

2001-09-02  Ravi Pratap  <ravi@ximian.com>

	* class.cs (Operator::CheckUnaryOperator): Correct error number used
	to make it coincide with MS' number.
	(Operator::CheckBinaryOperator): Ditto.

	* ../errors/errors.txt : Remove error numbers added earlier.

	* ../errors/cs1019.cs : Test case for error # 1019

	* ../errros/cs1020.cs : Test case for error # 1020

	* cs-parser.jay : Clean out commented cruft.
	(dimension_separators, dimension_separator): Comment out. Ostensibly not
	used anywhere - non-reducing rule.
	(namespace_declarations): Non-reducing rule - comment out.

	* enum.cs (Enum::AddEnum): Rename to AddEnumMember as I was getting confused
	with TypeContainer::AddEnum.

	* delegate.cs : New file for delegate handling classes.
	(Delegate): Class for declaring delegates.

	* makefile : Update.

	* cs-parser.jay (delegate_declaration): Implement.

2001-09-01  Ravi Pratap  <ravi@che.iitm.ac.in>

	* class.cs (Event::Define): Implement.
	(Event.EventBuilder): New member.

	* class.cs (TypeContainer::Populate): Update to define all enums and events
	we have.
	(Events): New property for the events arraylist we hold. Shouldn't we move to using
	readonly fields for all these cases ?

2001-08-31  Ravi Pratap  <ravi@che.iitm.ac.in>

	* class.cs (Property): Revamp to use the convention of making fields readonly.
	Accordingly modify code elsewhere.

	* class.cs : Apply patch from Mr. Mandar <go_mono@hotmail.com> for implementing
	the Define method of the Property class.

	* class.cs : Clean up applied patch and update references to variables etc. Fix 
	trivial bug.
	(TypeContainer::Populate): Update to define all the properties we have. Also
	define all enumerations.

	* enum.cs (Define): Implement.
	
2001-08-31  Ravi Pratap  <ravi@che.iitm.ac.in>

	* cs-parser.jay (overloadable_operator): The semantic value is an
	enum of the Operator class.
	(operator_declarator): Implement actions.
	(operator_declaration): Implement.

	* class.cs (Operator::CheckUnaryOperator): New static method to help in checking
	validity of definitions.
	(Operator::CheckBinaryOperator): Static method to check for binary operators
	(TypeContainer::AddOperator): New method to add an operator to a type.

	* cs-parser.jay (indexer_declaration): Added line to actually call the
	AddIndexer method so it gets added ;-)

	* ../errors/errors.txt : Update to include new error numbers. Are these numbers 
	already taken care of by the MS compiler ?  

2001-08-29  Ravi Pratap  <ravi@che.iitm.ac.in>

	* class.cs (Operator): New class for operator declarations.
	(Operator::OpType): Enum for the various operators.

2001-08-29  Ravi Pratap  <ravi@che.iitm.ac.in>

	* class.cs (TypeContainer::AddIndexer): Remove FIXME comment. We
	ostensibly handle this in semantic analysis.

	* cs-parser.jay (general_catch_clause): Comment out
	(specific_catch_clauses, specific_catch_clause): Ditto.
	(opt_general_catch_clause, opt_specific_catch_clauses): Ditto
	(catch_args, opt_catch_args): New productions.
	(catch_clause): Rewrite to use the new productions above
	(catch_clauses): Modify accordingly.
	(opt_catch_clauses): New production to use in try_statement
	(try_statement): Revamp. Basically, we get rid of one unnecessary rule
	and re-write the code in the actions to extract the specific and
	general catch clauses by being a little smart ;-)

	* ../tests/try.cs : Fix. It's not 'finalize' my friend, it's 'finally' !
	Hooray, try and catch statements parse fine !
	
2001-08-28  Ravi Pratap  <ravi@che.iitm.ac.in>

	* statement.cs (Block::GetVariableType): Fix logic to extract the type
	string from the hashtable of variables.

	* cs-parser.jay (event_accessor_declarations): Trivial fix. Man, how did
	I end up making that mistake ;-)
	(catch_clauses): Fixed gross error which made Key and Value of the 
	DictionaryEntry the same : $1 !!

2001-08-28  Ravi Pratap  <ravi@che.iitm.ac.in>

	* cs-tokenizer.cs (initTokens): Add keywords 'add' and 'remove'

	* cs-parser.jay (event_declaration): Correct to remove the semicolon
	when the add and remove accessors are specified. 

2001-08-28  Ravi Pratap  <ravi@che.iitm.ac.in>

	* cs-parser.jay (IndexerDeclaration): New helper class to hold
	information about indexer_declarator.
	(indexer_declarator): Implement actions.
	(parsing_indexer): New local boolean used to keep track of whether
	we are parsing indexers or properties. This is necessary because 
	implicit_parameters come into picture even for the get accessor in the 
	case of an indexer.
	(get_accessor_declaration, set_accessor_declaration): Correspondingly modified.

	* class.cs (Indexer): New class for indexer declarations.
	(TypeContainer::AddIndexer): New method to add an indexer to a type.
	(TypeContainer::indexers): New member to hold list of indexers for the
	type.

2001-08-27  Ravi Pratap  <ravi@che.iitm.ac.in>

	* cs-parser.jay (add_accessor_declaration): Implement action.
	(remove_accessor_declaration): Implement action.
	(event_accessors_declaration): Implement
	(variable_declarators): swap statements for first rule - trivial.

	* class.cs (Event): New class to hold information about event
	declarations.
	(TypeContainer::AddEvent): New method to add an event to a type
	(TypeContainer::events): New member to hold list of events.

	* cs-parser.jay (event_declaration): Implement actions.

2001-08-27  Ravi Pratap  <ravi@che.iitm.ac.in>

	* cs-parser.jay (dim_separators): Implement. Make it a string
	concatenating all the commas together, just as they appear.
	(opt_dim_separators): Modify accordingly
	(rank_specifiers): Update accordingly. Basically do the same
	thing - instead, collect the brackets here.
	(opt_rank_sepcifiers): Modify accordingly.
	(array_type): Modify to actually return the complete type string
	instead of ignoring the rank_specifiers.
	(expression_list): Implement to collect the expressions
	(variable_initializer): Implement. We make it a list of expressions
	essentially so that we can handle the array_initializer case neatly too.
	(variable_initializer_list): Implement.
	(array_initializer): Make it a list of variable_initializers
	(opt_array_initializer): Modify accordingly.

	* expression.cs (New::NType): Add enumeration to help us
	keep track of whether we have an object/delegate creation
	or an array creation.
	(New:NewType, New::Rank, New::Indices, New::Initializers): New
	members to hold data about array creation.
	(New:New): Modify to update NewType
	(New:New): New Overloaded contructor for the array creation
	case.

	* cs-parser.jay (array_creation_expression): Implement to call
	the overloaded New constructor.
	
2001-08-26  Ravi Pratap  <ravi@che.iitm.ac.in>

	* class.cs (TypeContainer::Constructors): Return member
	constructors instead of returning null.

2001-08-26  Miguel de Icaza  <miguel@ximian.com>

	* typemanager.cs (InitCoreTypes): Initialize the various core
	types after we have populated the type manager with the user
	defined types (this distinction will be important later while
	compiling corlib.dll)

	* expression.cs, literal.cs, assign.cs, constant.cs: Started work
	on Expression Classification.  Now all expressions have a method
	`Resolve' and a method `Emit'.

	* codegen.cs, cs-parser.jay: Fixed the bug that stopped code
	generation from working.     Also add some temporary debugging
	code. 
	
2001-08-24  Miguel de Icaza  <miguel@ximian.com>

	* codegen.cs: Lots of code generation pieces.  This is only the
	beginning, will continue tomorrow with more touches of polish.  We
	handle the fundamentals of if, while, do, for, return.  Others are
	trickier and I need to start working on invocations soon.
	
	* gen-treedump.cs: Bug fix, use s.Increment here instead of
	s.InitStatement. 

	* codegen.cs (EmitContext): New struct, used during code
	emission to keep a context.   Most of the code generation will be
	here. 

	* cs-parser.jay: Add embedded blocks to the list of statements of
	this block.  So code generation proceeds in a top down fashion.

2001-08-23  Miguel de Icaza  <miguel@ximian.com>

	* statement.cs: Add support for multiple child blocks.

2001-08-22  Miguel de Icaza  <miguel@ximian.com>

	* codegen.cs (EmitCode): New function, will emit the code for a
	Block of code given a TypeContainer and its ILGenerator. 

	* statement.cs (Block): Standard public readonly optimization.
	(Block::Block constructors): Link children. 
	(Block::Child): Child Linker.
	(Block::EmitVariables): Emits IL variable declarations.

	* class.cs: Drop support for MethodGroups here, delay until
	Semantic Analysis.
	(Method::): Applied the same simplification that I did before, and
	move from Properties to public readonly fields.
	(Method::ParameterTypes): Returns the parameter types for the
	function, and implements a cache that will be useful later when I
	do error checking and the semantic analysis on the methods is
	performed.
	(Constructor::GetCallingConvention): Renamed from CallingConvetion
	and made a method, optional argument tells whether this is a class
	or a structure to apply the `has-this' bit.
	(Method::GetCallingConvention): Implement, returns the calling
	convention. 
	(Method::Define): Defines the type, a second pass is performed
	later to populate the methods.

	(Constructor::ParameterTypes): implement a cache similar to the
	one on Method::ParameterTypes, useful later when we do semantic
	analysis. 

	(TypeContainer::EmitMethod):  New method.  Emits methods.

	* expression.cs: Removed MethodGroup class from here.
	
	* parameter.cs (Parameters::GetCallingConvention): new method.

2001-08-21  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer::Populate): Drop RootContext from the
	argument. 

	(Constructor::CallingConvention): Returns the calling convention.
	(Constructor::ParameterTypes): Returns the constructor parameter
	types. 
	
	(TypeContainer::AddConstructor): Keep track of default constructor
	and the default static constructor.

	(Constructor::) Another class that starts using `public readonly'
	instead of properties. 

	(Constructor::IsDefault): Whether this is a default constructor. 

	(Field::) use readonly public fields instead of properties also.

	(TypeContainer::TypeAttr, TypeContainer::AddConstructor): Keep
	track of static constructors;  If none is used, turn on
	BeforeFieldInit in the TypeAttributes. 

	* cs-parser.jay (opt_argument_list): now the return can be null
	for the cases where there are no arguments. 

	(constructor_declarator): If there is no implicit `base' or
	`this', then invoke the default parent constructor. 
	
	* modifiers.cs (MethodAttr): New static function maps a set of
	modifiers flags into a MethodAttributes enum
	(FieldAttr): renamed from `Map'.  So now we have FieldAttr,
	MethodAttr, TypeAttr to represent the various mappings where the
	modifiers are used.
	(FieldAttr): Map also `readonly' to `FieldAttributes.InitOnly' 	

2001-08-19  Miguel de Icaza  <miguel@ximian.com>

	* parameter.cs (GetParameterInfo): Fix bug where there would be no
	method arguments.

	* interface.cs (PopulateIndexer): Implemented the code generator
	for interface indexers.

2001-08-17  Miguel de Icaza  <miguel@ximian.com>

	* interface.cs (InterfaceMemberBase): Now we track the new status
	here.  

	(PopulateProperty): Implement property population.  Woohoo!  Got
	Methods and Properties going today. 

	Removed all the properties for interfaces, and replaced them with
	`public readonly' fields. 

2001-08-16  Miguel de Icaza  <miguel@ximian.com>

	* interface.cs (AddEvent, AddMethod, AddIndexer, AddProperty):
	initialize their hashtables/arraylists only when they are needed
	instead of doing this always.

	* parameter.cs: Handle refs and out parameters.

	* cs-parser.jay: Use an ArrayList to construct the arguments
	instead of the ParameterCollection, and then cast that to a
	Parameter[] array.

	* parameter.cs: Drop the use of ParameterCollection and use
	instead arrays of Parameters.

	(GetParameterInfo): Use the Type, not the Name when resolving
	types. 

2001-08-13  Miguel de Icaza  <miguel@ximian.com>

	* parameter.cs: Eliminate the properties Name, Type and ModFlags,
	and instead use public readonly fields.

	* class.cs: Put back walking code for type containers.

2001-08-11  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (MakeConstant): Code to define constants.

	* rootcontext.cs (LookupType): New function.  Used to locate types 

	
2001-08-08  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs: OH MY!  My trick works!   It is amazing how nice
	this System.Reflection code is.  Kudos to Microsoft
	
	* typemanager.cs: Implement a type cache and avoid loading all
	types at boot time.  Wrap in LookupType the internals.  This made
	the compiler so much faster.  Wow.  I rule!
	
	* driver.cs: Make sure we always load mscorlib first (for
	debugging purposes, nothing really important).

	* Renamespaced things that were on `CSC' to `CIR'.  Maybe I should
	have moved to `CSC' rather than `CIR'.  Oh man!  The confussion!  

	* rootcontext.cs: Lookup types on their namespace;  Lookup types
	on namespaces that have been imported using the `using' keyword.

	* class.cs (TypeContainer::TypeAttr): Virtualize.
	(Class::TypeAttr): Return attributes suitable for this bad boy.
	(Struct::TypeAttr): ditto.
	Handle nested classes.
	(TypeContainer::) Remove all the type visiting code, it is now
	replaced with the rootcontext.cs code

	* rootcontext.cs (GetClassBases): Added support for structs. 

2001-08-06  Miguel de Icaza  <miguel@ximian.com>

	* interface.cs, statement.cs, class.cs, parameter.cs,
	rootcontext.cs, gen-treedump.cs, enum.cs, cs-parse.jay:
	Drop use of TypeRefs, and use strings instead.

2001-08-04  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs: 

	* class.cs (Struct::Struct): set the SEALED flags after
	checking the modifiers.
	(TypeContainer::TypeAttr): new property, returns the
	TypeAttributes for a class.  

	* cs-parser.jay (type_list): Oops, list production was creating a
	new list of base types.

	* rootcontext.cs (StdLib): New property.
	(GetInterfaceTypeByName): returns an interface by type name, and
	encapsulates error handling here.
	(GetInterfaces): simplified.
	(ResolveTree): Encapsulated all the tree resolution here.
	(CreateClass, GetClassBases, GetInterfaceOrClass): Create class
	types. 
	
	* driver.cs: Add support for --nostdlib, to avoid loading the
	default assemblies.
	(Main): Do not put tree resolution here. 

	* rootcontext.cs: Beginning of the class resolution.

2001-08-03  Miguel de Icaza  <miguel@ximian.com>

	* rootcontext.cs: Provide better error reporting. 

	* cs-parser.jay (interface_base): set our $$ to be interfaces.

	* rootcontext.cs (CreateInterface): Handle the case where there
	are no parent interfaces.
	
	(CloseTypes): Routine to flush types at the end.
	(CreateInterface): Track types.
	(GetInterfaces): Returns an array of Types from the list of
	defined interfaces.

	* typemanager.c (AddUserType): Mechanism to track user types (puts
	the type on the global type hash, and allows us to close it at the
	end). 
	
2001-08-02  Miguel de Icaza  <miguel@ximian.com>

	* tree.cs: Removed RecordType, added RecordClass, RecordStruct and
	RecordInterface instead.

	* cs-parser.jay: Updated to reflect changes above.

	* decl.cs (Definition): Keep track of the TypeBuilder type that
	represents this type here.  Not sure we will use it in the long
	run, but wont hurt for now.

	* driver.cs: Smaller changes to accomodate the new code.

	Call ResolveInterfaceBases, Call ResolveClassBases, Save assembly
	when done. 

	* rootcontext.cs (CreateInterface):  New method, used to create
	the System.TypeBuilder type for interfaces.
	(ResolveInterfaces): new entry point to resolve the interface
	hierarchy. 
	(CodeGen): Property, used to keep track of the code generator.

2001-07-26  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Add a second production for delegate_declaration
	with `VOID'.

	(enum_body): Put an opt_comma here instead of putting it on
	enum_body or enum_member_declarations so we can handle trailing
	commas on enumeration members.  Gets rid of a shift/reduce.
	
	(type_list): Need a COMMA in the middle.

	(indexer_declaration): Tell tokenizer to recognize get/set

	* Remove old targets.

	* Re-add the parser target.

2001-07-13  Simon Cozens <simon@simon-cozens.org>

	* cs-parser.jay: Add precendence rules for a number of operators
	ot reduce the number of shift/reduce conflicts in the grammar.
	
2001-07-17  Miguel de Icaza  <miguel@ximian.com>

	* tree.cs: moved IGenerator interface and renamed it to ITreeDump
	and put it here.

	Get rid of old crufty code.

	* rootcontext.cs: Use this to keep track of the parsed
	representation and the defined types available to the program. 

	* gen-treedump.cs: adjust for new convention.

	* type.cs: Split out the type manager, and the assembly builder
	from here. 

	* typemanager.cs: the type manager will live here now.

	* cil-codegen.cs: And the code generator here. 

2001-07-14  Sean MacIsaac  <macisaac@ximian.com>

	* makefile: Fixed up for easy making.

2001-07-13  Simon Cozens <simon@simon-cozens.org>

	* cs-parser.jay (rank_specifier): Remove a conflict by reordering
	the 

	(unary_expression): Expand pre_increment_expression and
	post_decrement_expression to reduce a shift/reduce.

2001-07-11  Simon Cozens

	* cs-tokenizer.cs: Hex numbers should begin with a 0.

	Improve allow_keyword_as_indent name.

2001-06-19  Miguel de Icaza  <miguel@ximian.com>

	* Adjustments for Beta2. 

2001-06-13  Miguel de Icaza  <miguel@ximian.com>

	* decl.cs: Added `Define' abstract method.
	(InTransit): new property, used to catch recursive definitions. 

	* interface.cs: Implement `Define'. 

	* modifiers.cs: Map Modifiers.constants to
	System.Reflection.TypeAttribute flags.

	* class.cs: Keep track of types and user-defined types.
	(BuilderInit): New method for creating an assembly
	(ResolveType): New function to launch the resolution process, only
	used by interfaces for now.

	* cs-parser.jay: Keep track of Classes, Structs and Interfaces
	that are inserted into the name space. 

2001-06-08  Miguel de Icaza  <miguel@ximian.com>

	* ARGH.  I have screwed up my tree so many times due to the use of
	rsync rather than using CVS.  Going to fix this at once. 

	* driver.cs: Objetify driver.  Load assemblies, use assemblies to
	load types.

2001-06-07  Miguel de Icaza  <miguel@ximian.com>

	* Experiment successful: Use System.Type rather that our own
	version of Type.  

2001-05-25  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Removed nsAliases from here.

	Use new namespaces, handle `using XXX;' 

	* namespace.cs: Reimplemented namespace handling, use a recursive
	definition of the class.  Now we can keep track of using clauses
	and catch invalid using clauses.

2001-05-24  Miguel de Icaza  <miguel@ximian.com>

	* gen-treedump.cs: Adapted for all the renaming.

	* expression.cs (Expression): this class now has a Type property
	which returns an expression Type.

	(Probe::, New::, TypeOf::, SizeOf::, Constant::): renamed from
	`Type', as this has a different meaning now in the base

2001-05-22  Miguel de Icaza  <miguel@ximian.com>

	* interface.cs, class.cs: Removed from all the sources the
	references to signature computation, as we can not do method
	signature computation during the parsing time, as we are not
	trying to solve at that point distinguishing:

	class X {
		void a (Blah x) {}
		void a (NS.Blah x) {}
	}

	Which depending on the context might be valid or not, as we do not
	know if Blah is the same thing as NS.Blah at that point.

	* Redid everything so the code uses TypeRefs now instead of
	Types.  TypeRefs are just temporary type placeholders, that need
	to be resolved.  They initially have a pointer to a string and the
	current scope in which they are used.  This is used later by the
	compiler to resolve the reference to an actual Type. 

	* DeclSpace is no longer a CIR.Type, and neither are
	TypeContainers (Class and Struct) nor Interfaces nor Enums.  They
	are all DeclSpaces, but no Types. 

	* type.cs (TypeRefManager): This implements the TypeRef manager,
	which keeps track of all the types that need to be resolved after
	the parsing has finished. 

2001-05-13  Miguel de Icaza  <miguel@ximian.com>

	* ARGH.  We are going to have to store `foreach' as a class rather
	than resolving it, as we need to verify error 1579 after name
	resolution.   *OR* we could keep a flag that says `This request to
	IEnumerator comes from a foreach statement' which we can then use
	to generate the error.

2001-05-10  Miguel de Icaza  <miguel@ximian.com>

	* class.cs (TypeContainer.AddMethod): we now add methods to the
	MethodGroup instead of the method hashtable.  

	* expression.cs: Add MethodGroup abstraction, which gets us one
	step closer to the specification in the way we handle method
	declarations.  

	* cs-parser.jay (primary_expression): qualified_identifier now
	tried to match up an identifier to a local variable reference or
	to a parameter reference.

	current_local_parameters is now a parser global variable that
	points to the current parameters for the block, used during name
	lookup.

	(property_declaration): Now creates an implicit `value' argument to
	the set accessor.

2001-05-09  Miguel de Icaza  <miguel@ximian.com>

	* parameter.cs: Do not use `param' arguments as part of the
	signature, per the spec.

2001-05-08  Miguel de Icaza  <miguel@ximian.com>

	* decl.cs: Base class for classes, structs and interfaces.  This
	is the "Declaration Space" 

	* cs-parser.jay: Use CheckDef for checking declaration errors
	instead of having one on each function.

	* class.cs: Factor out some code for handling error handling in
	accordance to the "Declarations" section in the "Basic Concepts"
	chapter in the ECMA C# spec.

	* interface.cs: Make all interface member classes derive from
	InterfaceMemberBase.

2001-05-07  Miguel de Icaza  <miguel@ximian.com>

	* Many things: all interfaces are parsed and generated in
	gen-treedump.  Support for member variables, constructors,
	destructors, properties, constants is there.

	Beginning of the IL backend, but very little done, just there for
	testing purposes. 

2001-04-29  Miguel de Icaza  <miguel@ximian.com>

	* cs-parser.jay: Fix labeled statement.

	* cs-tokenizer.cs (escape): Escape " and ' always.
	ref_line, ref_name: keep track of the line/filename as instructed
	by #line by the compiler.
	Parse #line.

2001-04-27  Miguel de Icaza  <miguel@ximian.com>

	* System.CodeDOM/CodeBinaryOperatorExpression.cs: Rearrange enum
	to match the values in System.CodeDOM.

	Divid renamed to Divide.

	* System.CodeDOM/CodeForLoopStatement.cs: Always have valid
	statements. 
	(Statements.set): remove.

	* System.CodeDOM/CodeCatchClause.cs: always have a valid
	statements. 

	* System.CodeDOM/CodeIfStatement.cs: trueStatements and
	falseStatements always have valid values. 

	* cs-parser.jay: Use System.CodeDOM now.

