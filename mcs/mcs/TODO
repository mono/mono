BUGS
----

* Returning from exception blocks.

	Exception blocks can not actually "return", they have
	to "leave" to the end of the routine.

	If they need to return a value, the return value is stored in
	a temporary variable, and the final code, loads this value on
	the stack and returns.

* Reworking return values.

	To implement the above we need to rework the return mechanism.

* Adding variables.

	We do add variables in a number of places, and this is erroneous:

	void a (int b)
	{
		int b;
	}

	Also:

	void a (int b)
	{
		foreach (int b ...)
			;
	}

* Visibility

	I am not reporting errors on visibility yet.

* Interfaces

	For indexers, the output of ix2.cs is different from our
	compiler and theirs.  They use a DefaultMemberAttribute, which
	I have yet to figure out:

	.class interface private abstract auto ansi INTERFACE
	{
		.custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) 
		= ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..
		...
	}

* Interface indexers

	I have not figured out why the Microsoft version puts an
	`instance' attribute, and I am not generating this `instance' attribute.

	Explanation: The reason for the `instance' attribute on
	indexers is that indexers only apply to instances

* Handle destructors specially

	Turn ~X () { a () } into:
	void Finalize () { try { a (); } finally { base.Finalize (); } }

	The code is mostly done, but `base' is missing.  The reason it is 
	missing is because we have to implement visibility first.

* Method Names

	Method names could be; `IFACE.NAME' in the method declaration,
	stating that they implement a specific interface method.

	We currently fail to parse it.

* Namespaces

	Apparently:

		namespace X {
		}

		namespace X {
		}

	Is failing to create a single namespace

	>> This has been fixed. Test #33 tests this functionality

* Arrays

	We need to make sure at *compile time* that the arguments in
	the expression list of an array creation are always positive.

* Implement dead code elimination in statement.cs

	It is pretty simple to implement dead code elimination in 
	if/do/while

* Indexer bugs:

	the following wont work:

	x [0] = x [1] = N

	if x has indexers, the value of x [N] set is set to void.  This needs to be
	fixed.

* Array declarations

	Multi-dim arrays are declared as [,] instead of [0..,0..]

* Break/Continue statements

	A finally block should reset the InLoop/LoopBegin/LoopEnd, as
	they are logically outside the scope of the loop.

* Break/continue part 2.

	They should transfer control to the finally block if inside a try/catch
	block.

* Conversions and overflow

	I am not using the checked state while doing type casts,
	they should result in conv.ovf.XXX

PENDING TASKS
-------------

	* Implement explicit interface implemenation.

	* Implement Goto.

	* Unsafe code.

	* Implement `base' (BaseAccess class)

* OUT Variables passed as OUT variables.

	Currently we pass the pointer to the pointer (see expression.cs:Argument.Emit)

* Function Declarations

	Support PINvoke/Internallcall and extern declarated-functions.

* Manual field layout in structures

* Make the rules for inheritance/overriding apply to 
  properties, operators and indexers (currently we only do this
  on methods).

* Handle volatile

* Support Re-Throw exceptions:

	try {
		X ();
	} catch (SomeException e){
		LogIt ();
		throw;
	}

* Static flow analysis

	Required to warn about reachability of code and definite
	assignemt as well as missing returns on functions.

* Implement `goto case expr'


OPTIMIZATIONS
-------------

* Emitcontext

	Do we really need to instanciate this variable all the time?

	It could be static for all we care, and just use it for making
	sure that there are no recursive invocations on it.

* Static-ization

	Since AppDomain exists, maybe we can get rid of all the stuff
	that is part of the `compiler instance' and just use globals
	everywhere.


* Constructors

	Currently it calls the parent constructor before initializing fields.
	It should do it the other way around.

* Reducer and -Literal

	Maybe we should never handle -Literal in Unary expressions and let
	the reducer take care of it always?

* Use of EmitBranchable

	Currently I use brfalse/brtrue in the code for statements, instead of
	using the EmitBranchable function that lives in Binary

* Create an UnimplementedExpcetion

  	And use that instead of plain Exceptions to flag compiler errors.

* ConvertImplicit

	Currently ConvertImplicit will not catch things like:

	- IntLiteral in a float context to generate a -FloatLiteral.
	Instead it will perform an integer load followed by a conversion.

* Tests

	Write tests for the various reference conversions.  We have
	test for all the numeric conversions.

* Remove the tree dumper

	And make all the stuff which is `public readonly' be private unless
	required.

* Optimizations

	In Indexers and Properties, probably support an EmitWithDup
	That emits the code to call Get and then leaves a this pointer
	in the stack, so that later a Store can be emitted using that
	this pointer (consider Property++ or Indexer++)


* Add a cache for the various GetArrayMethod operations.

* Use of temporary values in Assign

	We generate suboptimal code for assignments, as we always
	store the result in a temporary.  

	When implenenting `using' on

		using (a = new XXX)

	Two instances of XXX were created, we need to research this.

		//
		// FIXME! We need a way to "probe" if the process can
		// just use `dup' to propagate the result.
		//
		// I Think I figured this out, have EmitAssign take an
		// argument: leave result on stack or not.  If true,
		// then we can dup ahead of time if we know about this,
		// and we get rid of the temporary value
		// 
  
RECOMMENDATIONS
---------------

* Use of lexer.Location in the parser

	Currently we do:

	TOKEN nt TERMINAL nt TERMINAL nt3 {
		$$ = new Blah ($2, $4, $6, lexer.Location);
	}

	This is bad, because the lexer.Location is for the last item in `nt3'

	We need to change that to use this pattern:

	TOKEN { oob_stack.Push (lexer.Location) } nt TERMINAL nt TERMINAL nt3 {
		$$ = new Blah ($3, $5, $7, (Location) oob_stack.Pop ());
	}

	Notice how numbering of the arguments changes as the
	{ oob_stack.Push (lexer.Location) } takes a "slot"  in the productions.

* local_variable_declaration

	Not sure that this grammar is correct, we might have to
	resolve this during semantic analysis.


* Try/Catch

	Investigate what is  the right value to return  from `Emit' in
	there (ie, for the `all code paths return')
	

* Optimizations

	Only create one `This' instance per class, and reuse it.

	Maybe keep a pool of constants/literals (zero, 1)?

