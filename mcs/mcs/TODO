* Ordering

	Can a constant_expression invoke overloaded operators?
	Explicit user-defined conversions?

* Visibility

	I am not reporting errors on visibility yet.

* Error handling

	Normalize, and use Tokenizer location 

* Enumerations

	Currently I am not resolving enumerations.

	Either I track them with `RecordEnum' as I do with classes,
	structs and interfaces or I rewrite the code to visit type
	containers and `walk' the enums with this process. 

* Known problems:

  Cast expressions

	They should should use:

		OPEN_PARENS type CLOSE_PARENS

	instead of the current production which is wrong, because it
	only handles a few cases.

	Complex casts like:

		Array r = (string []) object

	Wont be parsed.
  
* Interfaces

	For indexers, the output of ix2.cs is different from our
	compiler and theirs.  They use a DefaultMemberAttribute, which
	I have yet to figure out:

	.class interface private abstract auto ansi INTERFACE
	{
		.custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) 
		= ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..
		...
	}

* Interface indexers

	I have not figured out why the Microsoft version puts an
	`instance' attribute, and I am not generating this `instance' attribute.

* Constructors

	Currently it calls the parent constructor before initializing fields.
	It should do it the other way around.

* Use of EmitBranchable

	Currently I use brfalse/brtrue in the code for statements, instead of
	using the EmitBranchable function that lives in Binary

* Create an UnimplementedExpcetion

  	And use that instead of plain Exceptions.

* Bug

	Currently I cant cope with a = b = 1;
	Because the stack is empty after b = 1

	The current mechanism uses the return value of Emit to figure if there
	is something in the stack after we return. 

	But MAYBE we need to pass an extra argument: `Do I expect
	something in the stack' to Emit, that way we can optimize whether
	it is worth duping stuff on the stack or not.

	And we can also make sure that we dont generate extra pops.

* ConvertImplicit

	Currently ConvertImplicit will not catch things like:

	- IntLiteral in a float context to generate a -FloatLiteral.
	Instead it will perform an integer load followed by a conversion.

* Location

	Implement location as a struct that contains only an integer,
	to speed things up.

	The integer would be monotonically increasing across files and we
	would keep a table of where each file begun processing.

	Like this:
		A.cs	lines 1 to 24	 (a file with 24 lines)
		B.cs	lines 25 to 43	 (a file with 18 lines)
		C.cs	lines 44 to 50	 (a file with 6 lines)

	And then on error reporting, we map the the integer to the
	file/line

* In class.cs: Method.Define

	Need to use FindMembers to lookup the member for reporting
	whether a new is needed or not.  

* virtual-method.cs breaks

	It breaks on the call to: new B ();

	Where B is a class defined in the source code, my guess is that
	the look for ".ctor" fails



	
