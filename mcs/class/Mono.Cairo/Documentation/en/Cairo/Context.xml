<Type Name="Context" FullName="Cairo.Context">
  <TypeSignature Language="C#" Value="public class Context : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Mono.Cairo</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>This is the main object when drawing with Cairo. </summary>
    <remarks>
      <para>
      </para>
      <para>
        <example>
          <code lang="C#">
// This example sets up a surface on a GTK window and draws an arc to it. 
// More examples are available in the samples directory in mcs/classes/Mono.Cairo
//
// Compile like this:
//    mcs sample.cs -pkg:gtk-sharp-2.0 -r:Mono.Cairo
//
using System;
using System.Reflection;
using System.Runtime.InteropServices;
using Cairo;
using Gtk;

public class GtkCairo
{
        static DrawingArea a;

        static void Main ()
        {
                Application.Init ();
                Gtk.Window w = new Gtk.Window ("Mono.Cairo Circles demo");

                a = new CairoGraphic ();

                Box box = new HBox (true, 0);
                box.Add (a);
                w.Add (box);
                w.Resize (500,500);
                w.ShowAll ();

                Application.Run ();
        }


}

public class CairoGraphic : DrawingArea
{
        static readonly double  M_PI = 3.14159265358979323846;

        static void draw (Cairo.Context gr, int width, int height)
        {
                double xc = 0.5;
                double yc = 0.5;
                double radius = 0.4;
                double angle1 = 45.0  * (M_PI/180.0);  /* angles are specified */
                double angle2 = 180.0 * (M_PI/180.0);  /* in radians           */

                gr.Scale (width, height);
                gr.LineWidth = 0.04;

                gr.Arc (xc, yc, radius, angle1, angle2);
                gr.Stroke ();

                /* draw helping lines */
                gr.Color = new Color(1, 0.2, 0.2, 0.6);
                gr.Arc (xc, yc, 0.05, 0, 2*M_PI);
                gr.Fill ();
                gr.LineWidth = 0.03;
                gr.Arc (xc, yc, radius, angle1, angle1);
                gr.LineTo (new PointD(xc, yc));
                gr.Arc (xc, yc, radius, angle2, angle2);
                gr.LineTo (new PointD(xc, yc));
                gr.Stroke ();

        }

        protected override bool OnExposeEvent (Gdk.EventExpose args)
        {
                Gdk.Window win = args.Window;                

		#if OLD_SYSTEMS
		//
		// For old versions of Gtk# (before 2.8), you need the helper class
		// available in gtk-sharp/sample/GtkCairo.cs
		//
                Cairo.Context g = Gdk.Graphics.CreateDrawable (win);
                #else
		//
		// Starting with Gtk 2.8 Gtk has direct support for
		// Cairo, as its built on top of it, on older
		// versions, a helper routine is used
		//
                Context g = Gdk.CairoHelper.Create (args.Window);
		#endif

                int x, y, w, h, d;
                win.GetGeometry(out x, out y, out w, out h, out d);

                draw (g, w, h);
                return true;
        }
}
  </code>
        </example>
      </para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Context (Cairo.Surface surface);" />
      <MemberType>Constructor</MemberType>
      <Parameters>
        <Parameter Name="surface" Type="Cairo.Surface" />
      </Parameters>
      <Docs>
        <param name="surface">The <see cref="T:Cairo.Surface" /> on which this Context object will render everything.</param>
        <summary>Creates a <see cref="T:Cairo.Context" /> object using the provided surface.</summary>
        <remarks>
          <example>
            <code lang="C#">

/* Example assumes you have already set up the drawable as per the main code snippet shown*/

Cairo.XlibSurface s = new Cairo.XlibSurface (Xdisplay,
                                                          Xdrawable,
                                                          Xvisual,
                                                          w, h);

Cairo.Context g = new Cairo.Context (s);


  </code>
          </example>


Note that the <paramref name="surface" /> can be a <see cref="T:Cairo.Surface" /> or <see cref="T:Cairo.ImageSurface" />.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Context (IntPtr state);" />
      <MemberType>Constructor</MemberType>
      <Parameters>
        <Parameter Name="state" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="state">The raw C object.</param>
        <summary>This constructor accepts a Cairo graphics object coming in from the C API and wraps it into our <see cref="T:Cairo.Context" /> class.</summary>
        <remarks />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Antialias">
      <MemberSignature Language="C#" Value="public Cairo.Antialias Antialias { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Antialias</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The antialiasing mode of the rasterizer used for drawing shapes.</summary>
        <value>The antialiasing mode</value>
        <remarks>This value is a hint, and a particular backend may or may not support a particular value. At the current time, no backend supports <see cref="F:Cairo.Antialias.Subpixel" /> when drawing shapes. Note that this option does not affect text rendering.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="AppendPath">
      <MemberSignature Language="C#" Value="public void AppendPath (Cairo.Path path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="Cairo.Path" />
      </Parameters>
      <Docs>
        <param name="path">path to be appended</param>
        <summary>Appends the path <paramref name="path" /> onto the current path.</summary>
        <remarks>This Function appends the path onto the current path. The path may be either the return value from one of <see cref="P:Cairo.Context.CopyPath" /> or <see cref="P:Cairo.Context.CopyPathFlat" /> or it may be constructed manually.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arc">
      <MemberSignature Language="C#" Value="public void Arc (double xc, double yc, double radius, double angle1, double angle2);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xc" Type="System.Double" />
        <Parameter Name="yc" Type="System.Double" />
        <Parameter Name="radius" Type="System.Double" />
        <Parameter Name="angle1" Type="System.Double" />
        <Parameter Name="angle2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="xc">X position of the center of the arc</param>
        <param name="yc">Y position of the center of the arc</param>
        <param name="radius">the radius of the arc</param>
        <param name="angle1">the start angle, in radians</param>
        <param name="angle2">the end angle, in radians</param>
        <summary>Adds an arc from <paramref name="angle1" /> to <paramref name="angle2" /> to the current path. </summary>
        <remarks>
          <para>
	  If there is a current point, that point is connected to the
	  start of the arc by a straight line segment. Angles are
	  measured in radians with an angle of 0 along the X axis and
	  an angle of %M_PI radians (90 degrees) along the Y axis, so
	  with the default transformation matrix, positive angles are
	  clockwise. (To convert from degrees to radians, use degrees
	  * (M_PI / 180.) )  This function gives the arc in the
	  direction of increasing angle; see  <see cref="M:Cairo.Context.ArcNegative" /> to get the arc in the
	  direction of decreasing angle.
	</para>
          <para>
	  A full arc is drawn as a circle. To make an oval arc, you
	  can scale  the current transformation matrix by different
	  amounts in the X and Y directions.
	</para>
          <para>
            <example>
              <code lang="C#">
double xc = 0.5;
double yc = 0.5;
double radius = 0.4;
double angle1 = 45.0  * (M_PI/180.0);
double angle2 = 180.0 * (M_PI/180.0);

gr.Scale (width, height);
gr.LineWidth = 0.04;

gr.Arc (xc, yc, radius, angle1, angle2);
gr.Stroke ();
  </code>
            </example>
          </para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ArcNegative">
      <MemberSignature Language="C#" Value="public void ArcNegative (double xc, double yc, double radius, double angle1, double angle2);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xc" Type="System.Double" />
        <Parameter Name="yc" Type="System.Double" />
        <Parameter Name="radius" Type="System.Double" />
        <Parameter Name="angle1" Type="System.Double" />
        <Parameter Name="angle2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="xc">X position of the center of the arc</param>
        <param name="yc">Y position of the center of the arc</param>
        <param name="radius">the radius of the arc</param>
        <param name="angle1">the start angle, in radians</param>
        <param name="angle2">the end angle, in radians</param>
        <summary>Adds an arc from <paramref name="angle1" /> to <paramref name="angle2" /> to the current path. 
</summary>
        <remarks>
          <para>The function behaves identically to <see cref="M:Cairo.Context.Arc" /> except that instead of giving
	  the arc in the direction of increasing angle, it gives the
	  arc in the direction of decreasing angle.</para>
          <para>
            <example>
              <code lang="C#">
double xc = 0.5;
double yc = 0.5;
double radius = 0.4;
double angle1 = 45.0  * (M_PI/180.0);
double angle2 = 180.0 * (M_PI/180.0);

gr.Scale (width, height);
gr.LineWidth = 0.04;

gr.ArcNegative (xc, yc, radius, angle1, angle2);
gr.Stroke ();
  </code>
            </example>
          </para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public void Clip ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establishes a new clip region by intersecting the current clip region with the current path as it would be filled by <see cref="M:Cairo.Context.Fill" /> and according to the current fill rule (see <see cref="M:Cairo.Context.FillRule" />).
</summary>
        <remarks>
          <para>
	    After calling this method, the current path will be
	    cleared from the cairo context.
	  </para>
          <para>
	    The current clip region affects all drawing operations by
	    effectively masking out any changes to the surface that
	    are outside the current clip region. 
	  </para>
          <para>
	    Calling this method can only make the clip region smaller,
	    never larger. But the current clip is part of the graphics
	    state, so a temporary restriction of the clip region can
	    be achieved by calling this method within a <see cref="M:Cairo.Context.Save" /> / <see cref="M:Cairo.Context.Restore" /> pair. The only other
	    means of increasing the size of the clip region is <see cref="M:Cairo.Context.ClipReset" />.
	  </para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ClipPreserve">
      <MemberSignature Language="C#" Value="public void ClipPreserve ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establishes a new clip region by intersecting the current clip region with the current path as it would be filled by <see cref="M:Cairo.Context.Fill()" /> and according to the current fill rule (see <see cref="P:Cairo.Context.FillRule()" />).</summary>
        <remarks>Unlike Cairo.Context.Clip(), Cairo.Context.ClipPreserve() preserves the path within the cairo context. The current clip region affects all drawing operations by effectively masking out any changes to the surface that are outside the current clip region. Calling Cairo.Context.Clip() can only make the clip region smaller, never larger. But the current clip is part of the graphics state, so a temporary restriction of the clip region can be achieved by calling Cairo.Context.Clip() within a Cairo.Context.Save()/Cairo.Context.Restore() pair. The only other means of increasing the size of the clip region is Cairo.Context.ResetClip().</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ClosePath">
      <MemberSignature Language="C#" Value="public void ClosePath ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes a path so it can be stroked.</summary>
        <remarks>
          <example>
            <code lang="C#">
gr.Scale (width, height);
gr.LineWidth = 0.04;

gr.MoveTo ( new PointD (0.5, 0.1) );
gr.LineTo  ( new PointD (0.9, 0.9) );

gr.RelLineTo ( new Distance (-0.4, 0.0) );

gr.CurveTo ( new PointD (0.2, 0.9),
                  new PointD ( 0.2, 0.5),
                  new PointD (0.5, 0.5));

gr.ClosePath ();
  </code>
          </example>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Color">
      <MemberSignature Language="C#" Value="public Cairo.Color Color { set; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The current Color in the drawing context.</summary>
        <value>the Color</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ColorRgb">
      <MemberSignature Language="C#" Value="public Cairo.Color ColorRgb { set; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the source pattern to be the given opaque color.</summary>
        <value>To be added.</value>
        <remarks>
          <para>
	    Sets the context source color to be the opaque color
	    specified.  This opaque color will then be used for any
	    subsequent drawing operation until a new source pattern is set.
	  </para>
          <para>
	    The color components are floating point numbers in the
	    range 0 to 1. If the values passed in are outside that
	    range, they will be clamped.
	  </para>
        </remarks>
      </Docs>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use Color property")</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ContextFontFace">
      <MemberSignature Language="C#" Value="public Cairo.FontFace ContextFontFace { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.FontFace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary />
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version="Mono-1.2.5" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CopyPage">
      <MemberSignature Language="C#" Value="public void CopyPage ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emits the current page for backends that support multiple pages, without clearing it..</summary>
        <remarks>
	  The contents of the current page will be retained for the
	  next page too.  Use <see cref="M:Cairo.Context.ShowPage()" /> if you want to get an empty page
	  after the emission.
      </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CopyPath">
      <MemberSignature Language="C#" Value="public Cairo.Path CopyPath ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cairo.Path</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a copy of the current path and returns it as <see cref="T:Cairo.Path" />.</summary>
        <returns>Copy of current path</returns>
        <remarks>This function creates a copy of the current path and returns it to the user as <see cref="T:Cairo.Path" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyPathFlat">
      <MemberSignature Language="C#" Value="public Cairo.Path CopyPathFlat ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cairo.Path</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a flattened copy of the current path and returns it to the user as a <see cref="T:Cairo.Path" />.</summary>
        <returns>Flattened copy of current path.</returns>
        <remarks>This function is like <see cref="P:Cairo.Context.CopyPath" /> except that any curves in the path will be approximated with piecewise-linear approximations, (accurate to within the current tolerance value). That is, the result is guaranteed to not have any elements of type <see cref="P:Cairo.Context.CurveTo" /> which will instead be replaced by a series of <see cref="P:Cairo.Context.LineTo" /> elements.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentPoint">
      <MemberSignature Language="C#" Value="public Cairo.PointD CurrentPoint { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.PointD</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current point of the current path, which is conceptually the final point reached by the path so far.</summary>
        <value>the current point</value>
        <remarks>The current point is returned in the user-space coordinate system. If there is no defined current point then x and y will both be set to 0.0.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CurveTo">
      <MemberSignature Language="C#" Value="public void CurveTo (Cairo.PointD p1, Cairo.PointD p2, Cairo.PointD p3);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p1" Type="Cairo.PointD" />
        <Parameter Name="p2" Type="Cairo.PointD" />
        <Parameter Name="p3" Type="Cairo.PointD" />
      </Parameters>
      <Docs>
        <param name="p1">first control point</param>
        <param name="p2">second control point</param>
        <param name="p3">third control point</param>
        <summary>Adds a cubic Bézier spline to the path from the current point to position (x3, y3) in user-space coordinates, using (x1, y1) and (x2, y2) as the control points.</summary>
        <remarks>After this call the current point will be (p3.X, p3.Y).</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CurveTo">
      <MemberSignature Language="C#" Value="public void CurveTo (double x1, double y1, double x2, double y2, double x3, double y3);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Double" />
        <Parameter Name="y1" Type="System.Double" />
        <Parameter Name="x2" Type="System.Double" />
        <Parameter Name="y2" Type="System.Double" />
        <Parameter Name="x3" Type="System.Double" />
        <Parameter Name="y3" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x1">the X coordinate of the first control point</param>
        <param name="y1">the Y coordinate of the first control point</param>
        <param name="x2">the X coordinate of the second control point</param>
        <param name="y2">the Y coordinate of the second control point</param>
        <param name="x3">the X coordinate of the end of the curve</param>
        <param name="y3">the Y coordinate of the end of the curve</param>
        <summary>Adds a cubic Bézier spline to the path from the current point to position (x3, y3) in user-space coordinates, using (x1, y1) and (x2, y2) as the control points.</summary>
        <remarks>After this call the current point will be (x3, y3).</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="DeviceToUser">
      <MemberSignature Language="C#" Value="public void DeviceToUser (ref double x, ref double y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="y" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="x">X value of coordinate</param>
        <param name="y">Y value of coordinate</param>
        <summary>Transform a coordinate from device space to user space by multiplying the given point by the inverse of the current transformation matrix (CTM).</summary>
        <remarks>None</remarks>
        <since version="Mono-1.2.5" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="DeviceToUserDistance">
      <MemberSignature Language="C#" Value="public void DeviceToUserDistance (ref double dx, ref double dy);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="dy" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="dx">X value of the coordinate</param>
        <param name="dy">Y value of the coordinate</param>
        <summary>Transform a distance vector from device space to user space. </summary>
        <remarks>This function is similar to <see cref="P:Cairo.Context.DeviceToUser" /> except that the translation components of the inverse CTM will be ignored when transforming (dx,dy).</remarks>
        <since version="Mono-1.2.5" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">When false, returning and "Cairo.Context: called from finalization thread, programmer is missing a call to Dispose" is written</param>
        <summary>Decreases the reference count on cr by one. If the result is zero, then cr and all associated resources are freed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>A drawing operator that fills the current path according to the current fill rule. 
</summary>
        <remarks>
	After cairo_fill, the current path will be cleared from the
	  cairo context. See <see cref="P:Cairo.Context.FillRule" />
	  and <see cref="M:Cairo.Context.FillPreserve" />.
	  </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FillExtents">
      <MemberSignature Language="C#" Value="public Cairo.Rectangle FillExtents ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Computes a bounding box in user coordinates covering the area that would be affected by a call to <see cref="M:Cairo.Context.Fill()" />.</summary>
        <returns>The rectangle describing the area that would be affected.</returns>
        <remarks>If the current path is empty, returns an empty rectangle (0,0, 0,0). Surface dimensions and clipping are not taken into account.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FillPreserve">
      <MemberSignature Language="C#" Value="public void FillPreserve ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>A drawing operator that fills the current path according to the current fill rule. Unlike <see cref="M:Cairo.Context.Fill" />, this preserves the path within the cairo context.
</summary>
        <remarks />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FillRule">
      <MemberSignature Language="C#" Value="public Cairo.FillRule FillRule { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.FillRule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the fill rule.</summary>
        <value>See <see cref="T:Cairo.FillRule" /></value>
        <remarks>
	  The fill rule is used to determine which regions are inside
	  or outside a complex (potentially self-intersecting) path. The current
	  fill rule affects both <see cref="M:Cairo.Context.Fill()" /> and <see cref="M:Cairo.Context.Clip()" />. See
	  <see cref="T:Cairo.FillRule" /> for details on the semantics
	  of each available fill rule.
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Context ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontExtents">
      <MemberSignature Language="C#" Value="public Cairo.FontExtents FontExtents { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.FontExtents</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the font extents for the currently selected font.</summary>
        <value>the FontExtents</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FontFace">
      <MemberSignature Language="C#" Value="public void FontFace (string family, Cairo.FontSlant slant, Cairo.FontWeight weight);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="family" Type="System.String" />
        <Parameter Name="slant" Type="Cairo.FontSlant" />
        <Parameter Name="weight" Type="Cairo.FontWeight" />
      </Parameters>
      <Docs>
        <param name="family">a font family name, encoded in UTF-8</param>
        <param name="slant">the FontSlant</param>
        <param name="weight">the FontWeight</param>
        <summary>Selects a family and style of font from a simplified description as a family name, slant and weight. 
</summary>
        <remarks>
	  This function is meant to be used only for applications with
	  simple font needs: Cairo doesn't provide for operations such as
	  listing all available fonts on the system, and it is expected that
	  most applications will need to use a more comprehensive font handling
	  and text layout library in addition to Cairo.
	</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SelectFontFace() instead.")</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="FontMatrix">
      <MemberSignature Language="C#" Value="public Cairo.Matrix FontMatrix { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Matrix</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The current font matrix</summary>
        <value>a matrix describing a transform to be applied to the current font.</value>
        <remarks>The font matrix gives a transformation from the design space of the font (in this space, the em-square is 1 unit by 1 unit) to user space. Normally, a simple scale is used (see <see cref="M:Cairo.Context.SetFontSize()" />), but a more complex font matrix can be used to shear the font or stretch it unequally along the two axes</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FontOptions">
      <MemberSignature Language="C#" Value="public Cairo.FontOptions FontOptions { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.FontOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A set of custom font rendering options</summary>
        <value>font options to use</value>
        <remarks>Rendering options are derived by merging these options with the options derived from underlying surface; if the value in options has a default value (like Cairo.Antialias.Default), then the value from the surface is used.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FontSetSize">
      <MemberSignature Language="C#" Value="public void FontSetSize (double scale);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scale">size of the font.</param>
        <summary>Sets the current font matrix to a scale by a factor of size, replacing any font matrix previously set. This results in a font size of size user space units. (More precisely, this matrix will result in the font's em-square being a size by size square in user space.)</summary>
        <remarks>If text is drawn without a call to <see cref="S:Cairo.Context.FontSetSize" />, the default font size is 10.0.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SetFontSize() instead.")</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { set; }" />
      <MemberType>Property</MemberType>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SetFontSize() instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Set the size of the font for the context.</summary>
        <value>the new font size</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GlyphExtents">
      <MemberSignature Language="C#" Value="public Cairo.TextExtents GlyphExtents (Cairo.Glyph[] glyphs);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.TextExtents</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="glyphs" Type="Cairo.Glyph[]" />
      </Parameters>
      <Docs>
        <param name="glyphs">an array of <see cref="T:Cairo.Glyph" /></param>
        <summary>Gets the extents for an array of glyphs.</summary>
        <returns>The extents of an array of glyphs as <see cref="P:Cairo.Context.TextExtends" />.</returns>
        <remarks>Note that whitespace glyphs do not contribute to the size of the rectangle.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GlyphPath">
      <MemberSignature Language="C#" Value="public void GlyphPath (Cairo.Glyph[] glyphs);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="glyphs" Type="Cairo.Glyph[]" />
      </Parameters>
      <Docs>
        <param name="glyphs">array of glyphs to show</param>
        <summary>Adds closed paths for the glyphs to the current path.</summary>
        <remarks>None</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GlyphPath">
      <MemberSignature Language="C#" Value="public void GlyphPath (Cairo.Matrix matrix, Cairo.Glyph[] glyphs);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="Cairo.Matrix" />
        <Parameter Name="glyphs" Type="Cairo.Glyph[]" />
      </Parameters>
      <Docs>
        <param name="matrix">To be added.</param>
        <param name="glyphs">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The matrix argument was never used, use GlyphPath(Glyphs []) instead")</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GroupTarget">
      <MemberSignature Language="C#" Value="public Cairo.Surface GroupTarget { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Surface</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current destination surface for the context.</summary>
        <value>the target surface</value>
        <remarks>Gets the current destination surface for the context. This is either the original target surface or the target surface for the current group as started by the most recent call to <see cref="P:Cairo.Context.PushGroup" />.</remarks>
        <since version="cairo 1.2" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Internal handle to the native cairo object</summary>
        <value>pointer to native object</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IdentityMatrix">
      <MemberSignature Language="C#" Value="public void IdentityMatrix ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the current transformation matrix.</summary>
        <remarks>Resets the current transformation matrix (CTM) by setting it equal to the identity matrix. That is, the user-space and device-space axes will be aligned and one user-space unit will transform to one device-space unit.</remarks>
        <since version="Mono-1.2.5" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="InFill">
      <MemberSignature Language="C#" Value="public bool InFill (double x, double y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">X coordinate of the point to test</param>
        <param name="y">Y coordinate of the point to test</param>
        <summary>Tests whether the given point is inside the area that would be affected by a <see cref="P:Cairo.Context.Fill" /> operation given the current path and filling parameters.</summary>
        <returns>True if the point is inside, or false if outside.</returns>
        <remarks>Surface dimensions and clipping are not taken into account.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="InStroke">
      <MemberSignature Language="C#" Value="public bool InStroke (double x, double y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">X coordinate of the point to test</param>
        <param name="y">Y coordinate of the point to test</param>
        <summary>Tests whether the given point is inside the area that would be affected by a <see cref="P:Cairo.Context.Stroke" /> operation given the current path and stroking parameters.</summary>
        <returns>True if the point is inside, or false if outside.</returns>
        <remarks>Surface dimensions and clipping are not taken into account.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="InverseTransformDistance">
      <MemberSignature Language="C#" Value="public void InverseTransformDistance (ref double dx, ref double dy);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="dy" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="dx">X component of distance vector to be transformed.</param>
        <param name="dy">Y component of distance vector to be transformed.</param>
        <summary>Transform the specified distance vector by the inverse of the current transformation matrix (CTM).</summary>
        <remarks>
          <para>This is accomplished by multiplying the specified point by the inverse of the CTM, while ignoring the translation components of the CTM</para>
          <para>Equivalent to cairo_device_to_user_distance().</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="InverseTransformPoint">
      <MemberSignature Language="C#" Value="public void InverseTransformPoint (ref double x, ref double y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="y" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="x">X value of the point to be transformed.</param>
        <param name="y">Y value of the point to be transformed.</param>
        <summary>Transform the specified point by the inverse of the current transformation matrix (CTM).</summary>
        <remarks>
          <para>This is accomplished by multiplying the given point by the inverse of the CTM</para>
          <para>Equivalent to cairo_device_to_user().</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="LineCap">
      <MemberSignature Language="C#" Value="public Cairo.LineCap LineCap { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.LineCap</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the line cap style.</summary>
        <value>See <see cref="T:Cairo.LineCap" />.</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="LineJoin">
      <MemberSignature Language="C#" Value="public Cairo.LineJoin LineJoin { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.LineJoin</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the line join style.</summary>
        <value>See <see cref="T:Cairo.LineJoin" />.</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="LineTo">
      <MemberSignature Language="C#" Value="public void LineTo (Cairo.PointD p);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="Cairo.PointD" />
      </Parameters>
      <Docs>
        <param name="p">end of the new line</param>
        <summary>Adds a line to the path from the current point to position (x, y) in user-space coordinates.</summary>
        <remarks>After this call the current point will be (p.X, p.Y).</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="LineTo">
      <MemberSignature Language="C#" Value="public void LineTo (double x, double y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">the X coordinate of the end of the new line</param>
        <param name="y">the Y coordinate of the end of the new line</param>
        <summary>Adds a line to the path from the current point to position (x, y) in user-space coordinates.</summary>
        <remarks>After this call the current point will be (x, y).</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="LineWidth">
      <MemberSignature Language="C#" Value="public double LineWidth { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the width of the stroke.</summary>
        <value>The width of the stroke.</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Mask">
      <MemberSignature Language="C#" Value="public void Mask (Cairo.Pattern pattern);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="Cairo.Pattern" />
      </Parameters>
      <Docs>
        <param name="pattern">a Pattern</param>
        <summary>A drawing operator that paints the current source using the alpha channel of <paramref name="pattern" /> as a mask.</summary>
        <remarks>Opaque areas of mask are painted with the source, transparent areas are not painted.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MaskSurface">
      <MemberSignature Language="C#" Value="public void MaskSurface (Cairo.Surface surface, double surface_x, double surface_y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="surface" Type="Cairo.Surface" />
        <Parameter Name="surface_x" Type="System.Double" />
        <Parameter Name="surface_y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="surface">a Surface</param>
        <param name="surface_x">X coordinate at which to place the origin of <paramref name="surface" /></param>
        <param name="surface_y">Y coordinate at which to place the origin of <paramref name="surface" /></param>
        <summary>A drawing operator that paints the current source using the alpha channel of <paramref name="surface" /> as a mask.</summary>
        <remarks>Opaque areas of surface are painted with the source, transparent areas are not painted.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Matrix">
      <MemberSignature Language="C#" Value="public Cairo.Matrix Matrix { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Matrix</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the current transformation matrix (CTM).</summary>
        <value>the CTM</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MiterLimit">
      <MemberSignature Language="C#" Value="public double MiterLimit { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the miter limit (the value beyond which joins are no longer mitered).</summary>
        <value>the MiterLimit</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (Cairo.PointD p);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="Cairo.PointD" />
      </Parameters>
      <Docs>
        <param name="p">the new position</param>
        <summary>If the current subpath is not empty, begin a new subpath.</summary>
        <remarks>After this call the current point will be (p.X, p.Y).</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (double x, double y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">the X coordinate of the new position</param>
        <param name="y">the Y coordinate of the new position</param>
        <summary>If the current subpath is not empty, begin a new subpath.</summary>
        <remarks>After this call the current point will be (x, y).</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="NewPath">
      <MemberSignature Language="C#" Value="public void NewPath ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the current path.</summary>
        <remarks>After this call there will be no current point.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="NewSubPath">
      <MemberSignature Language="C#" Value="public void NewSubPath ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins a new sub-path.</summary>
        <remarks>Note that the existing path is not affected. After this call there will be no current point.
In many cases, this call is not needed since new sub-paths are frequently started with <see cref="P:Cairo.Context.MoveTo" />.
A call to <see cref="P:Cairo.Context.NewSubPath" /> is particularly useful when beginning a new sub-path with one of the <see cref="P:Cairo.Context.Arc" /> calls. This makes things easier as it is no longer necessary to manually compute the arc's initial coordinates for a call to <see cref="P:Cairo.Context.MoveTo" />.</remarks>
        <since version="cairo 1.2" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Operator">
      <MemberSignature Language="C#" Value="public Cairo.Operator Operator { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Operator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The current Operator for the drawing context.</summary>
        <value>the Operator</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public void Paint ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>A drawing operator that paints the current source everywhere within the current clip region.</summary>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="PaintWithAlpha">
      <MemberSignature Language="C#" Value="public void PaintWithAlpha (double alpha);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alpha" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="alpha">alpha value, between 0 (transparent) and 1 (opaque)</param>
        <summary>A drawing operator that paints the current source everywhere within the current clip region using a mask of constant alpha value <paramref name="alpha" />.</summary>
        <remarks>The effect is similar to <see cref="M:Cairo.Context.Paint()" />, but the drawing is faded out using the alpha value.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Pattern">
      <MemberSignature Language="C#" Value="public Cairo.Pattern Pattern { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Pattern</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>See <see cref="P:Cairo.Context.Source" />.</summary>
        <value>See <see cref="P:Cairo.Context.Source" />.</value>
        <remarks />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="PopGroup">
      <MemberSignature Language="C#" Value="public Cairo.Pattern PopGroup ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Pattern</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Terminates the redirection begun by a call to <see cref="P:Cairo.Context.PushGroup" /> and returns a new pattern containing the results of all drawing operations performed to the group.</summary>
        <returns>A newly created (surface) pattern containing the results of all drawing operations performed to the group. The caller owns the returned object and should call cairo_pattern_destroy() when finished with it.</returns>
        <remarks>The <see cref="P:Cairo.Context.PopGroup" /> function calls <see cref="P:Cairo.Context.Restore" />, (balancing a call to <see cref="P:Cairo.Context.Save" /> by the PopGroup function), so that any changes to the graphics state will not be visible outside the group.</remarks>
        <since version="cairo 1.2" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="PopGroupToSource">
      <MemberSignature Language="C#" Value="public void PopGroupToSource ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Terminates the redirection begun by a call to <see cref="P:Cairo.Context.PushGroup" /> and installs the resulting pattern as the source pattern in the given cairo context.</summary>
        <remarks>The <see cref="P:Cairo.Context.PopGroup" /> function calls <see cref="P:Cairo.Context.Restore" />, (balancing a call to <see cref="P:Cairo.Context.Save" /> by the PopGroup function), so that any changes to the graphics state will not be visible outside the group.</remarks>
        <since version="cairo 1.2" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="PushGroup">
      <MemberSignature Language="C#" Value="public void PushGroup ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Temporarily redirects drawing to an intermediate surface known as a group.</summary>
        <remarks>Temporarily redirects drawing to an intermediate surface known as a group. The redirection lasts until the group is completed by a call to <see cref="P:Cairo.Context.PopGroup" /> or <see cref="P:Cairo.Context.PopGroupToSource" />. These calls provide the result of any drawing to the group as a pattern, (either as an explicit object, or set as the source pattern).
This group functionality can be convenient for performing intermediate compositing. One common use of a group is to render objects as opaque within the group, (so that they occlude each other), and then blend the result with translucence onto the destination.
Groups can be nested arbitrarily deep by making balanced calls to <see cref="P:Cairo.Context.PushGroup" />/<see cref="P:Cairo.Context.PopGroup" />. Each call pushes/pops the new target group onto/from a stack.
The <see cref="P:Cairo.Context.PushGroup" /> function calls <see cref="P:Cairo.Context.Save" /> so that any changes to the graphics state will not be visible outside the group, (the <see cref="P:Cairo.Context.PopGroup" /> functions call <see cref="P:Cairo.Context.Restore" />).</remarks>
        <since version="cairo 1.2" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="PushGroup">
      <MemberSignature Language="C#" Value="public void PushGroup (Cairo.Content content);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="Cairo.Content" />
      </Parameters>
      <Docs>
        <param name="content">a <see cref="T:Cairo.Content" /> indicating the type of group that will be created</param>
        <summary>Temporarily redirects drawing to an intermediate surface known as a group. The group will have a content type of content.</summary>
        <remarks>Temporarily redirects drawing to an intermediate surface known as a group. The redirection lasts until the group is completed by a call to <see cref="P:Cairo.Context.PopGroup" /> or <see cref="P:Cairo.Context.PopGroupToSource" />. These calls provide the result of any drawing to the group as a pattern, (either as an explicit object, or set as the source pattern).
The group will have a content type of content. The ability to control this content type is the only distinction between this function and  <see cref="P:Cairo.Context.PushGroup" /> which you should see for a more detailed description of group rendering.</remarks>
        <since version="cairo 1.2" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Rectangle">
      <MemberSignature Language="C#" Value="public void Rectangle (Cairo.Rectangle rectangle);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rectangle" Type="Cairo.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rectangle">To be added.</param>
        <summary>Adds a closed-subpath rectangle of the given size to the current path in user-space coordinates.</summary>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Rectangle">
      <MemberSignature Language="C#" Value="public void Rectangle (Cairo.PointD p, double width, double height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="Cairo.PointD" />
        <Parameter Name="width" Type="System.Double" />
        <Parameter Name="height" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="p">point at which to draw</param>
        <param name="width">rectangle's width</param>
        <param name="height">rectangle's height</param>
        <summary>Draw a rectangle at <see cref="T:Cairo.PointD" /><paramref name=" p" /> with  <paramref name="width" /> and <paramref name="height" />.</summary>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Rectangle">
      <MemberSignature Language="C#" Value="public void Rectangle (double x, double y, double width, double height);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="width" Type="System.Double" />
        <Parameter Name="height" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">the X coordinate of the top left corner of the rectangle</param>
        <param name="y">the Y coordinate of the top left corner of the rectangle</param>
        <param name="width">the width of the rectangle</param>
        <param name="height">the height of the rectangle</param>
        <summary>Adds a closed-subpath rectangle of the given size to the current path at position (x, y) in user-space coordinates.</summary>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ReferenceCount">
      <MemberSignature Language="C#" Value="public uint ReferenceCount { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the current reference count.</summary>
        <value>the current reference count</value>
        <remarks> If the object is a nil object, 0 will be returned.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RelCurveTo">
      <MemberSignature Language="C#" Value="public void RelCurveTo (Cairo.Distance d1, Cairo.Distance d2, Cairo.Distance d3);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="Cairo.Distance" />
        <Parameter Name="d2" Type="Cairo.Distance" />
        <Parameter Name="d3" Type="Cairo.Distance" />
      </Parameters>
      <Docs>
        <param name="d1">offset to the first control point</param>
        <param name="d2">offset to the second control point</param>
        <param name="d3">offset to the end of the curve</param>
        <summary>Relative-coordinate version of <see cref="M:Cairo.Context.CurveTo()" />. </summary>
        <remarks>
          <para>All offsets are relative to the current point. Adds a cubic Bézier spline to the path from the current point to a point offset from the current point by (d3), using points offset by (d1) and (d2) as the control points. After this call the current point will be offset by (d3.Dx, d3.Dy).</para>
          <para>Given a current point of (x, y), Cairo.Context.RelCurveTo (d1, d2, d3) is logically equivalent to Cairo.Context.CurveTo (x + d1.Dx, y + d1.Dy, x + d2.Dx, y + d2.Dy, x + d3.Dx, y + d3.Dy).</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="RelCurveTo">
      <MemberSignature Language="C#" Value="public void RelCurveTo (double dx1, double dy1, double dx2, double dy2, double dx3, double dy3);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx1" Type="System.Double" />
        <Parameter Name="dy1" Type="System.Double" />
        <Parameter Name="dx2" Type="System.Double" />
        <Parameter Name="dy2" Type="System.Double" />
        <Parameter Name="dx3" Type="System.Double" />
        <Parameter Name="dy3" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dx1">the X offset to the first control point</param>
        <param name="dy1">the Y offset to the first control point</param>
        <param name="dx2">the X offset to the second control point</param>
        <param name="dy2">the Y offset to the second control point</param>
        <param name="dx3">the X offset to the end of the curve</param>
        <param name="dy3">the Y offset to the end of the curve</param>
        <summary>Relative-coordinate version of <see cref="M:Cairo.Context.CurveTo()" />. </summary>
        <remarks>
          <para>All offsets are relative to the current point. Adds a cubic Bézier spline to the path from the current point to a point offset from the current point by (dx3, dy3), using points offset by (dx1, dy1) and (dx2, dy2) as the control points. After this call the current point will be offset by (dx3, dy3).</para>
          <para>Given a current point of (x, y), Cairo.Context.RelCurveTo (dx1, dy1, dx2, dy2, dx3, dy3) is logically equivalent to Cairo.Context.CurveTo (x + dx1, y + dy1, x + dx2, y + dy2, x + dx3, y + dy3).</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="RelLineTo">
      <MemberSignature Language="C#" Value="public void RelLineTo (Cairo.Distance d);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="Cairo.Distance" />
      </Parameters>
      <Docs>
        <param name="d">the offset to the end of the new line</param>
        <summary>Relative-coordinate version of <see cref="M:Cairo.Context.LineTo()" />.</summary>
        <remarks>Adds a line to the path from the current point to a point that is offset from the current point by (d.Dx, d.Dy) in user space. After this call the current point will be offset by (d.Dx, d.Dy).  Given a current point of (x, y), Cairo.Context.RelLineTo (d) is logically equivalent to Cairo.Context.LineTo (x + d.Dx, y + d.Dy).</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="RelLineTo">
      <MemberSignature Language="C#" Value="public void RelLineTo (double dx, double dy);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Double" />
        <Parameter Name="dy" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dx">the X offset to the end of the new line</param>
        <param name="dy">the Y offset to the end of the new line</param>
        <summary>Relative-coordinate version of <see cref="M:Cairo.Context.LineTo()" />.</summary>
        <remarks>Adds a line to the path from the current point to a point that is offset from the current point by (dx, dy) in user space. After this call the current point will be offset by (dx, dy).  Given a current point of (x, y), Cairo.Context.RelLineTo (dx, dy) is logically equivalent to Cairo.Context.LineTo (x + dx, y + dy).</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="RelMoveTo">
      <MemberSignature Language="C#" Value="public void RelMoveTo (Cairo.Distance d);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="Cairo.Distance" />
      </Parameters>
      <Docs>
        <param name="d">offset</param>
        <summary>If the current subpath is not empty, begin a new subpath.</summary>
        <remarks>After this call the current point will offset by (d.Dx, d.Dy).  Given a current point of (x, y), Cairo.Context.RelMoveTo (d) is logically equivalent to Cairo.Context.MoveTo (x + d.Dx, y + d.Dy).</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="RelMoveTo">
      <MemberSignature Language="C#" Value="public void RelMoveTo (double dx, double dy);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Double" />
        <Parameter Name="dy" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dx">the X offset</param>
        <param name="dy">the Y offset</param>
        <summary>If the current subpath is not empty, begin a new subpath.</summary>
        <remarks>After this call the current point will offset by (dx, dy).  Given a current point of (x, y), Cairo.Context.RelMoveTo (dx, dy) is logically equivalent to Cairo.Context.MoveTo (x + dx, y + dy).</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ResetClip">
      <MemberSignature Language="C#" Value="public void ResetClip ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reset the current clip region to its original, unrestricted state.</summary>
        <remarks>That is, set the clip region to an infinitely large shape containing the target surface. Equivalently, if infinity is too hard to grasp, one can imagine the clip region being reset to the exact bounds of the target surface.

Note that code meant to be reusable should not call Cairo.Context.ResetClip() as it will cause results unexpected by higher-level code which calls Cairo.Context.Clip(). Consider using Cairo.Context.Save() and Cairo.Context.Restore() around Cairo.Context.Clip() as a more robust means of temporarily restricting the clip region.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Restore">
      <MemberSignature Language="C#" Value="public void Restore ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restores the object to the state saved by a preceding call to <see cref="M:Cairo.Context.Save" /> and removes that state from the stack of saved states.
</summary>
        <remarks />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Rotate">
      <MemberSignature Language="C#" Value="public void Rotate (double angle);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="angle">angle (in radians) by which the user-space axes will be rotated.
</param>
        <summary>Modifies the current transformation matrix (CTM) by rotating the user-space axes by <paramref name="angle" /> radians. 
</summary>
        <remarks>
	    The rotation of the axes takes places after any existing
	    transformation of user space. The rotation direction for
	    positive angles is from the positive X axis toward the
	    positive Y axis.
	</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary> Makes a copy of the current state of the object and saves it on an internal stack of saved states.</summary>
        <remarks>When <see cref="M:Cairo.Context.Restore" /> is called, @cr will be restored to the saved state. Multiple calls to <see cref="M:Cairo.Context.Save" /> and <see cref="M:Cairo.Context.Restore" /> can be nested; each call to <see cref="M:Cairo.Context.Restore" /> restores the state from the matching paired <see cref="M:Cairo.Context.Save" />.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (double sx, double sy);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Double" />
        <Parameter Name="sy" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="sx">scale factor for the X dimension</param>
        <param name="sy">scale factor for the Y dimension</param>
        <summary> Modifies the current transformation matrix (CTM) by scaling the X and Y user-space axes by <paramref name="sx" /> and <paramref name="sy" /> respectively. 
</summary>
        <remarks>
	The scaling of the axes takes place after any existing
	    transformation of user space.
	    </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ScaledFont">
      <MemberSignature Language="C#" Value="public Cairo.ScaledFont ScaledFont { set; get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cairo.ScaledFont</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current font face, font matrix, and font options.</summary>
        <value>the ScaledFont</value>
        <remarks>Returns the current scaled font.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectFontFace">
      <MemberSignature Language="C#" Value="public void SelectFontFace (string family, Cairo.FontSlant slant, Cairo.FontWeight weight);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="family" Type="System.String" />
        <Parameter Name="slant" Type="Cairo.FontSlant" />
        <Parameter Name="weight" Type="Cairo.FontWeight" />
      </Parameters>
      <Docs>
        <param name="family">a font family name, encoded in UTF-8</param>
        <param name="slant">the slant for the font</param>
        <param name="weight">the weight for the font</param>
        <summary>Selects a family and style of font from a simplified description as a family name, slant and weight.</summary>
        <remarks>This function is meant to be used only for applications with simple font needs: Cairo doesn't provide for operations such as listing all available fonts on the system, and it is expected that most applications will need to use a more comprehensive font handling and text layout library in addition to cairo.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetDash">
      <MemberSignature Language="C#" Value="public void SetDash (double[] dashes, double offset);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dashes" Type="System.Double[]" />
        <Parameter Name="offset" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dashes">length of on and off portions</param>
        <param name="offset">the offset to begin the stroke</param>
        <summary>Sets the dash pattern to be used by <see cref="M:Cairo.Context.Stroke()" />.</summary>
        <remarks>A dash pattern is specified by dashes, an array of positive values. Each value provides the user-space length of alternate "on" and "off" portions of the stroke. The offset specifies an offset into the pattern at which the stroke begins.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetFontSize">
      <MemberSignature Language="C#" Value="public void SetFontSize (double scale);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scale" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="scale">the new font size, in user space units</param>
        <summary>Sets the current font matrix to a scale by a factor of <paramref name="scale" />, replacing any font matrix previously set with <see cref="M:Cairo.Context.SetFontSize()" /> or <see cref="M:Cairo.Context.SetFontMatrix()" />.</summary>
        <remarks>This results in a font size of <paramref name="scale" /> user space units. (More precisely, this matrix will result in the font's em-square being a scale by scale square in user space.)</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetSource">
      <MemberSignature Language="C#" Value="public void SetSource (Cairo.Surface source);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Cairo.Surface" />
      </Parameters>
      <Docs>
        <param name="source">a surface to be used to set the source pattern</param>
        <summary>This is a convenience function for creating a pattern from surface and setting it as the source in cr with <see cref="P:Cairo.Context.GetSource" />.</summary>
        <remarks />
        <since version="Mono-1.2.5" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetSource">
      <MemberSignature Language="C#" Value="public void SetSource (Cairo.Surface source, double x, double y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Cairo.Surface" />
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="source">a surface to be used to set the source pattern</param>
        <param name="x">User-space X coordinate for surface origin</param>
        <param name="y">User-space Y coordinate for surface origin</param>
        <summary>This is a convenience function for creating a pattern from surface and setting it as the source in cr with <see cref="P:Cairo.Context.GetSource" />.</summary>
        <remarks>The x and y parameters give the user-space coordinate at which the surface origin should appear. (The surface origin is its upper-left corner before any transformation has been applied.) The x and y patterns are negated and then set as translation values in the pattern matrix.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetSourceRGB">
      <MemberSignature Language="C#" Value="public void SetSourceRGB (double r, double g, double b);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Double" />
        <Parameter Name="g" Type="System.Double" />
        <Parameter Name="b" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="r">red component of color</param>
        <param name="g">green component of color</param>
        <param name="b">blue component of color</param>
        <summary>Sets the source pattern to an opaque color.</summary>
        <remarks>This opaque color will then be used for any subsequent drawing operation until a new source pattern is set.  The color components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetSourceRGBA">
      <MemberSignature Language="C#" Value="public void SetSourceRGBA (double r, double g, double b, double a);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Double" />
        <Parameter Name="g" Type="System.Double" />
        <Parameter Name="b" Type="System.Double" />
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="r">red component of color</param>
        <param name="g">green component of color</param>
        <param name="b">blue component of color</param>
        <param name="a">alpha component of color</param>
        <summary>Sets the source pattern to a translucent color.</summary>
        <remarks>This color will then be used for any subsequent drawing operation until a new source pattern is set. The color and alpha components are floating point numbers in the range 0 to 1. If the values passed in are outside that range, they will be clamped.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetSourceSurface">
      <MemberSignature Language="C#" Value="public void SetSourceSurface (Cairo.Surface source, int x, int y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Cairo.Surface" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">a surface to be used to set the source pattern</param>
        <param name="x">User-space X coordinate for surface origin</param>
        <param name="y">User-space Y coordinate for surface origin</param>
        <summary>This is a convenience function for creating a pattern from a surface and setting it as the source.</summary>
        <remarks>
          <para>The x and y parameters give the user-space coordinate at which the surface origin should appear. (The surface origin is its upper-left corner before any transformation has been applied.) The x and y patterns are negated and then set as translation values in the pattern matrix.</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ShowGlyphs">
      <MemberSignature Language="C#" Value="public void ShowGlyphs (Cairo.Glyph[] glyphs);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="glyphs" Type="Cairo.Glyph[]" />
      </Parameters>
      <Docs>
        <param name="glyphs">array of glyphs to show</param>
        <summary>A drawing operator that generates the shape from an array of glyphs, rendered according to the current font face, font size (font matrix), and font options.</summary>
        <remarks />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ShowGlyphs">
      <MemberSignature Language="C#" Value="public void ShowGlyphs (Cairo.Matrix matrix, Cairo.Glyph[] glyphs);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="Cairo.Matrix" />
        <Parameter Name="glyphs" Type="Cairo.Glyph[]" />
      </Parameters>
      <Docs>
        <param name="matrix">Obsolete</param>
        <param name="glyphs">array of glyphs to show</param>
        <summary>A drawing operator that generates the shape from an array of glyphs, rendered according to the current font face, font size (font matrix), and font options.</summary>
        <remarks />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The matrix argument was never used, use ShowGlyphs(Glyphs []) instead")</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="ShowPage">
      <MemberSignature Language="C#" Value="public void ShowPage ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emits and clears the current page for backends that support multiple pages..</summary>
        <remarks>Use <see cref="M:Cairo.Context.CopyPage()" /> if you do not want to clear the page.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ShowText">
      <MemberSignature Language="C#" Value="public void ShowText (string str);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">the text to show</param>
        <summary>A drawing operator that generates the shape from a string of UTF-8 characters, rendered according to the current font_face, font_size (font_matrix), and font_options.</summary>
        <remarks>
          <para>This function first computes a set of glyphs for the string of text. The first glyph is placed so that its origin is at the current point. The origin of each subsequent glyph is offset from that of the previous glyph by the advance values of the previous glyph.</para>
          <para>After this call the current point is moved to the origin of where the next glyph would be placed in this same progression. That is, the current point will be at the origin of the final glyph offset by its advance values. This allows for easy display of a single logical string with multiple calls to Cairo.Context.ShowText().</para>
          <para>NOTE: The Cairo.Context.ShowText() function call is part of what the cairo designers call the "toy" text API. It is convenient for short demos and simple programs, but it is not expected to be adequate for the most serious of text-using applications. See <see cref="M:Cairo.Context.ShowGlyphs()" /> for the "real" text display API in cairo.</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Cairo.Pattern Source { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Pattern</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the source pattern within graphics object to <paramref name="source" />.</summary>
        <value>A <see cref="T:Cairo.Pattern" /> to be used as the source for subsequent drawing operations.
</value>
        <remarks>This pattern will then be used for any subsequent drawing operation until a new source pattern is set.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public Cairo.Status Status { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Status</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get the internal status of Cairo.</summary>
        <value>the Status</value>
        <remarks />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Stroke">
      <MemberSignature Language="C#" Value="public void Stroke ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>A drawing operator that strokes the current path according to the current line width, line join, line cap, and dash settings. 
</summary>
        <remarks>
	After cairo_stroke, the current path will be cleared from the
	  cairo context. See <see cref="P:Cairo.Context.LineWidth" />,
	  <see cref="P:Cairo.Context.LineJoin" />, <see cref="P:Cairo.Context.LineCap" />, <see cref="M:Cairo.Context.SetDash" />, and <see cref="M:Cairo.Context.StrokePreserve" />.
	  
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="StrokeExtents">
      <MemberSignature Language="C#" Value="public Cairo.Rectangle StrokeExtents ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Computes a bounding box in user coordinates covering the area that would be affected by a call to <see cref="M:Cairo.Context.Stroke()" /> using the current stroke parameters.</summary>
        <returns>The rectangle describing the area that would be affected.</returns>
        <remarks>If the current path is empty, returns an empty
rectangle (0,0, 0,0). Surface dimensions and clipping are not taken
into account.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="StrokePreserve">
      <MemberSignature Language="C#" Value="public void StrokePreserve ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>A drawing operator that strokes the current path according to the current line width, line join, line cap, and dash settings. Unlike <see cref="M:Cairo.Context.Stroke" />, it preserves the path within the cairo context.
</summary>
        <remarks />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public Cairo.Surface Target { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.Surface</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the target surface for the cairo context as passed to <see cref="C:Cairo.Context()" />.</summary>
        <value>the target surface.</value>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="TextExtents">
      <MemberSignature Language="C#" Value="public Cairo.TextExtents TextExtents (string utf8);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>Cairo.TextExtents</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="utf8">a string of text, encoded in UTF-8</param>
        <summary>Gets the extents for a string of text.</summary>
        <returns>the TextExtents</returns>
        <remarks>
          <para>The extents describe a user-space rectangle that encloses the "inked" portion of the text, (as it would be drawn by <see cref="M:Cairo.Context.ShowText()" />). Additionally, the <see cref="F:Cairo.TextExtents.XAdvance" /> and <see cref="F:Cairo.TextExtents.YAdvance" /> values indicate the amount by which the current point would be advanced by <see cref="M:Cairo.Context.ShowText()" />.</para>
          <para>Note that whitespace characters do not directly contribute to the size of the rectangle (TextExtents.Width and TextExtents.Height). They do contribute indirectly by changing the position of non-whitespace characters. In particular, trailing whitespace characters are likely to not affect the size of the rectangle, though they will affect the <see cref="F:Cairo.TextExtents.XAdvance" /> and <see cref="F:Cairo.TextExtents.YAdvance" /> values.</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="TextPath">
      <MemberSignature Language="C#" Value="public void TextPath (string str);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">a String</param>
        <summary>Adds closed paths for text to the current path. </summary>
        <remarks>Adds closed paths for text to the current path. The generated path if filled, achieves an effect similar to that of <see cref="P:Cairo.Context.ShowText" />.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Tolerance">
      <MemberSignature Language="C#" Value="public double Tolerance { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the tolerance used when converting paths into trapezoids.</summary>
        <value>the tolerance, in device units (typically pixels)</value>
        <remarks>Curved segments of the path will be subdivided until the maximum deviation between the original path and the polygonal approximation is less than the tolerance. The default value is 0.1. A larger value will give  better performance, a smaller value, better appearance. (Reducing the value from the default value of 0.1 is unlikely to improve appearance significantly.)</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (Cairo.Matrix m);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="Cairo.Matrix" />
      </Parameters>
      <Docs>
        <param name="m">The affine transformation to tranform by.</param>
        <summary>Transform the CTM (Current Transformation Matrix) by the specified affine transformation matrix.</summary>
        <remarks>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="TransformDistance">
      <MemberSignature Language="C#" Value="public void TransformDistance (ref double dx, ref double dy);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="dy" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="dx">X component of distance vector to be transformed.</param>
        <param name="dy">Y component of distance vector to be transformed.</param>
        <summary>Transform the specified distance vector by the current transformation matrix (CTM).</summary>
        <remarks>
          <para>This is accomplished by multiplying the specified point by the CTM, while ignoring the translation components of the CTM</para>
          <para>Equivalent to cairo_user_to_device_distance().</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="TransformPoint">
      <MemberSignature Language="C#" Value="public void TransformPoint (ref double x, ref double y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="y" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="x">X value of point to be transformed.</param>
        <param name="y">Y value of point to be transformed.</param>
        <summary>Transform the specified point by the current transformation matrix (CTM).</summary>
        <remarks>
          <para>This is accomplished by multiplying the given point by the CTM</para>
          <para>Equivalent to cairo_user_to_device().</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Translate">
      <MemberSignature Language="C#" Value="public void Translate (double tx, double ty);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tx" Type="System.Double" />
        <Parameter Name="ty" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="tx">amount to translate in the X direction</param>
        <param name="ty">amount to translate in the Y direction</param>
        <summary>Modifies the current transformation matrix (CTM) by translating the user-space origin by (tx, ty). 
</summary>
        <remarks>
          <para>
	  This offset is interpreted as a user-space coordinate
	  according to the CTM in place before the new call to
	  cairo_translate. In other words, the translation of the
	  user-space origin takes place after any existing
	  transformation.
	</para>
          <para>
            <example>
              <code lang="C#">
image = new ImageSurface ("data/e.png");
w = image.Width;
h = image.Height;

gr.Translate (0.5, 0.5);
gr.Rotate (45* M_PI/180);
gr.Scale  (1.0/w, 1.0/h);
gr.Translate (-0.5*w, -0.5*h);

image.Show (gr, 0, 0);
image.Destroy ();
  </code>
            </example>
          </para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="UserToDevice">
      <MemberSignature Language="C#" Value="public void UserToDevice (ref double x, ref double y);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="y" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="x">X value of coordinate</param>
        <param name="y">Y value of coordinate</param>
        <summary>Transform a coordinate from user space to device space by multiplying the given point by the current transformation matrix.</summary>
        <remarks />
        <since version="Mono-1.2.5" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="UserToDeviceDistance">
      <MemberSignature Language="C#" Value="public void UserToDeviceDistance (ref double dx, ref double dy);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="dy" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="dx">X component of a distance vector</param>
        <param name="dy">Y component of a distance vector</param>
        <summary>Transform a distance vector from user space to device space.</summary>
        <remarks> This function is similar to <see cref="P:Cairo.Context.UserToDevice" /> except that the translation components of the CTM will be ignored when transforming (dx,dy).</remarks>
        <since version="Mono-1.2.5" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
  </Members>
</Type>