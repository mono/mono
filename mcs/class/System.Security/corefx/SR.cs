//
// This file was generated by resx2sr tool
//

partial class SR
{
	public const string ArgumentOutOfRange_Index = "Index was out of range.  Must be non-negative and less than the size of the collection.";
	public const string Arg_EmptyOrNullString = "String cannot be empty or null.";
	public const string Cryptography_Partial_Chain = "A certificate chain could not be built to a trusted root authority.";
	public const string Cryptography_Xml_BadWrappedKeySize = "Bad wrapped key size.";
	public const string Cryptography_Xml_CipherValueElementRequired = "A Cipher Data element should have either a CipherValue or a CipherReference element.";
	public const string Cryptography_Xml_CreateHashAlgorithmFailed = "Could not create hash algorithm object.";
	public const string Cryptography_Xml_CreateTransformFailed = "Could not create the XML transformation identified by the URI {0}.";
	public const string Cryptography_Xml_CreatedKeyFailed = "Failed to create signing key.";
	public const string Cryptography_Xml_DigestMethodRequired = "A DigestMethod must be specified on a Reference prior to generating XML.";
	public const string Cryptography_Xml_DigestValueRequired = "A Reference must contain a DigestValue.";
	public const string Cryptography_Xml_EnvelopedSignatureRequiresContext = "An XmlDocument context is required for enveloped transforms.";
	public const string Cryptography_Xml_InvalidElement = "Malformed element {0}.";
	public const string Cryptography_Xml_InvalidEncryptionProperty = "Malformed encryption property element.";
	public const string Cryptography_Xml_InvalidKeySize = "The key size should be a non negative integer.";
	public const string Cryptography_Xml_InvalidReference = "Malformed reference element.";
	public const string Cryptography_Xml_InvalidSignatureLength = "The length of the signature with a MAC should be less than the hash output length.";
	public const string Cryptography_Xml_InvalidSignatureLength2 = "The length in bits of the signature with a MAC should be a multiple of 8.";
	public const string Cryptography_Xml_InvalidX509IssuerSerialNumber = "X509 issuer serial number is invalid.";
	public const string Cryptography_Xml_KeyInfoRequired = "A KeyInfo element is required to check the signature.";
	public const string Cryptography_Xml_KW_BadKeySize = "The length of the encrypted data in Key Wrap is either 32, 40 or 48 bytes.";
	public const string Cryptography_Xml_LoadKeyFailed = "Signing key is not loaded.";
	public const string Cryptography_Xml_MissingAlgorithm = "Symmetric algorithm is not specified.";
	public const string Cryptography_Xml_MissingCipherData = "Cipher data is not specified.";
	public const string Cryptography_Xml_MissingDecryptionKey = "Unable to retrieve the decryption key.";
	public const string Cryptography_Xml_MissingEncryptionKey = "Unable to retrieve the encryption key.";
	public const string Cryptography_Xml_NotSupportedCryptographicTransform = "The specified cryptographic transform is not supported.";
	public const string Cryptography_Xml_ReferenceElementRequired = "At least one Reference element is required.";
	public const string Cryptography_Xml_ReferenceTypeRequired = "The Reference type must be set in an EncryptedReference object.";
	public const string Cryptography_Xml_SelfReferenceRequiresContext = "An XmlDocument context is required to resolve the Reference Uri {0}.";
	public const string Cryptography_Xml_SignatureDescriptionNotCreated = "SignatureDescription could not be created for the signature algorithm supplied.";
	public const string Cryptography_Xml_SignatureMethodKeyMismatch = "The key does not fit the SignatureMethod.";
	public const string Cryptography_Xml_SignatureMethodRequired = "A signature method is required.";
	public const string Cryptography_Xml_SignatureValueRequired = "Signature requires a SignatureValue.";
	public const string Cryptography_Xml_SignedInfoRequired = "Signature requires a SignedInfo.";
	public const string Cryptography_Xml_TransformIncorrectInputType = "The input type was invalid for this transform.";
	public const string Cryptography_Xml_IncorrectObjectType = "Type of input object is invalid.";
	public const string Cryptography_Xml_UnknownTransform = "Unknown transform has been encountered.";
	public const string Cryptography_Xml_UriNotResolved = "Unable to resolve Uri {0}.";
	public const string Cryptography_Xml_UriNotSupported = " The specified Uri is not supported.";
	public const string Cryptography_Xml_UriRequired = "A Uri attribute is required for a CipherReference element.";
	public const string Cryptography_Xml_XrmlMissingContext = "Null Context property encountered.";
	public const string Cryptography_Xml_XrmlMissingIRelDecryptor = "IRelDecryptor is required.";
	public const string Cryptography_Xml_XrmlMissingIssuer = "Issuer node is required.";
	public const string Cryptography_Xml_XrmlMissingLicence = "License node is required.";
	public const string Cryptography_Xml_XrmlUnableToDecryptGrant = "Unable to decrypt grant content.";
	public const string NotSupported_KeyAlgorithm = "The certificate key algorithm is not supported.";
	public const string Log_ActualHashValue = "Actual hash value: {0}";
	public const string Log_BeginCanonicalization = "Beginning canonicalization using \"{0}\" ({1}).";
	public const string Log_BeginSignatureComputation = "Beginning signature computation.";
	public const string Log_BeginSignatureVerification = "Beginning signature verification.";
	public const string Log_BuildX509Chain = "Building and verifying the X509 chain for certificate {0}.";
	public const string Log_CanonicalizationSettings = "Canonicalization transform is using resolver {0} and base URI \"{1}\".";
	public const string Log_CanonicalizedOutput = "Output of canonicalization transform: {0}";
	public const string Log_CertificateChain = "Certificate chain:";
	public const string Log_CheckSignatureFormat = "Checking signature format using format validator \"[{0}] {1}.{2}\".";
	public const string Log_CheckSignedInfo = "Checking signature on SignedInfo with id \"{0}\".";
	public const string Log_FormatValidationSuccessful = "Signature format validation was successful.";
	public const string Log_FormatValidationNotSuccessful = "Signature format validation failed.";
	public const string Log_KeyUsages = "Found key usages \"{0}\" in extension {1} on certificate {2}.";
	public const string Log_NoNamespacesPropagated = "No namespaces are being propagated.";
	public const string Log_PropagatingNamespace = "Propagating namespace {0}=\"{1}\".";
	public const string Log_RawSignatureValue = "Raw signature: {0}";
	public const string Log_ReferenceHash = "Reference {0} hashed with \"{1}\" ({2}) has hash value {3}, expected hash value {4}.";
	public const string Log_RevocationMode = "Revocation mode for chain building: {0}.";
	public const string Log_RevocationFlag = "Revocation flag for chain building: {0}.";
	public const string Log_SigningAsymmetric = "Calculating signature with key {0} using signature description {1}, hash algorithm {2}, and asymmetric signature formatter {3}.";
	public const string Log_SigningHmac = "Calculating signature using keyed hash algorithm {0}.";
	public const string Log_SigningReference = "Hashing reference {0}, Uri \"{1}\", Id \"{2}\", Type \"{3}\" with hash algorithm \"{4}\" ({5}).";
	public const string Log_TransformedReferenceContents = "Transformed reference contents: {0}";
	public const string Log_UnsafeCanonicalizationMethod = "Canonicalization method \"{0}\" is not on the safe list. Safe canonicalization methods are: {1}.";
	public const string Log_UrlTimeout = "URL retrieval timeout for chain building: {0}.";
	public const string Log_VerificationFailed = "Verification failed checking {0}.";
	public const string Log_VerificationFailed_References = "references";
	public const string Log_VerificationFailed_SignedInfo = "SignedInfo";
	public const string Log_VerificationFailed_X509Chain = "X509 chain verification";
	public const string Log_VerificationFailed_X509KeyUsage = "X509 key usage verification";
	public const string Log_VerificationFlag = "Verification flags for chain building: {0}.";
	public const string Log_VerificationTime = "Verification time for chain building: {0}.";
	public const string Log_VerificationWithKeySuccessful = "Verification with key {0} was successful.";
	public const string Log_VerificationWithKeyNotSuccessful = "Verification with key {0} was not successful.";
	public const string Log_VerifyReference = "Processing reference {0}, Uri \"{1}\", Id \"{2}\", Type \"{3}\".";
	public const string Log_VerifySignedInfoAsymmetric = "Verifying SignedInfo using key {0}, signature description {1}, hash algorithm {2}, and asymmetric signature deformatter {3}.";
	public const string Log_VerifySignedInfoHmac = "Verifying SignedInfo using keyed hash algorithm {0}.";
	public const string Log_X509ChainError = "Error building X509 chain: {0}: {1}.";
	public const string Log_XmlContext = "Using context: {0}";
	public const string Log_SignedXmlRecursionLimit = "Signed xml recursion limit hit while trying to decrypt the key. Reference {0} hashed with \"{1}\" and ({2}).";
	public const string Log_UnsafeTransformMethod = "Transform method \"{0}\" is not on the safe list. Safe transform methods are: {1}.";
	public const string Arg_RankMultiDimNotSupported = "Only single dimensional arrays are supported for the requested action.";
	public const string Argument_InvalidOffLen = "Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.";
	public const string Argument_InvalidOidValue = "The OID value was invalid.";
	public const string Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum = "ASN.1 Enumerated values only apply to enum types without the [Flags] attribute.";
	public const string Cryptography_Asn_NamedBitListRequiresFlagsEnum = "Named bit list operations require an enum with the [Flags] attribute.";
	public const string Cryptography_Asn_NamedBitListValueTooBig = "The encoded named bit list value is larger than the value size of the '{0}' enum.";
	public const string Cryptography_Asn_UniversalValueIsFixed = "Tags with TagClass Universal must have the appropriate TagValue value for the data type being read or written.";
	public const string Cryptography_Asn_UnusedBitCountRange = "Unused bit count must be between 0 and 7, inclusive.";
	public const string Cryptography_AsnSerializer_AmbiguousFieldType = "Field '{0}' of type '{1}' has ambiguous type '{2}', an attribute derived from AsnTypeAttribute is required.";
	public const string Cryptography_AsnSerializer_Choice_AllowNullNonNullable = "[Choice].AllowNull=true is not valid because type '{0}' cannot have a null value.";
	public const string Cryptography_AsnSerializer_Choice_ConflictingTagMapping = "The tag ({0} {1}) for field '{2}' on type '{3}' already is associated in this context with field '{4}' on type '{5}'.";
	public const string Cryptography_AsnSerializer_Choice_DefaultValueDisallowed = "Field '{0}' on [Choice] type '{1}' has a default value, which is not permitted.";
	public const string Cryptography_AsnSerializer_Choice_NoChoiceWasMade = "An instance of [Choice] type '{0}' has no non-null fields.";
	public const string Cryptography_AsnSerializer_Choice_NonNullableField = "Field '{0}' on [Choice] type '{1}' can not be assigned a null value.";
	public const string Cryptography_AsnSerializer_Choice_TooManyValues = "Fields '{0}' and '{1}' on type '{2}' are both non-null when only one value is permitted.";
	public const string Cryptography_AsnSerializer_Choice_TypeCycle = "Field '{0}' on [Choice] type '{1}' has introduced a type chain cycle.";
	public const string Cryptography_AsnSerializer_MultipleAsnTypeAttributes = "Field '{0}' on type '{1}' has multiple attributes deriving from '{2}' when at most one is permitted.";
	public const string Cryptography_AsnSerializer_NoJaggedArrays = "Type '{0}' cannot be serialized or deserialized because it is an array of arrays.";
	public const string Cryptography_AsnSerializer_NoMultiDimensionalArrays = "Type '{0}' cannot be serialized or deserialized because it is a multi-dimensional array.";
	public const string Cryptography_AsnSerializer_NoOpenTypes = "Type '{0}' cannot be serialized or deserialized because it is not sealed or has unbound generic parameters.";
	public const string Cryptography_AsnSerializer_Optional_NonNullableField = "Field '{0}' on type '{1}' is declared [OptionalValue], but it can not be assigned a null value.";
	public const string Cryptography_AsnSerializer_PopulateFriendlyNameOnString = "Field '{0}' on type '{1}' has [ObjectIdentifier].PopulateFriendlyName set to true, which is not applicable to a string.  Change the field to '{2}' or set PopulateFriendlyName to false.";
	public const string Cryptography_AsnSerializer_SetValueException = "Unable to set field {0} on type {1}.";
	public const string Cryptography_AsnSerializer_SpecificTagChoice = "Field '{0}' on type '{1}' has specified an implicit tag value via [ExpectedTag] for [Choice] type '{2}'. ExplicitTag must be true, or the [ExpectedTag] attribute removed.";
	public const string Cryptography_AsnSerializer_UnexpectedTypeForAttribute = "Field '{0}' of type '{1}' has an effective type of '{2}' when one of ({3}) was expected.";
	public const string Cryptography_AsnSerializer_UtcTimeTwoDigitYearMaxTooSmall = "Field '{0}' on type '{1}' has a [UtcTime] TwoDigitYearMax value ({2}) smaller than the minimum (99).";
	public const string Cryptography_AsnSerializer_UnhandledType = "Could not determine how to serialize or deserialize type '{0}'.";
	public const string Cryptography_AsnWriter_EncodeUnbalancedStack = "Encode cannot be called while a Sequence or SetOf is still open.";
	public const string Cryptography_AsnWriter_PopWrongTag = "Cannot pop the requested tag as it is not currently in progress.";
	public const string Cryptography_BadHashValue = "The hash value is not correct.";
	public const string Cryptography_BadSignature = "Invalid signature.";
	public const string Cryptography_Cms_CannotDetermineSignatureAlgorithm = "Could not determine signature algorithm for the signer certificate.";
	public const string Cryptography_Cms_IncompleteCertChain = "The certificate chain is incomplete, the self-signed root authority could not be determined.";
	public const string Cryptography_Cms_Invalid_Originator_Identifier_Choice = "Invalid originator identifier choice {0} found in decoded CMS.";
	public const string Cryptography_Cms_Invalid_Subject_Identifier_Type = "The subject identifier type {0} is not valid.";
	public const string Cryptography_Cms_InvalidMessageType = "Invalid cryptographic message type.";
	public const string Cryptography_Cms_InvalidSignerHashForSignatureAlg = "SignerInfo digest algorithm '{0}' is not valid for signature algorithm '{1}'.";
	public const string Cryptography_Cms_Key_Agree_Date_Not_Available = "The Date property is not available for none KID key agree recipient.";
	public const string Cryptography_Cms_MessageNotEncrypted = "The CMS message is not encrypted.";
	public const string Cryptography_Cms_MessageNotSigned = "The CMS message is not signed.";
	public const string Cryptography_Cms_MissingAuthenticatedAttribute = "The cryptographic message does not contain an expected authenticated attribute.";
	public const string Cryptography_Cms_NoCounterCounterSigner = "Only one level of counter-signatures are supported on this platform.";
	public const string Cryptography_Cms_NoRecipients = "The recipients collection is empty. You must specify at least one recipient. This platform does not implement the certificate picker UI.";
	public const string Cryptography_Cms_NoSignerCert = "No signer certificate was provided. This platform does not implement the certificate picker UI.";
	public const string Cryptography_Cms_NoSignerAtIndex = "The signed cryptographic message does not have a signer for the specified signer index.";
	public const string Cryptography_Cms_RecipientNotFound = "The enveloped-data message does not contain the specified recipient.";
	public const string Cryptography_Cms_RecipientType_NotSupported = "The recipient type '{0}' is not supported for encryption or decryption on this platform.";
	public const string Cryptography_Cms_Sign_Empty_Content = "Cannot create CMS signature for empty content.";
	public const string Cryptography_Cms_SignerNotFound = "Cannot find the original signer.";
	public const string Cryptography_Cms_Signing_RequiresPrivateKey = "A certificate with a private key is required.";
	public const string Cryptography_Cms_TrustFailure = "Certificate trust could not be established. The first reported error is: {0}";
	public const string Cryptography_Cms_UnknownAlgorithm = "Unknown algorithm '{0}'.";
	public const string Cryptography_Cms_UnknownKeySpec = "Unable to determine the type of key handle from this keyspec {0}.";
	public const string Cryptography_Cms_WrongKeyUsage = "The certificate is not valid for the requested usage.";
	public const string Cryptography_Pkcs_InvalidSignatureParameters = "Invalid signature paramters.";
	public const string Cryptography_Pkcs9_AttributeMismatch = "The parameter should be a PKCS 9 attribute.";
	public const string Cryptography_Pkcs9_MultipleSigningTimeNotAllowed = "Cannot add multiple PKCS 9 signing time attributes.";
	public const string Cryptography_Pkcs_PssParametersMissing = "PSS parameters were not present.";
	public const string Cryptography_Pkcs_PssParametersHashMismatch = "This platform requires that the PSS hash algorithm ({0}) match the data digest algorithm ({1}).";
	public const string Cryptography_Pkcs_PssParametersMgfHashMismatch = "This platform does not support the MGF hash algorithm ({0}) being different from the signature hash algorithm ({1}).";
	public const string Cryptography_Pkcs_PssParametersMgfNotSupported = "Mask generation function '{0}' is not supported by this platform.";
	public const string Cryptography_Pkcs_PssParametersSaltMismatch = "PSS salt size {0} is not supported by this platform with hash algorithm {1}.";
	public const string Cryptography_TimestampReq_BadNonce = "The response from the timestamping server did not match the request nonce.";
	public const string Cryptography_TimestampReq_BadResponse = "The response from the timestamping server was not understood.";
	public const string Cryptography_TimestampReq_Failure = "The timestamping server did not grant the request. The request status is '{0}' with failure info '{1}'.";
	public const string Cryptography_TimestampReq_NoCertFound = "The timestamping request required the TSA certificate in the response, but it was not found.";
	public const string Cryptography_TimestampReq_UnexpectedCertFound = "The timestamping request required the TSA certificate not be included in the response, but certificates were present.";
	public const string InvalidOperation_DuplicateItemNotAllowed = "Duplicate items are not allowed in the collection.";
	public const string InvalidOperation_WrongOidInAsnCollection = "AsnEncodedData element in the collection has wrong Oid value: expected = '{0}', actual = '{1}'.";
	public const string PlatformNotSupported_CryptographyPkcs = "System.Security.Cryptography.Pkcs is only supported on Windows platforms.";
	public const string Cryptography_Der_Invalid_Encoding = "ASN1 corrupted data.";
	public const string Cryptography_Invalid_IA5String = "The string contains a character not in the 7 bit ASCII character set.";
	public const string Cryptography_UnknownHashAlgorithm = "'{0}' is not a known hash algorithm.";
	public const string Cryptography_WriteEncodedValue_OneValueAtATime = "The input to WriteEncodedValue must represent a single encoded value with no trailing data.";
	public const string Cryptography_DpApi_ProfileMayNotBeLoaded = "The data protection operation was unsuccessful. This may have been caused by not having the user profile loaded for the current thread's user context, which may be the case when the thread is impersonating.";
	public const string PlatformNotSupported_CryptographyProtectedData = "Windows Data Protection API (DPAPI) is not supported on this platform.";
}
