//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace System.ServiceModel.Web.Diagnostics.Application
{
    using System.Runtime;
    using System.Runtime.Diagnostics;
    using System.Security;
    
    
    internal partial class TD
    {
        
        static System.Resources.ResourceManager resourceManager;
        
        static System.Globalization.CultureInfo resourceCulture;
        
        [System.Security.SecurityCriticalAttribute()]
        static System.Runtime.Diagnostics.EventDescriptor[] eventDescriptors;
        
        static object syncLock = new object();
        
        // Double-checked locking pattern requires volatile for read/write synchronization
        static volatile bool eventDescriptorsCreated;
        
        private TD()
        {
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification="This is an auto-generated code, some ETW/TraceSource mixed code would use it.")]
        static System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if (object.ReferenceEquals(resourceManager, null))
                {
                    resourceManager = new System.Resources.ResourceManager("System.ServiceModel.Web.Diagnostics.Application.TD", typeof(TD).Assembly);
                }
                return resourceManager;
            }
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification="This template is shared across all assemblies, some of which use this accessor.")]
        internal static System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=5203, Level=verbose, Channel=Debug
        /// </summary>
        internal static bool JsonMessageDecodingStartIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose && TD.IsEtwEventEnabled(0));
        }
        
        /// <summary>
        /// Gets trace definition like: JsonMessageEncoder started decoding the message.
        /// Event description ID=5203, Level=verbose, Channel=Debug
        /// </summary>
        internal static void JsonMessageDecodingStart()
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(0))
            {
                TD.WriteEtwEvent(0, null, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=5204, Level=verbose, Channel=Debug
        /// </summary>
        internal static bool JsonMessageEncodingStartIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose && TD.IsEtwEventEnabled(1));
        }
        
        /// <summary>
        /// Gets trace definition like: JsonMessageEncoder started encoding the message.
        /// Event description ID=5204, Level=verbose, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void JsonMessageEncodingStart(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(1))
            {
                TD.WriteEtwEvent(1, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Creates the event descriptors array
        /// </summary>
        // Critical = Sets the SecurityCritical member eventDescriptors
        // Safe = We control what the event descriptors contain
        [System.Security.SecuritySafeCriticalAttribute()]
        static void CreateEventDescriptors()
        {
            System.Runtime.Diagnostics.EventDescriptor[] descriptors = new System.Runtime.Diagnostics.EventDescriptor[] {
                    new System.Runtime.Diagnostics.EventDescriptor(5203, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Start, 0x9fb, 0x1000000000001000),
                    new System.Runtime.Diagnostics.EventDescriptor(5204, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Start, 0x9fc, 0x1000000000001000)};
            ushort[] e2eEvents = new ushort[] {
                    5204};
            FxTrace.UpdateEventDefinitions(descriptors, e2eEvents);
            eventDescriptors = descriptors;
        }
        
        /// <summary>
        /// Ensures that the event descriptors array is initialized
        /// </summary>
        static void EnsureEventDescriptors()
        {
            if (eventDescriptorsCreated)
            {
                return;
            }
            System.Threading.Monitor.Enter(syncLock);
            try
            {
                if (eventDescriptorsCreated)
                {
                    return;
                }
                CreateEventDescriptors();
                eventDescriptorsCreated = true;
            }
            finally
            {
                System.Threading.Monitor.Exit(syncLock);
            }
        }
        
        /// <summary>
        /// Check if ETW tracing is enabled for the particular event
        /// </summary>
        /// <param name="eventIndex">The index of the event descriptor</param>
        static bool IsEtwEventEnabled(int eventIndex)
        {
            if (FxTrace.Trace.IsEtwProviderEnabled)
            {
                EnsureEventDescriptors();
                return FxTrace.IsEventEnabled(eventIndex);
            }
            return false;
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1);
        }
    }
}

