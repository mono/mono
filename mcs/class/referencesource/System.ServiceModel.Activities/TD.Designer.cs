//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace System.ServiceModel.Activities
{
    using System.Runtime;
    using System.Runtime.Diagnostics;
    using System.Security;
    
    
    internal partial class TD
    {
        
        static System.Resources.ResourceManager resourceManager;
        
        static System.Globalization.CultureInfo resourceCulture;
        
        [System.Security.SecurityCriticalAttribute()]
        static System.Runtime.Diagnostics.EventDescriptor[] eventDescriptors;
        
        static object syncLock = new object();
        
        // Double-checked locking pattern requires volatile for read/write synchronization
        static volatile bool eventDescriptorsCreated;
        
        private TD()
        {
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification="This is an auto-generated code, some ETW/TraceSource mixed code would use it.")]
        static System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if (object.ReferenceEquals(resourceManager, null))
                {
                    resourceManager = new System.Resources.ResourceManager("System.ServiceModel.Activities.TD", typeof(TD).Assembly);
                }
                return resourceManager;
            }
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification="This template is shared across all assemblies, some of which use this accessor.")]
        internal static System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=57398, Level=Warning, Channel=Analytic
        /// </summary>
        internal static bool MaxInstancesExceededIsEnabled()
        {
            return (FxTrace.ShouldTraceWarning 
                        && (FxTrace.ShouldTraceWarningToTraceSource || TD.IsEtwEventEnabled(0)));
        }
        
        /// <summary>
        /// Gets trace definition like: The system hit the limit set for throttle 'MaxConcurrentInstances'. Limit for this throttle was set to {0}. Throttle value can be changed by modifying attribute 'maxConcurrentInstances' in serviceThrottle element or by modifying 'MaxConcurrentInstances' property on behavior ServiceThrottlingBehavior.
        /// Event description ID=57398, Level=Warning, Channel=Analytic
        /// </summary>
        /// <param name="limit">Parameter 0 for event: The system hit the limit set for throttle 'MaxConcurrentInstances'. Limit for this throttle was set to {0}. Throttle value can be changed by modifying attribute 'maxConcurrentInstances' in serviceThrottle element or by modifying 'MaxConcurrentInstances' property on behavior ServiceThrottlingBehavior.</param>
        internal static void MaxInstancesExceeded(int limit)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(0))
            {
                TD.WriteEtwEvent(0, null, limit, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceWarningToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("MaxInstancesExceeded", Culture), limit);
                TD.WriteTraceSource(0, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3501, Level=Informational, Channel=Analytic
        /// </summary>
        internal static bool InferredContractDescriptionIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(1)));
        }
        
        /// <summary>
        /// Gets trace definition like: ContractDescription with Name='{0}' and Namespace='{1}' has been inferred from WorkflowService.
        /// Event description ID=3501, Level=Informational, Channel=Analytic
        /// </summary>
        /// <param name="param0">Parameter 0 for event: ContractDescription with Name='{0}' and Namespace='{1}' has been inferred from WorkflowService.</param>
        /// <param name="param1">Parameter 1 for event: ContractDescription with Name='{0}' and Namespace='{1}' has been inferred from WorkflowService.</param>
        internal static void InferredContractDescription(string param0, string param1)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(1))
            {
                TD.WriteEtwEvent(1, null, param0, param1, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("InferredContractDescription", Culture), param0, param1);
                TD.WriteTraceSource(1, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3502, Level=Informational, Channel=Analytic
        /// </summary>
        internal static bool InferredOperationDescriptionIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(2)));
        }
        
        /// <summary>
        /// Gets trace definition like: OperationDescription with Name='{0}' in contract '{1}' has been inferred from WorkflowService. IsOneWay={2}.
        /// Event description ID=3502, Level=Informational, Channel=Analytic
        /// </summary>
        /// <param name="param0">Parameter 0 for event: OperationDescription with Name='{0}' in contract '{1}' has been inferred from WorkflowService. IsOneWay={2}.</param>
        /// <param name="param1">Parameter 1 for event: OperationDescription with Name='{0}' in contract '{1}' has been inferred from WorkflowService. IsOneWay={2}.</param>
        /// <param name="param2">Parameter 2 for event: OperationDescription with Name='{0}' in contract '{1}' has been inferred from WorkflowService. IsOneWay={2}.</param>
        internal static void InferredOperationDescription(string param0, string param1, string param2)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(2))
            {
                TD.WriteEtwEvent(2, null, param0, param1, param2, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("InferredOperationDescription", Culture), param0, param1, param2);
                TD.WriteTraceSource(2, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3503, Level=Warning, Channel=Analytic
        /// </summary>
        internal static bool DuplicateCorrelationQueryIsEnabled()
        {
            return (FxTrace.ShouldTraceWarning 
                        && (FxTrace.ShouldTraceWarningToTraceSource || TD.IsEtwEventEnabled(3)));
        }
        
        /// <summary>
        /// Gets trace definition like: A duplicate CorrelationQuery was found with Where='{0}'. This duplicate query will not be used when calculating correlation.
        /// Event description ID=3503, Level=Warning, Channel=Analytic
        /// </summary>
        /// <param name="param0">Parameter 0 for event: A duplicate CorrelationQuery was found with Where='{0}'. This duplicate query will not be used when calculating correlation.</param>
        internal static void DuplicateCorrelationQuery(string param0)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(3))
            {
                TD.WriteEtwEvent(3, null, param0, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceWarningToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("DuplicateCorrelationQuery", Culture), param0);
                TD.WriteTraceSource(3, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3507, Level=Informational, Channel=Analytic
        /// </summary>
        internal static bool ServiceEndpointAddedIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(4)));
        }
        
        /// <summary>
        /// Gets trace definition like: A service endpoint has been added for address '{0}', binding '{1}', and contract '{2}'.
        /// Event description ID=3507, Level=Informational, Channel=Analytic
        /// </summary>
        /// <param name="param0">Parameter 0 for event: A service endpoint has been added for address '{0}', binding '{1}', and contract '{2}'.</param>
        /// <param name="param1">Parameter 1 for event: A service endpoint has been added for address '{0}', binding '{1}', and contract '{2}'.</param>
        /// <param name="param2">Parameter 2 for event: A service endpoint has been added for address '{0}', binding '{1}', and contract '{2}'.</param>
        internal static void ServiceEndpointAdded(string param0, string param1, string param2)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(4))
            {
                TD.WriteEtwEvent(4, null, param0, param1, param2, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("ServiceEndpointAdded", Culture), param0, param1, param2);
                TD.WriteTraceSource(4, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=440, Level=informational, Channel=Analytic
        /// </summary>
        internal static bool StartSignpostEventIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(5)));
        }
        
        /// <summary>
        /// Gets trace definition like: Activity boundary.
        /// Event description ID=440, Level=informational, Channel=Analytic
        /// </summary>
        /// <param name="traceRecord">Extended data (TraceRecord) for the event</param>
        internal static void StartSignpostEvent(TraceRecord traceRecord)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, traceRecord, null);
            if (TD.IsEtwEventEnabled(5))
            {
                TD.WriteEtwEvent(5, null, payload.ExtendedData, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("StartSignpostEvent", Culture));
                TD.WriteTraceSource(5, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=441, Level=informational, Channel=Analytic
        /// </summary>
        internal static bool StopSignpostEventIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(6)));
        }
        
        /// <summary>
        /// Gets trace definition like: Activity boundary.
        /// Event description ID=441, Level=informational, Channel=Analytic
        /// </summary>
        /// <param name="traceRecord">Extended data (TraceRecord) for the event</param>
        internal static void StopSignpostEvent(TraceRecord traceRecord)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, traceRecord, null);
            if (TD.IsEtwEventEnabled(6))
            {
                TD.WriteEtwEvent(6, null, payload.ExtendedData, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("StopSignpostEvent", Culture));
                TD.WriteTraceSource(6, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3550, Level=Informational, Channel=Analytic
        /// </summary>
        internal static bool BufferOutOfOrderMessageNoInstanceIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(7)));
        }
        
        /// <summary>
        /// Gets trace definition like: Operation '{0}' cannot be performed at this time. Another attempt will be made when the service instance is ready to process this particular operation.
        /// Event description ID=3550, Level=Informational, Channel=Analytic
        /// </summary>
        /// <param name="param0">Parameter 0 for event: Operation '{0}' cannot be performed at this time. Another attempt will be made when the service instance is ready to process this particular operation.</param>
        internal static void BufferOutOfOrderMessageNoInstance(string param0)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(7))
            {
                TD.WriteEtwEvent(7, null, param0, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("BufferOutOfOrderMessageNoInstance", Culture), param0);
                TD.WriteTraceSource(7, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3551, Level=Informational, Channel=Analytic
        /// </summary>
        internal static bool BufferOutOfOrderMessageNoBookmarkIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(8)));
        }
        
        /// <summary>
        /// Gets trace definition like: Operation '{1}' on service instance '{0}' cannot be performed at this time. Another attempt will be made when the service instance is ready to process this particular operation.
        /// Event description ID=3551, Level=Informational, Channel=Analytic
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="param0">Parameter 0 for event: Operation '{1}' on service instance '{0}' cannot be performed at this time. Another attempt will be made when the service instance is ready to process this particular operation.</param>
        /// <param name="param1">Parameter 1 for event: Operation '{1}' on service instance '{0}' cannot be performed at this time. Another attempt will be made when the service instance is ready to process this particular operation.</param>
        internal static void BufferOutOfOrderMessageNoBookmark(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string param0, string param1)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(8))
            {
                TD.WriteEtwEvent(8, eventTraceActivity, param0, param1, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("BufferOutOfOrderMessageNoBookmark", Culture), param0, param1);
                TD.WriteTraceSource(8, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3552, Level=Warning, Channel=Analytic
        /// </summary>
        internal static bool MaxPendingMessagesPerChannelExceededIsEnabled()
        {
            return (FxTrace.ShouldTraceWarning 
                        && (FxTrace.ShouldTraceWarningToTraceSource || TD.IsEtwEventEnabled(9)));
        }
        
        /// <summary>
        /// Gets trace definition like: The throttle 'MaxPendingMessagesPerChannel' limit of  '{0}' was hit. To increase this limit, adjust the MaxPendingMessagesPerChannel property on BufferedReceiveServiceBehavior.
        /// Event description ID=3552, Level=Warning, Channel=Analytic
        /// </summary>
        /// <param name="limit">Parameter 0 for event: The throttle 'MaxPendingMessagesPerChannel' limit of  '{0}' was hit. To increase this limit, adjust the MaxPendingMessagesPerChannel property on BufferedReceiveServiceBehavior.</param>
        internal static void MaxPendingMessagesPerChannelExceeded(int limit)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(9))
            {
                TD.WriteEtwEvent(9, null, limit, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceWarningToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("MaxPendingMessagesPerChannelExceeded", Culture), limit);
                TD.WriteTraceSource(9, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3555, Level=informational, Channel=debug
        /// </summary>
        internal static bool CreateWorkflowServiceHostStartIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(10));
        }
        
        /// <summary>
        /// Gets trace definition like: CreateWorkflowServiceHost start
        /// Event description ID=3555, Level=informational, Channel=debug
        /// </summary>
        internal static void CreateWorkflowServiceHostStart()
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(10))
            {
                TD.WriteEtwEvent(10, null, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3556, Level=informational, Channel=debug
        /// </summary>
        internal static bool CreateWorkflowServiceHostStopIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(11));
        }
        
        /// <summary>
        /// Gets trace definition like: CreateWorkflowServiceHost Stop
        /// Event description ID=3556, Level=informational, Channel=debug
        /// </summary>
        internal static void CreateWorkflowServiceHostStop()
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(11))
            {
                TD.WriteEtwEvent(11, null, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3557, Level=informational, Channel=Analytic
        /// </summary>
        internal static bool TransactedReceiveScopeEndCommitFailedIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(12)));
        }
        
        /// <summary>
        /// Gets trace definition like: The call to EndCommit on the CommittableTransaction with id = '{0}' threw a TransactionException with the following message: '{1}'.
        /// Event description ID=3557, Level=informational, Channel=Analytic
        /// </summary>
        /// <param name="param0">Parameter 0 for event: The call to EndCommit on the CommittableTransaction with id = '{0}' threw a TransactionException with the following message: '{1}'.</param>
        /// <param name="param1">Parameter 1 for event: The call to EndCommit on the CommittableTransaction with id = '{0}' threw a TransactionException with the following message: '{1}'.</param>
        internal static void TransactedReceiveScopeEndCommitFailed(string param0, string param1)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(12))
            {
                TD.WriteEtwEvent(12, null, param0, param1, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("TransactedReceiveScopeEndCommitFailed", Culture), param0, param1);
                TD.WriteTraceSource(12, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3508, Level=verbose, Channel=Analytic
        /// </summary>
        internal static bool TrackingProfileNotFoundIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose 
                        && (FxTrace.ShouldTraceVerboseToTraceSource || TD.IsEtwEventEnabled(13)));
        }
        
        /// <summary>
        /// Gets trace definition like: TrackingProfile '{0}' for the ActivityDefinitionId '{1}' not found. Either the TrackingProfile is not found in the config file or the ActivityDefinitionId does not match.
        /// Event description ID=3508, Level=verbose, Channel=Analytic
        /// </summary>
        /// <param name="TrackingProfile">Parameter 0 for event: TrackingProfile '{0}' for the ActivityDefinitionId '{1}' not found. Either the TrackingProfile is not found in the config file or the ActivityDefinitionId does not match.</param>
        /// <param name="ActivityDefinitionId">Parameter 1 for event: TrackingProfile '{0}' for the ActivityDefinitionId '{1}' not found. Either the TrackingProfile is not found in the config file or the ActivityDefinitionId does not match.</param>
        internal static void TrackingProfileNotFound(string TrackingProfile, string ActivityDefinitionId)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(13))
            {
                TD.WriteEtwEvent(13, null, TrackingProfile, ActivityDefinitionId, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceVerboseToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("TrackingProfileNotFound", Culture), TrackingProfile, ActivityDefinitionId);
                TD.WriteTraceSource(13, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=225, Level=informational, Channel=Analytic
        /// </summary>
        internal static bool TraceCorrelationKeysIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(14)));
        }
        
        /// <summary>
        /// Gets trace definition like: Calculated correlation key '{0}' using values '{1}' in parent scope '{2}'.
        /// Event description ID=225, Level=informational, Channel=Analytic
        /// </summary>
        /// <param name="InstanceKey">Parameter 0 for event: Calculated correlation key '{0}' using values '{1}' in parent scope '{2}'.</param>
        /// <param name="Values">Parameter 1 for event: Calculated correlation key '{0}' using values '{1}' in parent scope '{2}'.</param>
        /// <param name="ParentScope">Parameter 2 for event: Calculated correlation key '{0}' using values '{1}' in parent scope '{2}'.</param>
        internal static void TraceCorrelationKeys(System.Guid InstanceKey, string Values, string ParentScope)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null, true);
            if (TD.IsEtwEventEnabled(14))
            {
                TD.WriteEtwEvent(14, null, InstanceKey, Values, ParentScope, payload.HostReference, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("TraceCorrelationKeys", Culture), InstanceKey, Values, ParentScope);
                TD.WriteTraceSource(14, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=2023, Level=Verbose, Channel=Debug
        /// </summary>
        internal static bool SendMessageChannelCacheMissIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose && TD.IsEtwEventEnabled(15));
        }
        
        /// <summary>
        /// Gets trace definition like: SendMessageChannelCache miss
        /// Event description ID=2023, Level=Verbose, Channel=Debug
        /// </summary>
        internal static void SendMessageChannelCacheMiss()
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(15))
            {
                TD.WriteEtwEvent(15, null, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=1450, Level=Informational, Channel=Debug
        /// </summary>
        internal static bool WfMessageSentIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(16));
        }
        
        /// <summary>
        /// Gets trace definition like: Message sent from workflow
        /// Event description ID=1450, Level=Informational, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="relatedActivityId">The related event activity Id</param>
        internal static void WfMessageSent(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, System.Guid relatedActivityId)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(16))
            {
                TD.WriteEtwTransferEvent(16, eventTraceActivity, relatedActivityId, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=1449, Level=Informational, Channel=Debug
        /// </summary>
        internal static bool WfMessageReceivedIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(17));
        }
        
        /// <summary>
        /// Gets trace definition like: Message received by workflow
        /// Event description ID=1449, Level=Informational, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="relatedActivityId">The related event activity Id</param>
        internal static void WfMessageReceived(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, System.Guid relatedActivityId)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(17))
            {
                TD.WriteEtwTransferEvent(17, eventTraceActivity, relatedActivityId, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=1436, Level=verbose, Channel=analytic
        /// </summary>
        internal static bool PendingMessagesPerChannelRatioIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose && TD.IsEtwEventEnabled(18));
        }
        
        /// <summary>
        /// Gets trace definition like: Pending messages per channel ratio: {0}/{1}
        /// Event description ID=1436, Level=verbose, Channel=analytic
        /// </summary>
        /// <param name="cur">Parameter 0 for event: Pending messages per channel ratio: {0}/{1}</param>
        /// <param name="max">Parameter 1 for event: Pending messages per channel ratio: {0}/{1}</param>
        internal static void PendingMessagesPerChannelRatio(int cur, int max)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(18))
            {
                TD.WriteEtwEvent(18, null, cur, max, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Creates the event descriptors array
        /// </summary>
        // Critical = Sets the SecurityCritical member eventDescriptors
        // Safe = We control what the event descriptors contain
        [System.Security.SecuritySafeCriticalAttribute()]
        static void CreateEventDescriptors()
        {
            System.Runtime.Diagnostics.EventDescriptor[] descriptors = new System.Runtime.Diagnostics.EventDescriptor[] {
                    new System.Runtime.Diagnostics.EventDescriptor(57398, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Warning, (byte)TraceEventOpcode.Info, 0xa22, 0x2000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(3501, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)69, 0x9f4, 0x2000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(3502, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)70, 0x9f4, 0x2000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(3503, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Warning, (byte)28, 0x9db, 0x2000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(3507, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Info, 0x9cb, 0x2000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(440, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Start, 0xa1c, 0x2000000004080000),
                    new System.Runtime.Diagnostics.EventDescriptor(441, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Stop, 0xa1c, 0x2000000004080000),
                    new System.Runtime.Diagnostics.EventDescriptor(3550, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)11, 0x9cc, 0x2000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(3551, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)10, 0x9cc, 0x2000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(3552, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Warning, (byte)TraceEventOpcode.Info, 0xa00, 0x2000000004400000),
                    new System.Runtime.Diagnostics.EventDescriptor(3555, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Start, 0x9de, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(3556, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Stop, 0x9de, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(3557, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Info, 0xa08, 0x2000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(3508, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Verbose, (byte)124, 0xa25, 0x2000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(225, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Info, 0x9db, 0x2000000004080000),
                    new System.Runtime.Diagnostics.EventDescriptor(2023, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)76, 0x9fa, 0x1000000001000000),
                    new System.Runtime.Diagnostics.EventDescriptor(1450, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Send, 0xa2e, 0x1000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(1449, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Receive, 0xa2e, 0x1000000004000000),
                    new System.Runtime.Diagnostics.EventDescriptor(1436, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Info, 0xa00, 0x2000000000400000)};
            // The hashcodes calculated from PTCop for TD.CreateEventDescriptors are unstable when just declaring
            // a local field of ushort[] if the array is non-empty and contains more than 2 entries, because
            // the c#-compiler is using some private types for optimization. The type name follows the following pattern:
            // <PrivateImplementationDetails>{6BAE93FD-290B-4DE0-BCEE-366B30800FDF} (where the GUID is changing with every build)
            // To scope the change to unblock PTCop as much as possible we wrap the list of End2EndEvents in a List<ushort>
            System.Collections.Generic.List<ushort> e2eEvents = new System.Collections.Generic.List<ushort>(3);
            e2eEvents.Add(1449);
            e2eEvents.Add(1450);
            e2eEvents.Add(3551);
            FxTrace.UpdateEventDefinitions(descriptors, e2eEvents.ToArray());
            eventDescriptors = descriptors;
        }
        
        /// <summary>
        /// Ensures that the event descriptors array is initialized
        /// </summary>
        static void EnsureEventDescriptors()
        {
            if (eventDescriptorsCreated)
            {
                return;
            }
            System.Threading.Monitor.Enter(syncLock);
            try
            {
                if (eventDescriptorsCreated)
                {
                    return;
                }
                CreateEventDescriptors();
                eventDescriptorsCreated = true;
            }
            finally
            {
                System.Threading.Monitor.Exit(syncLock);
            }
        }
        
        /// <summary>
        /// Check if ETW tracing is enabled for the particular event
        /// </summary>
        /// <param name="eventIndex">The index of the event descriptor</param>
        static bool IsEtwEventEnabled(int eventIndex)
        {
            if (FxTrace.Trace.IsEtwProviderEnabled)
            {
                EnsureEventDescriptors();
                return FxTrace.IsEventEnabled(eventIndex);
            }
            return false;
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, int eventParam1, string eventParam2)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        /// <param name="eventParam3">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1, string eventParam2, string eventParam3)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2, eventParam3);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        /// <param name="eventParam3">A parameter of the ETW event</param>>
        /// <param name="eventParam4">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1, string eventParam2, string eventParam3, string eventParam4)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2, eventParam3, eventParam4);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1, string eventParam2)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        /// <param name="eventParam3">A parameter of the ETW event</param>>
        /// <param name="eventParam4">A parameter of the ETW event</param>>
        /// <param name="eventParam5">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, System.Guid eventParam1, string eventParam2, string eventParam3, string eventParam4, string eventParam5)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2, eventParam3, eventParam4, eventParam5);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        /// <param name="eventParam3">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, int eventParam1, int eventParam2, string eventParam3)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2, eventParam3);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwTransferEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, System.Guid eventParam1, string eventParam2)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteTransferEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2);
        }
        
        /// <summary>
        /// write a trace source into the diagnostic trace
        /// </summary>
        /// <param name="eventIndex">The index of the event descriptor</param>
        /// <param name="description">The description to write</param>
        /// <param name="payload">The trace payload</param>
        // Critical = Calls SecurityCritical method EtwDiagnosticTrace.WriteTraceSource
        // Safe = We only allow setting of provider id from SecurityCritical code
        [System.Security.SecuritySafeCriticalAttribute()]
        static void WriteTraceSource(int eventIndex, string description, TracePayload payload)
        {
            EnsureEventDescriptors();
            FxTrace.Trace.WriteTraceSource(ref eventDescriptors[eventIndex], description, payload);
        }
    }
}

