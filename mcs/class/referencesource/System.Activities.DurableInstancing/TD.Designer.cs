//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace System.Activities.DurableInstancing
{
    using System.Runtime;
    using System.Runtime.Diagnostics;
    using System.Security;
    
    
    internal partial class TD
    {
        
        static System.Resources.ResourceManager resourceManager;
        
        static System.Globalization.CultureInfo resourceCulture;
        
        [System.Security.SecurityCriticalAttribute()]
        static System.Runtime.Diagnostics.EventDescriptor[] eventDescriptors;
        
        static object syncLock = new object();
        
        // Double-checked locking pattern requires volatile for read/write synchronization
        static volatile bool eventDescriptorsCreated;
        
        private TD()
        {
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification="This is an auto-generated code, some ETW/TraceSource mixed code would use it.")]
        static System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if (object.ReferenceEquals(resourceManager, null))
                {
                    resourceManager = new System.Resources.ResourceManager("System.Activities.DurableInstancing.TD", typeof(TD).Assembly);
                }
                return resourceManager;
            }
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification="This template is shared across all assemblies, some of which use this accessor.")]
        internal static System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4201, Level=Verbose, Channel=debug
        /// </summary>
        internal static bool EndSqlCommandExecuteIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose 
                        && (FxTrace.ShouldTraceVerboseToTraceSource || TD.IsEtwEventEnabled(0)));
        }
        
        /// <summary>
        /// Gets trace definition like: End SQL command execution: {0}
        /// Event description ID=4201, Level=Verbose, Channel=debug
        /// </summary>
        /// <param name="param0">Parameter 0 for event: End SQL command execution: {0}</param>
        internal static void EndSqlCommandExecute(string param0)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(0))
            {
                TD.WriteEtwEvent(0, null, param0, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceVerboseToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("EndSqlCommandExecute", Culture), param0);
                TD.WriteTraceSource(0, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4202, Level=Verbose, Channel=debug
        /// </summary>
        internal static bool StartSqlCommandExecuteIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose 
                        && (FxTrace.ShouldTraceVerboseToTraceSource || TD.IsEtwEventEnabled(1)));
        }
        
        /// <summary>
        /// Gets trace definition like: Starting SQL command execution: {0}
        /// Event description ID=4202, Level=Verbose, Channel=debug
        /// </summary>
        /// <param name="param0">Parameter 0 for event: Starting SQL command execution: {0}</param>
        internal static void StartSqlCommandExecute(string param0)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(1))
            {
                TD.WriteEtwEvent(1, null, param0, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceVerboseToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("StartSqlCommandExecute", Culture), param0);
                TD.WriteTraceSource(1, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4203, Level=Error, Channel=debug
        /// </summary>
        internal static bool RenewLockSystemErrorIsEnabled()
        {
            return (FxTrace.ShouldTraceError 
                        && (FxTrace.ShouldTraceErrorToTraceSource || TD.IsEtwEventEnabled(2)));
        }
        
        /// <summary>
        /// Gets trace definition like: Failed to extend lock expiration, lock expiration already passed or the lock owner was deleted. Aborting SqlWorkflowInstanceStore.
        /// Event description ID=4203, Level=Error, Channel=debug
        /// </summary>
        internal static void RenewLockSystemError()
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(2))
            {
                TD.WriteEtwEvent(2, null, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceErrorToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("RenewLockSystemError", Culture));
                TD.WriteTraceSource(2, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4205, Level=Error, Channel=debug
        /// </summary>
        internal static bool FoundProcessingErrorIsEnabled()
        {
            return (FxTrace.ShouldTraceError 
                        && (FxTrace.ShouldTraceErrorToTraceSource || TD.IsEtwEventEnabled(3)));
        }
        
        /// <summary>
        /// Gets trace definition like: Command failed: {0}
        /// Event description ID=4205, Level=Error, Channel=debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="param0">Parameter 0 for event: Command failed: {0}</param>
        /// <param name="exception">Exception associated with the event</param>
        internal static void FoundProcessingError(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string param0, System.Exception exception)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, exception);
            if (TD.IsEtwEventEnabled(3))
            {
                TD.WriteEtwEvent(3, eventTraceActivity, param0, payload.SerializedException, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceErrorToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("FoundProcessingError", Culture), param0);
                TD.WriteTraceSource(3, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4206, Level=Error, Channel=debug
        /// </summary>
        internal static bool UnlockInstanceExceptionIsEnabled()
        {
            return (FxTrace.ShouldTraceError 
                        && (FxTrace.ShouldTraceErrorToTraceSource || TD.IsEtwEventEnabled(4)));
        }
        
        /// <summary>
        /// Gets trace definition like: Encountered exception {0} while attempting to unlock instance.
        /// Event description ID=4206, Level=Error, Channel=debug
        /// </summary>
        /// <param name="param0">Parameter 0 for event: Encountered exception {0} while attempting to unlock instance.</param>
        internal static void UnlockInstanceException(string param0)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(4))
            {
                TD.WriteEtwEvent(4, null, param0, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceErrorToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("UnlockInstanceException", Culture), param0);
                TD.WriteTraceSource(4, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4207, Level=Informational, Channel=debug
        /// </summary>
        internal static bool MaximumRetriesExceededForSqlCommandIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(5)));
        }
        
        /// <summary>
        /// Gets trace definition like: Giving up retrying a SQL command as the maximum number of retries have been performed.
        /// Event description ID=4207, Level=Informational, Channel=debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void MaximumRetriesExceededForSqlCommand(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(5))
            {
                TD.WriteEtwEvent(5, eventTraceActivity, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("MaximumRetriesExceededForSqlCommand", Culture));
                TD.WriteTraceSource(5, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4208, Level=Informational, Channel=debug
        /// </summary>
        internal static bool RetryingSqlCommandDueToSqlErrorIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation 
                        && (FxTrace.ShouldTraceInformationToTraceSource || TD.IsEtwEventEnabled(6)));
        }
        
        /// <summary>
        /// Gets trace definition like: Retrying a SQL command due to SQL error number {0}.
        /// Event description ID=4208, Level=Informational, Channel=debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="param0">Parameter 0 for event: Retrying a SQL command due to SQL error number {0}.</param>
        internal static void RetryingSqlCommandDueToSqlError(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string param0)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(6))
            {
                TD.WriteEtwEvent(6, eventTraceActivity, param0, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceInformationToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("RetryingSqlCommandDueToSqlError", Culture), param0);
                TD.WriteTraceSource(6, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4209, Level=Error, Channel=debug
        /// </summary>
        internal static bool TimeoutOpeningSqlConnectionIsEnabled()
        {
            return (FxTrace.ShouldTraceError 
                        && (FxTrace.ShouldTraceErrorToTraceSource || TD.IsEtwEventEnabled(7)));
        }
        
        /// <summary>
        /// Gets trace definition like: Timeout trying to open a SQL connection. The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
        /// Event description ID=4209, Level=Error, Channel=debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="param0">Parameter 0 for event: Timeout trying to open a SQL connection. The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</param>
        internal static void TimeoutOpeningSqlConnection(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string param0)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(7))
            {
                TD.WriteEtwEvent(7, eventTraceActivity, param0, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceErrorToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("TimeoutOpeningSqlConnection", Culture), param0);
                TD.WriteTraceSource(7, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4210, Level=Warning, Channel=debug
        /// </summary>
        internal static bool SqlExceptionCaughtIsEnabled()
        {
            return (FxTrace.ShouldTraceWarning 
                        && (FxTrace.ShouldTraceWarningToTraceSource || TD.IsEtwEventEnabled(8)));
        }
        
        /// <summary>
        /// Gets trace definition like: Caught SQL Exception number {0} message {1}.
        /// Event description ID=4210, Level=Warning, Channel=debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="param0">Parameter 0 for event: Caught SQL Exception number {0} message {1}.</param>
        /// <param name="param1">Parameter 1 for event: Caught SQL Exception number {0} message {1}.</param>
        internal static void SqlExceptionCaught(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string param0, string param1)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(8))
            {
                TD.WriteEtwEvent(8, eventTraceActivity, param0, param1, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceWarningToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("SqlExceptionCaught", Culture), param0, param1);
                TD.WriteTraceSource(8, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4212, Level=Warning, Channel=debug
        /// </summary>
        internal static bool LockRetryTimeoutIsEnabled()
        {
            return (FxTrace.ShouldTraceWarning 
                        && (FxTrace.ShouldTraceWarningToTraceSource || TD.IsEtwEventEnabled(9)));
        }
        
        /// <summary>
        /// Gets trace definition like: Timeout trying to acquire the instance lock.  The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
        /// Event description ID=4212, Level=Warning, Channel=debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="param0">Parameter 0 for event: Timeout trying to acquire the instance lock.  The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.</param>
        internal static void LockRetryTimeout(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string param0)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(9))
            {
                TD.WriteEtwEvent(9, eventTraceActivity, param0, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceWarningToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("LockRetryTimeout", Culture), param0);
                TD.WriteTraceSource(9, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4211, Level=Warning, Channel=debug
        /// </summary>
        internal static bool QueuingSqlRetryIsEnabled()
        {
            return (FxTrace.ShouldTraceWarning 
                        && (FxTrace.ShouldTraceWarningToTraceSource || TD.IsEtwEventEnabled(10)));
        }
        
        /// <summary>
        /// Gets trace definition like: Queuing SQL retry with delay {0} milliseconds.
        /// Event description ID=4211, Level=Warning, Channel=debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="param0">Parameter 0 for event: Queuing SQL retry with delay {0} milliseconds.</param>
        internal static void QueuingSqlRetry(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string param0)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(10))
            {
                TD.WriteEtwEvent(10, eventTraceActivity, param0, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceWarningToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("QueuingSqlRetry", Culture), param0);
                TD.WriteTraceSource(10, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4213, Level=Error, Channel=debug
        /// </summary>
        internal static bool RunnableInstancesDetectionErrorIsEnabled()
        {
            return (FxTrace.ShouldTraceError 
                        && (FxTrace.ShouldTraceErrorToTraceSource || TD.IsEtwEventEnabled(11)));
        }
        
        /// <summary>
        /// Gets trace definition like: Detection of runnable instances failed due to the following exception
        /// Event description ID=4213, Level=Error, Channel=debug
        /// </summary>
        /// <param name="exception">Exception associated with the event</param>
        internal static void RunnableInstancesDetectionError(System.Exception exception)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, exception);
            if (TD.IsEtwEventEnabled(11))
            {
                TD.WriteEtwEvent(11, null, payload.SerializedException, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceErrorToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("RunnableInstancesDetectionError", Culture));
                TD.WriteTraceSource(11, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4214, Level=Error, Channel=debug
        /// </summary>
        internal static bool InstanceLocksRecoveryErrorIsEnabled()
        {
            return (FxTrace.ShouldTraceError 
                        && (FxTrace.ShouldTraceErrorToTraceSource || TD.IsEtwEventEnabled(12)));
        }
        
        /// <summary>
        /// Gets trace definition like: Recovering instance locks failed due to the following exception
        /// Event description ID=4214, Level=Error, Channel=debug
        /// </summary>
        /// <param name="exception">Exception associated with the event</param>
        internal static void InstanceLocksRecoveryError(System.Exception exception)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, exception);
            if (TD.IsEtwEventEnabled(12))
            {
                TD.WriteEtwEvent(12, null, payload.SerializedException, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceErrorToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("InstanceLocksRecoveryError", Culture));
                TD.WriteTraceSource(12, description, payload);
            }
        }
        
        /// <summary>
        /// Creates the event descriptors array
        /// </summary>
        // Critical = Sets the SecurityCritical member eventDescriptors
        // Safe = We control what the event descriptors contain
        [System.Security.SecuritySafeCriticalAttribute()]
        static void CreateEventDescriptors()
        {
            System.Runtime.Diagnostics.EventDescriptor[] descriptors = new System.Runtime.Diagnostics.EventDescriptor[] {
                    new System.Runtime.Diagnostics.EventDescriptor(4201, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Stop, 0xa1d, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4202, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Start, 0xa1d, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4203, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Error, (byte)TraceEventOpcode.Info, 0x9f9, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4205, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Error, (byte)TraceEventOpcode.Info, 0xa1d, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4206, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Error, (byte)TraceEventOpcode.Info, 0x9f9, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4207, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Info, 0xa1d, 0x1000000008400000),
                    new System.Runtime.Diagnostics.EventDescriptor(4208, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Info, 0xa1d, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4209, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Error, (byte)TraceEventOpcode.Info, 0xa1d, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4210, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Warning, (byte)TraceEventOpcode.Info, 0xa1d, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4212, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Warning, (byte)TraceEventOpcode.Info, 0xa1d, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4211, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Warning, (byte)TraceEventOpcode.Info, 0x9f9, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4213, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Error, (byte)TraceEventOpcode.Info, 0x9f9, 0x1000000008000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4214, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Error, (byte)TraceEventOpcode.Info, 0x9f9, 0x1000000008000000)};
            // The hashcodes calculated from PTCop for TD.CreateEventDescriptors are unstable when just declaring
            // a local field of ushort[] if the array is non-empty and contains more than 2 entries, because
            // the c#-compiler is using some private types for optimization. The type name follows the following pattern:
            // <PrivateImplementationDetails>{6BAE93FD-290B-4DE0-BCEE-366B30800FDF} (where the GUID is changing with every build)
            // To scope the change to unblock PTCop as much as possible we wrap the list of End2EndEvents in a List<ushort>
            System.Collections.Generic.List<ushort> e2eEvents = new System.Collections.Generic.List<ushort>(7);
            e2eEvents.Add(4205);
            e2eEvents.Add(4207);
            e2eEvents.Add(4208);
            e2eEvents.Add(4209);
            e2eEvents.Add(4210);
            e2eEvents.Add(4211);
            e2eEvents.Add(4212);
            FxTrace.UpdateEventDefinitions(descriptors, e2eEvents.ToArray());
            eventDescriptors = descriptors;
        }
        
        /// <summary>
        /// Ensures that the event descriptors array is initialized
        /// </summary>
        static void EnsureEventDescriptors()
        {
            if (eventDescriptorsCreated)
            {
                return;
            }
            System.Threading.Monitor.Enter(syncLock);
            try
            {
                if (eventDescriptorsCreated)
                {
                    return;
                }
                CreateEventDescriptors();
                eventDescriptorsCreated = true;
            }
            finally
            {
                System.Threading.Monitor.Exit(syncLock);
            }
        }
        
        /// <summary>
        /// Check if ETW tracing is enabled for the particular event
        /// </summary>
        /// <param name="eventIndex">The index of the event descriptor</param>
        static bool IsEtwEventEnabled(int eventIndex)
        {
            if (FxTrace.Trace.IsEtwProviderEnabled)
            {
                EnsureEventDescriptors();
                return FxTrace.IsEventEnabled(eventIndex);
            }
            return false;
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1, string eventParam2)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        /// <param name="eventParam3">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1, string eventParam2, string eventParam3)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2, eventParam3);
        }
        
        /// <summary>
        /// write a trace source into the diagnostic trace
        /// </summary>
        /// <param name="eventIndex">The index of the event descriptor</param>
        /// <param name="description">The description to write</param>
        /// <param name="payload">The trace payload</param>
        // Critical = Calls SecurityCritical method EtwDiagnosticTrace.WriteTraceSource
        // Safe = We only allow setting of provider id from SecurityCritical code
        [System.Security.SecuritySafeCriticalAttribute()]
        static void WriteTraceSource(int eventIndex, string description, TracePayload payload)
        {
            EnsureEventDescriptors();
            FxTrace.Trace.WriteTraceSource(ref eventDescriptors[eventIndex], description, payload);
        }
    }
}

