//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace System.ServiceModel.Channels
{
    using System.Runtime;
    using System.Runtime.Diagnostics;
    using System.Security;
    
    
    internal partial class TD
    {
        
        static System.Resources.ResourceManager resourceManager;
        
        static System.Globalization.CultureInfo resourceCulture;
        
        [System.Security.SecurityCriticalAttribute()]
        static System.Runtime.Diagnostics.EventDescriptor[] eventDescriptors;
        
        static object syncLock = new object();
        
        // Double-checked locking pattern requires volatile for read/write synchronization
        static volatile bool eventDescriptorsCreated;
        
        private TD()
        {
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification="This is an auto-generated code, some ETW/TraceSource mixed code would use it.")]
        static System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if (object.ReferenceEquals(resourceManager, null))
                {
                    resourceManager = new System.Resources.ResourceManager("System.ServiceModel.Channels.TD", typeof(TD).Assembly);
                }
                return resourceManager;
            }
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification="This template is shared across all assemblies, some of which use this accessor.")]
        internal static System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4800, Level=Warning, Channel=debug
        /// </summary>
        internal static bool MaxPendingMessagesTotalSizeReachedIsEnabled()
        {
            return (FxTrace.ShouldTraceWarning 
                        && (FxTrace.ShouldTraceWarningToTraceSource || TD.IsEtwEventEnabled(0)));
        }
        
        /// <summary>
        /// Gets trace definition like: Message {0}was dropped, because pending messages total size limit ({1}) was exceeded. Use {2}.MaxPendingMessagesTotalSize to adjust the pending message limit.
        /// Event description ID=4800, Level=Warning, Channel=debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="messageID">Parameter 0 for event: Message {0}was dropped, because pending messages total size limit ({1}) was exceeded. Use {2}.MaxPendingMessagesTotalSize to adjust the pending message limit.</param>
        /// <param name="maxPendingMessagesTotalSize">Parameter 1 for event: Message {0}was dropped, because pending messages total size limit ({1}) was exceeded. Use {2}.MaxPendingMessagesTotalSize to adjust the pending message limit.</param>
        /// <param name="bindingElementTypeName">Parameter 2 for event: Message {0}was dropped, because pending messages total size limit ({1}) was exceeded. Use {2}.MaxPendingMessagesTotalSize to adjust the pending message limit.</param>
        internal static void MaxPendingMessagesTotalSizeReached(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string messageID, long maxPendingMessagesTotalSize, string bindingElementTypeName)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(0))
            {
                TD.WriteEtwEvent(0, eventTraceActivity, messageID, maxPendingMessagesTotalSize, bindingElementTypeName, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceWarningToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("MaxPendingMessagesTotalSizeReached", Culture), messageID, maxPendingMessagesTotalSize, bindingElementTypeName);
                TD.WriteTraceSource(0, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4801, Level=verbose, Channel=Debug
        /// </summary>
        internal static bool ByteStreamMessageDecodingStartIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose && TD.IsEtwEventEnabled(1));
        }
        
        /// <summary>
        /// Gets trace definition like: ByteStreamMessageEncoder started decoding the message.
        /// Event description ID=4801, Level=verbose, Channel=Debug
        /// </summary>
        internal static void ByteStreamMessageDecodingStart()
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(1))
            {
                TD.WriteEtwEvent(1, null, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=4802, Level=verbose, Channel=Debug
        /// </summary>
        internal static bool ByteStreamMessageEncodingStartIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose && TD.IsEtwEventEnabled(2));
        }
        
        /// <summary>
        /// Gets trace definition like: ByteStreamMessageEncoder started encoding the message.
        /// Event description ID=4802, Level=verbose, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void ByteStreamMessageEncodingStart(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(2))
            {
                TD.WriteEtwEvent(2, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Creates the event descriptors array
        /// </summary>
        // Critical = Sets the SecurityCritical member eventDescriptors
        // Safe = We control what the event descriptors contain
        [System.Security.SecuritySafeCriticalAttribute()]
        static void CreateEventDescriptors()
        {
            System.Runtime.Diagnostics.EventDescriptor[] descriptors = new System.Runtime.Diagnostics.EventDescriptor[] {
                    new System.Runtime.Diagnostics.EventDescriptor(4800, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Warning, (byte)TraceEventOpcode.Info, 0x0, 0x1000000000000000),
                    new System.Runtime.Diagnostics.EventDescriptor(4801, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Start, 0x9fb, 0x1000000000001000),
                    new System.Runtime.Diagnostics.EventDescriptor(4802, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Start, 0x9fb, 0x1000000000001000)};
            ushort[] e2eEvents = new ushort[] {
                    4800,
                    4802};
            FxTrace.UpdateEventDefinitions(descriptors, e2eEvents);
            eventDescriptors = descriptors;
        }
        
        /// <summary>
        /// Ensures that the event descriptors array is initialized
        /// </summary>
        static void EnsureEventDescriptors()
        {
            if (eventDescriptorsCreated)
            {
                return;
            }
            System.Threading.Monitor.Enter(syncLock);
            try
            {
                if (eventDescriptorsCreated)
                {
                    return;
                }
                CreateEventDescriptors();
                eventDescriptorsCreated = true;
            }
            finally
            {
                System.Threading.Monitor.Exit(syncLock);
            }
        }
        
        /// <summary>
        /// Check if ETW tracing is enabled for the particular event
        /// </summary>
        /// <param name="eventIndex">The index of the event descriptor</param>
        static bool IsEtwEventEnabled(int eventIndex)
        {
            if (FxTrace.Trace.IsEtwProviderEnabled)
            {
                EnsureEventDescriptors();
                return FxTrace.IsEventEnabled(eventIndex);
            }
            return false;
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        /// <param name="eventParam3">A parameter of the ETW event</param>>
        /// <param name="eventParam4">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1, long eventParam2, string eventParam3, string eventParam4)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2, eventParam3, eventParam4);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1);
        }
        
        /// <summary>
        /// write a trace source into the diagnostic trace
        /// </summary>
        /// <param name="eventIndex">The index of the event descriptor</param>
        /// <param name="description">The description to write</param>
        /// <param name="payload">The trace payload</param>
        // Critical = Calls SecurityCritical method EtwDiagnosticTrace.WriteTraceSource
        // Safe = We only allow setting of provider id from SecurityCritical code
        [System.Security.SecuritySafeCriticalAttribute()]
        static void WriteTraceSource(int eventIndex, string description, TracePayload payload)
        {
            EnsureEventDescriptors();
            FxTrace.Trace.WriteTraceSource(ref eventDescriptors[eventIndex], description, payload);
        }
    }
}

