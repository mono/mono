//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace System.ServiceModel.Activation
{
    using System.Runtime;
    using System.Runtime.Diagnostics;
    using System.Security;
    
    
    internal partial class TD
    {
        
        static System.Resources.ResourceManager resourceManager;
        
        static System.Globalization.CultureInfo resourceCulture;
        
        [System.Security.SecurityCriticalAttribute()]
        static System.Runtime.Diagnostics.EventDescriptor[] eventDescriptors;
        
        static object syncLock = new object();
        
        // Double-checked locking pattern requires volatile for read/write synchronization
        static volatile bool eventDescriptorsCreated;
        
        private TD()
        {
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification="This is an auto-generated code, some ETW/TraceSource mixed code would use it.")]
        static System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if (object.ReferenceEquals(resourceManager, null))
                {
                    resourceManager = new System.Resources.ResourceManager("System.ServiceModel.Activation.TD", typeof(TD).Assembly);
                }
                return resourceManager;
            }
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification="This template is shared across all assemblies, some of which use this accessor.")]
        internal static System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=501, Level=informational, Channel=Debug
        /// </summary>
        internal static bool CompilationStartIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(0));
        }
        
        /// <summary>
        /// Gets trace definition like: Begin compilation
        /// Event description ID=501, Level=informational, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void CompilationStart(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(0))
            {
                TD.WriteEtwEvent(0, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=502, Level=informational, Channel=Debug
        /// </summary>
        internal static bool CompilationStopIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(1));
        }
        
        /// <summary>
        /// Gets trace definition like: End compilation
        /// Event description ID=502, Level=informational, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void CompilationStop(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(1))
            {
                TD.WriteEtwEvent(1, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=503, Level=informational, Channel=Debug
        /// </summary>
        internal static bool ServiceHostFactoryCreationStartIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(2));
        }
        
        /// <summary>
        /// Gets trace definition like: ServiceHostFactory begin creation
        /// Event description ID=503, Level=informational, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void ServiceHostFactoryCreationStart(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(2))
            {
                TD.WriteEtwEvent(2, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=504, Level=informational, Channel=Debug
        /// </summary>
        internal static bool ServiceHostFactoryCreationStopIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(3));
        }
        
        /// <summary>
        /// Gets trace definition like: ServiceHostFactory end creation
        /// Event description ID=504, Level=informational, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void ServiceHostFactoryCreationStop(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(3))
            {
                TD.WriteEtwEvent(3, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=505, Level=informational, Channel=Debug
        /// </summary>
        internal static bool CreateServiceHostStartIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(4));
        }
        
        /// <summary>
        /// Gets trace definition like: Begin CreateServiceHost
        /// Event description ID=505, Level=informational, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void CreateServiceHostStart(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(4))
            {
                TD.WriteEtwEvent(4, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=506, Level=informational, Channel=Debug
        /// </summary>
        internal static bool CreateServiceHostStopIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(5));
        }
        
        /// <summary>
        /// Gets trace definition like: End CreateServiceHost
        /// Event description ID=506, Level=informational, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void CreateServiceHostStop(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(5))
            {
                TD.WriteEtwEvent(5, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=507, Level=informational, Channel=Debug
        /// </summary>
        internal static bool HostedTransportConfigurationManagerConfigInitStartIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(6));
        }
        
        /// <summary>
        /// Gets trace definition like: HostedTransportConfigurationManager begin configuration initialization
        /// Event description ID=507, Level=informational, Channel=Debug
        /// </summary>
        internal static void HostedTransportConfigurationManagerConfigInitStart()
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(6))
            {
                TD.WriteEtwEvent(6, null, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=508, Level=informational, Channel=Debug
        /// </summary>
        internal static bool HostedTransportConfigurationManagerConfigInitStopIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(7));
        }
        
        /// <summary>
        /// Gets trace definition like: HostedTransportConfigurationManager end configuration initialization
        /// Event description ID=508, Level=informational, Channel=Debug
        /// </summary>
        internal static void HostedTransportConfigurationManagerConfigInitStop()
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(7))
            {
                TD.WriteEtwEvent(7, null, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=513, Level=informational, Channel=Debug
        /// </summary>
        internal static bool WebHostRequestStartIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(8));
        }
        
        /// <summary>
        /// Gets trace definition like: Received request with virtual path '{1}' from the AppDomain '{0}'.
        /// Event description ID=513, Level=informational, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="AppDomainFriendlyName">Parameter 0 for event: Received request with virtual path '{1}' from the AppDomain '{0}'.</param>
        /// <param name="VirtualPath">Parameter 1 for event: Received request with virtual path '{1}' from the AppDomain '{0}'.</param>
        /// <param name="relatedActivityId">The related event activity Id</param>
        internal static void WebHostRequestStart(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string AppDomainFriendlyName, string VirtualPath, System.Guid relatedActivityId)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(8))
            {
                TD.WriteEtwTransferEvent(8, eventTraceActivity, relatedActivityId, AppDomainFriendlyName, VirtualPath, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=514, Level=informational, Channel=Debug
        /// </summary>
        internal static bool WebHostRequestStopIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(9));
        }
        
        /// <summary>
        /// Gets trace definition like: WebHostRequest stop.
        /// Event description ID=514, Level=informational, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void WebHostRequestStop(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(9))
            {
                TD.WriteEtwEvent(9, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=603, Level=verbose, Channel=Debug
        /// </summary>
        internal static bool AspNetRoutingServiceIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose 
                        && (FxTrace.ShouldTraceVerboseToTraceSource || TD.IsEtwEventEnabled(10)));
        }
        
        /// <summary>
        /// Gets trace definition like: Incoming request matches a WCF Service defined in Asp.Net route with address {0}.  
        /// Event description ID=603, Level=verbose, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="IncomingAddress">Parameter 0 for event: Incoming request matches a WCF Service defined in Asp.Net route with address {0}.  </param>
        internal static void AspNetRoutingService(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string IncomingAddress)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(10))
            {
                TD.WriteEtwEvent(10, eventTraceActivity, IncomingAddress, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceVerboseToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("AspNetRoutingService", Culture), IncomingAddress);
                TD.WriteTraceSource(10, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=604, Level=verbose, Channel=Debug
        /// </summary>
        internal static bool AspNetRouteIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose 
                        && (FxTrace.ShouldTraceVerboseToTraceSource || TD.IsEtwEventEnabled(11)));
        }
        
        /// <summary>
        /// Gets trace definition like: A new Asp.Net route '{0}' with serviceType '{1}' and serviceHostFactoryType '{2}' is added.
        /// Event description ID=604, Level=verbose, Channel=Debug
        /// </summary>
        /// <param name="AspNetRoutePrefix">Parameter 0 for event: A new Asp.Net route '{0}' with serviceType '{1}' and serviceHostFactoryType '{2}' is added.</param>
        /// <param name="ServiceType">Parameter 1 for event: A new Asp.Net route '{0}' with serviceType '{1}' and serviceHostFactoryType '{2}' is added.</param>
        /// <param name="ServiceHostFactoryType">Parameter 2 for event: A new Asp.Net route '{0}' with serviceType '{1}' and serviceHostFactoryType '{2}' is added.</param>
        internal static void AspNetRoute(string AspNetRoutePrefix, string ServiceType, string ServiceHostFactoryType)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(11))
            {
                TD.WriteEtwEvent(11, null, AspNetRoutePrefix, ServiceType, ServiceHostFactoryType, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceVerboseToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("AspNetRoute", Culture), AspNetRoutePrefix, ServiceType, ServiceHostFactoryType);
                TD.WriteTraceSource(11, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=213, Level=LogAlways, Channel=Analytic
        /// </summary>
        internal static bool ServiceHostStartedIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(12));
        }
        
        /// <summary>
        /// Gets trace definition like: ServiceHost started: '{0}'.
        /// Event description ID=213, Level=LogAlways, Channel=Analytic
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="ServiceTypeName">Parameter 0 for event: ServiceHost started: '{0}'.</param>
        /// <param name="reference">Reference (e.g. service reference) to be added to trace</param>
        internal static void ServiceHostStarted(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string ServiceTypeName, string reference)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(12))
            {
                TD.WriteEtwEvent(12, eventTraceActivity, ServiceTypeName, reference, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=226, Level=LogAlways, Channel=Analytic
        /// </summary>
        internal static bool IdleServicesClosedIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(13));
        }
        
        /// <summary>
        /// Gets trace definition like: {0} idle services out of total {1} activated services closed.
        /// Event description ID=226, Level=LogAlways, Channel=Analytic
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="ClosedCount">Parameter 0 for event: {0} idle services out of total {1} activated services closed.</param>
        /// <param name="TotalCount">Parameter 1 for event: {0} idle services out of total {1} activated services closed.</param>
        internal static void IdleServicesClosed(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, int ClosedCount, int TotalCount)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(13))
            {
                TD.WriteEtwEvent(13, eventTraceActivity, ClosedCount, TotalCount, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=601, Level=verbose, Channel=Debug
        /// </summary>
        internal static bool CBAEntryReadIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose 
                        && (FxTrace.ShouldTraceVerboseToTraceSource || TD.IsEtwEventEnabled(14)));
        }
        
        /// <summary>
        /// Gets trace definition like: Processed ServiceActivation Element Relative Address:'{0}', Normalized Relative Address '{1}' .
        /// Event description ID=601, Level=verbose, Channel=Debug
        /// </summary>
        /// <param name="RelativeAddress">Parameter 0 for event: Processed ServiceActivation Element Relative Address:'{0}', Normalized Relative Address '{1}' .</param>
        /// <param name="NormalizedAddress">Parameter 1 for event: Processed ServiceActivation Element Relative Address:'{0}', Normalized Relative Address '{1}' .</param>
        internal static void CBAEntryRead(string RelativeAddress, string NormalizedAddress)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(14))
            {
                TD.WriteEtwEvent(14, null, RelativeAddress, NormalizedAddress, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceVerboseToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("CBAEntryRead", Culture), RelativeAddress, NormalizedAddress);
                TD.WriteTraceSource(14, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=602, Level=verbose, Channel=Debug
        /// </summary>
        internal static bool CBAMatchFoundIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose 
                        && (FxTrace.ShouldTraceVerboseToTraceSource || TD.IsEtwEventEnabled(15)));
        }
        
        /// <summary>
        /// Gets trace definition like: Incoming request matches a ServiceActivation element with address '{0}'. 
        /// Event description ID=602, Level=verbose, Channel=Debug
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        /// <param name="IncomingAddress">Parameter 0 for event: Incoming request matches a ServiceActivation element with address '{0}'. </param>
        internal static void CBAMatchFound(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity, string IncomingAddress)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(15))
            {
                TD.WriteEtwEvent(15, eventTraceActivity, IncomingAddress, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceVerboseToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("CBAMatchFound", Culture), IncomingAddress);
                TD.WriteTraceSource(15, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3553, Level=informational, Channel=Debug
        /// </summary>
        internal static bool XamlServicesLoadStartIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(16));
        }
        
        /// <summary>
        /// Gets trace definition like: XamlServicesLoad start
        /// Event description ID=3553, Level=informational, Channel=Debug
        /// </summary>
        internal static void XamlServicesLoadStart()
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(16))
            {
                TD.WriteEtwEvent(16, null, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3554, Level=informational, Channel=Debug
        /// </summary>
        internal static bool XamlServicesLoadStopIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(17));
        }
        
        /// <summary>
        /// Gets trace definition like: XamlServicesLoad Stop
        /// Event description ID=3554, Level=informational, Channel=Debug
        /// </summary>
        internal static void XamlServicesLoadStop()
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(17))
            {
                TD.WriteEtwEvent(17, null, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=605, Level=verbose, Channel=debug
        /// </summary>
        internal static bool IncrementBusyCountIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose 
                        && (FxTrace.ShouldTraceVerboseToTraceSource || TD.IsEtwEventEnabled(18)));
        }
        
        /// <summary>
        /// Gets trace definition like: IncrementBusyCount called. Source : {0}
        /// Event description ID=605, Level=verbose, Channel=debug
        /// </summary>
        /// <param name="Data">Parameter 0 for event: IncrementBusyCount called. Source : {0}</param>
        internal static void IncrementBusyCount(string Data)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(18))
            {
                TD.WriteEtwEvent(18, null, Data, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceVerboseToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("IncrementBusyCount", Culture), Data);
                TD.WriteTraceSource(18, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=606, Level=verbose, Channel=debug
        /// </summary>
        internal static bool DecrementBusyCountIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose 
                        && (FxTrace.ShouldTraceVerboseToTraceSource || TD.IsEtwEventEnabled(19)));
        }
        
        /// <summary>
        /// Gets trace definition like: DecrementBusyCount called. Source : {0}
        /// Event description ID=606, Level=verbose, Channel=debug
        /// </summary>
        /// <param name="Data">Parameter 0 for event: DecrementBusyCount called. Source : {0}</param>
        internal static void DecrementBusyCount(string Data)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(19))
            {
                TD.WriteEtwEvent(19, null, Data, payload.AppDomainFriendlyName);
            }
            if (FxTrace.ShouldTraceVerboseToTraceSource)
            {
                string description = string.Format(Culture, ResourceManager.GetString("DecrementBusyCount", Culture), Data);
                TD.WriteTraceSource(19, description, payload);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3558, Level=informational, Channel=analytic
        /// </summary>
        internal static bool ServiceActivationStartIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(20));
        }
        
        /// <summary>
        /// Gets trace definition like: Service activation start
        /// Event description ID=3558, Level=informational, Channel=analytic
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void ServiceActivationStart(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(20))
            {
                TD.WriteEtwEvent(20, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3559, Level=informational, Channel=analytic
        /// </summary>
        internal static bool ServiceActivationStopIsEnabled()
        {
            return (FxTrace.ShouldTraceInformation && TD.IsEtwEventEnabled(21));
        }
        
        /// <summary>
        /// Gets trace definition like: Service activation Stop
        /// Event description ID=3559, Level=informational, Channel=analytic
        /// </summary>
        /// <param name="eventTraceActivity">The event trace activity</param>
        internal static void ServiceActivationStop(System.Runtime.Diagnostics.EventTraceActivity eventTraceActivity)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(21))
            {
                TD.WriteEtwEvent(21, eventTraceActivity, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3560, Level=verbose, Channel=analytic
        /// </summary>
        internal static bool ServiceActivationAvailableMemoryIsEnabled()
        {
            return (FxTrace.ShouldTraceVerbose && TD.IsEtwEventEnabled(22));
        }
        
        /// <summary>
        /// Gets trace definition like: Available memory (bytes): {0}
        /// Event description ID=3560, Level=verbose, Channel=analytic
        /// </summary>
        /// <param name="availableMemoryBytes">Parameter 0 for event: Available memory (bytes): {0}</param>
        internal static void ServiceActivationAvailableMemory(ulong availableMemoryBytes)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, null);
            if (TD.IsEtwEventEnabled(22))
            {
                TD.WriteEtwEvent(22, null, availableMemoryBytes, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Check if trace definition is enabled
        /// Event description ID=3561, Level=error, Channel=Operational
        /// </summary>
        internal static bool ServiceActivationExceptionIsEnabled()
        {
            return (FxTrace.ShouldTraceError && TD.IsEtwEventEnabled(23));
        }
        
        /// <summary>
        /// Gets trace definition like: The service could not be activated. Exception details: {0}
        /// Event description ID=3561, Level=error, Channel=Operational
        /// </summary>
        /// <param name="param0">Parameter 0 for event: The service could not be activated. Exception details: {0}</param>
        /// <param name="exception">Exception associated with the event</param>
        internal static void ServiceActivationException(string param0, System.Exception exception)
        {
            TracePayload payload = FxTrace.Trace.GetSerializedPayload(null, null, exception);
            if (TD.IsEtwEventEnabled(23))
            {
                TD.WriteEtwEvent(23, null, param0, payload.SerializedException, payload.AppDomainFriendlyName);
            }
        }
        
        /// <summary>
        /// Creates the event descriptors array
        /// </summary>
        // Critical = Sets the SecurityCritical member eventDescriptors
        // Safe = We control what the event descriptors contain
        [System.Security.SecuritySafeCriticalAttribute()]
        static void CreateEventDescriptors()
        {
            System.Runtime.Diagnostics.EventDescriptor[] descriptors = new System.Runtime.Diagnostics.EventDescriptor[] {
                    new System.Runtime.Diagnostics.EventDescriptor(501, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Start, 0xa13, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(502, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Stop, 0xa13, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(503, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Start, 0xa15, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(504, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Stop, 0xa15, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(505, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Start, 0xa14, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(506, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Stop, 0xa14, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(507, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Start, 0x9f2, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(508, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Stop, 0x9f2, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(513, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Start, 0xa2c, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(514, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Stop, 0xa2c, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(603, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Info, 0x0, 0x1000000000008000),
                    new System.Runtime.Diagnostics.EventDescriptor(604, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Info, 0x0, 0x1000000000008000),
                    new System.Runtime.Diagnostics.EventDescriptor(213, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.LogAlways, (byte)TraceEventOpcode.Start, 0xa12, 0x20000000000E0001),
                    new System.Runtime.Diagnostics.EventDescriptor(226, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.LogAlways, (byte)TraceEventOpcode.Info, 0xa19, 0x2000000000040080),
                    new System.Runtime.Diagnostics.EventDescriptor(601, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Info, 0x0, 0x1000000000000000),
                    new System.Runtime.Diagnostics.EventDescriptor(602, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Info, 0x0, 0x1000000000000000),
                    new System.Runtime.Diagnostics.EventDescriptor(3553, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Start, 0xa32, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(3554, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Stop, 0xa32, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(605, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Info, 0xa2c, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(606, 0, (byte)TraceChannel.Debug, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Stop, 0xa2c, 0x1000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(3558, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Start, 0xa0f, 0x2000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(3559, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Informational, (byte)TraceEventOpcode.Stop, 0xa0f, 0x2000000000000080),
                    new System.Runtime.Diagnostics.EventDescriptor(3560, 0, (byte)TraceChannel.Analytic, (byte)TraceEventLevel.Verbose, (byte)TraceEventOpcode.Info, 0xa00, 0x2000000000400000),
                    new System.Runtime.Diagnostics.EventDescriptor(3561, 0, (byte)TraceChannel.Operational, (byte)TraceEventLevel.Error, (byte)TraceEventOpcode.Info, 0x0, 0x4000000000000080)};
            // The hashcodes calculated from PTCop for TD.CreateEventDescriptors are unstable when just declaring
            // a local field of ushort[] if the array is non-empty and contains more than 2 entries, because
            // the c#-compiler is using some private types for optimization. The type name follows the following pattern:
            // <PrivateImplementationDetails>{6BAE93FD-290B-4DE0-BCEE-366B30800FDF} (where the GUID is changing with every build)
            // To scope the change to unblock PTCop as much as possible we wrap the list of End2EndEvents in a List<ushort>
            System.Collections.Generic.List<ushort> e2eEvents = new System.Collections.Generic.List<ushort>(14);
            e2eEvents.Add(213);
            e2eEvents.Add(226);
            e2eEvents.Add(501);
            e2eEvents.Add(502);
            e2eEvents.Add(503);
            e2eEvents.Add(504);
            e2eEvents.Add(505);
            e2eEvents.Add(506);
            e2eEvents.Add(513);
            e2eEvents.Add(514);
            e2eEvents.Add(602);
            e2eEvents.Add(603);
            e2eEvents.Add(3558);
            e2eEvents.Add(3559);
            FxTrace.UpdateEventDefinitions(descriptors, e2eEvents.ToArray());
            eventDescriptors = descriptors;
        }
        
        /// <summary>
        /// Ensures that the event descriptors array is initialized
        /// </summary>
        static void EnsureEventDescriptors()
        {
            if (eventDescriptorsCreated)
            {
                return;
            }
            System.Threading.Monitor.Enter(syncLock);
            try
            {
                if (eventDescriptorsCreated)
                {
                    return;
                }
                CreateEventDescriptors();
                eventDescriptorsCreated = true;
            }
            finally
            {
                System.Threading.Monitor.Exit(syncLock);
            }
        }
        
        /// <summary>
        /// Check if ETW tracing is enabled for the particular event
        /// </summary>
        /// <param name="eventIndex">The index of the event descriptor</param>
        static bool IsEtwEventEnabled(int eventIndex)
        {
            if (FxTrace.Trace.IsEtwProviderEnabled)
            {
                EnsureEventDescriptors();
                return FxTrace.IsEventEnabled(eventIndex);
            }
            return false;
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1, string eventParam2)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        /// <param name="eventParam3">A parameter of the ETW event</param>>
        /// <param name="eventParam4">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1, string eventParam2, string eventParam3, string eventParam4)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2, eventParam3, eventParam4);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        /// <param name="eventParam3">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, string eventParam1, string eventParam2, string eventParam3)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2, eventParam3);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        /// <param name="eventParam3">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, int eventParam1, int eventParam2, string eventParam3)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2, eventParam3);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, ulong eventParam1, string eventParam2)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2);
        }
        
        /// <summary>
        /// Writes ETW trace event
        ///</summary>
        /// <param name="eventIndex">The index of the event descriptor</param>>
        /// <param name="eventParam0">A parameter of the ETW event</param>>
        /// <param name="eventParam1">A parameter of the ETW event</param>>
        /// <param name="eventParam2">A parameter of the ETW event</param>>
        /// <param name="eventParam3">A parameter of the ETW event</param>>
        /// <param name="eventParam4">A parameter of the ETW event</param>>
        // Critical = Calls SecurityCritical method EtwProvider.WriteEvent
        // Safe = We only allow setting of provider id from SecurityCritical code, access to EventDescriptors is SecurityCritical, and ETW limits buffer sizes.
        [System.Security.SecuritySafeCriticalAttribute()]
        static bool WriteEtwTransferEvent(int eventIndex, System.Runtime.Diagnostics.EventTraceActivity eventParam0, System.Guid eventParam1, string eventParam2, string eventParam3, string eventParam4)
        {
            EnsureEventDescriptors();
            return FxTrace.Trace.EtwProvider.WriteTransferEvent(ref eventDescriptors[eventIndex], eventParam0, eventParam1, eventParam2, eventParam3, eventParam4);
        }
        
        /// <summary>
        /// write a trace source into the diagnostic trace
        /// </summary>
        /// <param name="eventIndex">The index of the event descriptor</param>
        /// <param name="description">The description to write</param>
        /// <param name="payload">The trace payload</param>
        // Critical = Calls SecurityCritical method EtwDiagnosticTrace.WriteTraceSource
        // Safe = We only allow setting of provider id from SecurityCritical code
        [System.Security.SecuritySafeCriticalAttribute()]
        static void WriteTraceSource(int eventIndex, string description, TracePayload payload)
        {
            EnsureEventDescriptors();
            FxTrace.Trace.WriteTraceSource(ref eventDescriptors[eventIndex], description, payload);
        }
    }
}

