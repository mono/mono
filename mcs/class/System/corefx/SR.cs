//
// This file was generated by resx2sr tool
//

partial class SR
{
	public const string BlockingCollection_Add_ConcurrentCompleteAdd = "CompleteAdding may not be used concurrently with additions to the collection.";
	public const string BlockingCollection_Add_Failed = "The underlying collection didn't accept the item.";
	public const string BlockingCollection_CantAddAnyWhenCompleted = "At least one of the specified collections is marked as complete with regards to additions.";
	public const string BlockingCollection_CantTakeAnyWhenAllDone = "All collections are marked as complete with regards to additions.";
	public const string BlockingCollection_CantTakeWhenDone = "The collection argument is empty and has been marked as complete with regards to additions.";
	public const string BlockingCollection_Completed = "The collection has been marked as complete with regards to additions.";
	public const string BlockingCollection_CopyTo_IncorrectType = "The array argument is of the incorrect type.";
	public const string BlockingCollection_CopyTo_MultiDim = "The array argument is multidimensional.";
	public const string BlockingCollection_CopyTo_NonNegative = "The index argument must be greater than or equal zero.";
	public const string Collection_CopyTo_TooManyElems = "The number of elements in the collection is greater than the available space from index to the end of the destination array.";
	public const string BlockingCollection_ctor_BoundedCapacityRange = "The boundedCapacity argument must be positive.";
	public const string BlockingCollection_ctor_CountMoreThanCapacity = "The collection argument contains more items than are allowed by the boundedCapacity.";
	public const string BlockingCollection_Disposed = "The collection has been disposed.";
	public const string BlockingCollection_Take_CollectionModified = "The underlying collection was modified from outside of the BlockingCollection<T>.";
	public const string BlockingCollection_TimeoutInvalid = "The specified timeout must represent a value between -1 and {0}, inclusive.";
	public const string BlockingCollection_ValidateCollectionsArray_DispElems = "The collections argument contains at least one disposed element.";
	public const string BlockingCollection_ValidateCollectionsArray_LargeSize = "The collections length is greater than the supported range for 32 bit machine.";
	public const string BlockingCollection_ValidateCollectionsArray_NullElems = "The collections argument contains at least one null element.";
	public const string BlockingCollection_ValidateCollectionsArray_ZeroSize = "The collections argument is a zero-length array.";
	public const string Common_OperationCanceled = "The operation was canceled.";
	public const string ConcurrentBag_Ctor_ArgumentNullException = "The collection argument is null.";
	public const string ConcurrentBag_CopyTo_ArgumentNullException = "The array argument is null.";
	public const string Collection_CopyTo_ArgumentOutOfRangeException = "The index argument must be greater than or equal zero.";
	public const string ConcurrentCollection_SyncRoot_NotSupported = "The SyncRoot property may not be used for the synchronization of concurrent collections.";
	public const string ConcurrentDictionary_ArrayIncorrectType = "The array is multidimensional, or the type parameter for the set cannot be cast automatically to the type of the destination array.";
	public const string ConcurrentDictionary_SourceContainsDuplicateKeys = "The source argument contains duplicate keys.";
	public const string ConcurrentDictionary_ConcurrencyLevelMustBePositive = "The concurrencyLevel argument must be positive.";
	public const string ConcurrentDictionary_CapacityMustNotBeNegative = "The capacity argument must be greater than or equal to zero.";
	public const string ConcurrentDictionary_IndexIsNegative = "The index argument is less than zero.";
	public const string ConcurrentDictionary_ArrayNotLargeEnough = "The index is equal to or greater than the length of the array, or the number of elements in the dictionary is greater than the available space from index to the end of the destination array.";
	public const string ConcurrentDictionary_KeyAlreadyExisted = "The key already existed in the dictionary.";
	public const string ConcurrentDictionary_ItemKeyIsNull = "TKey is a reference type and item.Key is null.";
	public const string ConcurrentDictionary_TypeOfKeyIncorrect = "The key was of an incorrect type for this dictionary.";
	public const string ConcurrentDictionary_TypeOfValueIncorrect = "The value was of an incorrect type for this dictionary.";
	public const string ConcurrentStack_PushPopRange_CountOutOfRange = "The count argument must be greater than or equal to zero.";
	public const string ConcurrentStack_PushPopRange_InvalidCount = "The sum of the startIndex and count arguments must be less than or equal to the collection's Count.";
	public const string ConcurrentStack_PushPopRange_StartOutOfRange = "The startIndex argument must be greater than or equal to zero.";
	public const string Partitioner_DynamicPartitionsNotSupported = "Dynamic partitions are not supported by this partitioner.";
	public const string PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed = "Can not call GetEnumerator on partitions after the source enumerable is disposed";
	public const string PartitionerStatic_CurrentCalledBeforeMoveNext = "MoveNext must be called at least once before calling Current.";
	public const string ConcurrentBag_Enumerator_EnumerationNotStartedOrAlreadyFinished = "Enumeration has either not started or has already finished.";
	public const string IO_FileExists_Name = "The file '{0}' already exists.";
	public const string IO_FileName_Name = "File name: '{0}'";
	public const string IO_FileNotFound = "Unable to find the specified file.";
	public const string IO_FileNotFound_FileName = "Could not load file or assembly '{0}'. The system cannot find the file specified.";
	public const string IO_FileLoad = "Could not load the specified file.";
	public const string IO_NoPermissionToDirectoryName = "<Path discovery permission to the specified directory was denied.%gt;";
	public const string IO_PathNotFound_NoPathName = "Could not find a part of the path.";
	public const string IO_PathNotFound_Path = "Could not find a part of the path '{0}'.";
	public const string IO_AlreadyExists_Name = "Cannot create '{0}' because a file or directory with the same name already exists.";
	public const string Lazy_CreateValue_NoParameterlessCtorForT = "The lazily-initialized type does not have a public, parameterless constructor.";
	public const string Lazy_ctor_ModeInvalid = "The mode argument specifies an invalid value.";
	public const string Lazy_StaticInit_InvalidOperation = "ValueFactory returned null.";
	public const string Lazy_ToString_ValueNotCreated = "Value is not created.";
	public const string Lazy_Value_RecursiveCallsToValue = "ValueFactory attempted to access the Value property of this instance.";
	public const string MissingConstructor_Name = "Constructor on type '{0}' not found.";
	public const string MustUseCCRewrite = "An assembly (probably '{1}') must be rewritten using the code contracts binary rewriter (CCRewrite) because it is calling Contract.{0} and the CONTRACTS_FULL symbol is defined.  Remove any explicit definitions of the CONTRACTS_FULL symbol from your project and rebuild.  CCRewrite can be downloaded from http://go.microsoft.com/fwlink/?LinkID=169180. \\r\\nAfter the rewriter is installed, it can be enabled in Visual Studio from the project's Properties page on the Code Contracts pane.  Ensure that 'Perform Runtime Contract Checking' is enabled, which will define CONTRACTS_FULL.";
	public const string ObjectDisposed_Generic = "Cannot access a disposed object.";
	public const string ObjectDisposed_ObjectName_Name = "Object name: '{0}'.";

	public const string PlatformNotSupported_MakePointerType = "MakePointerType() is not supported on this platform.";
	public const string Rank_MultiDimNotSupported = "Only single dimension arrays are supported here.";
	public const string RuntimeWrappedException = "An object that does not derive from System.Exception has been wrapped in a RuntimeWrappedException.";
	public const string SpinWait_SpinUntil_ArgumentNull = "The condition argument is null.";
	public const string Serialization_CorruptField = "The value of the field '{0}' is invalid.  The serialized data is corrupt.";
	public const string Serialization_InvalidData = "An error occurred while deserializing the object.  The serialized data is corrupt.";
	public const string Serialization_InvalidEscapeSequence = "The serialized data contained an invalid escape sequence '\\\\{0}'.";
	public const string SpinWait_SpinUntil_TimeoutWrong = "The timeout must represent a value between -1 and Int32.MaxValue, inclusive.";
	public const string Threading_AbandonedMutexException = "The wait completed due to an abandoned mutex.";
	public const string Threading_SemaphoreFullException = "Adding the specified count to the semaphore would cause it to exceed its maximum count.";
	public const string Threading_WaitHandleCannotBeOpenedException = "No handle of the given name exists.";
	public const string Threading_WaitHandleCannotBeOpenedException_InvalidHandle = "A WaitHandle with system-wide name '{0}' cannot be created. A WaitHandle of a different type might have the same name.";
	public const string TimeZoneNotFound_MissingRegistryData = "The time zone ID '{0}' was not found on the local computer.";
	public const string TypeInitialization_Default = "Type constructor threw an exception.";
	public const string TypeInitialization_Type = "The type initializer for '{0}' threw an exception.";
	public const string TypeInitialization_Type_NoTypeAvailable = "A type initializer threw an exception. To determine which type, inspect the InnerException's StackTrace property.";
	public const string Verification_Exception = "Operation could destabilize the runtime.";
	public const string Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType = "Enum underlying type and the object must be same type or object. Type passed in was '{0}'; the enum underlying type was '{1}'.";
	public const string Format_InvalidEnumFormatSpecification = "Format String can be only 'G', 'g', 'X', 'x', 'F', 'f', 'D' or 'd'.";
	public const string Arg_MustBeEnumBaseTypeOrEnum = "The value passed in must be an enum base or an underlying type for an enum, such as an Int32.";
	public const string Arg_EnumUnderlyingTypeAndObjectMustBeSameType = "Enum underlying type and the object must be same type or object must be a String. Type passed in was '{0}'; the enum underlying type was '{1}'.";
	public const string Arg_MustBeType = "Type must be a type provided by the runtime.";
	public const string Arg_MustContainEnumInfo = "Must specify valid information for parsing in the string.";
	public const string Arg_EnumValueNotFound = "Requested value '{0}' was not found.";
	public const string Argument_StringZeroLength = "String cannot be of zero length.";
	public const string Argument_StringFirstCharIsZero = "The first char in the string is the null character.";
	public const string Argument_LongEnvVarValue = "Environment variable name or value is too long.";
	public const string Argument_IllegalEnvVarName = "Environment variable name cannot contain equal character.";
	public const string AssumptionFailed = "Assumption failed.";
	public const string AssumptionFailed_Cnd = "Assumption failed: {0}";
	public const string AssertionFailed = "Assertion failed.";
	public const string AssertionFailed_Cnd = "Assertion failed: {0}";
	public const string Debug_Fail = "Fail: {0}";
	public const string PreconditionFailed = "Precondition failed.";
	public const string PreconditionFailed_Cnd = "Precondition failed: {0}";
	public const string PostconditionFailed = "Postcondition failed.";
	public const string PostconditionFailed_Cnd = "Postcondition failed: {0}";
	public const string PostconditionOnExceptionFailed = "Postcondition failed after throwing an exception.";
	public const string PostconditionOnExceptionFailed_Cnd = "Postcondition failed after throwing an exception: {0}";
	public const string InvariantFailed = "Invariant failed.";
	public const string InvariantFailed_Cnd = "Invariant failed: {0}";
	public const string MissingEncodingNameResource = "Could not find a resource entry for the encoding codepage '{0} - {1}'";
	public const string Globalization_cp_1200 = "Unicode";
	public const string Globalization_cp_1201 = "Unicode (Big-Endian)";
	public const string Globalization_cp_12000 = "Unicode (UTF-32)";
	public const string Globalization_cp_12001 = "Unicode (UTF-32 Big-Endian)";
	public const string Globalization_cp_20127 = "US-ASCII";
	public const string Globalization_cp_28591 = "Western European (ISO)";
	public const string Globalization_cp_65000 = "Unicode (UTF-7)";
	public const string Globalization_cp_65001 = "Unicode (UTF-8)";
	public const string InvalidCast_Empty = "Object cannot be cast to Empty.";
	public const string Arg_UnknownTypeCode = "Unknown TypeCode value.";
	public const string Format_BadDatePattern = "Could not determine the order of year, month, and date from '{0}'.";
	public const string Format_BadDateTime = "String was not recognized as a valid DateTime.";
	public const string Format_BadDateTimeCalendar = "The DateTime represented by the string is not supported in calendar {0}.";
	public const string Format_BadDayOfWeek = "String was not recognized as a valid DateTime because the day of week was incorrect.";
	public const string Format_DateOutOfRange = "The DateTime represented by the string is out of range.";
	public const string Format_MissingIncompleteDate = "There must be at least a partial date with a year present in the input.";
	public const string Format_OffsetOutOfRange = "The time zone offset must be within plus or minus 14 hours.";
	public const string Format_RepeatDateTimePattern = "DateTime pattern '{0}' appears more than once with different values.";
	public const string Format_UnknowDateTimeWord = "The string was not recognized as a valid DateTime. There is an unknown word starting at index {0}.";
	public const string Format_UTCOutOfRange = "The UTC representation of the date falls outside the year range 1-9999.";
	public const string InvalidOperation_ComputerName = "Computer name could not be obtained.";
	public const string RFLCT_Ambiguous = "Ambiguous match found.";
	public const string AggregateException_ctor_DefaultMessage = "One or more errors occurred.";
	public const string AggregateException_ctor_InnerExceptionNull = "An element of innerExceptions was null.";
	public const string AggregateException_DeserializationFailure = "The serialization stream contains no inner exceptions.";
	public const string AggregateException_InnerException = "(Inner Exception #{0}) "; // {entry.Item3}
	public const string ArgumentOutOfRange_TimeoutTooLarge = "Time-out interval must be less than 2^32-2.";
	public const string ArgumentOutOfRange_PeriodTooLarge = "Period must be less than 2^32-2.";
	public const string TaskScheduler_FromCurrentSynchronizationContext_NoCurrent = "The current SynchronizationContext may not be used as a TaskScheduler.";
	public const string TaskScheduler_ExecuteTask_WrongTaskScheduler = "ExecuteTask may not be called for a task which was previously queued to a different TaskScheduler.";
	public const string TaskScheduler_InconsistentStateAfterTryExecuteTaskInline = "The TryExecuteTaskInline call to the underlying scheduler succeeded, but the task body was not invoked.";
	public const string TaskSchedulerException_ctor_DefaultMessage = "An exception was thrown by a TaskScheduler.";
	public const string Task_MultiTaskContinuation_FireOptions = "It is invalid to exclude specific continuation kinds for continuations off of multiple tasks.";
	public const string Task_ContinueWith_ESandLR = "The specified TaskContinuationOptions combined LongRunning and ExecuteSynchronously.  Synchronous continuations should not be long running.";
	public const string Task_MultiTaskContinuation_EmptyTaskList = "The tasks argument contains no tasks.";
	public const string Task_MultiTaskContinuation_NullTask = "The tasks argument included a null value.";
	public const string Task_FromAsync_PreferFairness = "It is invalid to specify TaskCreationOptions.PreferFairness in calls to FromAsync.";
	public const string Task_FromAsync_LongRunning = "It is invalid to specify TaskCreationOptions.LongRunning in calls to FromAsync.";
	public const string AsyncMethodBuilder_InstanceNotInitialized = "The builder was not properly initialized.";
	public const string TaskT_TransitionToFinal_AlreadyCompleted = "An attempt was made to transition a task to a final state when it had already completed.";
	public const string TaskT_DebuggerNoResult = "{Not yet computed}";
	public const string OperationCanceled = "The operation was canceled.";
	public const string CancellationToken_CreateLinkedToken_TokensIsEmpty = "No tokens were supplied.";
	public const string CancellationTokenSource_Disposed = "The CancellationTokenSource has been disposed.";
	public const string CancellationToken_SourceDisposed = "The CancellationTokenSource associated with this CancellationToken has been disposed.";
	public const string TaskExceptionHolder_UnknownExceptionType = "(Internal)Expected an Exception or an IEnumerable<Exception>";
	public const string TaskExceptionHolder_UnhandledException = "A Task's exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result, the unobserved exception was rethrown by the finalizer thread.";
	public const string Task_Delay_InvalidMillisecondsDelay = "The value needs to be either -1 (signifying an infinite timeout), 0 or a positive integer.";
	public const string Task_Delay_InvalidDelay = "The value needs to translate in milliseconds to -1 (signifying an infinite timeout), 0 or a positive integer less than or equal to Int32.MaxValue.";
	public const string Task_WaitMulti_NullTask = "The tasks array included at least one null element.";
	public const string Task_ContinueWith_NotOnAnything = "The specified TaskContinuationOptions excluded all continuation kinds.";
	public const string Task_RunSynchronously_AlreadyStarted = "RunSynchronously may not be called on a task that was already started.";
	public const string Task_ThrowIfDisposed = "The task has been disposed.";
	public const string Task_RunSynchronously_TaskCompleted = "RunSynchronously may not be called on a task that has already completed.";
	public const string Task_RunSynchronously_Promise = "RunSynchronously may not be called on a task not bound to a delegate, such as the task returned from an asynchronous method.";
	public const string Task_RunSynchronously_Continuation = "RunSynchronously may not be called on a continuation task.";
	public const string Task_Start_AlreadyStarted = "Start may not be called on a task that was already started.";
	public const string Task_Start_ContinuationTask = "Start may not be called on a continuation task.";
	public const string Task_Start_Promise = "Start may not be called on a promise-style task.";
	public const string Task_Start_TaskCompleted = "Start may not be called on a task that has completed.";
	public const string TaskCanceledException_ctor_DefaultMessage = "A task was canceled.";
	public const string TaskCompletionSourceT_TrySetException_NoExceptions = "The exceptions collection was empty.";
	public const string TaskCompletionSourceT_TrySetException_NullException = "The exceptions collection included at least one null element.";
	public const string Argument_MinMaxValue = "'{0}' cannot be greater than {1}.";
	public const string InvalidOperation_NullContext = "Cannot call Set on a null context";
	public const string ExecutionContext_ExceptionInAsyncLocalNotification = "An exception was not handled in an AsyncLocal<T> notification callback.";
	public const string InvalidOperation_WrongAsyncResultOrEndCalledMultiple = "Either the IAsyncResult object did not come from the corresponding async method on this type, or the End method was called multiple times with the same IAsyncResult.";
	public const string SpinLock_IsHeldByCurrentThread = "Thread tracking is disabled.";
	public const string SpinLock_TryEnter_LockRecursionException = "The calling thread already holds the lock.";
	public const string SpinLock_Exit_SynchronizationLockException = "The calling thread does not hold the lock.";
	public const string SpinLock_TryReliableEnter_ArgumentException = "The tookLock argument must be set to false before calling this method.";
	public const string SpinLock_TryEnter_ArgumentOutOfRange = "The timeout must be a value between -1 and Int32.MaxValue, inclusive.";
	public const string ManualResetEventSlim_Disposed = "The event has been disposed.";
	public const string ManualResetEventSlim_ctor_SpinCountOutOfRange = "The spinCount argument must be in the range 0 to {0}, inclusive.";
	public const string ManualResetEventSlim_ctor_TooManyWaiters = "There are too many threads currently waiting on the event. A maximum of {0} waiting threads are supported.";
	public const string InvalidOperation_SendNotSupportedOnWindowsRTSynchronizationContext = "Send is not supported in the Windows Runtime SynchronizationContext";
	public const string SemaphoreSlim_Disposed = "The semaphore has been disposed.";
	public const string SemaphoreSlim_Release_CountWrong = "The releaseCount argument must be greater than zero.";
	public const string SemaphoreSlim_Wait_TimeoutWrong = "The timeout must represent a value between -1 and Int32.MaxValue, inclusive.";
	public const string SemaphoreSlim_ctor_MaxCountWrong = "The maximumCount argument must be a positive number. If a maximum is not required, use the constructor without a maxCount parameter.";
	public const string SemaphoreSlim_ctor_InitialCountWrong = "The initialCount argument must be non-negative and less than or equal to the maximumCount.";
	public const string ThreadLocal_ValuesNotAvailable = "The ThreadLocal object is not tracking values. To use the Values property, use a ThreadLocal constructor that accepts the trackAllValues parameter and set the parameter to true.";
	public const string ThreadLocal_Value_RecursiveCallsToValue = "ValueFactory attempted to access the Value property of this instance.";
	public const string ThreadLocal_Disposed = "The ThreadLocal object has been disposed.";
	public const string LockRecursionException_WriteAfterReadNotAllowed = "Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock.";
	public const string LockRecursionException_RecursiveWriteNotAllowed = "Recursive write lock acquisitions not allowed in this mode.";
	public const string LockRecursionException_ReadAfterWriteNotAllowed = "A read lock may not be acquired with the write lock held in this mode.";
	public const string LockRecursionException_RecursiveUpgradeNotAllowed = "Recursive upgradeable lock acquisitions not allowed in this mode.";
	public const string LockRecursionException_RecursiveReadNotAllowed = "Recursive read lock acquisitions not allowed in this mode.";
	public const string SynchronizationLockException_IncorrectDispose = "The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock.";
	public const string SynchronizationLockException_MisMatchedWrite = "The write lock is being released without being held.";
	public const string LockRecursionException_UpgradeAfterReadNotAllowed = "Upgradeable lock may not be acquired with read lock held.";
	public const string LockRecursionException_UpgradeAfterWriteNotAllowed = "Upgradeable lock may not be acquired with write lock held in this mode. Acquiring Upgradeable lock gives the ability to read along with an option to upgrade to a writer.";
	public const string SynchronizationLockException_MisMatchedUpgrade = "The upgradeable lock is being released without being held.";
	public const string SynchronizationLockException_MisMatchedRead = "The read lock is being released without being held.";
	public const string InvalidOperation_TimeoutsNotSupported = "Timeouts are not supported on this stream.";
	public const string NotSupported_SubclassOverride = "Derived classes must provide an implementation.";
	public const string InvalidOperation_NoPublicRemoveMethod = "Cannot remove the event handler since no public remove method exists for the event.";
	public const string InvalidOperation_NoPublicAddMethod = "Cannot add the event handler since no public add method exists for the event.";
	public const string SerializationException = "Serialization error.";
	public const string Serialization_NotFound = "Member '{0}' was not found.";
	public const string Serialization_OptionalFieldVersionValue = "Version value must be positive.";
	public const string Serialization_SameNameTwice = "Cannot add the same member twice to a SerializationInfo object.";
	public const string NotSupported_AbstractNonCLS = "This non-CLS method is not implemented.";
	public const string NotSupported_NoTypeInfo = "Cannot resolve {0} to a TypeInfo object.";
	public const string ReflectionTypeLoad_LoadFailed = "Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.";
	public const string Arg_CustomAttributeFormatException = "Binary format of the specified custom attribute was invalid.";
	public const string Argument_InvalidMemberForNamedArgument = "The member must be either a field or a property.";
	public const string Arg_InvalidFilterCriteriaException = "Specified filter criteria was invalid.";
	public const string Arg_ParmArraySize = "Must specify one or more parameters.";
	public const string Arg_MustBePointer = "Type must be a Pointer.";
	public const string Arg_InvalidHandle = "Invalid handle.";
	public const string Argument_InvalidEnum = "The Enum type should contain one and only one instance field.";
	public const string Argument_MustHaveAttributeBaseClass = "Type passed in must be derived from System.Attribute or System.Attribute itself.";
	public const string InvalidFilterCriteriaException_CritString = "A String must be provided for the filter criteria.";
	public const string InvalidFilterCriteriaException_CritInt = "An Int32 must be provided for the filter criteria.";
	public const string InvalidOperation_NotSupportedOnWinRTEvent = "Adding or removing event handlers dynamically is not supported on WinRT events.";
	public const string PlatformNotSupported_ReflectionOnly = "ReflectionOnly loading is not supported on this platform.";
	public const string MissingMember_Name = "Member '{0}' not found.";
	public const string MissingMethod_Name = "Method '{0}' not found.";
	public const string MissingField_Name = "Field '{0}' not found.";
	public const string Format_StringZeroLength = "String cannot have zero length.";
	public const string Security_CannotReadRegistryData = "The time zone ID '{0}' was found on the local computer, but the application does not have permission to read the registry information.";
	public const string Security_InvalidAssemblyPublicKey = "Invalid assembly public key.";
	public const string Security_RegistryPermission = "Requested registry access is not allowed.";
	public const string ClassLoad_General = "Could not load type '{0}' from assembly '{1}'.";
	public const string ClassLoad_RankTooLarge = "'{0}' from assembly '{1}' has too many dimensions.";
	public const string ClassLoad_ExplicitGeneric = "Could not load type '{0}' from assembly '{1}' because generic types cannot have explicit layout.";
	public const string ClassLoad_BadFormat = "Could not load type '{0}' from assembly '{1}' because the format is invalid.";
	public const string ClassLoad_ValueClassTooLarge = "Array of type '{0}' from assembly '{1}' cannot be created because base value type is too large.";
	public const string ClassLoad_ExplicitLayout = "Could not load type '{0}' from assembly '{1}' because it contains an object field at offset '{2}' that is incorrectly aligned or overlapped by a non-object field.";
	public const string EE_MissingMethod = "Method not found: '{0}'.";
	public const string EE_MissingField = "Field not found: '{0}'.";
	public const string UnauthorizedAccess_RegistryKeyGeneric_Key = "Access to the registry key '{0}' is denied.";
	public const string UnknownError_Num = "Unknown error '{0}'.";
	public const string Argument_NeedNonGenericType = "The specified Type must not be a generic type definition.";
	public const string Argument_NeedStructWithNoRefs = "The specified Type must be a struct containing no references.";
	public const string ArgumentOutOfRange_AddressSpace = "The number of bytes cannot exceed the virtual address space on a 32 bit machine.";
	public const string ArgumentOutOfRange_UIntPtrMaxMinusOne = "The length of the buffer must be less than the maximum UIntPtr value for your platform.";
	public const string Arg_BufferTooSmall = "Not enough space available in the buffer.";
	public const string InvalidOperation_MustCallInitialize = "You must call Initialize on this object instance before using it.";
	public const string ArgumentException_BufferNotFromPool = "The buffer is not associated with this pool and may not be returned to it.";
	public const string Argument_InvalidSafeBufferOffLen = "Offset and length were greater than the size of the SafeBuffer.";
	public const string Argument_InvalidSeekOrigin = "Invalid seek origin.";
	public const string Argument_NotEnoughBytesToRead = "There are not enough bytes remaining in the accessor to read at this position.";
	public const string Argument_NotEnoughBytesToWrite = "There are not enough bytes remaining in the accessor to write at this position.";
	public const string Argument_OffsetAndCapacityOutOfBounds = "Offset and capacity were greater than the size of the view.";
	public const string Argument_UnmanagedMemAccessorWrapAround = "The UnmanagedMemoryAccessor capacity and offset would wrap around the high end of the address space.";
	public const string ArgumentOutOfRange_StreamLength = "Stream length must be non-negative and less than 2^31 - 1 - origin.";
	public const string ArgumentOutOfRange_UnmanagedMemStreamWrapAround = "The UnmanagedMemoryStream capacity would wrap around the high end of the address space.";
	public const string InvalidOperation_CalledTwice = "The method cannot be called twice on the same instance.";
	public const string IO_FixedCapacity = "Unable to expand length of this stream beyond its capacity.";
	public const string IO_SeekBeforeBegin = "An attempt was made to move the position before the beginning of the stream.";
	public const string IO_StreamTooLong = "Stream was too long.";
	public const string Arg_BadDecimal = "Read an invalid decimal value from the buffer.";
	public const string NotSupported_Reading = "Accessor does not support reading.";
	public const string NotSupported_UmsSafeBuffer = "This operation is not supported for an UnmanagedMemoryStream created from a SafeBuffer.";
	public const string NotSupported_Writing = "Accessor does not support writing.";
	public const string IndexOutOfRange_UMSPosition = "Unmanaged memory stream position was beyond the capacity of the stream.";
	public const string ObjectDisposed_StreamIsClosed = "Cannot access a closed Stream.";
	public const string ObjectDisposed_ViewAccessorClosed = "Cannot access a closed accessor.";
	public const string ArgumentOutOfRange_PositionLessThanCapacityRequired = "The position may not be greater or equal to the capacity of the accessor.";
	public const string Arg_EndOfStreamException = "Attempted to read past the end of the stream.";
	public const string ObjectDisposed_FileClosed = "Cannot access a closed file.";
	public const string Arg_InvalidSearchPattern = "Search pattern cannot contain \\\"..\\\" to move up directories and can be contained only internally in file/directory names, as in \\\"a..b\\\".";
	public const string ArgumentOutOfRange_FileLengthTooBig = "Specified file length was too large for the file system.";
	public const string Argument_InvalidHandle = "'handle' has been disposed or is an invalid handle.";
	public const string Argument_AlreadyBoundOrSyncHandle = "'handle' has already been bound to the thread pool, or was not opened for asynchronous I/O.";
	public const string Argument_PreAllocatedAlreadyAllocated = "'preAllocated' is already in use.";
	public const string Argument_NativeOverlappedAlreadyFree = "'overlapped' has already been freed.";
	public const string Argument_NativeOverlappedWrongBoundHandle = "'overlapped' was not allocated by this ThreadPoolBoundHandle instance.";
	public const string Arg_HandleNotAsync = "Handle does not support asynchronous operations. The parameters to the FileStream constructor may need to be changed to indicate that the handle was opened synchronously (that is, it was not opened for overlapped I/O).";
	public const string ArgumentNull_Path = "Path cannot be null.";
	public const string Argument_EmptyPath = "Empty path name is not legal.";
	public const string Argument_InvalidFileModeAndAccessCombo = "Combining FileMode: {0} with FileAccess: {1} is invalid.";
	public const string Argument_InvalidAppendMode = "Append access can be requested only in write-only mode.";
	public const string IO_UnknownFileName = "[Unknown]";
	public const string IO_FileStreamHandlePosition = "The OS handle's position is not what FileStream expected. Do not use a handle simultaneously in one FileStream and in Win32 code or another FileStream. This may cause data loss.";
	public const string NotSupported_FileStreamOnNonFiles = "FileStream was asked to open a device that was not a file. For support for devices like 'com1:' or 'lpt1:', call CreateFile, then use the FileStream constructors that take an OS handle as an IntPtr.";
	public const string Arg_HandleNotSync = "Handle does not support synchronous operations. The parameters to the FileStream constructor may need to be changed to indicate that the handle was opened asynchronously (that is, it was opened explicitly for overlapped I/O).";
	public const string IO_SetLengthAppendTruncate = "Unable to truncate data that previously existed in a file opened in Append mode.";
	public const string IO_SeekAppendOverwrite = "Unable seek backward to overwrite data that previously existed in a file opened in Append mode.";
	public const string IO_FileTooLongOrHandleNotSync = "IO operation will not work. Most likely the file will become too long or the handle was not opened to support synchronous IO operations.";
	public const string EventStream_FailedToStart = "Failed to start the EventStream";
	public const string Arg_NonZeroLowerBound = "The lower bound of target array must be zero.";
	public const string Arg_WrongType = "The value '{0}' is not of type '{1}' and cannot be used in this generic collection.";
	public const string Arg_ArrayPlusOffTooSmall = "Destination array is not long enough to copy all the items in the collection. Check array index and length.";
	public const string ArgumentOutOfRange_NeedNonNegNum = "Non-negative number required.";
	public const string ArgumentOutOfRange_SmallCapacity = "capacity was less than the current size.";
	public const string Argument_InvalidOffLen = "Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.";
	public const string Argument_AddingDuplicate = "An item with the same key has already been added. Key: {0}";
	public const string InvalidOperation_EmptyQueue = "Queue empty.";
	public const string InvalidOperation_EnumOpCantHappen = "Enumeration has either not started or has already finished.";
	public const string InvalidOperation_EnumFailedVersion = "Collection was modified; enumeration operation may not execute.";
	public const string InvalidOperation_EmptyStack = "Stack empty.";
	public const string InvalidOperation_EnumNotStarted = "Enumeration has not started. Call MoveNext.";
	public const string InvalidOperation_EnumEnded = "Enumeration already finished.";
	public const string NotSupported_KeyCollectionSet = "Mutating a key collection derived from a dictionary is not allowed.";
	public const string NotSupported_ValueCollectionSet = "Mutating a value collection derived from a dictionary is not allowed.";
	public const string Arg_ArrayLengthsDiffer = "Array lengths must be the same.";
	public const string Arg_BitArrayTypeUnsupported = "Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[].";
	public const string Arg_HSCapacityOverflow = "HashSet capacity is too big.";
	public const string Arg_HTCapacityOverflow = "Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.";
	public const string Arg_InsufficientSpace = "Insufficient space in the target location to copy the information.";
	public const string Arg_RankMultiDimNotSupported = "Only single dimensional arrays are supported for the requested action.";
	public const string Argument_ArrayTooLarge = "The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.";
	public const string Argument_InvalidArrayType = "Target array type is not compatible with the type of items in the collection.";
	public const string ArgumentOutOfRange_BiggerThanCollection = "Must be less than or equal to the size of the collection.";
	public const string ArgumentOutOfRange_Index = "Index was out of range. Must be non-negative and less than the size of the collection.";
	public const string ExternalLinkedListNode = "The LinkedList node does not belong to current LinkedList.";
	public const string LinkedListEmpty = "The LinkedList is empty.";
	public const string LinkedListNodeIsAttached = "The LinkedList node already belongs to a LinkedList.";
	public const string NotSupported_SortedListNestedWrite = "This operation is not supported on SortedList nested types because they require modifying the original SortedList.";
	public const string SortedSet_LowerValueGreaterThanUpperValue = "Must be less than or equal to upperValue.";
	public const string Serialization_InvalidOnDeser = "OnDeserialization method was called while the object was not being deserialized.";
	public const string Serialization_MismatchedCount = "The serialized Count information doesn't match the number of items.";
	public const string Serialization_MissingKeys = "The keys for this dictionary are missing.";
	public const string Serialization_MissingValues = "The values for this dictionary are missing.";
}
