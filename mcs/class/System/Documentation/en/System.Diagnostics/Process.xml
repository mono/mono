<?xml version="1.0" encoding="utf-8"?>
<Type Name="Process" FullName="System.Diagnostics.Process">
  <TypeSignature Language="C#" Maintainer="auto" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00]</AssemblyPublicKey>
    <AssemblyVersion>1.0.3300.0</AssemblyVersion>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the &lt;link location="node:gtk-sharp/programming/threads"&gt;Gtk# Thread Programming&lt;/link&gt; for details.</ThreadSafetyStatement>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents a system process")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <block subset="none" type="note">
        <para>Starting with the .NET Framework version 2.0, the ability to reference performance counter data on other computers has been eliminated for many of the .NET Framework methods and properties. This change was made to improve performance and to enable non-administrators to use the <see cref="T:System.Diagnostics.Process" /> class. As a result, some applications that did not get exceptions in earlier versions of the .NET Framework may now get a <see cref="T:System.NotSupportedException" />. The methods and properties affected are too numerous to list here, but the exception information has been added to the affected member topics.</para>
      </block>
      <para>A <see cref="T:System.Diagnostics.Process" /> component provides access to a process that is running on a computer. A process, in the simplest terms, is a running application. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.</para>
      <para>The <see cref="T:System.Diagnostics.Process" /> component is a useful tool for starting, stopping, controlling, and monitoring applications. Using the <see cref="T:System.Diagnostics.Process" /> component, you can obtain a list of the processes that are running, or you can start a new process. A <see cref="T:System.Diagnostics.Process" /> component is used to access system processes. After a <see cref="T:System.Diagnostics.Process" /> component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.</para>
      <block subset="none" type="note">
        <para>A 32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <see cref="T:System.ComponentModel.Win32Exception" /> exception.</para>
      </block>
      <para>If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if c:\mypath is not in your path, and you add it using quotation marks: path = %path%;"c:\mypath", you must fully qualify any process in c:\mypath when starting it.</para>
      <para>The process component obtains information about a group of properties all at once. After the <see cref="T:System.Diagnostics.Process" /> component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <see cref="M:System.Diagnostics.Process.Refresh" /> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <see cref="M:System.Diagnostics.Process.Refresh" /> method. The group breakdowns are operating-system dependent.</para>
      <para>A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <see cref="P:System.Diagnostics.Process.Handle" /> property of the <see cref="T:System.Diagnostics.Process" /> component, even when the process has exited. Thus, you can get the process's administrative information, such as the <see cref="P:System.Diagnostics.Process.ExitCode" /> (usually either zero for success or a nonzero error code) and the <see cref="P:System.Diagnostics.Process.ExitTime" />. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.</para>
      <block subset="none" type="note">
        <para>This class contains a link demand and an inheritance demand at the class level that applies to all members. A <see cref="T:System.Security.SecurityException" /> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see <format type="text/html"><a href="a33fd5f9-2de9-4653-a4f0-d9df25082c4d">Link Demands</a></format> and <format type="text/html"><a href="28b9adbb-8f08-4f10-b856-dbf59eb932d9">Inheritance Demands</a></format>.</para>
      </block>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides access to local and remote processes and enables you to start and stop local system processes.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you do not specify the <see cref="P:System.Diagnostics.Process.MachineName" /> property, the default is the local computer, (".").</para>
          <para>You have two options for associating a new <see cref="T:System.Diagnostics.Process" /> component with a process on the computer. The first option is to use the constructor to create the <see cref="T:System.Diagnostics.Process" /> component, set the appropriate members of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property and call <see cref="M:System.Diagnostics.Process.Start" /> to associate the <see cref="T:System.Diagnostics.Process" /> with a new system process. The second option is to associate the <see cref="T:System.Diagnostics.Process" /> with a running system process by using <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> or one of the <see cref="M:System.Diagnostics.Process.GetProcesses" /> return values.</para>
          <para>If you use a static overload of the <see cref="M:System.Diagnostics.Process.Start" /> method to start a new system process, the method creates a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the process.</para>
          <para>When the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property is set to its default value, true, you can start applications and documents in a way that is similar to using the Run dialog box of the Windows Start menu. When <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is false, you can start only executables.</para>
          <para>Any executable file that you can call from the command line can be started in one of two ways: by setting the appropriate members of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property and calling the <see cref="M:System.Diagnostics.Process.Start" /> method with no parameters, or by passing the appropriate parameter to the static <see cref="M:System.Diagnostics.Process.Start" /> member.</para>
          <para>You can create a <see cref="T:System.Diagnostics.Process" /> component by using the constructor, one of the static <see cref="M:System.Diagnostics.Process.Start" /> overloads, or any of the <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />, <see cref="M:System.Diagnostics.Process.GetProcesses" />, or <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> methods. After you have done so, you have a view into the associated process. This is not a dynamic view that updates itself automatically when the process properties have changed in memory. Instead, you must call <see cref="M:System.Diagnostics.Process.Refresh" /> for the component to update the <see cref="T:System.Diagnostics.Process" /> property information in your application.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Diagnostics.Process.BasePriority" /> of the process is the starting priority for threads created within the associated process. You can view information about the base priority through the System Monitor's Priority Base counter.</para>
          <para>Based on the time elapsed or other boosts, the operating system can change the base priority when a process should be placed ahead of others.</para>
          <para>The <see cref="P:System.Diagnostics.Process.BasePriority" /> property lets you view the starting priority assigned to a process. However, because it is read-only, you cannot use the <see cref="P:System.Diagnostics.Process.BasePriority" /> to set the priority of the process. To change the priority, use the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property. The <see cref="P:System.Diagnostics.Process.BasePriority" /> is viewable using the System Monitor, while the <see cref="P:System.Diagnostics.Process.PriorityClass" /> is not. Both the <see cref="P:System.Diagnostics.Process.BasePriority" /> and the <see cref="P:System.Diagnostics.Process.PriorityClass" /> can be viewed programmatically. The following table shows the relationship between <see cref="P:System.Diagnostics.Process.BasePriority" /> values and <see cref="P:System.Diagnostics.Process.PriorityClass" /> values.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>BasePriority </para>
                </term>
                <description>
                  <para>PriorityClass </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>4 </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.Diagnostics.ProcessPriorityClass.Idle" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>8 </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.Diagnostics.ProcessPriorityClass.Normal" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>13 </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.Diagnostics.ProcessPriorityClass.High" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>24 </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.Diagnostics.ProcessPriorityClass.RealTime" /> </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the base priority of the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Diagnostics.Process.StandardError" /> stream can be read synchronously or asynchronously. Methods such as <see cref="M:System.IO.StreamReader.Read" />, <see cref="M:System.IO.StreamReader.ReadLine" />, and <see cref="M:System.IO.StreamReader.ReadToEnd" /> perform synchronous read operations on the error output stream of the process. These synchronous read operations do not complete until the associated <see cref="T:System.Diagnostics.Process" /> writes to its <see cref="P:System.Diagnostics.Process.StandardError" /> stream, or closes the stream.</para>
          <para>In contrast, <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> starts asynchronous read operations on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream. This method enables the designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</para>
          <para>Follow these steps to perform asynchronous read operations on <see cref="P:System.Diagnostics.Process.StandardError" /> for a <see cref="T:System.Diagnostics.Process" /> : </para>
          <list type="ordered">
            <item>
              <para>Set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to false.</para>
            </item>
            <item>
              <para>Set <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> to true.</para>
            </item>
            <item>
              <para>Add your event handler to the <see cref="E:System.Diagnostics.Process.ErrorDataReceived" /> event. The event handler must match the <see cref="T:System.Diagnostics.DataReceivedEventHandler" /> delegate signature.</para>
            </item>
            <item>
              <para>Start the <see cref="T:System.Diagnostics.Process" />.</para>
            </item>
            <item>
              <para>Call <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> for the <see cref="T:System.Diagnostics.Process" />. This call starts asynchronous read operations on <see cref="P:System.Diagnostics.Process.StandardError" />.</para>
            </item>
          </list>
          <para>When asynchronous read operations start, the event handler is called each time the associated <see cref="T:System.Diagnostics.Process" /> writes a line of text to its <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</para>
          <para>You can cancel an asynchronous read operation by calling <see cref="M:System.Diagnostics.Process.CancelErrorRead" />. The read operation can be canceled by the caller or by the event handler. After canceling, you can call <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> again to resume asynchronous read operations.</para>
          <block subset="none" type="note">
            <para>You cannot mix asynchronous and synchronous read operations on a redirected stream. Once the redirected stream of a <see cref="T:System.Diagnostics.Process" /> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. For example, do not follow <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> with a call to <see cref="M:System.IO.StreamReader.ReadLine" /> on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream, or vice versa. However, you can read two different streams in different modes. For example, you can call <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> and then call <see cref="M:System.IO.StreamReader.ReadLine" /> for the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream can be read synchronously or asynchronously. Methods such as <see cref="M:System.IO.StreamReader.Read" />, <see cref="M:System.IO.StreamReader.ReadLine" />, and <see cref="M:System.IO.StreamReader.ReadToEnd" /> perform synchronous read operations on the output stream of the process. These synchronous read operations do not complete until the associated <see cref="T:System.Diagnostics.Process" /> writes to its <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream, or closes the stream.</para>
          <para>In contrast, <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> starts asynchronous read operations on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream. This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</para>
          <para>Follow these steps to perform asynchronous read operations on <see cref="P:System.Diagnostics.Process.StandardOutput" /> for a <see cref="T:System.Diagnostics.Process" /> : </para>
          <list type="ordered">
            <item>
              <para>Set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to false.</para>
            </item>
            <item>
              <para>Set <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> to true.</para>
            </item>
            <item>
              <para>Add your event handler to the <see cref="E:System.Diagnostics.Process.OutputDataReceived" /> event. The event handler must match the <see cref="T:System.Diagnostics.DataReceivedEventHandler" /> delegate signature.</para>
            </item>
            <item>
              <para>Start the <see cref="T:System.Diagnostics.Process" />.</para>
            </item>
            <item>
              <para>Call <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> for the <see cref="T:System.Diagnostics.Process" />. This call starts asynchronous read operations on <see cref="P:System.Diagnostics.Process.StandardOutput" />.</para>
            </item>
          </list>
          <para>When asynchronous read operations start, the event handler is called each time the associated <see cref="T:System.Diagnostics.Process" /> writes a line of text to its <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</para>
          <para>You can cancel an asynchronous read operation by calling <see cref="M:System.Diagnostics.Process.CancelOutputRead" />. The read operation can be canceled by the caller or by the event handler. After canceling, you can call <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> again to resume asynchronous read operations.</para>
          <block subset="none" type="note">
            <para>You cannot mix asynchronous and synchronous read operations on a redirected stream. Once the redirected stream of a <see cref="T:System.Diagnostics.Process" /> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. For example, do not follow <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> with a call to <see cref="M:System.IO.StreamReader.ReadLine" /> on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream, or vice versa. However, you can read two different streams in different modes. For example, you can call <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> and then call <see cref="M:System.IO.StreamReader.ReadLine" /> for the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> starts an asynchronous read operation on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream. <see cref="M:System.Diagnostics.Process.CancelErrorRead" /> ends the asynchronous read operation.</para>
          <para>After canceling, you can resume the asynchronous read operation by calling <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> again.</para>
          <para>When you call <see cref="M:System.Diagnostics.Process.CancelErrorRead" />, all in-progress read operations for <see cref="P:System.Diagnostics.Process.StandardError" /> are completed and then the event handler is disabled. All further redirected output to <see cref="P:System.Diagnostics.Process.StandardError" /> is saved in a buffer. If you re-enable the event handler with a call to <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />, the saved output is sent to the event handler and asynchronous read operations resume. If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler: </para>
          <code>    // At this point the DataReceivedEventHandler(ErrorHandler1) 
    // has executed a CancelErrorRead.

    // Remove the prior event handler.
    process.ErrorDataReceived -= 
        new DataReceivedEventHandler(ErrorHandler1);

    // Register a new event handler.
    process.ErrorDataReceived += 
        new DataReceivedEventHandler(ErrorHandler2);

    // Call the corresponding BeginErrorReadLine.
    process.BeginErrorReadLine();</code>
          <block subset="none" type="note">
            <para>You cannot mix asynchronous and synchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream. Once the redirected stream of a <see cref="T:System.Diagnostics.Process" /> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. If you cancel an asynchronous read operation on <see cref="P:System.Diagnostics.Process.StandardError" /> and then need to read from the stream again, you must use <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> to resume asynchronous read operations. Do not follow <see cref="M:System.Diagnostics.Process.CancelErrorRead" /> with a call to the synchronous read methods of <see cref="P:System.Diagnostics.Process.StandardError" /> such as <see cref="M:System.IO.StreamReader.Read" />, <see cref="M:System.IO.StreamReader.ReadLine" />, or <see cref="M:System.IO.StreamReader.ReadToEnd" />.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> starts an asynchronous read operation on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream. <see cref="M:System.Diagnostics.Process.CancelOutputRead" /> ends the asynchronous read operation.</para>
          <para>After canceling, you can resume asynchronous read operations by calling <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> again.</para>
          <para>When you call <see cref="M:System.Diagnostics.Process.CancelOutputRead" />, all in-progress read operations for <see cref="P:System.Diagnostics.Process.StandardOutput" /> are completed and then the event handler is disabled. All further redirected output to <see cref="P:System.Diagnostics.Process.StandardOutput" /> is saved in a buffer. If you re-enable the event handler with a call to <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />, the saved output is sent to the event handler and asynchronous read operations resume. If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler: </para>
          <code>    // At this point the DataReceivedEventHandler(OutputHandler1) 
    // has executed a CancelOutputRead.

    // Remove the prior event handler.
    process.OutputDataReceived -= 
        new DataReceivedEventHandler(OutputHandler1);

    // Register a new event handler.
    process.OutputDataReceived += 
        new DataReceivedEventHandler(OutputHandler2);

    // Call the corresponding BeginOutputReadLine.
    process.BeginOutputReadLine();</code>
          <block subset="none" type="note">
            <para>You cannot mix asynchronous and synchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream. Once the redirected stream of a <see cref="T:System.Diagnostics.Process" /> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. If you cancel an asynchronous read operation on <see cref="P:System.Diagnostics.Process.StandardOutput" /> and then need to read from the stream again, you must use <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> to resume asynchronous read operations. Do not follow <see cref="M:System.Diagnostics.Process.CancelOutputRead" /> with a call to the synchronous read methods of <see cref="P:System.Diagnostics.Process.StandardOutput" /> such as <see cref="M:System.IO.StreamReader.Read" />, <see cref="M:System.IO.StreamReader.ReadLine" />, or <see cref="M:System.IO.StreamReader.ReadToEnd" />.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Diagnostics.Process.Close" /> method causes the process to stop waiting for exit if it was waiting, closes the process handle, and clears process-specific properties. <see cref="M:System.Diagnostics.Process.Close" /> does not close the standard output, input, and error readers and writers in case they are being referenced externally.</para>
          <block subset="none" type="note">
            <para>The <see cref="M:System.Diagnostics.Process.Dispose(System.Boolean)" /> method calls <see cref="M:System.Diagnostics.Process.Close" />. Placing the <see cref="T:System.Diagnostics.Process" /> object in a using block disposes of resources without the need to call <see cref="M:System.Diagnostics.Process.Close" />. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees all the resources that are associated with this component.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When a process is executing, its message loop is in a wait state. The message loop executes every time a Windows message is sent to the process by the operating system. Calling <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application. The request to exit the process by calling <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> does not force the application to quit. The application can ask for user verification before quitting, or it can refuse to quit. To force the application to quit, use the <see cref="M:System.Diagnostics.Process.Kill" /> method. The behavior of <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> is identical to that of a user closing an application's main window using the system menu. Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</para>
          <para>Data edited by the process or resources allocated to the process can be lost if you call <see cref="M:System.Diagnostics.Process.Kill" />. <see cref="M:System.Diagnostics.Process.Kill" /> causes an abnormal process termination, and should be used only when necessary. <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface. If <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> fails, you can use <see cref="M:System.Diagnostics.Process.Kill" /> to terminate the process. <see cref="M:System.Diagnostics.Process.Kill" /> is the only way to terminate processes that do not have graphical interfaces.</para>
          <para>You can call <see cref="M:System.Diagnostics.Process.Kill" /> and <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> only for processes that are running on the local computer. You cannot cause processes on remote computers to exit. You can only view information for processes running on remote computers.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Closes a process that has a user interface by sending a close message to its main window.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the close message was successfully sent; false if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Release all resources used by this process.</para>
        </summary>
        <param name="disposing">
          <attribution license="cc4" from="Microsoft" modified="false" />true to release both managed and unmanaged resources; false to release only unmanaged resources. </param>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Check for exiting of the process to raise the apropriate event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'bool'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> property indicates whether the component should be notified when the operating system has shut down a process. The <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> property is used in asynchronous processing to notify your application that a process has exited. To force your application to synchronously wait for an exit event (which interrupts processing of the application until the exit event has occurred), use the <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> method.</para>
          <block subset="none" type="note">
            <para>If you are using Visual Studio and double-click a <see cref="T:System.Diagnostics.Process" /> component in your project, an <see cref="E:System.Diagnostics.Process.Exited" /> event delegate and event handler are automatically generated. Additional code sets the <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> property to false. You must change this property to true for your event handler to be executed when the associated process exits.</para>
          </block>
          <para>When an associated process exits after being shut down by the operating system either through a normal or abnormal termination, the operating system notifies each process component to which the process was associated, as long as the component's <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> value is true. If a component started the process, the component can then access the administrative information for the associated process, which is still being stored by the operating system. Such information includes the <see cref="P:System.Diagnostics.Process.ExitTime" />, and the <see cref="P:System.Diagnostics.Process.ExitCode" />.</para>
          <para>After the associated process exits, the <see cref="P:System.Diagnostics.Process.Handle" /> of the component no longer points to an existing process resource. Instead, it can be used only to access the operating system's information about the process resource. The operating system is aware that there are handles to exited processes that have not been released by <see cref="T:System.Diagnostics.Process" /> components, so it keeps the <see cref="P:System.Diagnostics.Process.ExitTime" /> and <see cref="P:System.Diagnostics.Process.Handle" /> information in memory.</para>
          <para>There is a cost associated with watching for a process to exit. If <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> is true, the <see cref="E:System.Diagnostics.Process.Exited" /> event is raised when the associated process terminates. The procedures that you have specified for the <see cref="E:System.Diagnostics.Process.Exited" /> event run at that time.</para>
          <para>Sometimes, your application starts a process but does not need to be notified of its closure. For example, your application can start Notepad to allow the user to perform text editing, but make no further use of the Notepad application. You can choose to not be notified when the process exits, because it is not relevant to the continued operation of your application. Setting <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> to false saves system resources.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Some operating system processes run in a special mode. Attempting to read properties of or attach to these processes is not possible unless you have called <see cref="M:System.Diagnostics.Process.EnterDebugMode" /> on the component. Call <see cref="M:System.Diagnostics.Process.LeaveDebugMode" /> when you no longer need access to these processes that run in special mode.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property SeDebugPrivilege on the current thread.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised when it receives error data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="E:System.Diagnostics.Process.ErrorDataReceived" /> event indicates that the associated process has written to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</para>
          <para>The event only occurs during asynchronous read operations on <see cref="P:System.Diagnostics.Process.StandardError" />. To start asynchronous read operations, you must redirect the <see cref="P:System.Diagnostics.Process.StandardError" /> stream of a <see cref="T:System.Diagnostics.Process" />, add your event handler to the <see cref="E:System.Diagnostics.Process.ErrorDataReceived" /> event, and call <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />. Thereafter, the <see cref="E:System.Diagnostics.Process.ErrorDataReceived" /> event signals each time the process writes a line to the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream, until the process exits or calls <see cref="M:System.Diagnostics.Process.CancelErrorRead" />.</para>
          <block subset="none" type="note">
            <para>The application that is processing the asynchronous output should call the <see cref="M:System.Diagnostics.Process.WaitForExit" /> method to ensure that the output buffer has been flushed.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The exit code of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use <see cref="P:System.Diagnostics.Process.ExitCode" /> to get the status that the system process returned when it exited. You can use the exit code much like an integer return value from a main() procedure. </para>
          <para>The <see cref="P:System.Diagnostics.Process.ExitCode" /> value for a process reflects the specific convention implemented by the application developer for that process. If you use the exit code value to make decisions in your code, be sure that you know the exit code convention used by the application process.</para>
          <para>Developers usually indicate a successful exit by an <see cref="P:System.Diagnostics.Process.ExitCode" /> value of zero, and designate errors by nonzero values that the calling method can use to identify the cause of an abnormal process termination. It is not necessary to follow these guidelines, but they are the convention.</para>
          <para>If you try to get the <see cref="P:System.Diagnostics.Process.ExitCode" /> before the process has exited, the attempt throws an exception. Examine the <see cref="P:System.Diagnostics.Process.HasExited" /> property first to verify whether the associated process has terminated.</para>
          <block subset="none" type="note">
            <para>When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when <see cref="P:System.Diagnostics.Process.HasExited" /> returns true. To ensure that asynchronous event handling has been completed, call the <see cref="M:System.Diagnostics.Process.WaitForExit" /> overload that takes no parameter before checking <see cref="P:System.Diagnostics.Process.HasExited" />.</para>
          </block>
          <para>You can use the <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> or the <see cref="M:System.Diagnostics.Process.Kill" /> method to cause an associated process to exit.</para>
          <para>There are two ways of being notified when the associated process exits: synchronously and asynchronously. Synchronous notification relies on calling the <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> method to pause the processing of your application until the associated component exits. Asynchronous notification relies on the <see cref="E:System.Diagnostics.Process.Exited" /> event. When using asynchronous notification, <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> must be set to true for the <see cref="T:System.Diagnostics.Process" /> component to receive notification that the process has exited.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the value that the associated process specified when it terminated.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised when this process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="E:System.Diagnostics.Process.Exited" /> event indicates that the associated process exited. This occurrence means either that the process terminated (aborted) or successfully closed. This event can occur only if the value of the <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> property is true.</para>
          <para>There are two ways of being notified when the associated process exits: synchronously and asynchronously. Synchronous notification relies on calling the <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> method to pause the processing of your application until the associated component exits. Asynchronous notification relies on the <see cref="E:System.Diagnostics.Process.Exited" /> event. In either case, <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> must be set to true for the <see cref="T:System.Diagnostics.Process" /> component to receive notification that the process has exited.</para>
          <para>When the operating system shuts down a process, any process component that is waiting for an exit is notified. The component can then access the associated process information that is still resident in the operating system memory (such as <see cref="P:System.Diagnostics.Process.ExitTime" /> property) by using the handle that it has to the process.</para>
          <para>Because the associated process has exited, the <see cref="P:System.Diagnostics.Process.Handle" /> property of the component no longer points to an existing process resource. Instead, it can be used only to access the operating system's information about the process resource. The system is aware of handles to exited processes that have not been released by <see cref="T:System.Diagnostics.Process" /> components, so it keeps the <see cref="P:System.Diagnostics.Process.ExitTime" /> and <see cref="P:System.Diagnostics.Process.Handle" /> property information in memory until the <see cref="T:System.Diagnostics.Process" /> component specifically frees the resources.</para>
          <block subset="none" type="note">
            <para>Even if you have a handle to an exited process, you cannot call <see cref="M:System.Diagnostics.Process.Start" /> again to reconnect to the same process. Calling <see cref="M:System.Diagnostics.Process.Start" /> automatically releases the associated process and connects to a process with the same file but an entirely new <see cref="P:System.Diagnostics.Process.Handle" />.</para>
          </block>
          <para>For more information about the use of the <see cref="E:System.Diagnostics.Process.Exited" /> event in Windows Forms applications, see the <see cref="P:System.Diagnostics.Process.SynchronizingObject" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when a process exits.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The exit time of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'DateTime'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the process has not terminated, attempting to retrieve the <see cref="P:System.Diagnostics.Process.ExitTime" /> property throws an exception. Use <see cref="P:System.Diagnostics.Process.HasExited" /> before getting the <see cref="P:System.Diagnostics.Process.ExitTime" /> property to determine whether the associated process has terminated.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the time that the associated process exited.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Process ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to create a new <see cref="T:System.Diagnostics.Process" /> instance and associate it with the process resource on the local computer.</para>
          <para>Like the similar <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />, <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />, and <see cref="M:System.Diagnostics.Process.GetProcesses" /> methods, <see cref="M:System.Diagnostics.Process.GetCurrentProcess" /> associates an existing resource with a new <see cref="T:System.Diagnostics.Process" /> component.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to create a new <see cref="T:System.Diagnostics.Process" /> component and associate it with a process resource on the local computer. The process resource must already exist on the computer, because <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32)" /> does not create a system resource, but rather associates a resource with an application-generated <see cref="T:System.Diagnostics.Process" /> component. A process <see cref="P:System.Diagnostics.Process.Id" /> can be retrieved only for a process that is currently running on the computer. After the process terminates, <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32)" /> throws an exception if you pass it an expired identifier.</para>
          <para>On any particular computer, the identifier of a process is unique. <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32)" /> returns one process at most. If you want to get all the processes running a particular application, use <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />. If multiple processes exist on the computer running the specified application, <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> returns an array containing all the associated processes. You can query each of these processes in turn for its identifier. The process identifier can be viewed in the Processes panel of the Windows Task Manager. The PID column displays the process identifier that is assigned to a process.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</para>
        </returns>
        <param name="processId">
          <attribution license="cc4" from="Microsoft" modified="false" />The system-unique identifier of a process resource. </param>
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to create a new <see cref="T:System.Diagnostics.Process" /> component and associate it with a process resource on a remote computer on the network. The process resource must already exist on the specified computer, because <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> does not create a system resource, but rather associates a resource with an application-generated <see cref="T:System.Diagnostics.Process" /> component. A process <see cref="P:System.Diagnostics.Process.Id" /> can be retrieved only for a process that is currently running on the computer. After the process terminates, <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> throws an exception if you pass it an expired identifier.</para>
          <para>On any particular computer, the identifier of a process is unique. <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> returns one process at most. If you want to get all the processes running a particular application, use <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />. If multiple processes exist on the computer running the specified application, <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> returns an array containing all the associated processes. You can query each of these processes in turn for its identifier. The process identifier can be viewed in the Processes panel of the Windows Task Manager. The PID column displays the process identifier that is assigned to a process.</para>
          <para>If you do not specify a <paramref name="machineName" />, the local computer is used. Alternatively, you can specify the local computer by setting <paramref name="machineName" /> to the value "." or to an empty string ("").</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</para>
        </returns>
        <param name="processId">
          <attribution license="cc4" from="Microsoft" modified="false" />The system-unique identifier of a process resource. </param>
        <param name="machineName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of a computer on the network. </param>
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to create an array of new <see cref="T:System.Diagnostics.Process" /> components and associate them with all the process resources on the local computer. The process resources must already exist on the local computer, because <see cref="M:System.Diagnostics.Process.GetProcesses" /> does not create system resources but rather associates resources with application-generated <see cref="T:System.Diagnostics.Process" /> components. Because the operating system itself is running background processes, this array is never empty.</para>
          <para>If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> or <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> method. <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> creates a <see cref="T:System.Diagnostics.Process" /> component that is associated with the process identified on the system by the process identifier that you pass to the method. <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> creates an array of <see cref="T:System.Diagnostics.Process" /> components whose associated process resources share the executable file you pass to the method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to create an array of new <see cref="T:System.Diagnostics.Process" /> components and associate them with all the process resources on the specified (usually remote) computer. The process resources must already exist on the local computer, because <see cref="M:System.Diagnostics.Process.GetProcesses" /> does not create system resources but rather associates resources with application-generated <see cref="T:System.Diagnostics.Process" /> components. Because the operating system itself is running background processes, this array is never empty.</para>
          <para>If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> or <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> method. <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> creates a <see cref="T:System.Diagnostics.Process" /> component that is associated with the process identified on the system by the process identifier that you pass to the method. <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> creates an array of <see cref="T:System.Diagnostics.Process" /> components whose associated process resources share the executable file you pass to the method.</para>
          <para>This overload of the <see cref="M:System.Diagnostics.Process.GetProcesses" /> method is generally used to retrieve the list of process resources running on a remote computer on the network, but you can specify the local computer by passing ".".</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</para>
        </returns>
        <param name="machineName">
          <attribution license="cc4" from="Microsoft" modified="false" />The computer from which to read the list of processes. </param>
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to create an array of new <see cref="T:System.Diagnostics.Process" /> components and associate them with all the process resources that are running the same executable file on the local computer. The process resources must already exist on the computer, because <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> does not create system resources but rather associates them with application-generated <see cref="T:System.Diagnostics.Process" /> components. A <paramref name="processName" /> can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</para>
          <para>The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path. <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> is helpful for getting and manipulating all the processes that are associated with the same executable file. For example, you can pass an executable file name as the <paramref name="processName" /> parameter, in order to shut down all the running instances of that executable file.</para>
          <para>Although a process <see cref="P:System.Diagnostics.Process.Id" /> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the <paramref name="processName" /> parameter. Therefore, <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> returns one process at most, but <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> returns an array containing all the associated processes. If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier. You cannot access process resources through the process name alone but, once you have retrieved an array of <see cref="T:System.Diagnostics.Process" /> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</para>
        </returns>
        <param name="processName">
          <attribution license="cc4" from="Microsoft" modified="false" />The friendly name of the process. </param>
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to create an array of new <see cref="T:System.Diagnostics.Process" /> components and associate them with all the process resources that are running the same executable file on the specified computer. The process resources must already exist on the computer, because <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> does not create system resources but rather associates them with application-generated <see cref="T:System.Diagnostics.Process" /> components. A <paramref name="processName" /> can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</para>
          <para>The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path. <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> is helpful for getting and manipulating all the processes that are associated with the same executable file. For example, you can pass an executable file name as the <paramref name="processName" /> parameter, in order to shut down all the running instances of that executable file.</para>
          <para>Although a process <see cref="P:System.Diagnostics.Process.Id" /> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the <paramref name="processName" /> parameter. Therefore, <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> returns one process at most, but <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" /> returns an array containing all the associated processes. If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier. You cannot access process resources through the process name alone but, once you have retrieved an array of <see cref="T:System.Diagnostics.Process" /> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</para>
          <para>You can use this overload to get processes on the local computer as well as on a remote computer. Use "." to specify the local computer. Another overload exists that uses the local computer by default.</para>
          <para>You can access processes on remote computers only to view information, such as statistics, about the processes. You cannot close, terminate (using <see cref="M:System.Diagnostics.Process.Kill" />), or start processes on remote computers.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</para>
        </returns>
        <param name="processName">
          <attribution license="cc4" from="Microsoft" modified="false" />The friendly name of the process. </param>
        <param name="machineName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of a computer on the network. </param>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handle for this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'IntPtr'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An application can obtain a handle to a process that can be used as a parameter to many process-information and control functions. You can use this handle to initialize a <see cref="T:System.Threading.WaitHandle" /> or to call native methods with platform invoke.</para>
          <para>This process handle is private to an application--in other words, process handles cannot be shared. A process also has a process <see cref="P:System.Diagnostics.Process.Id" /> which, unlike the <see cref="P:System.Diagnostics.Process.Handle" />, is unique and, therefore, valid throughout the system.</para>
          <para>Only processes started through a call to <see cref="M:System.Diagnostics.Process.Start" /> set the <see cref="P:System.Diagnostics.Process.Handle" /> property of the corresponding <see cref="T:System.Diagnostics.Process" /> instances.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the native handle of the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Handles provide a way for a process to refer to objects. A process can obtain handles to files, resources, message queues, and many other operating system objects. The operating system reclaims the memory associated with the process only when the handle count is zero.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of handles opened by the process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Determines if the process is still running.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'bool'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A value of true for <see cref="P:System.Diagnostics.Process.HasExited" /> indicates that the associated process has terminated, either normally or abnormally. You can request or force the associated process to exit by calling <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> or <see cref="M:System.Diagnostics.Process.Kill" />. If a handle is open to the process, the operating system releases the process memory when the process has exited, but retains administrative information about the process, such as the handle, exit code, and exit time. To get this information, you can use the <see cref="P:System.Diagnostics.Process.ExitCode" /> and <see cref="P:System.Diagnostics.Process.ExitTime" /> properties. These properties are populated automatically for processes that were started by this component. The administrative information is released when all the <see cref="T:System.Diagnostics.Process" /> components that are associated with the system process are destroyed and hold no more handles to the exited process.</para>
          <para>A process can terminate independently of your code. If you started the process using this component, the system updates the value of <see cref="P:System.Diagnostics.Process.HasExited" /> automatically, even if the associated process exits independently.</para>
          <block subset="none" type="note">
            <para>When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this property returns true. To ensure that asynchronous event handling has been completed, call the <see cref="M:System.Diagnostics.Process.WaitForExit" /> overload that takes no parameter before checking <see cref="P:System.Diagnostics.Process.HasExited" />.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the associated process has been terminated.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process identifier.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The process <see cref="P:System.Diagnostics.Process.Id" /> is not valid if the associated process is not running. Therefore, you should ensure that the process is running before attempting to retrieve the <see cref="P:System.Diagnostics.Process.Id" /> property. Until the process terminates, the process identifier uniquely identifies the process throughout the system.</para>
          <para>You can connect a process that is running on a local or remote computer to a new <see cref="T:System.Diagnostics.Process" /> instance by passing the process identifier to the <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> method. <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" /> is a static method that creates a new component and sets the <see cref="P:System.Diagnostics.Process.Id" /> property for the new <see cref="T:System.Diagnostics.Process" /> instance automatically.</para>
          <para>Process identifiers can be reused by the system. The <see cref="P:System.Diagnostics.Process.Id" /> property value is unique only while the associated process is running. After the process has terminated, the system can reuse the <see cref="P:System.Diagnostics.Process.Id" /> property value for an unrelated process.</para>
          <para>Because the identifier is unique on the system, you can pass it to other threads as an alternative to passing a <see cref="T:System.Diagnostics.Process" /> instance. This action can save system resources yet guarantee that the process is correctly identified.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the unique identifier for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Diagnostics.Process.Kill" /> forces a termination of the process, while <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> only requests a termination. When a process with a graphical interface is executing, its message loop is in a wait state. The message loop executes every time a Windows message is sent to the process by the operating system. Calling <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application. The request to exit the process by calling <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> does not force the application to quit. The application can ask for user verification before quitting, or it can refuse to quit. To force the application to quit, use the <see cref="M:System.Diagnostics.Process.Kill" /> method. The behavior of <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> is identical to that of a user closing an application's main window using the system menu. Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</para>
          <block subset="none" type="note">
            <para>The <see cref="M:System.Diagnostics.Process.Kill" /> method executes asynchronously. After calling the <see cref="M:System.Diagnostics.Process.Kill" /> method, call the <see cref="Overload:System.Diagnostics.Process.WaitForExit" /> method to wait for the process to exit, or check the <see cref="P:System.Diagnostics.Process.HasExited" /> property to determine if the process has exited.</para>
          </block>
          <para>Data edited by the process or resources allocated to the process can be lost if you call <see cref="M:System.Diagnostics.Process.Kill" />. <see cref="M:System.Diagnostics.Process.Kill" /> causes an abnormal process termination and should be used only when necessary. <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface. If <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> fails, you can use <see cref="M:System.Diagnostics.Process.Kill" /> to terminate the process. <see cref="M:System.Diagnostics.Process.Kill" /> is the only way to terminate processes that do not have graphical interfaces.</para>
          <para>You can call <see cref="M:System.Diagnostics.Process.Kill" /> and <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> only for processes that are running on the local computer. You cannot cause processes on remote computers to exit. You can only view information for processes running on remote computers.</para>
          <block subset="none" type="note">
            <para>If the call to the <see cref="M:System.Diagnostics.Process.Kill" /> method is made while the process is currently terminating, a <see cref="T:System.ComponentModel.Win32Exception" /> is thrown for Access Denied.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Immediately stops the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Some operating system processes run in a special mode. Attempting to read properties of or attach to these processes is not possible unless you have called <see cref="M:System.Diagnostics.Process.EnterDebugMode" /> on the component. Call <see cref="M:System.Diagnostics.Process.LeaveDebugMode" /> when you no longer need access to these processes that run in special mode.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the computer running the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'string'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can view statistical data and process information for processes running on remote computers but you cannot call <see cref="M:System.Diagnostics.Process.Start" />, <see cref="M:System.Diagnostics.Process.CloseMainWindow" />, or <see cref="M:System.Diagnostics.Process.Kill" /> on remote computers.</para>
          <block subset="none" type="note">
            <para>When the associated process is executing on the local machine, this property returns a period (".") for the machine name. You should use the <see cref="P:System.Environment.MachineName" /> property to get the correct machine name. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the name of the computer the associated process is running on.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'ProcessModule'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A process module represents a.dll or .exe file that is loaded into a particular process. The <see cref="P:System.Diagnostics.Process.MainModule" /> property lets you view information about the executable used to start the process, including the module name, file name, and module memory details.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the main module for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'IntPtr'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The main window is the window opened by the process that currently has the focus (the <see cref="P:System.Windows.Forms.Form.TopLevel" /> form). You must use the <see cref="M:System.Diagnostics.Process.Refresh" /> method to refresh the <see cref="T:System.Diagnostics.Process" /> object to get the current main window handle if it has changed.</para>
          <para>You can get the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property only for processes that are running on the local computer. The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property is a value that uniquely identifies the window that is associated with the process.</para>
          <para>A process has a main window associated with it only if the process has a graphical interface. If the associated process does not have a main window, the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> value is zero. The value is also zero for processes that have been hidden, that is, processes that are not visible in the taskbar. This can be the case for processes that appear as icons in the notification area, at the far right of the taskbar. </para>
          <para>If you have just started a process and want to use its main window handle, consider using the <see cref="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" /> method to allow the process to finish starting, ensuring that the main window handle has been created. Otherwise, an exception will be thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the window handle of the main window of the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'string'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A process has a main window associated with it only if the process has a graphical interface. If the associated process does not have a main window (so that <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is zero), <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> is an empty string (""). If you have just started a process and want to use its main window title, consider using the <see cref="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" /> method to allow the process to finish starting, ensuring that the main window handle has been created. Otherwise, the system throws an exception.</para>
          <block subset="none" type="note">
            <para>The main window is the window that currently has the focus; note that this might not be the primary window for the process. You must use the <see cref="M:System.Diagnostics.Process.Refresh" /> method to refresh the <see cref="T:System.Diagnostics.Process" /> object to get the current main window handle if it has changed.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the caption of the main window of the process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum working set for this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'IntPtr'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault.</para>
          <para>The working set includes both shared and private data. The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files. As the working set size increases, memory demand increases.</para>
          <para>A process has minimum and maximum working set sizes. Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process. The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</para>
          <para>The system sets the default working set sizes. You can modify these sizes using the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> and <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> members. However, setting these values does not guarantee that the memory will be reserved or resident.</para>
          <block subset="none" type="note">
            <para>When you increase the working set size of a process, you take physical memory away from the rest of the system. Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the maximum allowable working set size for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum working set for this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'IntPtr'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault.</para>
          <para>The working set includes both shared and private data. The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files. As the working set size increases, memory demand increases.</para>
          <para>A process has minimum and maximum working set sizes. Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process. The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</para>
          <para>The system sets the default working set sizes. You can modify these sizes using the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> and <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> members. However, setting these values does not guarantee that the memory will be reserved or resident.</para>
          <block subset="none" type="note">
            <para>When you increase the working set size of a process, you take physical memory away from the rest of the system. Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the minimum allowable working set size for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'ProcessModuleCollection'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A process module represents a.dll or .exe file that is loaded into a particular process. A <see cref="T:System.Diagnostics.ProcessModule" /> instance lets you view information about a module, including the module name, file name, and module memory details.</para>
          <para>A process can load multiple modules into memory. For example,.exe files that load additional .dll files have multiple modules.</para>
          <para>After starting the process, this collection is empty until the system has loaded the process. If the process has a main window, you can call <see cref="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" /> before retrieving this property to ensure that the collection is nonempty when you get the list.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the modules that have been loaded by the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the nonpaged system memory size allocated to this process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by this property represents the current size of nonpaged system memory used by the process. System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools. Nonpaged memory allocations remain in system memory and are not paged out to the virtual memory paging file.</para>
          <para>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the <ui>Pool Nonpaged Bytes</ui> performance counter for the process. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the amount of nonpaged system memory allocated for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Diagnostics.Process.OnExited" /> is the API method that raises the <see cref="E:System.Diagnostics.Process.Exited" /> event. Calling <see cref="M:System.Diagnostics.Process.OnExited" /> causes the <see cref="E:System.Diagnostics.Process.Exited" /> event to occur and is the only way to raise the event using the <see cref="T:System.Diagnostics.Process" /> component. <see cref="M:System.Diagnostics.Process.OnExited" /> is primarily used when deriving classes from the component.</para>
          <para>As an alternative to <see cref="M:System.Diagnostics.Process.OnExited" />, you can write your own event handler. You create your own event handler delegate and your own event-handling method.</para>
          <block subset="none" type="note">
            <para>If you are using the Visual Studio environment, an event handler delegate (AddOnExited) and an event-handling method (Process1_Exited) are created for you when you drag a <see cref="T:System.Diagnostics.Process" /> component onto a form and double-click the icon. The code you create to run when the <see cref="E:System.Diagnostics.Process.Exited" /> event occurs is entered into the Process1_Exited procedure. You do not need to create the <see cref="M:System.Diagnostics.Process.OnExited" /> member, because it is implemented for you.</para>
          </block>
          <para>Raising an event invokes the event handler through a delegate. For an overview, see <format type="text/html"><a href="F2ADAF01-1ED1-42E1-8C31-8D467E7E0EE2">[&lt;topic://cpconProvidingEventFunctionality&gt;]</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised when it receives output data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="E:System.Diagnostics.Process.OutputDataReceived" /> event indicates that the associated <see cref="T:System.Diagnostics.Process" /> has written to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</para>
          <para>The event is enabled during asynchronous read operations on <see cref="P:System.Diagnostics.Process.StandardOutput" />. To start asynchronous read operations, you must redirect the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of a <see cref="T:System.Diagnostics.Process" />, add your event handler to the <see cref="E:System.Diagnostics.Process.OutputDataReceived" /> event, and call <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />. Thereafter, the <see cref="E:System.Diagnostics.Process.OutputDataReceived" /> event signals each time the process writes a line to the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream, until the process exits or calls <see cref="M:System.Diagnostics.Process.CancelOutputRead" />.</para>
          <block subset="none" type="note">
            <para>The application that is processing the asynchronous output should call the <see cref="M:System.Diagnostics.Process.WaitForExit" /> method to ensure that the output buffer has been flushed.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the paged memory size.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by this property represents the current size of memory in the virtual memory paging file used by the process. The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process. When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk. To obtain the size of memory used by the operating system for the process, use the <see cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" /> property.</para>
          <para>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the <ui>Page File Bytes</ui> performance counter for the process. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the amount of paged memory allocated for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the paged system memory size.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by this property value represents the current size of pageable system memory used by the process. System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools. When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk. To obtain the size of the application memory used by the process, use the <see cref="P:System.Diagnostics.Process.PagedMemorySize64" /> property.</para>
          <para>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the <ui>Pool Paged Bytes</ui> performance counter for the process. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the amount of pageable system memory allocated for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the peak paged memory size.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by this property value represents the maximum size of memory in the virtual memory paging file used by the process since it started. The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process. When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</para>
          <para>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the <ui>Page File Bytes Peak</ui> performance counter for the process. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the maximum amount of memory in the virtual memory paging file used by the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the peak virtual memory size.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by this property represents the maximum size of virtual memory used by the process since it started. The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</para>
          <para>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the <ui>Virtual Bytes Peak</ui> performance counter for the process. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the maximum amount of virtual memory used by the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault.</para>
          <para>The working set includes both shared and private data. The shared data includes the pages that contain all the instructions that the process executes, including process modules and the system libraries.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the peak working set size for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by this property represents the maximum size of working set memory used by the process since it started. The working set of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault.</para>
          <para>The working set includes both shared and private data. The shared data includes the pages that contain all the instructions that the process executes, including instructions from the process modules and the system libraries.</para>
          <para>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the <ui>Working Set Peak</ui> performance counter for the process. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the maximum amount of physical memory used by the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'bool'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When a thread runs in a process for which the priority class has one of the dynamic priority enumeration values (<see cref="F:System.Diagnostics.ProcessPriorityClass.Normal" />, <see cref="F:System.Diagnostics.ProcessPriorityClass.High" />, or <see cref="F:System.Diagnostics.ProcessPriorityClass.RealTime" />), the system temporarily boosts the thread's priority when it is taken out of a wait state. This action prevents other processes from interrupting the processing of the current thread. The <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> setting affects all the existing threads and any threads subsequently created by the process. To restore normal behavior, set the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property to false.</para>
          <block subset="none" type="note">
            <para>Boosting the priority too high can drain resources from essential operating system and network functions, causing problems with other operating system tasks.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The relative process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoLimitation("Under Unix, only root is allowed to raise the priority.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'ProcessPriorityClass'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A process priority class encompasses a range of thread priority levels. Threads with different priorities that are running in the process run relative to the priority class of the process. Win32 uses four priority classes with seven base priority levels per class. These process priority classes are captured in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration, which lets you set the process priority to <see cref="F:System.Diagnostics.ProcessPriorityClass.Idle" />, <see cref="F:System.Diagnostics.ProcessPriorityClass.Normal" />, <see cref="F:System.Diagnostics.ProcessPriorityClass.High" />, <see cref="F:System.Diagnostics.ProcessPriorityClass.AboveNormal" />, <see cref="F:System.Diagnostics.ProcessPriorityClass.BelowNormal" />, or <see cref="F:System.Diagnostics.ProcessPriorityClass.RealTime" />. Based on the time elapsed or other boosts, the base priority level can be changed by the operating system when a process needs to be put ahead of others for access to the processor. In addition, you can set the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> to temporarily boost the priority level of threads that have been taken out of the wait state. The priority is reset when the process returns to the wait state.</para>
          <para>The <see cref="P:System.Diagnostics.Process.BasePriority" /> property lets you view the starting priority that is assigned to a process. However, because it is read-only, you cannot use the <see cref="P:System.Diagnostics.Process.BasePriority" /> property to set the priority of a process. To change the priority, use the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property, which gets or sets the overall priority category for the process.</para>
          <para>The priority class cannot be viewed using System Monitor. The following table shows the relationship between the <see cref="P:System.Diagnostics.Process.BasePriority" /> and <see cref="P:System.Diagnostics.Process.PriorityClass" /> values.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>BasePriority </para>
                </term>
                <description>
                  <para>PriorityClass </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>4 </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.Diagnostics.ProcessPriorityClass.Idle" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>8 </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.Diagnostics.ProcessPriorityClass.Normal" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>13 </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.Diagnostics.ProcessPriorityClass.High" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>24 </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.Diagnostics.ProcessPriorityClass.RealTime" /> </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the overall priority category for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the private memory size.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by this property represents the current size of memory used by the process that cannot be shared with other processes.</para>
          <para>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the <ui>Private Bytes</ui> performance counter for the process. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the amount of private memory allocated for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of processing time spent in the OS core for this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'TimeSpan'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the privileged processor time for this process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'string'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Diagnostics.Process.ProcessName" /> property holds an executable file name, such as Outlook, that does not include the .exe extension or the path. It is helpful for getting and manipulating all the processes that are associated with the same executable file.</para>
          <block subset="none" type="note">
            <para>On win2kfamily operating systems, the <see cref="P:System.Diagnostics.Process.ProcessName" /> property may be truncated to 15 characters if the process module information cannot be obtained.</para>
          </block>
          <para>You can call <see cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />, passing it an executable file name, to retrieve an array that contains every running instance on the specified computer. You can use this array, for example, to shut down all the running instances of the executable file.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the name of the process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'IntPtr'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In Windows 2000 and later, a thread in a process can migrate from processor to processor, with each migration reloading the processor cache. Under heavy system loads, specifying which processor should run a specific thread can improve performance by reducing the number of times the processor cache is reloaded. The association between a processor and a thread is called the processor affinity.</para>
          <para>Each processor is represented as a bit. Bit 0 is processor one, bit 1 is processor two, and so forth. If you set a bit to the value 1, the corresponding processor is selected for thread assignment. When you set the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> value to zero, the operating system's scheduling algorithms set the thread's affinity. When the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> value is set to any nonzero value, the value is interpreted as a bitmask that specifies those processors eligible for selection.</para>
          <para>The following table shows a selection of <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> values for an eight-processor system.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Bitmask </para>
                </term>
                <description>
                  <para>Binary value </para>
                </description>
                <description>
                  <para>Eligible processors </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>0x0001 </para>
              </term>
              <description>
                <para>00000000 00000001 </para>
              </description>
              <description>
                <para>1 </para>
              </description>
            </item>
            <item>
              <term>
                <para>0x0003 </para>
              </term>
              <description>
                <para>00000000 00000011 </para>
              </description>
              <description>
                <para>1 and 2 </para>
              </description>
            </item>
            <item>
              <term>
                <para>0x0007 </para>
              </term>
              <description>
                <para>00000000 00000111 </para>
              </description>
              <description>
                <para>1, 2 and 3 </para>
              </description>
            </item>
            <item>
              <term>
                <para>0x0009 </para>
              </term>
              <description>
                <para>00000000 00001001 </para>
              </description>
              <description>
                <para>1 and 4 </para>
              </description>
            </item>
            <item>
              <term>
                <para>0x007F </para>
              </term>
              <description>
                <para>00000000 01111111 </para>
              </description>
              <description>
                <para>1, 2, 3, 4, 5, 6 and 7 </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the processors on which the threads in this process can be scheduled to run.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>After <see cref="M:System.Diagnostics.Process.Refresh" /> is called, the first request for information about each property causes the process component to obtain a new value from the associated process.</para>
          <para>When a <see cref="T:System.Diagnostics.Process" /> component is associated with a process resource, the property values of the <see cref="T:System.Diagnostics.Process" /> are immediately populated according to the status of the associated process. If the information about the associated process subsequently changes, those changes are not reflected in the <see cref="T:System.Diagnostics.Process" /> component's cached values. The <see cref="T:System.Diagnostics.Process" /> component is a snapshot of the process resource at the time they are associated. To view the current values for the associated process, call the <see cref="M:System.Diagnostics.Process.Refresh" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Discards any information about the associated process that has been cached inside the process component.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'bool'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If a process has a user interface, the <see cref="P:System.Diagnostics.Process.Responding" /> property contacts the user interface to determine whether the process is responding to user input. If the interface does not respond immediately, the <see cref="P:System.Diagnostics.Process.Responding" /> property returns false. Use this property to determine whether the interface of the associated process has stopped responding.</para>
          <para>If the process does not have a <see cref="P:System.Diagnostics.Process.MainWindowHandle" />, this property returns true.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the user interface of the process is responding.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Diagnostics.Process.SessionId" /> property identifies the session in which the application is currently running.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the Terminal Services session identifier for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The standard error stream of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'IO.StreamReader'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When a <see cref="T:System.Diagnostics.Process" /> writes text to its standard error stream, that text is normally displayed on the console. By redirecting the <see cref="P:System.Diagnostics.Process.StandardError" /> stream, you can manipulate or suppress the error output of a process. For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</para>
          <block subset="none" type="note">
            <para>To use <see cref="P:System.Diagnostics.Process.StandardError" />, you must set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to false, and you must set <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> to true. Otherwise, reading from the <see cref="P:System.Diagnostics.Process.StandardError" /> stream throws an exception.</para>
          </block>
          <para>The redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream can be read synchronously or asynchronously. Methods such as <see cref="M:System.IO.StreamReader.Read" />, <see cref="M:System.IO.StreamReader.ReadLine" />, and <see cref="M:System.IO.StreamReader.ReadToEnd" /> perform synchronous read operations on the error output stream of the process. These synchronous read operations do not complete until the associated <see cref="T:System.Diagnostics.Process" /> writes to its <see cref="P:System.Diagnostics.Process.StandardError" /> stream, or closes the stream.</para>
          <para>In contrast, <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> starts asynchronous read operations on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream. This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</para>
          <para>Synchronous read operations introduce a dependency between the caller reading from the <see cref="P:System.Diagnostics.Process.StandardError" /> stream and the child process writing to that stream. These dependencies can result in deadlock conditions. When the caller reads from the redirected stream of a child process, it is dependent on the child. The caller waits on the read operation until the child writes to the stream or closes the stream. When the child process writes enough data to fill its redirected stream, it is dependent on the parent. The child process waits on the next write operation until the parent reads from the full stream or closes the stream. The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed. You can avoid deadlocks by evaluating dependencies between the caller and child process.</para>
          <para>The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</para>
          <code>// Start the child process.
 Process p = new Process();
 // Redirect the error stream of the child process.
 p.StartInfo.UseShellExecute = false;
 p.StartInfo.RedirectStandardError = true;
 p.StartInfo.FileName = "Write500Lines.exe";
 p.Start();
 // Do not wait for the child process to exit before
 // reading to the end of its redirected error stream.
 // p.WaitForExit();
 // Read the error stream first and then wait.
 string error = p.StandardError.ReadToEnd();
 p.WaitForExit();</code>
          <para>The code example avoids a deadlock condition by calling p.StandardError.ReadToEnd before p.WaitForExit. A deadlock condition can result if the parent process calls p.WaitForExit before p.StandardError.ReadToEnd and the child process writes enough text to fill the redirected stream. The parent process would wait indefinitely for the child process to exit. The child process would wait indefinitely for the parent to read from the full <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</para>
          <para>There is a similar issue when you read all text from both the standard output and standard error streams. The following C# code, for example, performs a read operation on both streams.</para>
          <code> // Do not perform a synchronous read to the end of both 
 // redirected streams.
 // string output = p.StandardOutput.ReadToEnd();
 // string error = p.StandardError.ReadToEnd();
 // p.WaitForExit();
 // Use asynchronous read operations on at least one of the streams.
 p.BeginOutputReadLine();
 string error = p.StandardError.ReadToEnd();
 p.WaitForExit();</code>
          <para>The code example avoids the deadlock condition by performing asynchronous read operations on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream. A deadlock condition results if the parent process calls p.StandardOutput.ReadToEnd followed by p.StandardError.ReadToEnd and the child process writes enough text to fill its error stream. The parent process would wait indefinitely for the child process to close its <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream. The child process would wait indefinitely for the parent to read from the full <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</para>
          <para>You can use asynchronous read operations to avoid these dependencies and their deadlock potential. Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</para>
          <block subset="none" type="note">
            <para>You cannot mix asynchronous and synchronous read operations on a redirected stream. Once the redirected stream of a <see cref="T:System.Diagnostics.Process" /> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. For example, do not follow <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> with a call to <see cref="M:System.IO.StreamReader.ReadLine" /> on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream, or vice versa. However, you can read two different streams in different modes. For example, you can call <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> and then call <see cref="M:System.IO.StreamReader.ReadLine" /> for the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a stream used to read the error output of the application.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The standard input stream of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'IO.StreamWriter'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Diagnostics.Process" /> can read input text from its standard input stream, typically the keyboard. By redirecting the <see cref="P:System.Diagnostics.Process.StandardInput" /> stream, you can programmatically specify the input. For example, instead of using keyboard input, you can provide text from the contents of a designated file or output from another application.</para>
          <block subset="none" type="note">
            <para>To use <see cref="P:System.Diagnostics.Process.StandardInput" />, you must set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to false, and you must set <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> to true. Otherwise, writing to the <see cref="P:System.Diagnostics.Process.StandardInput" /> stream throws an exception.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a stream used to write the input of the application.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The standard output stream of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'IO.StreamReader'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When a <see cref="T:System.Diagnostics.Process" /> writes text to its standard stream, that text is normally displayed on the console. By redirecting the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream, you can manipulate or suppress the output of a process. For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</para>
          <block subset="none" type="note">
            <para>To use <see cref="P:System.Diagnostics.Process.StandardOutput" />, you must set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to false, and you must set <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> to true. Otherwise, reading from the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream throws an exception.</para>
          </block>
          <para>The redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream can be read synchronously or asynchronously. Methods such as <see cref="M:System.IO.StreamReader.Read" />, <see cref="M:System.IO.StreamReader.ReadLine" />, and <see cref="M:System.IO.StreamReader.ReadToEnd" /> perform synchronous read operations on the output stream of the process. These synchronous read operations do not complete until the associated <see cref="T:System.Diagnostics.Process" /> writes to its <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream, or closes the stream.</para>
          <para>In contrast, <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> starts asynchronous read operations on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream. This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</para>
          <para>Synchronous read operations introduce a dependency between the caller reading from the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream and the child process writing to that stream. These dependencies can result in deadlock conditions. When the caller reads from the redirected stream of a child process, it is dependent on the child. The caller waits on the read operation until the child writes to the stream or closes the stream. When the child process writes enough data to fill its redirected stream, it is dependent on the parent. The child process waits on the next write operation until the parent reads from the full stream or closes the stream. The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed. You can avoid deadlocks by evaluating dependencies between the caller and child process.</para>
          <para>The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</para>
          <code> // Start the child process.
 Process p = new Process();
 // Redirect the output stream of the child process.
 p.StartInfo.UseShellExecute = false;
 p.StartInfo.RedirectStandardOutput = true;
 p.StartInfo.FileName = "Write500Lines.exe";
 p.Start();
 // Do not wait for the child process to exit before
 // reading to the end of its redirected stream.
 // p.WaitForExit();
 // Read the output stream first and then wait.
 string output = p.StandardOutput.ReadToEnd();
 p.WaitForExit();</code>
          <para>The code example avoids a deadlock condition by calling p.StandardOutput.ReadToEnd before p.WaitForExit. A deadlock condition can result if the parent process calls p.WaitForExit before p.StandardOutput.ReadToEnd and the child process writes enough text to fill the redirected stream. The parent process would wait indefinitely for the child process to exit. The child process would wait indefinitely for the parent to read from the full <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</para>
          <para>There is a similar issue when you read all text from both the standard output and standard error streams. The following C# code, for example, performs a read operation on both streams.</para>
          <code> // Do not perform a synchronous read to the end of both 
 // redirected streams.
 // string output = p.StandardOutput.ReadToEnd();
 // string error = p.StandardError.ReadToEnd();
 // p.WaitForExit();
 // Use asynchronous read operations on at least one of the streams.
 p.BeginOutputReadLine();
 string error = p.StandardError.ReadToEnd();
 p.WaitForExit();</code>
          <para>The code example avoids the deadlock condition by performing asynchronous read operations on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream. A deadlock condition results if the parent process calls p.StandardOutput.ReadToEnd followed by p.StandardError.ReadToEnd and the child process writes enough text to fill its error stream. The parent process would wait indefinitely for the child process to close its <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream. The child process would wait indefinitely for the parent to read from the full <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</para>
          <para>You can use asynchronous read operations to avoid these dependencies and their deadlock potential. Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</para>
          <block subset="none" type="note">
            <para>You cannot mix asynchronous and synchronous read operations on a redirected stream. Once the redirected stream of a <see cref="T:System.Diagnostics.Process" /> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. For example, do not follow <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> with a call to <see cref="M:System.IO.StreamReader.ReadLine" /> on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream, or vice versa. However, you can read two different streams in different modes. For example, you can call <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> and then call <see cref="M:System.IO.StreamReader.ReadLine" /> for the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a stream used to read the output of the application.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this overload to start a process resource and associate it with the current <see cref="T:System.Diagnostics.Process" /> component. The return value true indicates that a new process resource was started. If the process resource specified by the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and false is returned.</para>
          <para>You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.</para>
          <block subset="none" type="note">
            <para>If you are using Visual Studio, this overload of the <see cref="M:System.Diagnostics.Process.Start" /> method is the one that you insert into your code after you drag a <see cref="T:System.Diagnostics.Process" /> component onto the designer. Use the Properties window to expand the StartInfo category and write the appropriate value into the FileName property. Your changes will appear in the form's InitializeComponent procedure.</para>
          </block>
          <para>This overload of <see cref="M:System.Diagnostics.Process.Start" /> is not a static method. You must call it from an instance of the <see cref="T:System.Diagnostics.Process" /> class. Before calling <see cref="M:System.Diagnostics.Process.Start" />, you must first specify <see cref="P:System.Diagnostics.Process.StartInfo" /> property information for this <see cref="T:System.Diagnostics.Process" /> instance, because that information is used to determine the process resource to start.</para>
          <para>The other overloads of the <see cref="M:System.Diagnostics.Process.Start" /> method are static members. You do not need to create an instance of the <see cref="T:System.Diagnostics.Process" /> component before you call those overloads of the method. Instead, you can call <see cref="M:System.Diagnostics.Process.Start" /> for the <see cref="T:System.Diagnostics.Process" /> class itself, and a new <see cref="T:System.Diagnostics.Process" /> component is created if the process was started. Or, null is returned if a process was reused. The process resource is automatically associated with the new <see cref="T:System.Diagnostics.Process" /> component that is returned by the <see cref="M:System.Diagnostics.Process.Start" /> method.</para>
          <para>The <see cref="P:System.Diagnostics.Process.StartInfo" /> members can be used to duplicate the functionality of the Run dialog box of the Windows Start menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <see cref="P:System.Diagnostics.Process.StartInfo" /> property. The only <see cref="P:System.Diagnostics.Process.StartInfo" /> property that must be set is the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property. The <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.</para>
          <para>In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <see cref="P:System.Diagnostics.ProcessStartInfo.Verb" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property. For other types of files, you can specify command-line arguments when you start the file from the Run dialog box. For example, you can pass a URL as an argument if you specify your browser as the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />. These arguments can be specified in the <see cref="P:System.Diagnostics.Process.StartInfo" /> property's <see cref="P:System.Diagnostics.ProcessStartInfo.Arguments" /> member.</para>
          <para>If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if c:\mypath is not in your path, and you add it using quotation marks: path = %path%;"c:\mypath", you must fully qualify any process in c:\mypath when starting it.</para>
          <block subset="none" type="note">
            <para>ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <see cref="Overload:System.Diagnostics.Process.Start" /> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.</para>
          </block>
          <para>Whenever you use <see cref="M:System.Diagnostics.Process.Start" /> to start a process, you might need to close it or you risk losing system resources. Close processes using <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> or <see cref="M:System.Diagnostics.Process.Kill" />.</para>
          <para>A note about apartment states in managed threads is necessary here. When <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is true on the process component's <see cref="P:System.Diagnostics.Process.StartInfo" /> property, make sure you have set a threading model on your application by setting the attribute [STAThread] on the main() method. Otherwise, a managed thread can be in an unknown state or put in the MTA state, the latter of which conflicts with <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> being true. Some methods require that the apartment state not be unknown. If the state is not explicitly set, when the application encounters such a method, it defaults to MTA, and once set, the apartment state cannot be changed. However, MTA causes an exception to be thrown when the operating system shell is managing the thread.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if a process resource is started; false if no new process resource is started (for example, if an existing process is reused).</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this overload to start a process resource by specifying a <see cref="T:System.Diagnostics.ProcessStartInfo" /> instance. The overload associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component. If the process is already running, no additional process resource is started. Instead, the existing process resource is reused and no new <see cref="T:System.Diagnostics.Process" /> component is created. In such a case, instead of returning a new <see cref="T:System.Diagnostics.Process" /> component, <see cref="M:System.Diagnostics.Process.Start" /> returns null to the calling procedure.</para>
          <block subset="none" type="note">
            <para>If the address of the executable file to start is a URL, the process is not started and null is returned.</para>
          </block>
          <para>This overload lets you start a process without first creating a new <see cref="T:System.Diagnostics.Process" /> instance. Using this overload with a <see cref="T:System.Diagnostics.ProcessStartInfo" /> parameter is an alternative to the explicit steps of creating a new <see cref="T:System.Diagnostics.Process" /> instance, setting its <see cref="P:System.Diagnostics.Process.StartInfo" /> properties, and calling <see cref="M:System.Diagnostics.Process.Start" /> for the <see cref="T:System.Diagnostics.Process" /> instance.</para>
          <para>Using a <see cref="T:System.Diagnostics.ProcessStartInfo" /> instance as the parameter lets you call <see cref="M:System.Diagnostics.Process.Start" /> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <see cref="T:System.Diagnostics.ProcessStartInfo" /> instance, although that is an option. The only <see cref="P:System.Diagnostics.Process.StartInfo" /> property that must be set is the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property. The <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word. </para>
          <para>You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.</para>
          <para>If the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> properties of the <see cref="P:System.Diagnostics.Process.StartInfo" /> instance are set, the unmanaged <unmanagedCodeEntityReference>CreateProcessWithLogonW</unmanagedCodeEntityReference> function is called, which starts the process in a new window even if the <see cref="P:System.Diagnostics.ProcessStartInfo.CreateNoWindow" /> property value is true or the <see cref="P:System.Diagnostics.ProcessStartInfo.WindowStyle" /> property value is <see cref="F:System.Diagnostics.ProcessWindowStyle.Hidden" />.</para>
          <para>Unlike the other overloads, the overload of <see cref="M:System.Diagnostics.Process.Start" /> that has no parameters is not a static member. Use that overload when you have already created a <see cref="T:System.Diagnostics.Process" /> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <see cref="T:System.Diagnostics.Process" /> instance. Use one of the static overloads when you want to create a new <see cref="T:System.Diagnostics.Process" /> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <see cref="T:System.Diagnostics.ProcessStartInfo" /> instance.</para>
          <para>If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if c:\mypath is not in your path, and you add it using quotation marks: path = %path%;"c:\mypath", you must fully qualify any process in c:\mypath when starting it.</para>
          <block subset="none" type="note">
            <para>ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <see cref="Overload:System.Diagnostics.Process.Start" /> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.</para>
          </block>
          <para>Whenever you use <see cref="M:System.Diagnostics.Process.Start" /> to start a process, you might need to close it or you risk losing system resources. Close processes using <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> or <see cref="M:System.Diagnostics.Process.Kill" />.</para>
          <para>A note about apartment states in managed threads is necessary here. When <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is true on the <paramref name="startInfo" /> parameter, make sure you have set a threading model on your application by setting the attribute [STAThread] on the main() method. Otherwise, a managed thread can be in an unknown state or put in the MTA state, the latter of which conflicts with <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> being true. Some methods require that the apartment state not be unknown. If the state is not explicitly set, when the application encounters such a method, it defaults to MTA, and once set, the apartment state cannot be changed. However, MTA causes an exception to be thrown when the operating system shell is managing the thread.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new <see cref="T:System.Diagnostics.Process" /> component that is associated with the process resource, or null if no process resource is started (for example, if an existing process is reused).</para>
        </returns>
        <param name="startInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments. </param>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component. If the process is already running, no additional process resource is started. Instead, the existing process resource is reused and no new <see cref="T:System.Diagnostics.Process" /> component is created. In such a case, instead of returning a new <see cref="T:System.Diagnostics.Process" /> component, <see cref="M:System.Diagnostics.Process.Start" /> returns null to the calling procedure.</para>
          <block subset="none" type="note">
            <para>If the address of the executable file to start is a URL, the process is not started and null is returned.</para>
          </block>
          <para>This overload lets you start a process without first creating a new <see cref="T:System.Diagnostics.Process" /> instance. The overload is an alternative to the explicit steps of creating a new <see cref="T:System.Diagnostics.Process" /> instance, setting the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property, and calling <see cref="M:System.Diagnostics.Process.Start" /> for the <see cref="T:System.Diagnostics.Process" /> instance. </para>
          <para>You can start a ClickOnce application by setting the <paramref name="fileName" /> parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.</para>
          <para>Starting a process by specifying its file name is similar to typing the information in the Run dialog box of the Windows Start menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the Run dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <paramref name="fileName" /> parameter. For example, you can set the <paramref name="fileName" /> parameter to either "Notepad.exe" or "Notepad".</para>
          <para>This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <see cref="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" /> or <see cref="M:System.Diagnostics.Process.Start(System.String,System.String)" /> overloads.</para>
          <para>Unlike the other overloads, the overload of <see cref="M:System.Diagnostics.Process.Start" /> that has no parameters is not a static member. Use that overload when you have already created a <see cref="T:System.Diagnostics.Process" /> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <see cref="T:System.Diagnostics.Process" /> instance. Use one of the static overloads when you want to create a new <see cref="T:System.Diagnostics.Process" /> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.</para>
          <para>If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if c:\mypath is not in your path, and you add it using quotation marks: path = %path%;"c:\mypath", you must fully qualify any process in c:\mypath when starting it.</para>
          <block subset="none" type="note">
            <para>ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <see cref="Overload:System.Diagnostics.Process.Start" /> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.</para>
          </block>
          <para>Whenever you use <see cref="M:System.Diagnostics.Process.Start" /> to start a process, you might need to close it or you risk losing system resources. Close processes using <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> or <see cref="M:System.Diagnostics.Process.Kill" />.</para>
          <para>A note about apartment states in managed threads is necessary here. When <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is true on the process component's <see cref="P:System.Diagnostics.Process.StartInfo" /> property, make sure you have set a threading model on your application by setting the attribute [STAThread] on the main() method. Otherwise, a managed thread can be in an unknown state or put in the MTA state, the latter of which conflicts with <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> being true. Some methods require that the apartment state not be unknown. If the state is not explicitly set, when the application encounters such a method, it defaults to MTA, and once set, the apartment state cannot be changed. However, MTA causes an exception to be thrown when the operating system shell is managing the thread.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new <see cref="T:System.Diagnostics.Process" /> component that is associated with the process resource, or null, if no process resource is started (for example, if an existing process is reused).</para>
        </returns>
        <param name="fileName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of a document or application file to run in the process. </param>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component. If the process is already running, no additional process is started. Instead, the existing process resource is reused and no new <see cref="T:System.Diagnostics.Process" /> component is created. In such a case, instead of returning a new <see cref="T:System.Diagnostics.Process" /> component, <see cref="M:System.Diagnostics.Process.Start" /> returns null to the calling procedure.</para>
          <block subset="none" type="note">
            <para>If the address of the executable file to start is a URL, the process is not started and null is returned.</para>
          </block>
          <para>This overload lets you start a process without first creating a new <see cref="T:System.Diagnostics.Process" /> instance. The overload is an alternative to the explicit steps of creating a new <see cref="T:System.Diagnostics.Process" /> instance, setting the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.Arguments" /> members of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property, and calling <see cref="M:System.Diagnostics.Process.Start" /> for the <see cref="T:System.Diagnostics.Process" /> instance.</para>
          <para>Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the Run dialog box of the Windows Start menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the Run dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <paramref name="fileName" /> parameter. For example, you can set the <paramref name="fileName" /> parameter to either "Notepad.exe" or "Notepad". If the <paramref name="fileName" /> parameter represents an executable file, the <paramref name="arguments" /> parameter might represent a file to act upon, such as the text file in Notepad.exe myfile.txt. If the <paramref name="fileName" /> parameter represents a command (.cmd) file, the <paramref name="arguments" /> parameter must include either a "/c" or "/k" argument to specify whether the command window exits or remains after completion.</para>
          <para>Unlike the other overloads, the overload of <see cref="M:System.Diagnostics.Process.Start" /> that has no parameters is not a static member. Use that overload when you have already created a <see cref="T:System.Diagnostics.Process" /> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <see cref="T:System.Diagnostics.Process" /> instance. Use one of the static overloads when you want to create a new <see cref="T:System.Diagnostics.Process" /> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.</para>
          <para>If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if c:\mypath is not in your path, and you add it using quotation marks: path = %path%;"c:\mypath", you must fully qualify any process in c:\mypath when starting it.</para>
          <block subset="none" type="note">
            <para>ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <see cref="Overload:System.Diagnostics.Process.Start" /> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.</para>
          </block>
          <para>Whenever you use <see cref="M:System.Diagnostics.Process.Start" /> to start a process, you might need to close it or you risk losing system resources. Close processes using <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> or <see cref="M:System.Diagnostics.Process.Kill" />.</para>
          <para>A note about apartment states in managed threads is necessary here. When <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is true on the process component's <see cref="P:System.Diagnostics.Process.StartInfo" /> property, make sure you have set a threading model on your application by setting the attribute [STAThread] on the main() method. Otherwise, a managed thread can be in an unknown state or put in the MTA state, the latter of which conflicts with <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> being true. Some methods require that the apartment state not be unknown. If the state is not explicitly set, when the application encounters such a method, it defaults to MTA, and once set, the apartment state cannot be changed. However, MTA causes an exception to be thrown when the operating system shell is managing the thread.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new <see cref="T:System.Diagnostics.Process" /> component that is associated with the process, or null, if no process resource is started (for example, if an existing process is reused).</para>
        </returns>
        <param name="fileName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of an application file to run in the process. </param>
        <param name="arguments">
          <attribution license="cc4" from="Microsoft" modified="false" />Command-line arguments to pass when starting the process. </param>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string username, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string username, class System.Security.SecureString password, string domain) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">To be added.</param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this overload to create a new process and its primary thread by specifying its file name, user name, password, and domain. The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password). </para>
          <block subset="none" type="note">
            <para>When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</para>
          </block>
          <block subset="none" type="note">
            <para>If the address of the executable file to start is a URL, the process is not started and null is returned.</para>
          </block>
          <para>If the process is already running, no additional process resource is started. Instead, the existing process resource is reused and no new <see cref="T:System.Diagnostics.Process" /> component is created. In such a case, instead of returning a new <see cref="T:System.Diagnostics.Process" /> component, <see cref="M:System.Diagnostics.Process.Start" /> returns null to the calling procedure.</para>
          <para>This overload lets you start a process without first creating a new <see cref="T:System.Diagnostics.Process" /> instance. The overload is an alternative to the explicit steps of creating a new <see cref="T:System.Diagnostics.Process" /> instance, setting the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />, <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" />, <see cref="P:System.Diagnostics.ProcessStartInfo.Password" />, and <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> properties of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property, and calling <see cref="M:System.Diagnostics.Process.Start" /> for the <see cref="T:System.Diagnostics.Process" /> instance.</para>
          <para>Similarly, in the same way that the <ui>Run</ui> dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <paramref name="fileName" /> parameter. For example, you can set the <paramref name="fileName" /> parameter to either "Notepad.exe" or "Notepad". If the <paramref name="fileName" /> parameter represents an executable file, the <paramref name="arguments" /> parameter might represent a file to act upon, such as the text file in Notepad.exe myfile.txt.</para>
          <block subset="none" type="note">
            <para>The file name must represent an executable file in the <see cref="Overload:System.Diagnostics.Process.Start" /> overloads that have <paramref name="userName" />, <paramref name="password" />, and <paramref name="domain" /> parameters.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new <see cref="T:System.Diagnostics.Process" /> component that is associated with the process resource, or null if no process resource is started (for example, if an existing process is reused).</para>
        </returns>
        <param name="fileName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of an application file to run in the process.</param>
        <param name="password">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">
          <attribution license="cc4" from="Microsoft" modified="false" />The domain to use when starting the process.</param>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string username, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string username, class System.Security.SecureString password, string domain) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">To be added.</param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this overload to create a new process and its primary thread by specifying its file name, command-line arguments, user name, password, and domain. The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password). </para>
          <block subset="none" type="note">
            <para>When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</para>
          </block>
          <block subset="none" type="note">
            <para>If the address of the executable file to start is a URL, the process is not started and null is returned.</para>
          </block>
          <para>The overload associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component. If the process is already running, no additional process resource is started. Instead, the existing process resource is reused and no new <see cref="T:System.Diagnostics.Process" /> component is created. In such a case, instead of returning a new <see cref="T:System.Diagnostics.Process" /> component, <see cref="M:System.Diagnostics.Process.Start" /> returns null to the calling procedure.</para>
          <para>This overload lets you start a process without first creating a new <see cref="T:System.Diagnostics.Process" /> instance. The overload is an alternative to the explicit steps of creating a new <see cref="T:System.Diagnostics.Process" /> instance, setting the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" />, <see cref="P:System.Diagnostics.ProcessStartInfo.Arguments" />, <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" />, <see cref="P:System.Diagnostics.ProcessStartInfo.Password" />, and <see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> properties of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property, and calling <see cref="M:System.Diagnostics.Process.Start" /> for the <see cref="T:System.Diagnostics.Process" /> instance.</para>
          <para>Similarly, in the same way that the <ui>Run</ui> dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <paramref name="fileName" /> parameter. For example, you can set the <paramref name="fileName" /> parameter to either "Notepad.exe" or "Notepad". If the <paramref name="fileName" /> parameter represents an executable file, the <paramref name="arguments" /> parameter might represent a file to act upon, such as the text file in Notepad.exe myfile.txt.</para>
          <block subset="none" type="note">
            <para>The file name must represent an executable file in the <see cref="Overload:System.Diagnostics.Process.Start" /> overloads that have <paramref name="userName" />, <paramref name="password" />, and <paramref name="domain" /> parameters.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new <see cref="T:System.Diagnostics.Process" /> component that is associated with the process resource, or null if no process resource is started (for example, if an existing process is reused).</para>
        </returns>
        <param name="fileName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of an application file to run in the process. </param>
        <param name="arguments">
          <attribution license="cc4" from="Microsoft" modified="false" />Command-line arguments to pass when starting the process. </param>
        <param name="password">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">
          <attribution license="cc4" from="Microsoft" modified="false" />The domain to use when starting the process.</param>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Information for the start of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'ProcessStartInfo'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="P:System.Diagnostics.Process.StartInfo" /> represents the set of parameters to use to start a process. When <see cref="M:System.Diagnostics.Process.Start" /> is called, the <see cref="P:System.Diagnostics.Process.StartInfo" /> is used to specify the process to start. The only necessary <see cref="P:System.Diagnostics.Process.StartInfo" /> member to set is the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property. Starting a process by specifying the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property is similar to typing the information in the <ui>Run</ui> dialog box of the Windows <ui>Start</ui> menu. Therefore, the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the <ui>Run</ui> dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> member. For example, you can set the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property to either "Notepad.exe" or "Notepad". </para>
          <para>You can start a ClickOnce application by setting the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.</para>
          <para>If the file name involves a nonexecutable file, such as a .doc file, you can include a verb specifying what action to take on the file. For example, you could set the <see cref="P:System.Diagnostics.ProcessStartInfo.Verb" /> to "Print" for a file ending in the .doc extension. The file name specified in the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property does not need to have an extension if you manually enter a value for the <see cref="P:System.Diagnostics.ProcessStartInfo.Verb" /> property. However, if you use the <see cref="P:System.Diagnostics.ProcessStartInfo.Verbs" /> property to determine what verbs are available, you must include the extension.</para>
          <para>You can change the parameters specified in the <see cref="P:System.Diagnostics.Process.StartInfo" /> property up to the time that you call the <see cref="Overload:System.Diagnostics.Process.Start" /> method on the process. After you start the process, changing the <see cref="P:System.Diagnostics.Process.StartInfo" /> values does not affect or restart the associated process. If you call the <see cref="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" /> method with the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> properties set, the unmanaged <unmanagedCodeEntityReference>CreateProcessWithLogonW</unmanagedCodeEntityReference> function is called, which starts the process in a new window even if the <see cref="P:System.Diagnostics.ProcessStartInfo.CreateNoWindow" /> property value is true or the <see cref="P:System.Diagnostics.ProcessStartInfo.WindowStyle" /> property value is <see cref="F:System.Diagnostics.ProcessWindowStyle.Hidden" />.</para>
          <para>If you did not use the <see cref="Overload:System.Diagnostics.Process.Start" /> method to start a process, the <see cref="P:System.Diagnostics.Process.StartInfo" /> property does not reflect the parameters used to start the process. For example, if you use <see cref="Overload:System.Diagnostics.Process.GetProcesses" /> to get an array of processes running on the computer, the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of each <see cref="T:System.Diagnostics.Process" /> does not contain the original file name or arguments used to start the process.</para>
          <para>When the process is started, the file name is the file that populates the (read-only) <see cref="P:System.Diagnostics.Process.MainModule" /> property. If you want to retrieve the executable file that is associated with the process after the process has started, use the <see cref="P:System.Diagnostics.Process.MainModule" /> property. If you want to set the executable file of a <see cref="T:System.Diagnostics.Process" /> instance for which an associated process has not been started, use the <see cref="P:System.Diagnostics.Process.StartInfo" /> property's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> member. Because the members of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property are arguments that are passed to the <see cref="M:System.Diagnostics.Process.Start" /> method of a process, changing the <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property after the associated process has started will not reset the <see cref="P:System.Diagnostics.Process.MainModule" /> property. These properties are used only to initialize the associated process.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this process started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'DateTime'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the time that the associated process was started.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object that is used to synchronize event handler calls for this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'ComponentModel.ISynchronizeInvoke'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When <see cref="P:System.Diagnostics.EventLog.SynchronizingObject" /> is null, methods that handle the <see cref="E:System.Diagnostics.Process.Exited" /> event are called on a thread from the system thread pool. For more information about system thread pools, see <see cref="T:System.Threading.ThreadPool" />.</para>
          <para>When the <see cref="E:System.Diagnostics.Process.Exited" /> event is handled by a visual Windows Forms component, such as a <see cref="T:System.Windows.Forms.Button" />, accessing the component through the system thread pool might not work, or might result in an exception. Avoid this by setting <see cref="P:System.Diagnostics.Process.SynchronizingObject" /> to a Windows Forms component, which causes the methods handling the <see cref="E:System.Diagnostics.Process.Exited" /> event to be called on the same thread on which the component was created.</para>
          <para>If the <see cref="T:System.Diagnostics.Process" /> is used inside vsprvslong in a Windows Forms designer, <see cref="P:System.Diagnostics.Process.SynchronizingObject" /> is automatically set to the control that contains the <see cref="T:System.Diagnostics.Process" />. For example, if you place a <see cref="T:System.Diagnostics.Process" /> on a designer for Form1 (which inherits from <see cref="T:System.Windows.Forms.Form" />) the <see cref="P:System.Diagnostics.Process.SynchronizingObject" /> property of <see cref="T:System.Diagnostics.Process" /> is set to the instance of Form1:</para>
          <para>code reference: Process_SynchronizingObject#2</para>
          <para>Typically, this property is set when the component is placed inside a control or form, because those components are bound to a specific thread.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'ProcessThreadCollection'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A thread executes code in a process. Each process is started with a single thread, its primary thread. Any thread can create additional threads. Threads within a process share the address space of the process.</para>
          <para>Use <see cref="T:System.Diagnostics.ProcessThread" /> to get all the threads associated with the current process. The primary thread is not necessarily at index zero in the array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the set of threads that are running in the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Formats the process's name as a string, combined with the parent component type, if applicable.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The total CPU time spent for this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'TimeSpan'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the total processor time for this process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The CPU time spent for this process in user mode.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'TimeSpan'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the user processor time for this process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the size of the process's virtual memory.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by this property represents the current size of virtual memory used by the process. The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</para>
          <para>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the <ui>Virtual Bytes</ui> performance counter for the process. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the amount of the virtual memory allocated for the associated process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Diagnostics.Process.WaitForExit" /> overload is used to make the current thread wait until the associated process terminates.  This method instructs the <see cref="T:System.Diagnostics.Process" /> component to wait an infinite amount of time for the process and event handlers to exit. This can cause an application to stop responding. For example, if you call <see cref="M:System.Diagnostics.Process.CloseMainWindow" /> for a process that has a user interface, the request to the operating system to terminate the associated process might not be handled if the process is written to never enter its message loop.</para>
          <block subset="none" type="note">
            <para>In the net_v35_long and earlier versions, the <see cref="M:System.Diagnostics.Process.WaitForExit" /> overload waited for <see cref="F:System.Int32.MaxValue" /> milliseconds (approximately 24 days), not indefinitely. Also, previous versions did not wait for the event handlers to exit if the full <see cref="F:System.Int32.MaxValue" /> time was reached.</para>
          </block>
          <para>This overload ensures that all processing has been completed, including the handling of asynchronous events for redirected standard output. You should use this overload after a call to the <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> overload when standard output has been redirected to asynchronous event handlers.</para>
          <para>When an associated process exits (that is, when it is shut down by the operation system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <see cref="M:System.Diagnostics.Process.WaitForExit" />. The <see cref="T:System.Diagnostics.Process" /> component can then access the information, which includes the <see cref="P:System.Diagnostics.Process.ExitTime" />, by using the <see cref="P:System.Diagnostics.Process.Handle" /> to the exited process.</para>
          <para>Because the associated process has exited, the <see cref="P:System.Diagnostics.Process.Handle" /> property of the component no longer points to an existing process resource. Instead, the handle can be used only to access the operating system's information about the process resource. The system is aware of handles to exited processes that have not been released by <see cref="T:System.Diagnostics.Process" /> components, so it keeps the <see cref="P:System.Diagnostics.Process.ExitTime" /> and <see cref="P:System.Diagnostics.Process.Handle" /> information in memory until the <see cref="T:System.Diagnostics.Process" /> component specifically frees the resources. For this reason, any time you call <see cref="M:System.Diagnostics.Process.Start" /> for a <see cref="T:System.Diagnostics.Process" /> instance, call <see cref="M:System.Diagnostics.Process.Close" /> when the associated process has terminated and you no longer need any administrative information about it. <see cref="M:System.Diagnostics.Process.Close" /> frees the memory allocated to the exited process.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> overload is used to make the current thread wait until the associated process terminates. This overload instructs the <see cref="T:System.Diagnostics.Process" /> component to wait a finite amount of time for the process to exit. If the associated process does not exit by the end of the interval because the request to terminate is denied, false is returned to the calling procedure. You can specify a negative number (<see cref="F:System.Threading.Timeout.Infinite" />) for <paramref name="milliseconds" />, and <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> will behave the same as the <see cref="M:System.Diagnostics.Process.WaitForExit" /> overload. If you pass 0 (zero) to the method, it returns true only if the process has already exited; otherwise, it immediately returns false.</para>
          <block subset="none" type="note">
            <para>In the net_v35_long and earlier versions, if <paramref name="milliseconds" /> was -1, the <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> overload waited for <see cref="F:System.Int32.MaxValue" /> milliseconds (approximately 24 days), not indefinitely. </para>
          </block>
          <para>When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this method returns. To ensure that asynchronous event handling has been completed, call the <see cref="M:System.Diagnostics.Process.WaitForExit" /> overload that takes no parameter after receiving a true from this overload. To help ensure that the <see cref="E:System.Diagnostics.Process.Exited" /> event is handled correctly in Windows Forms applications, set the <see cref="P:System.Diagnostics.Process.SynchronizingObject" /> property.</para>
          <para>When an associated process exits (is shut down by the operating system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />. The <see cref="T:System.Diagnostics.Process" /> component can then access the information, which includes the <see cref="P:System.Diagnostics.Process.ExitTime" />, by using the <see cref="P:System.Diagnostics.Process.Handle" /> to the exited process.</para>
          <para>Because the associated process has exited, the <see cref="P:System.Diagnostics.Process.Handle" /> property of the component no longer points to an existing process resource. Instead, the handle can be used only to access the operating system's information about the process resource. The system is aware of handles to exited processes that have not been released by <see cref="T:System.Diagnostics.Process" /> components, so it keeps the <see cref="P:System.Diagnostics.Process.ExitTime" /> and <see cref="P:System.Diagnostics.Process.Handle" /> information in memory until the <see cref="T:System.Diagnostics.Process" /> component specifically frees the resources. For this reason, any time you call <see cref="M:System.Diagnostics.Process.Start" /> for a <see cref="T:System.Diagnostics.Process" /> instance, call <see cref="M:System.Diagnostics.Process.Close" /> when the associated process has terminated and you no longer need any administrative information about it. <see cref="M:System.Diagnostics.Process.Close" /> frees the memory allocated to the exited process.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the associated process has exited; otherwise, false.</para>
        </returns>
        <param name="milliseconds">
          <attribution license="cc4" from="Microsoft" modified="false" />The amount of time, in milliseconds, to wait for the associated process to exit. The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use <see cref="M:System.Diagnostics.Process.WaitForInputIdle" /> to force the processing of your application to wait until the message loop has returned to the idle state. When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system. The process then returns to the message loop. A process is said to be in an idle state when it is waiting for messages inside of a message loop. This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</para>
          <para>If a process does not have a message loop, <see cref="M:System.Diagnostics.Process.WaitForInputIdle" /> throws an <see cref="T:System.InvalidOperationException" />.</para>
          <para>The <see cref="M:System.Diagnostics.Process.WaitForInputIdle" /> overload instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the process to become idle in the message loop. This instruction can cause an application to stop responding. For example, if the process is written to always exit its message loop immediately, as in the code fragment while(true).</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the associated process has reached an idle state.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use <see cref="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" /> to force the processing of your application to wait until the message loop has returned to the idle state. When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system. The process then returns to the message loop. A process is said to be in an idle state when it is waiting for messages inside of a message loop. This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</para>
          <para>If a process does not have a message loop, <see cref="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" /> throws an <see cref="T:System.InvalidOperationException" />.</para>
          <para>The <see cref="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" /> overload instructs the <see cref="T:System.Diagnostics.Process" /> component to wait a finite amount of time for the process to become idle in the message loop. If the associated process has not become idle by the end of the interval because the loop is still processing messages, false is returned to the calling procedure.</para>
          <para>For more information about handling events, see <format type="text/html"><a href="01E4F1BC-E55E-413F-98C7-6588493E5F67">[&lt;topic://cpconEventsOverview&gt;]</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the associated process has reached an idle state; otherwise, false.</para>
        </returns>
        <param name="milliseconds">
          <attribution license="cc4" from="Microsoft" modified="false" />A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle. A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait. </param>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'int'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault.</para>
          <para>The working set includes both shared and private data. The shared data includes the pages that contain all the instructions that the process executes, including the process modules and the system libraries.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the associated process's physical memory usage.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by this property represents the current size of working set memory used by the process. The working set of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault.</para>
          <para>The working set includes both shared and private data. The shared data includes the pages that contain all the instructions that the process executes, including instructions in the process modules and the system libraries.</para>
          <para>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the <ui>Working Set</ui> performance counter for the process.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the amount of physical memory allocated for the associated process.</para>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>