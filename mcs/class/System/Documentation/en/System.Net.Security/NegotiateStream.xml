<?xml version="1.0" encoding="utf-8"?>
<Type Name="NegotiateStream" FullName="System.Net.Security.NegotiateStream">
  <TypeSignature Language="C#" Value="public class NegotiateStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NegotiateStream extends System.Net.Security.AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <since version=".NET 2.0" />
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Use the <see cref="T:System.Net.Security.NegotiateStream" /> class for authentication and to help secure information transmitted between a client and a server. Using <see cref="T:System.Net.Security.NegotiateStream" />, you can do the following.</para>
      <list type="bullet">
        <item>
          <para>Send the client's credentials to the server for Impersonation or Delegation. </para>
        </item>
        <item>
          <para>Request server authentication.</para>
        </item>
        <item>
          <para>Encrypt and/or sign data before transmitting it. </para>
        </item>
      </list>
      <para>Authentication must be performed before transmitting information. Clients request authentication using the synchronous <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" /> methods, which block until the authentication completes, or the asynchronous <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" /> methods, which do not block while waiting for the authentication to complete. Servers request authentication using the synchronous <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" /> or asynchronous <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> methods. The client, and optionally the server, is authenticated using the Negotiate security protocol. On Windows 95/98 systems, Windows NT LAN Manager (NTLM) is the protocol used for authentication. On other platforms the Kerberos protocol is used for authentication if both client and server support it; otherwise NTLM is used. For detailed descriptions of these protocols, see the Platform SDK documentation on MSDN, at msdn.microsoft.com/library/. The <see cref="T:System.Net.Security.NegotiateStream" /> class performs the authentication using the Security Support Provider Interface (SSPI). </para>
      <para>When authentication succeeds, you must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services will be used by the <see cref="T:System.Net.Security.NegotiateStream" /> to help secure your data during transmission. Check the <see cref="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" /> property to determine whether mutual authentication occurred. You can get information about the remote client or server using the <see cref="P:System.Net.Security.NegotiateStream.RemoteIdentity" /> property.</para>
      <para>If the authentication fails, you will receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or a <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential.</para>
      <para>You send data using the synchronous <see cref="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" /> or asynchronous <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> methods. You receive data using the synchronous <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" /> or asynchronous <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> methods. If security services such as encryption or signing are enabled, these are automatically applied to your data by the <see cref="T:System.Net.Security.NegotiateStream" />.</para>
      <para>The <see cref="T:System.Net.Security.NegotiateStream" /> transmits data using a stream that you supply when creating the <see cref="T:System.Net.Security.NegotiateStream" />. When you supply this underlying stream, you have the option to specify whether closing the <see cref="T:System.Net.Security.NegotiateStream" /> also closes the underlying stream.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides a stream that uses the Negotiate security protocol to authenticate the client, and optionally the server, in client-server communication.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Net.Security.NegotiateStream" /> class using the specified <see cref="T:System.IO.Stream" />.</para>
        </summary>
        <param name="innerStream">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.IO.Stream" /> object used by the <see cref="T:System.Net.Security.NegotiateStream" /> for sending and receiving data.</param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When you specify true for the <paramref name="leaveStreamOpen" /> parameter, closing the <see cref="T:System.Net.Security.NegotiateStream" /> has no effect on the <paramref name="innerStream" /> stream; you must explicitly close <paramref name="innerStream" /> when you no longer need it.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Net.Security.NegotiateStream" /> class using the specified <see cref="T:System.IO.Stream" /> and stream closure behavior.</para>
        </summary>
        <param name="innerStream">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.IO.Stream" /> object used by the <see cref="T:System.Net.Security.NegotiateStream" /> for sending and receiving data.</param>
        <param name="leaveInnerStreamOpen">
          <attribution license="cc4" from="Microsoft" modified="false" />true to indicate that closing this <see cref="T:System.Net.Security.NegotiateStream" /> has no effect on <paramref name="innerstream" />; false to indicate that closing this <see cref="T:System.Net.Security.NegotiateStream" /> also closes <paramref name="innerStream" />. See the Remarks section for more information.</param>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The authentication uses the client's <see cref="P:System.Net.CredentialCache.DefaultCredentials" />. No Service Principal Name (SPN) is specified for the server. The impersonation level is <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, the security level is <see cref="F:System.Net.Security.ProtectionLevel.EncryptAndSign" />, and mutual authentication is requested. The <see cref="T:System.Net.Security.NegotiateStream" /> class will construct the SPN used for mutual authentication. </para>
          <para>When authentication succeeds, you must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services are used by the <see cref="T:System.Net.Security.NegotiateStream" />. Check the <see cref="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" /> property to determine whether mutual authentication occurred.</para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Called by clients to authenticate the client, and optionally the server, in a client-server connection.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The impersonation level is <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, the security level is <see cref="F:System.Net.Security.ProtectionLevel.EncryptAndSign" />, and mutual authentication is requested. The <see cref="T:System.Net.Security.NegotiateStream" /> class will construct the SPN used for mutual authentication. </para>
          <para>When authentication succeeds, you must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services are used by the <see cref="T:System.Net.Security.NegotiateStream" />. Check the <see cref="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" /> property to determine whether mutual authentication occurred.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Called by clients to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified client credential. </para>
        </summary>
        <param name="credential">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="targetName">
          <attribution license="cc4" from="Microsoft" modified="false" />The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <paramref name="requiredProtectionLevel" /> parameter to request security services for data transmitted using the authenticated stream. For example, to have the data encrypted and signed, specify the <see cref="F:System.Net.Security.ProtectionLevel.EncryptAndSign" /> value. Successful authentication does not guarantee that the requested <see cref="T:System.Net.Security.ProtectionLevel" /> has been granted. You must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services are used by the <see cref="T:System.Net.Security.NegotiateStream" />.</para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Called by clients to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials and authentication options.</para>
        </summary>
        <param name="credential">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="targetName">
          <attribution license="cc4" from="Microsoft" modified="false" />The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="requiredProtectionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="allowedImpersonationLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The authentication uses the server's <see cref="P:System.Net.CredentialCache.DefaultCredentials" />. No Service Principal Name (SPN) is specified for the server. The impersonation level is <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, and the security level is <see cref="F:System.Net.Security.ProtectionLevel.EncryptAndSign" />.</para>
          <para>When authentication succeeds, you must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services are used by the <see cref="T:System.Net.Security.NegotiateStream" />. Check the <see cref="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" /> property to determine whether mutual authentication occurred.</para>
          <para>This method blocks until the operation completes. To prevent blocking until the operation completes, use one of the <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> method overloads.</para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Called by servers to authenticate the client, and optionally the server, in a client-server connection.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When authentication succeeds, you must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services are used by the <see cref="T:System.Net.Security.NegotiateStream" />. Check the <see cref="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" /> property to determine whether mutual authentication occurred.</para>
          <para>This method blocks until the operation completes. To prevent blocking until the operation completes, use one of the <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> method overloads.</para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Called by servers to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified server credentials and authentication options.</para>
        </summary>
        <param name="credential">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the server.</param>
        <param name="requiredProtectionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="requiredImpersonationLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The authentication uses the client's <see cref="P:System.Net.CredentialCache.DefaultCredentials" />. No Service Principal Name (SPN) is specified for the server. The impersonation level is <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, and the security level is <see cref="F:System.Net.Security.ProtectionLevel.EncryptAndSign" />. The <see cref="T:System.Net.Security.NegotiateStream" /> class will construct the SPN used for mutual authentication. </para>
          <para>This method is asynchronous and does not block while the operation completes. To block until the operation completes, use one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" /> method overloads. </para>
          <para>The asynchronous authentication operation must be completed by calling the <see cref="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="asyncCallback" /> delegate. For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format></para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. This method does not block.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation. </para>
        </returns>
        <param name="asyncCallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object containing information about the operation. This object is passed to the <paramref name="asyncCallback" /> delegate when the operation completes.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is asynchronous and does not block while the operation completes. To block until the operation completes, use one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" /> method overloads.</para>
          <para>The asynchronous authentication operation must be completed by calling the <see cref="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="asyncCallback" /> delegate. For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format></para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials. This method does not block.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation. </para>
        </returns>
        <param name="credential">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="targetName">
          <attribution license="cc4" from="Microsoft" modified="false" />The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="asyncCallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object containing information about the write operation. This object is passed to the <paramref name="asyncCallback" /> delegate when the operation completes.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <paramref name="requiredProtectionLevel" /> parameter to request security services for data transmitted using the authenticated stream. For example, to have the data encrypted and signed, specify the <see cref="F:System.Net.Security.ProtectionLevel.EncryptAndSign" /> value. Successful authentication does not guarantee that the requested <see cref="T:System.Net.Security.ProtectionLevel" /> has been granted. You must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services are used by the <see cref="T:System.Net.Security.NegotiateStream" />.</para>
          <para>This method is asynchronous and does not block while the operation completes. To block until the operation completes, use one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" /> method overloads.</para>
          <para>The asynchronous authentication operation must be completed by calling the <see cref="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="asyncCallback" /> delegate. For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format></para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials and authentication options. This method does not block.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation. </para>
        </returns>
        <param name="credential">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="targetName">
          <attribution license="cc4" from="Microsoft" modified="false" />The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="requiredProtectionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="allowedImpersonationLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <param name="asyncCallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete. </param>
        <param name="asyncState">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object containing information about the write operation. This object is passed to the <paramref name="asyncCallback" /> delegate when the operation completes.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The authentication uses the server's <see cref="P:System.Net.CredentialCache.DefaultCredentials" />. No Service Principal Name (SPN) is specified for the server. The impersonation level is <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, the security level is <see cref="F:System.Net.Security.ProtectionLevel.EncryptAndSign" />.</para>
          <para>When authentication succeeds, you must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services are used by the <see cref="T:System.Net.Security.NegotiateStream" />. Check the <see cref="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" /> property to determine whether mutual authentication occurred.</para>
          <para>To block until the operation completes, use one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" /> method overloads.</para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Called by servers to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. This method does not block.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation. </para>
        </returns>
        <param name="asyncCallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object containing information about the operation. This object is passed to the <paramref name="asyncCallback" /> delegate when the operation completes.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <paramref name="requiredProtectionLevel" /> parameter to request security services for data transmitted using the authenticated stream. For example, to have the data encrypted and signed, specify the <see cref="F:System.Net.Security.ProtectionLevel.EncryptAndSign" /> value. Successful authentication does not guarantee that, the requested <see cref="T:System.Net.Security.ProtectionLevel" /> has been granted. You must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services are used by the <see cref="T:System.Net.Security.NegotiateStream" />.</para>
          <para>This method is asynchronous and does not block while the operation completes. To block until the operation completes, use one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" /> method overloads.</para>
          <para>The asynchronous authentication operation must be completed by calling the <see cref="M:System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="asyncCallback" /> delegate. For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format></para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Called by servers to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified server credentials and authentication options. This method does not block.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation. </para>
        </returns>
        <param name="credential">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="requiredProtectionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="requiredImpersonationLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <param name="asyncCallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object containing information about the operation. This object is passed to the <paramref name="asyncCallback" /> delegate when the operation completes.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If encryption, signing, or encryption and signing are enabled, the read operation reads the data from the underlying stream, checks the integrity of the data, and decrypts it. If no security services such as data encryption or signing are in use, this method starts an asynchronous read operation on the underlying stream.</para>
          <para>This method is asynchronous and does not block while the operation completes. To block until the operation completes, use the <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" /> method.</para>
          <para>The asynchronous read operation must be completed by calling the <see cref="M:System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="asyncCallback" /> delegate. For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format></para>
          <para>The <see cref="T:System.Net.Security.NegotiateStream" /> class does not support multiple simultaneous read operations. If you attempt to start a read operation while another read operation is already executing on the same stream, a <see cref="T:System.NotSupportedException" /> exception will be thrown.</para>
          <para>You cannot call this method until you have successfully authenticated. To authenticate, call one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" />, or <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous read operation that reads data from the stream and stores it in the specified array. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation. </para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Byte" /> array that receives the bytes read from the stream.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based location in <paramref name="buffer" /> at which to begin storing the data read from this stream.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to read from the stream.</param>
        <param name="asyncCallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the read operation is complete. </param>
        <param name="asyncState">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object containing information about the read operation. This object is passed to the <paramref name="asyncCallback" /> delegate when the operation completes.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If encryption, signing, or encryption and signing are enabled, this method reads the data from buffer, encrypts, signs, or encrypts and signs it, and transmits it using the underlying stream. If no security services such as data encryption or signing are in use, this method starts an asynchronous write operation on the underlying stream. </para>
          <para>This method is asynchronous and does not block while the operation completes. To block until the operation completes, use the <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" /> method.</para>
          <para>The asynchronous read operation must be completed by calling the <see cref="M:System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="asyncCallback" /> delegate. For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format></para>
          <para>The <see cref="T:System.Net.Security.NegotiateStream" /> class does not support multiple simultaneous write operations. If you attempt to start a write operation while another write operation is already executing on the same stream, a <see cref="T:System.NotSupportedException" /> exception will be thrown.</para>
          <para>You cannot call this method until you have successfully authenticated. To authenticate, call one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" />, or <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous write operation that writes <see cref="T:System.Byte" />s from the specified buffer to the stream.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation. </para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Byte" /> array that supplies the bytes to be written to the stream.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based location in<paramref name=" buffer" /> at which to begin reading bytes to be written to the stream.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Int32" /> value that specifies the number of bytes to read from <paramref name="buffer" />.</param>
        <param name="asyncCallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the write operation is complete. </param>
        <param name="asyncState">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object containing information about the write operation. This object is passed to the <paramref name="asyncCallback" /> delegate when the operation completes.</param>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If successful authentication has occurred, this property returns the value returned by invoking the <see cref="P:System.IO.Stream.CanRead" /> property on the underlying stream. The underlying stream is specified when you create an instance of the <see cref="T:System.Net.Security.NegotiateStream" /> class.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether the underlying stream is readable.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You should not attempt to set the position of the <see cref="T:System.Net.Security.NegotiateStream" /> object or its underlying stream. The underlying stream is specified when you create an instance of the <see cref="T:System.Net.Security.NegotiateStream" /> class.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether the underlying stream is seekable.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property returns the value returned by invoking the <see cref="P:System.IO.Stream.CanTimeout" /> property on the underlying stream. The underlying stream is specified when you create an instance of the <see cref="T:System.Net.Security.NegotiateStream" /> class.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether the underlying stream supports time-outs.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If successful authentication has occurred, this property returns the value returned by invoking the <see cref="P:System.IO.Stream.CanWrite" /> property on the underlying stream. The underlying stream is specified when you create an instance of the <see cref="T:System.Net.Security.NegotiateStream" /> class.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether the underlying stream is writable.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is called by the public Dispose() method and the <see cref="M:System.Object.Finalize" /> method. Dispose() invokes the protected Dispose(Boolean) method with the <paramref name="disposing" /> parameter set to true. <see cref="M:System.Object.Finalize" /> invokes Dispose with <paramref name="disposing" /> set to false.</para>
          <para>When the <paramref name="disposing" /> parameter is true, this method releases all resources held by any managed objects that this <see cref="T:System.Net.Security.NegotiateStream" /> references. This method invokes the Dispose() method of each referenced object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the unmanaged resources used by the <see cref="T:System.Net.Security.NegotiateStream" /> and optionally releases the managed resources. </para>
        </summary>
        <param name="disposing">
          <attribution license="cc4" from="Microsoft" modified="false" />true to release both managed and unmanaged resources; false to release only unmanaged resources. </param>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the operation has not completed, this method blocks until it does. When the authentication succeeds, you must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services are used by the <see cref="T:System.Net.Security.NegotiateStream" />. Check the <see cref="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" /> property to determine whether mutual authentication occurred.</para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential. </para>
          <para>To perform this operation synchronously, use one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends a pending asynchronous client authentication operation that was started with a call to <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</para>
        </summary>
        <param name="asyncResult">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.IAsyncResult" /> instance returned by a call to <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />. </param>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the operation has not completed, this method blocks until it does. </para>
          <para>When authentication succeeds, you must check the <see cref="P:System.Net.Security.NegotiateStream.IsEncrypted" /> and <see cref="P:System.Net.Security.NegotiateStream.IsSigned" /> properties to determine what security services are used by the <see cref="T:System.Net.Security.NegotiateStream" />. Check the <see cref="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" /> property to determine whether mutual authentication occurred.</para>
          <para>If the authentication fails, you receive an <see cref="T:System.Security.Authentication.AuthenticationException" /> or an <see cref="T:System.Security.Authentication.InvalidCredentialException" />. In this case, you can retry the authentication with a different credential. </para>
          <para>To perform this operation synchronously, use the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends a pending asynchronous client authentication operation that was started with a call to <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</para>
        </summary>
        <param name="asyncResult">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.IAsyncResult" /> instance returned by a call to <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</param>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the operation has not completed, this method blocks until it does. </para>
          <para>To perform this operation synchronously, use the <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" /> method. </para>
          <para>You cannot call this method until you have successfully authenticated. To authenticate, call one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" />, or <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends an asynchronous read operation that was started with a call to <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Int32" /> value that specifies the number of bytes read from the underlying stream.</para>
        </returns>
        <param name="asyncResult">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.IAsyncResult" /> instance returned by a call to <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> </param>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the operation has not completed, this method blocks until it does. </para>
          <para>You cannot call this method until you have successfully authenticated. To authenticate, call one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" />, or <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> methods.</para>
          <para>To perform this operation synchronously, use the <see cref="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends an asynchronous write operation that was started with a call to <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</para>
        </summary>
        <param name="asyncResult">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.IAsyncResult" /> instance returned by a call to <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method invokes <see cref="M:System.IO.Stream.Flush" /> on the underlying stream.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Causes any buffered data to be written to the underlying device.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You must successfully authenticate before calling this method. Clients specify the impersonation level when they request authentication by calling one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" /> or <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" /> methods. If you authenticate without specifying a <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> , <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" /> is used.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates how the server can use the client's credentials.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Clients authenticate by calling the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" /> or <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" /> methods. Servers authenticate by calling the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" /> or <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether authentication was successful.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Encryption helps to protect the privacy of the data; namely, it helps to ensure that while data is in transit it cannot be deciphered by third parties. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether this <see cref="T:System.Net.Security.NegotiateStream" /> uses data encryption.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Mutual authentication is specified by the client when the client wants the server to provide credentials for authentication. By default, clients request mutual authentication.</para>
          <para>The Negotiate protocol selects either NTLM or Kerberos depending on the security protocols supported by the client and server. NTLM does not support mutual authentication.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether both the server and the client have been authenticated.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If authentication failed or did not occur, this property returns false.</para>
          <para>To authenticate as the server, call the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" /> or <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether the local side of the connection used by this <see cref="T:System.Net.Security.NegotiateStream" /> was authenticated as the server.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Data signing helps to protect the integrity of the data; namely, it helps the recipient determine whether the data has been tampered with while in transit. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether the data sent using this stream is signed.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property returns the value returned by invoking the <see cref="P:System.IO.Stream.Length" /> property on the underlying stream. If the underlying stream is not seekable, this property will typically throw an exception. The run-time type of the underlying stream determines the run-time type of the exception that is thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the length of the underlying stream.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property returns the value returned by invoking the <see cref="P:System.IO.Stream.Position" /> property on the underlying stream. If the underlying stream is not seekable, this property will typically throw an exception. The run-time type of the underlying stream determines the run-time type of the exception that is thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the current position in the underlying stream.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method reads a maximum of <paramref name="count" /> bytes from the current stream and stores them in <paramref name="buffer" /> beginning at <paramref name="offset" />.</para>
          <para>You cannot call this method until you have successfully authenticated. To authenticate, call one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" />, or <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> methods.</para>
          <para>To perform this operation asynchronously, use the <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads data from this stream and stores it in the specified array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Int32" /> value that specifies the number of bytes read from the underlying stream. When there is no more data to be read, returns 0.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Byte" /> array that receives the bytes read from the stream.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Int32" /> containing the zero-based location in <paramref name="buffer" /> at which to begin storing the data read from this stream.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Int32" /> containing the maximum number of bytes to read from the stream.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property returns the value returned by invoking the <see cref="P:System.IO.Stream.ReadTimeout" /> property on the underlying stream. When you set this property, the <see cref="P:System.IO.Stream.ReadTimeout" /> value on the underlying stream is set to the specified value.</para>
          <para>If the underlying stream is a <see cref="T:System.Net.Sockets.NetworkStream" />, <see cref="P:System.Net.Security.NegotiateStream.ReadTimeout" /> is in milliseconds and is set to <see cref="F:System.Threading.Timeout.Infinite" /> by default so that read operations do not time out.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the amount of time a read operation blocks waiting for data.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RemoteIdentity">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity RemoteIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When accessed by the client, this property returns a <see cref="T:System.Security.Principal.GenericIdentity" /> containing the Service Principal Name (SPN) of the server and the authentication protocol used. When accessed by the server, this property returns a <see cref="T:System.Security.Principal.WindowsIdentity" /> that describes the client. If the <see cref="T:System.Security.Principal.WindowsIdentity" /> is not available, client information is returned to the server in a <see cref="T:System.Security.Principal.GenericIdentity" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets information about the identity of the remote party sharing this authenticated stream.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Do not call this method. It is inherited, but is not supported by <see cref="T:System.Net.Security.NegotiateStream" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Throws <see cref="T:System.NotSupportedException" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Always throws a <see cref="T:System.NotSupportedException" />.</para>
        </returns>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />This value is ignored.</param>
        <param name="origin">
          <attribution license="cc4" from="Microsoft" modified="false" />This value is ignored.</param>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the length of the underlying stream.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Int64" /> value that specifies the length of the stream.</param>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If encryption, signing, or encryption and signing are enabled, this method reads the data from buffer, encrypts, signs, or encrypts and signs it, and transmits it using the underlying stream. If no security services such as data encryption or signing are in use, this method invokes <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> on the underlying stream.</para>
          <para>This method blocks while the write operation completes. To prevent blocking while the operation completes, use the <see cref="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" /> method.</para>
          <para>You cannot call this method until you have successfully authenticated. To authenticate, call one of the <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />, <see cref="Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer" />, or <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" /> methods.</para>
          <para>The <see cref="T:System.Net.Security.NegotiateStream" /> class does not support multiple simultaneous write operations. If you attempt to start a write operation while another write operation is already executing on the same stream, a <see cref="T:System.NotSupportedException" /> exception will be thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Write the specified number of <see cref="T:System.Byte" />s to the underlying stream using the specified buffer and offset.</para>
        </summary>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Byte" /> array that supplies the bytes written to the stream.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Int32" /> containing the zero-based location in<paramref name=" buffer" /> at which to begin reading bytes to be written to the stream.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Int32" /> containing the number of bytes to read from <paramref name="buffer" />.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property returns the value returned by invoking the <see cref="P:System.IO.Stream.WriteTimeout" /> property on the underlying stream. For set operations, the specified value sets the <see cref="P:System.IO.Stream.WriteTimeout" /> value on the underlying stream.</para>
          <para>If the underlying stream is a <see cref="T:System.Net.Sockets.NetworkStream" />, <see cref="P:System.Net.Security.NegotiateStream.WriteTimeout" /> is in milliseconds and is set to <see cref="F:System.Threading.Timeout.Infinite" /> by default so that write operations do not time out.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the amount of time a write operation blocks waiting for data.</para>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>