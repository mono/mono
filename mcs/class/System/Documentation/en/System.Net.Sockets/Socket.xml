<?xml version="1.0" encoding="utf-8"?>
<Type Name="Socket" FullName="System.Net.Sockets.Socket" FullNameSP="System_Net_Sockets_Socket" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public Socket extends System.Object implements System.IDisposable" />
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <MemberOfLibrary>Networking</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.x.x</AssemblyVersion>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <example>
      <para>The following examples provide a client/server
      application that demonstrates the
      use of asynchronous communication between sockets. Run the client and server on
      different consoles.</para>
      <para> The following code is for the
      server application. Start this application before the client application.</para>
      <code lang="C#">using System;
using System.Threading;
using System.Text;
using System.Net;
using System.Net.Sockets;

public class Server 
{
  // used to pass state information to delegate
  internal class StateObject 
  {
    internal byte[] sBuffer;
    internal Socket sSocket;
    internal StateObject(int size, Socket sock) {
      sBuffer = new byte[size];
      sSocket = sock;
    }
  }
  static void Main() 
  {
    IPAddress ipAddress =
      Dns.Resolve( Dns.GetHostName() ).AddressList[0];

    IPEndPoint ipEndpoint =
      new IPEndPoint(ipAddress, 1800);

    Socket listenSocket =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);

    listenSocket.Bind(ipEndpoint);
    listenSocket.Listen(1);
    IAsyncResult asyncAccept = listenSocket.BeginAccept(
      new AsyncCallback(Server.acceptCallback),
      listenSocket );

    // could call listenSocket.EndAccept(asyncAccept) here
    // instead of in the callback method, but since 
    // EndAccept blocks, the behavior would be similar to 
    // calling the synchronous Accept method

    Console.Write("Connection in progress.");
    if( writeDot(asyncAccept) == true ) 
    {
      // allow time for callbacks to
      // finish before the program ends 
      Thread.Sleep(3000);
    }
  }

  public static void
    acceptCallback(IAsyncResult asyncAccept) {
      Socket listenSocket = (Socket)asyncAccept.AsyncState;
      Socket serverSocket =
        listenSocket.EndAccept(asyncAccept);

      // arriving here means the operation completed
      // (asyncAccept.IsCompleted = true) but not
      // necessarily successfully
      if( serverSocket.Connected == false )
      {
        Console.WriteLine( ".server is not connected." );
        return;
      }
      else Console.WriteLine( ".server is connected." );

      listenSocket.Close();

      StateObject stateObject =
        new StateObject(16, serverSocket);

      // this call passes the StateObject because it 
      // needs to pass the buffer as well as the socket
      IAsyncResult asyncReceive =
        serverSocket.BeginReceive(
          stateObject.sBuffer,
          0,
          stateObject.sBuffer.Length,
          SocketFlags.None,
          new AsyncCallback(receiveCallback),
          stateObject);

      Console.Write("Receiving data.");
      writeDot(asyncReceive);
  }

  public static void
    receiveCallback(IAsyncResult asyncReceive) {
      StateObject stateObject =
        (StateObject)asyncReceive.AsyncState;
      int bytesReceived =
        stateObject.sSocket.EndReceive(asyncReceive);

      Console.WriteLine(
        ".{0} bytes received: {1}",
        bytesReceived.ToString(),
        Encoding.ASCII.GetString(stateObject.sBuffer) );

      byte[] sendBuffer =
        Encoding.ASCII.GetBytes("Goodbye");
      IAsyncResult asyncSend =
        stateObject.sSocket.BeginSend(
          sendBuffer,
          0,
          sendBuffer.Length,
          SocketFlags.None,
          new AsyncCallback(sendCallback),
          stateObject.sSocket);

      Console.Write("Sending response.");
      writeDot(asyncSend);
  }

  public static void sendCallback(IAsyncResult asyncSend) {
    Socket serverSocket = (Socket)asyncSend.AsyncState;
    int bytesSent = serverSocket.EndSend(asyncSend);
    Console.WriteLine(
      ".{0} bytes sent.{1}{1}Shutting down.",
      bytesSent.ToString(),
      Environment.NewLine );

    serverSocket.Shutdown(SocketShutdown.Both);
    serverSocket.Close();
  }

  // times out after 20 seconds but operation continues
  internal static bool writeDot(IAsyncResult ar)
  {
    int i = 0;
    while( ar.IsCompleted == false ) 
    {
      if( i++ &gt; 40 ) 
      {
        Console.WriteLine("Timed out.");
        return false;
      }
      Console.Write(".");
      Thread.Sleep(500);
    }
    return true;
  }
}
   </code>
      <para>The following code is for the client application. When
      starting the application, supply the hostname of the console running the server
      application as an input parameter (for example, ProgramName <paramref name="hostname" />
      ). </para>
      <code lang="C#">using System;
using System.Threading;
using System.Text;
using System.Net;
using System.Net.Sockets;

public class Client {

  // used to pass state information to delegate
  class StateObject 
  {
    internal byte[] sBuffer;
    internal Socket sSocket;
    internal StateObject(int size, Socket sock) {
      sBuffer = new byte[size];
      sSocket = sock;
    }
  }

  static void Main(string[] argHostName) 
  {
    IPAddress ipAddress =
      Dns.Resolve( argHostName[0] ).AddressList[0];

    IPEndPoint ipEndpoint =
      new IPEndPoint(ipAddress, 1800);

    Socket clientSocket = new Socket(
      AddressFamily.InterNetwork,
      SocketType.Stream,
      ProtocolType.Tcp);

    IAsyncResult asyncConnect = clientSocket.BeginConnect(
      ipEndpoint,
      new AsyncCallback(connectCallback),
      clientSocket );

    Console.Write("Connection in progress.");
    if( writeDot(asyncConnect) == true ) 
    {
      // allow time for callbacks to
      // finish before the program ends
      Thread.Sleep(3000);
    }
  }

  public static void
    connectCallback(IAsyncResult asyncConnect) {
      Socket clientSocket =
        (Socket)asyncConnect.AsyncState;
      clientSocket.EndConnect(asyncConnect);
      // arriving here means the operation completed
      // (asyncConnect.IsCompleted = true) but not
      // necessarily successfully
      if( clientSocket.Connected == false )
      {
        Console.WriteLine( ".client is not connected." );
        return;
      }
      else Console.WriteLine( ".client is connected." );

      byte[] sendBuffer = Encoding.ASCII.GetBytes("Hello");
      IAsyncResult asyncSend = clientSocket.BeginSend(
        sendBuffer,
        0,
        sendBuffer.Length,
        SocketFlags.None,
        new AsyncCallback(sendCallback),
        clientSocket);

      Console.Write("Sending data.");
      writeDot(asyncSend);
  }

  public static void sendCallback(IAsyncResult asyncSend) 
  {
    Socket clientSocket = (Socket)asyncSend.AsyncState;
    int bytesSent = clientSocket.EndSend(asyncSend);
    Console.WriteLine(
      ".{0} bytes sent.",
      bytesSent.ToString() );

    StateObject stateObject =
      new StateObject(16, clientSocket);

    // this call passes the StateObject because it
    // needs to pass the buffer as well as the socket
    IAsyncResult asyncReceive =
      clientSocket.BeginReceive(
        stateObject.sBuffer,
        0,
        stateObject.sBuffer.Length,
        SocketFlags.None,
        new AsyncCallback(receiveCallback),
        stateObject);

    Console.Write("Receiving response.");
    writeDot(asyncReceive);
  }

  public static void
    receiveCallback(IAsyncResult asyncReceive) {
      StateObject stateObject =
       (StateObject)asyncReceive.AsyncState;

      int bytesReceived =
        stateObject.sSocket.EndReceive(asyncReceive);

      Console.WriteLine(
        ".{0} bytes received: {1}{2}{2}Shutting down.",
        bytesReceived.ToString(),
        Encoding.ASCII.GetString(stateObject.sBuffer),
        Environment.NewLine );

      stateObject.sSocket.Shutdown(SocketShutdown.Both);
      stateObject.sSocket.Close();
  }

  // times out after 2 seconds but operation continues
  internal static bool writeDot(IAsyncResult ar)
  {
    int i = 0;
    while( ar.IsCompleted == false ) 
    {
      if( i++ &gt; 20 ) 
      {
        Console.WriteLine("Timed out.");
        return false;
      }
      Console.Write(".");
      Thread.Sleep(100);
    }
    return true;
  }
}
   </code>
      <para>The output of the server application is</para>
      <c>
        <para>Connection in progress...........server is connected.</para>
        <para>Receiving data......5 bytes received: Hello</para>
        <para>Sending response....7 bytes sent.</para>
        <para>Shutting down.</para>
        <para>-----------------------------------------</para>
      </c>
      <para>The output of the client application is</para>
      <c>
        <para>Connection in progress......client is connected.</para>
        <para>Sending data......5 bytes sent.</para>
        <para>Receiving response......7 bytes received: Goodbye</para>
        <para>Shutting down.</para>
      </c>
    </example>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The <see cref="T:System.Net.Sockets.Socket" /> class provides a rich set of methods and properties for network communications. The <see cref="T:System.Net.Sockets.Socket" /> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <see cref="T:System.Net.Sockets.ProtocolType" /> enumeration. </para>
      <para>The <see cref="T:System.Net.Sockets.Socket" /> class follows the .NET Framework naming pattern for asynchronous methods. For example, the synchronous <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method corresponds to the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> and <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> methods.</para>
      <para>If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</para>
      <list type="bullet">
        <item>
          <para>If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method. The <see cref="M:System.Net.Sockets.Socket.Accept" /> method processes any incoming connection requests and returns a <see cref="T:System.Net.Sockets.Socket" /> that you can use to communicate data with the remote host. Use this returned <see cref="T:System.Net.Sockets.Socket" /> to call the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> or <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method. Call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method prior to calling the <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method if you want to specify the local IP address and port number. Use a port number of zero if you want the underlying service provider to assign a free port for you. If you want to connect to a listening host, call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method. To communicate data, call the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> or <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method.</para>
        </item>
        <item>
          <para>If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all. Call the <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> method to accept any incoming datagrams. Use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method to send datagrams to a remote host.</para>
        </item>
      </list>
      <para>To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</para>
      <list type="bullet">
        <item>
          <para>If you are using a connection-oriented protocol such as TCP, use the <see cref="T:System.Net.Sockets.Socket" />, <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, and <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> methods to connect with a listening host. Use the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> and <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> or <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> and <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> methods to communicate data asynchronously. Incoming connection requests can be processed using <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> and <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</para>
        </item>
        <item>
          <para>If you are using a connectionless protocol such as UDP, you can use <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> and <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> to send datagrams, and <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> and <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> to receive datagrams.</para>
        </item>
      </list>
      <para>If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</para>
      <para>When you are finished sending and receiving data, use the <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> method to disable the <see cref="T:System.Net.Sockets.Socket" />. After calling <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />, call the <see cref="M:System.Net.Sockets.Socket.Close" /> method to release all resources associated with the <see cref="T:System.Net.Sockets.Socket" />.</para>
      <para>The <see cref="T:System.Net.Sockets.Socket" /> class allows you to configure your <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method. Retrieve these settings using the <see cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" /> method.</para>
      <block subset="none" type="note">
        <para>If you are writing a relatively simple application and do not require maximum performance, consider using <see cref="T:System.Net.Sockets.TcpClient" />, <see cref="T:System.Net.Sockets.TcpListener" />, and <see cref="T:System.Net.Sockets.UdpClient" />. These classes provide a simpler and more user-friendly interface to <see cref="T:System.Net.Sockets.Socket" /> communications.</para>
      </block>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Implements the Berkeley sockets interface.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you call the <see cref="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" /> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <see cref="T:System.Net.Sockets.Socket" />s with the same underlying socket. This practice is strongly discouraged.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</para>
        </summary>
        <param name="socketInformation">
          <attribution license="cc4" from="Microsoft" modified="false" />The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType)" />
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> is invalid.</para>
          <para>-or-</para>
          <para>An error occurred while creating the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="addressFamily" /> parameter specifies the addressing scheme that the <see cref="T:System.Net.Sockets.Socket" /> class uses, the <paramref name="socketType" /> parameter specifies the type of the <see cref="T:System.Net.Sockets.Socket" /> class, and the <paramref name="protocolType" /> parameter specifies the protocol used by <see cref="T:System.Net.Sockets.Socket" />. The three parameters are not independent. Some address families restrict which protocols can be used with them, and often the <see cref="T:System.Net.Sockets.Socket" /> type is implicit in the protocol. If the combination of address family, <see cref="T:System.Net.Sockets.Socket" /> type, and protocol type results in an invalid <see cref="T:System.Net.Sockets.Socket" />, this constructor throws a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <block subset="none" type="note">
            <para>If this constructor throws a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</para>
        </summary>
        <param name="addressFamily">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values. </param>
        <param name="socketType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketType" /> values. </param>
        <param name="protocolType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept()" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <exception cref="T:System.ArgumentException">An error occurred while creating the new <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>An error occurred while accessing the listening socket or while creating the new socket.</para>
          <para>-or-</para>
          <para> The <see cref="P:System.Net.Sockets.Socket.Blocking" /> property is set to <see langword="false" />.</para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.Accept" /> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <see cref="T:System.Net.Sockets.Socket" />. You cannot use this returned <see cref="T:System.Net.Sockets.Socket" /> to accept any additional connections from the connection queue. However, you can call the <see cref="P:System.Net.Sockets.Socket.RemoteEndPoint" /> method of the returned <see cref="T:System.Net.Sockets.Socket" /> to identify the remote host's network address and port number.</para>
          <para>In blocking mode, <see cref="M:System.Net.Sockets.Socket.Accept" /> blocks until an incoming connection attempt is queued. Once a connection is accepted, the original <see cref="T:System.Net.Sockets.Socket" /> continues queuing incoming connection requests until you close it.</para>
          <para>If you call this method using a non-blocking <see cref="T:System.Net.Sockets.Socket" />, and no connection requests are queued, <see cref="M:System.Net.Sockets.Socket.Accept" /> throws a <see cref="T:System.Net.Sockets.SocketException" />. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          <block subset="none" type="note">
            <para>Before calling the <see cref="M:System.Net.Sockets.Socket.Accept" /> method, you must first call the <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method to listen for and queue incoming connection requests.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Connection-oriented protocols can use the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method, you must call the <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method to listen for and queue incoming connection requests.</para>
          <para>To be notified of completion, you must create a callback method that implements the EventHandler&lt;SocketAsyncEventArgs&gt; delegate and hook it to the <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event.</para>
          <para>The following properties and events on the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object are required:</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
              </para>
            </item>
          </list>
          <para>The caller can optionally specify an existing <see cref="T:System.Net.Sockets.Socket" /> to use for the incoming connection by specifying the <see cref="T:System.Net.Sockets.Socket" /> to use with the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" /> property.</para>
          <para>If the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" /> property is null, a new <see cref="T:System.Net.Sockets.Socket" /> is constructed with the same <see cref="P:System.Net.Sockets.Socket.AddressFamily" />, <see cref="P:System.Net.Sockets.Socket.SocketType" />, and <see cref="P:System.Net.Sockets.Socket.ProtocolType" /> as the current <see cref="T:System.Net.Sockets.Socket" /> and set as the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" /> property.</para>
          <para>The caller may set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" /> property to any user state object desired before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </para>
          <para>Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method succeeds. In this case, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property needs to be set to the buffer containing the data to receive and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> property needs to be set to the maximum number of bytes of data to receive in the buffer. These properties can be set using the <see cref="Overload:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer" /> method. Part of the buffer passed in will be consumed internally for use by the the underlying Winsock AcceptEx call. This means that the amount of data returned will always be less than the value of the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> property on the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> instance provided. The amount of the buffer used internally varies based on the address family of the socket. The minimum buffer size required is 288 bytes. If a larger buffer size is specified, then the <see cref="T:System.Net.Sockets.Socket" /> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received. If a timeout occurs, the connection is reset. So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</para>
          <para>The completion callback method should examine the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketError" /> property to determine if the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> operation was successful.</para>
          <para>The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event can occur in some cases when no connection has been accepted and cause the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketError" /> property to be set to <see cref="F:System.Net.Sockets.SocketError.ConnectionReset" />. This can occur as a result of port scanning using a half-open SYN type scan (a SYN -&gt; SYN-ACK -&gt; RST sequence). Applications using the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method should be prepared to handle this condition. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous operation to accept an incoming connection attempt.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</para>
          <para>Returns false if the I/O operation completed synchronously. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</para>
        </returns>
        <param name="e">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="ILASM" Value=".property valuetype System.Net.Sockets.AddressFamily AddressFamily { public hidebysig specialname instance valuetype System.Net.Sockets.AddressFamily get_AddressFamily() }" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>One of the values defined in
      the <see cref="T:System.Net.Sockets.AddressFamily" /> enumeration.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Net.Sockets.AddressFamily" /> specifies the addressing scheme that an instance of the <see cref="T:System.Net.Sockets.Socket" /> class can use. This property is read-only and is set when the <see cref="T:System.Net.Sockets.Socket" /> is created.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="ILASM" Value=".property int32 Available { public hidebysig specialname instance int32 get_Available() }" />
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para> A <see cref="T:System.Int32" qualify="true" /> containing the number of bytes of data that are
   available to be read.</para>
        </value>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you are using a non-blocking <see cref="T:System.Net.Sockets.Socket" />, <see cref="P:System.Net.Sockets.Socket.Available" /> is a good way to determine whether data is queued for reading, before calling <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />. The available data is the total amount of data queued in the network buffer for reading. If no data is queued in the network buffer, <see cref="P:System.Net.Sockets.Socket.Available" /> returns 0.</para>
          <para>If the remote host shuts down or closes the connection, <see cref="P:System.Net.Sockets.Socket.Available" /> can throw a <see cref="T:System.Net.Sockets.SocketException" />. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the amount of data that has been received from the network and is available to be read.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accepting the connection. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para> The following excerpt from the <see cref="T:System.Net.Sockets.Socket" /> class overview
   example outlines an asynchronous accept operation. </para>
          <code lang="C#">public class Server
{
  static void Main()
  {
    .
    .
    .
    listenSocket.BeginAccept(
      new AsyncCallback(Server.acceptCallback),
      listenSocket);
    .
    .
    .
    // EndAccept can be called here
    .
    .
    .
  }

  public static void
    acceptCallback(IAsyncResult asyncAccept)
  {
    Socket listenSocket =
      (Socket)asyncAccept.AsyncState;

    Socket serverSocket =
      listenSocket.EndAccept(asyncAccept);

    serverSocket.BeginReceive(...);
    .
    .
    .
  }
}
</code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Connection-oriented protocols can use the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method, you must call the <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method to listen for and queue incoming connection requests.</para>
          <para>You must create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate and pass its name to the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method. To do this, at the very minimum, you must pass the listening <see cref="T:System.Net.Sockets.Socket" /> object to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> through the <paramref name="state" /> parameter. If your callback needs more information, you can create a small class to hold the <see cref="T:System.Net.Sockets.Socket" /> and the other required information. Pass an instance of this class to the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method should invoke the <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />, the system usually uses a separate thread to execute the specified callback method and blocks on <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> until a pending connection is retrieved. <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> will return a new <see cref="T:System.Net.Sockets.Socket" /> object that you can use to send and receive data with the remote host. You cannot use this returned <see cref="T:System.Net.Sockets.Socket" /> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method, use <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />. Call the Set method on a <see cref="T:System.Threading.ManualResetEvent" /> in the callback method when you want the original thread to continue executing. </para>
          <para>The system may also use the calling thread to invoke the callback method. In this case, the <see cref="P:System.IAsyncResult.CompletedSynchronously" /> property on the returned <see cref="T:System.IAsyncResult" /> will be set to indicate that the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method completed synchronously.</para>
          <para>For additional information on writing callback methods see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">[&lt;topic://cpconcallbacksample&gt;]</a></format>.</para>
          <para>To cancel a pending call to the <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> method, close the <see cref="T:System.Net.Sockets.Socket" />. When the <see cref="M:System.Net.Sockets.Socket.Close" /> method is called while an asynchronous operation is in progress, the callback provided to the <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> method is called.  A subsequent call to the <see cref="Overload:System.Net.Sockets.Socket.EndAccept" /> method will throw an <see cref="T:System.ObjectDisposedException" /> to indicate that the operation has been cancelled.</para>
          <block subset="none" type="note">
            <para>You can use the <see cref="P:System.Net.Sockets.Socket.RemoteEndPoint" /> property of the returned <see cref="T:System.Net.Sockets.Socket" /> to identify the remote host's network address and port number.</para>
          </block>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
            <para />
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous operation to accept an incoming connection attempt.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</para>
        </returns>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains state information for this request. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Connection-oriented protocols can use the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method to asynchronously process incoming connection attempts. Accepting connections asynchronously enables you to send and receive data within a separate execution thread. This overload allows you to specify the number of bytes to accept in the initial transfer in the <paramref name="receiveSize" /> parameter.</para>
          <para>Before calling the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method, you must call the <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method to listen for and queue incoming connection requests.</para>
          <para>You must create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate and pass its name to the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method. To do this, at the very minimum, you must pass the listening <see cref="T:System.Net.Sockets.Socket" /> object to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> through the <paramref name="state" /> parameter. If your callback needs more information, you can create a small class to hold the <see cref="T:System.Net.Sockets.Socket" /> and the other required information. Pass an instance of this class to the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method should invoke the <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />, the system usually uses a separate thread to execute the specified callback method and blocks on <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> until a pending connection is retrieved.</para>
          <para>
            <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> returns a new <see cref="T:System.Net.Sockets.Socket" /> that you can use to send and receive data with the remote host. You cannot use this returned <see cref="T:System.Net.Sockets.Socket" /> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" /> method, use <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />. Call the Set method on a <see cref="T:System.Threading.ManualResetEvent" /> in the callback method when you want the original thread to continue executing. </para>
          <para>The system may also use the calling thread to invoke the callback method. In this case, the <see cref="P:System.IAsyncResult.CompletedSynchronously" /> property on the returned <see cref="T:System.IAsyncResult" /> will be set to indicate that the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" /> method completed synchronously.</para>
          <para>For additional information on writing callback methods see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">[&lt;topic://cpconcallbacksample&gt;]</a></format>.</para>
          <para>To cancel a pending call to the <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> method, close the <see cref="T:System.Net.Sockets.Socket" />.  When the  <see cref="M:System.Net.Sockets.Socket.Close" /> method is called while an asynchronous operation is in progress, the callback provided to the <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> method is called.  A subsequent call to the <see cref="Overload:System.Net.Sockets.Socket.EndAccept" /> method will throw an <see cref="T:System.ObjectDisposedException" /> to indicate that the operation has been cancelled.</para>
          <block subset="none" type="note">
            <para>You can call use the <see cref="P:System.Net.Sockets.Socket.RemoteEndPoint" /> property of the returned <see cref="T:System.Net.Sockets.Socket" /> object to identify the remote host's network address and port number.</para>
          </block>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</para>
        </returns>
        <param name="receiveSize">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to accept from the sender. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains state information for this request. </param>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Connection-oriented protocols can use the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. This overload allows you to specify the accepted socket in the <paramref name="acceptSocket" /> parameter. If this parameter is null, the accepted socket is created by the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method. You can specify the number of bytes to accept in the initial transfer in the <paramref name="receiveSize" /> parameter.</para>
          <para>Before calling the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" /> method, you must call the <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method to listen for and queue incoming connection requests.</para>
          <para>You must create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate and pass its name to the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" /> method. To do this, at the very minimum, you must pass the listening <see cref="T:System.Net.Sockets.Socket" /> object to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" /> through the <paramref name="state" /> parameter. If your callback needs more information, you can create a small class to hold the <see cref="T:System.Net.Sockets.Socket" /> and the other required information. Pass an instance of this class to the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method should invoke the <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />, the system usually uses a separate thread to execute the specified callback method and blocks on <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> until a pending connection is retrieved.</para>
          <para>
            <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> returns a new <see cref="T:System.Net.Sockets.Socket" /> object that you can use to send and receive data with the remote host. You cannot use this returned <see cref="T:System.Net.Sockets.Socket" /> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" /> method, use <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />. Call the Set method on a <see cref="T:System.Threading.ManualResetEvent" /> in the callback method when you want the original thread to continue executing. </para>
          <para>The system may also use the calling thread to invoke the callback method. In this case, the <see cref="P:System.IAsyncResult.CompletedSynchronously" /> property on the returned <see cref="T:System.IAsyncResult" /> will be set to indicate that the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" /> method completed synchronously.</para>
          <para>For additional information on writing callback methods, see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">[&lt;topic://cpconcallbacksample&gt;]</a></format>.</para>
          <para>To cancel a pending call to the <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> method, close the <see cref="T:System.Net.Sockets.Socket" />. When the <see cref="M:System.Net.Sockets.Socket.Close" /> method is called while an asynchronous operation is in progress, the callback provided to the <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> method is called.  A subsequent call to the <see cref="Overload:System.Net.Sockets.Socket.EndAccept" /> method will throw an <see cref="T:System.ObjectDisposedException" /> to indicate that the operation has been cancelled.</para>
          <block subset="none" type="note">
            <para>You can use the <see cref="P:System.Net.Sockets.Socket.RemoteEndPoint" /> property of the returned <see cref="T:System.Net.Sockets.Socket" /> object to identify the remote host's network address and port number.</para>
          </block>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</para>
        </returns>
        <param name="acceptSocket">
          <attribution license="cc4" from="Microsoft" modified="false" />The accepted <see cref="T:System.Net.Sockets.Socket" /> object. This value may be null. </param>
        <param name="receiveSize">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to receive. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains state information for this request. </param>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="end_point" Type="System.Net.EndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="end_point">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="remoteEP " />is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while making the connection. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to make a connection to the endpoint defined by <paramref name="remoteEP" />. <block subset="none" type="note">See <see cref="F:System.Net.NetworkAccess.Connect" qualify="true" />.</block></permission>
        <example>
          <para> For an outline of an asynchronous
      operation, see the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For the complete example, which uses the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method, see the
      <see cref="T:System.Net.Sockets.Socket" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you are using a connection-oriented protocol, the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method starts an asynchronous request for a connection to the <paramref name="remoteEP" /> parameter. If you are using a connectionless protocol, <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> establishes a default remote host. Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</para>
          <para>You can create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate and pass its name to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method. At the very minimum, you must pass the <see cref="T:System.Net.Sockets.Socket" /> to <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> through the <paramref name="state" /> parameter. If your callback needs more information, you can create a small class to hold the <see cref="T:System.Net.Sockets.Socket" />, and the other required information. Pass an instance of this class to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method should invoke the <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, the system will use a separate thread to execute the specified callback method, and will block on <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> until the <see cref="T:System.Net.Sockets.Socket" /> connects successfully or throws an exception. If you want the original thread to block after you call the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method, use <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />. Call the Set method on a <see cref="T:System.Threading.ManualResetEvent" /> in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">[&lt;topic://cpconcallbacksample&gt;]</a></format>.</para>
          <para>If you are using a connectionless protocol such as UDP, you do not have to call <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> before sending and receiving data. You can use <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> and <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> to communicate with a remote host. If you do call <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, any datagrams that arrive from an address other than the specified default will be discarded. If you wish to set your default remote host to a broadcast address, you must first call <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> and set Broadcast to true. If you cannot, <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <para>If you are using a connection-oriented protocol and do not call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, the underlying service provider will assign the most appropriate local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> or <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> method. If you want to change the default remote host, call the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method again with the desired endpoint.</para>
          <para>To cancel a pending call to the <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> method, close the <see cref="T:System.Net.Sockets.Socket" />. When the <see cref="M:System.Net.Sockets.Socket.Close" /> method is called while an asynchronous operation is in progress, the callback provided to the <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> method is called.  A subsequent call to the <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method will throw an <see cref="T:System.ObjectDisposedException" /> to indicate that the operation has been cancelled.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>If this socket has previously been disconnected, then <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>. </para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous request for a remote host connection.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</para>
        </returns>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains state information for this request. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The asynchronous <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" /> operation must be completed by calling the <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="requestCallback" /> delegate.</para>
          <para>This method does not block until the operation is complete. To block until the operation is complete, use one of the <see cref="Overload:System.Net.Sockets.Socket.Connect" /> method overloads, or <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />.</para>
          <para>To cancel a pending call to the  <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> method, close the <see cref="T:System.Net.Sockets.Socket" />. When the <see cref="M:System.Net.Sockets.Socket.Close" /> method is called while an asynchronous operation is in progress, the callback provided to the <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> method is called.  A subsequent call to the <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method will throw an <see cref="T:System.ObjectDisposedException" /> to indicate that the operation has been cancelled.</para>
          <para>For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format></para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>If this socket has previously been disconnected, then <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <see cref="T:System.Net.EndPoint" /> that is used must be different.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous request for a remote host connection. The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</para>
        </returns>
        <param name="address">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.IPAddress" /> of the remote host.</param>
        <param name="port">
          <attribution license="cc4" from="Microsoft" modified="false" />The port number of the remote host.</param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object that contains information about the connect operation. This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The asynchronous <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" /> operation must be completed by calling the <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="requestCallback" /> delegate.</para>
          <para>This method does not block until the operation is complete. To block until the operation is complete, use one of the <see cref="Overload:System.Net.Sockets.Socket.Connect" /> method overloads.</para>
          <para>To cancel a pending call to the <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> method, close the <see cref="T:System.Net.Sockets.Socket" />. When the <see cref="M:System.Net.Sockets.Socket.Close" /> method is called while an asynchronous operation is in progress, the callback provided to the <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> method is called.  A subsequent call to the  <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method will throw an <see cref="T:System.ObjectDisposedException" /> to indicate that the operation has been cancelled.</para>
          <para>For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format>.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>If this socket has previously been disconnected, then <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <see cref="T:System.Net.EndPoint" /> that is used must be different.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous request for a remote host connection. The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</para>
        </returns>
        <param name="addresses">
          <attribution license="cc4" from="Microsoft" modified="false" />At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</param>
        <param name="port">
          <attribution license="cc4" from="Microsoft" modified="false" />The port number of the remote host.</param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object that contains information about the connect operation. This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The asynchronous <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" /> operation must be completed by calling the <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="requestCallback" /> delegate.</para>
          <para>This method does not block until the operation is complete. To block until the operation is complete, use one of the <see cref="Overload:System.Net.Sockets.Socket.Connect" /> method overloads.</para>
          <para>To cancel a pending call to the  <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> method, close the <see cref="T:System.Net.Sockets.Socket" />. When the <see cref="M:System.Net.Sockets.Socket.Close" /> method is called while an asynchronous operation is in progress, the callback provided to the <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> method is called.  A subsequent call to the <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method will throw an <see cref="T:System.ObjectDisposedException" /> to indicate that the operation has been cancelled.</para>
          <para>For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format></para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>If this socket has previously been disconnected, then <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <see cref="T:System.Net.EndPoint" /> that is used must be different.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous request for a remote host connection. The host is specified by a host name and a port number.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</para>
        </returns>
        <param name="host">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the remote host.</param>
        <param name="port">
          <attribution license="cc4" from="Microsoft" modified="false" />The port number of the remote host.</param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object that contains information about the connect operation. This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you are using a connection-oriented protocol, you can call the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method to request a disconnect from a remote endpoint. If <paramref name="reuseSocket" /> is true, you can reuse the socket.</para>
          <para>The <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method uses a separate thread to invoke the specified callback method. The <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> method blocks until the pending disconnect is complete. For additional information on writing callback methods, see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">[&lt;topic://cpconcallbacksample&gt;]</a></format>.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" /> exception, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous request to disconnect from a remote endpoint.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</para>
        </returns>
        <param name="reuseSocket">
          <attribution license="cc4" from="Microsoft" modified="false" />true if this socket can be reused after the connection is closed; otherwise, false. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains state information for this request. </param>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The asynchronous <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> operation must be completed by calling the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="callback" /> delegate.</para>
          <para>This method does not block until the operation is complete. To block until the operation is complete, use one of the <see cref="Overload:System.Net.Sockets.Socket.Receive" /> method overloads.</para>
          <para>To cancel a pending <see cref="Overload:System.Net.Sockets.Socket.BeginReceive" />, call the <see cref="M:System.Net.Sockets.Socket.Close" /> method.</para>
          <para>For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format>.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.</para>
          </block>
          <block subset="none" type="note">
            <para>
              <paramref name="state" /> is an instantiation of a user-defined class. </para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</para>
        </returns>
        <param name="buffers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="socketFlags">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object that contains information about the receive operation. This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Byte[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="socket_flags">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0. </para>
          <para>-or-</para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para> -or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see
      the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For the complete example, which uses the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method, see the <see cref="T:System.Net.Sockets.Socket" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The asynchronous <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> operation must be completed by calling the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> method. Typically, the method is invoked by the <paramref name="callback" /> delegate.</para>
          <para>This method does not block until the operation is complete. To block until the operation is complete, use one of the <see cref="Overload:System.Net.Sockets.Socket.Receive" /> method overloads.</para>
          <para>To cancel a pending <see cref="Overload:System.Net.Sockets.Socket.BeginReceive" />, call the <see cref="M:System.Net.Sockets.Socket.Close" /> method.</para>
          <para>For detailed information about using the asynchronous programming model, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchronous Programming Overview</a></format>.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.</para>
          </block>
          <block subset="none" type="note">
            <para>
              <paramref name="state" /> is an instantiation of a user-defined class. </para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that is the storage location for the received data. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based position in the <paramref name="buffer" /> parameter at which to store the received data. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to receive. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object that contains information about the receive operation. This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, valuetype System.Net.Sockets.SocketError error, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(class System.Byte[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" qualify="true" /> array to store data received from the socket.</param>
        <param name="offset">A <see cref="T:System.Int32" qualify="true" /> containing the zero-based position in <paramref name="buffer " />to begin storing the received data.</param>
        <param name="size">A <see cref="T:System.Int32" qualify="true" /> containing the number of bytes to receive.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">A <see cref="T:System.AsyncCallback" /> delegate, or <see langword="null" />.</param>
        <param name="state">An application-defined object, or <see langword="null" />.</param>
        <summary>
          <para> Begins an asynchronous operation to receive data from a socket and,
      for connectionless protocols, store the endpoint associated with the socket that
      sent the data.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.IAsyncResult" /> instance that contains information about the asynchronous operation.</para>
        </returns>
        <remarks>
          <para>To retrieve the results of the operation and release
      resources allocated by the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method, call
      the <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> method, and specify the
   <see cref="T:System.IAsyncResult" /> object returned by this
      
      method.</para>
          <para>
            <block subset="none" type="note">The <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> method should be
   called exactly once for each call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
   method.</block>
          </para>
          <para>If the <paramref name="callback" /> parameter is not
<see langword="null" />, the method referenced by <paramref name="callback" /> is invoked 
when the asynchronous operation completes. The <see cref="T:System.IAsyncResult" /> object returned by this method is
passed as the argument to the method referenced by <paramref name="callback" />. The method
referenced by <paramref name="callback" /> can retrieve the results of the operation by calling
the <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
method.</para>
          <para> The <paramref name="state" /> parameter
can be any object that the caller wishes to have available for the duration of
the asynchronous operation. This object is available via the
<see cref="P:System.IAsyncResult.AsyncState" /> 
property of the object returned by this
method.</para>
          <block subset="none" type="note">
            <para>For more information, see <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />, the
   synchronous version of this method.</para>
          </block>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="buffer " />is <see langword="null" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="remoteEP " />is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0. </para>
          <para>-or-</para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para> -or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">
          <para>Requires permission to accept a connection on the endpoint defined by the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property of the current instance. See <see cref="F:System.Net.NetworkAccess.Accept" qualify="true" />.</para>
          <para>Requires permission to make a connection to the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Connect" qualify="true" />.</para>
        </permission>
        <example>
          <para>For an outline of an asynchronous operation, see
      the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For the complete example, see <see cref="T:System.Net.Sockets.Socket" />.</para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method starts an asynchronous send operation to the remote host established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.Sockets.Socket.Accept" />, or <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method. <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> will throw an exception if you do not first call <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />. Calling the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method gives you the ability to send data within a separate execution thread.</para>
          <para>You can create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate and pass its name to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method. To do this, at the very minimum, your <paramref name="state" /> parameter must contain the connected or default <see cref="T:System.Net.Sockets.Socket" /> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <see cref="T:System.Net.Sockets.Socket" /> and the other required information. Pass an instance of this class to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method should invoke the <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />, the system will use a separate thread to execute the specified callback method, and will block on <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> until the <see cref="T:System.Net.Sockets.Socket" /> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method, use the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">[&lt;topic://cpconcallbacksample&gt;]</a></format>.</para>
          <para>Although intended for connection-oriented protocols, <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> also works for connectionless protocols, provided that you first call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />. It is okay to use <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> even after you have established a default remote host with <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />. You can also change the default remote host prior to calling <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> by making another call to <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <para>If you specify the <see cref="F:System.Net.Sockets.SocketFlags.DontRoute" /> flag as the <paramref name="socketflags" /> parameter, the data you are sending will not be routed. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes. </para>
          </block>
          <block subset="none" type="note">
            <para>
              <paramref name="state" /> is an instantiation of a user-defined class. </para>
          </block>
          <block subset="none" type="note">
            <para>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</para>
        </returns>
        <param name="buffers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the data to send. </param>
        <param name="socketFlags">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains state information for this request. </param>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Byte[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="socket_flags">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0. </para>
          <para>-or- </para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para> -or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see
      the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For the complete example, which uses the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method, see the <see cref="T:System.Net.Sockets.Socket" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method starts an asynchronous send operation to the remote host established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.Sockets.Socket.Accept" />, or <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method. <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> will throw an exception if you do not first call <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />. Calling the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method gives you the ability to send data within a separate execution thread.</para>
          <para>You can create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate and pass its name to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method. To do this, at the very minimum, your <paramref name="state" /> parameter must contain the connected or default <see cref="T:System.Net.Sockets.Socket" /> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <see cref="T:System.Net.Sockets.Socket" /> and the other required information. Pass an instance of this class to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method should invoke the <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />, the system will use a separate thread to execute the specified callback method, and will block on <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> until the <see cref="T:System.Net.Sockets.Socket" /> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method, use the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">[&lt;topic://cpconcallbacksample&gt;]</a></format>.</para>
          <para>Although intended for connection-oriented protocols, <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> also works for connectionless protocols, provided that you first call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />. It is okay to use <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> even after you have established a default remote host with <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />. You can also change the default remote host prior to calling <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> by making another call to <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <para>If you specify the <see cref="F:System.Net.Sockets.SocketFlags.DontRoute" /> flag as the <paramref name="socketflags" /> parameter, the data you are sending will not be routed. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes. </para>
          </block>
          <block subset="none" type="note">
            <para>
              <paramref name="state" /> is an instantiation of a user-defined class. </para>
          </block>
          <block subset="none" type="note">
            <para>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the data to send. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to send. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains state information for this request. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This overload sends the file <paramref name="fileName" /> to the connected socket. If <paramref name="fileName" /> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards ("..\\myfile.txt") and UNC share names ("\\\\shared directory\\myfile.txt") are supported. If the file is not found, the exception <see cref="T:System.IO.FileNotFoundException" /> is thrown.</para>
          <para>This method uses the TransmitFile function found in the Windows Sockets 2 API. For more information about the TransmitFile function and its flags, see the Windows Sockets documentation in the MSDN Library.</para>
          <para>The <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method starts an asynchronous send operation to the remote host established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.Sockets.Socket.Accept" />, or <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> methods. <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> throws an exception if you do not first call <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />. Calling the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method enables you to send a file within a separate execution thread.</para>
          <para>To complete the operation, you can create a callback method that is invoked by the <see cref="T:System.AsyncCallback" /> delegate parameter. To do this, at the very minimum, the <paramref name="state" /> parameter must contain the <see cref="T:System.Net.Sockets.Socket" /> object being used for communication. If your callback needs more information, you can create a class or structure to hold the <see cref="T:System.Net.Sockets.Socket" /> and the other required information. Pass an instance of this custom object to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method must invoke the <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />, the system uses a separate thread to execute the specified callback method, and blocks on <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> until the <see cref="T:System.Net.Sockets.Socket" /> sends the entire file or throws an exception. For additional information on writing callback methods see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">[&lt;topic://cpconcallbacksample&gt;]</a></format>.</para>
          <para>Although intended for connection-oriented protocols, <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> also works for connectionless protocols, provided that you first call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method to establish a default remote host. With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> throws a <see cref="T:System.Net.Sockets.SocketException" /> exception.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" /> exception, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</para>
        </returns>
        <param name="fileName">
          <attribution license="cc4" from="Microsoft" modified="false" />A string that contains the path and name of the file to send. This parameter can be null. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains state information for this request. </param>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This overload requires the name of the file you want to send and a bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values. The <paramref name="preBuffer" /> parameter contains any data you want to precede the file. <paramref name="postBuffer" /> contains data you want to follow the file. If <paramref name="fileName" /> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards ("..\\myfile.txt") and UNC share names ("\\\\shared directory\\myfile.txt") are supported. If the file is not found, the exception <see cref="T:System.IO.FileNotFoundException" /> is thrown.</para>
          <para>The <paramref name="flags" /> parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</para>
          <para>This method uses the TransmitFile function found in the Windows Sockets 2 API. For more information about the TransmitFile function and its flags, see the Windows Sockets documentation in the MSDN Library.</para>
          <para>The <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method starts an asynchronous send operation to the remote host established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.Sockets.Socket.Accept" />, or <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> methods. <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> throws an exception if you do not first call <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />. Calling the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method gives you the ability to send a file within a separate execution thread.</para>
          <para>To complete the operation, you can create a callback method that is invoked by the <see cref="T:System.AsyncCallback" /> delegate parameter. To do this, at the very minimum, the <paramref name="state" /> parameter must contain the <see cref="T:System.Net.Sockets.Socket" /> object being used for communication. If your callback needs more information, you can create a class or structure to hold the <see cref="T:System.Net.Sockets.Socket" /> and the other required information. Pass an instance of this custom object to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method must invoke the <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />, the system uses a separate thread to execute the specified callback method, and blocks on <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> until the <see cref="T:System.Net.Sockets.Socket" /> sends the entire file or throws an exception. For additional information on writing callback methods see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">[&lt;topic://cpconcallbacksample&gt;]</a></format>.</para>
          <para>Although intended for connection-oriented protocols, <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> also works for connectionless protocols, provided that you first call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> throws a <see cref="T:System.Net.Sockets.SocketException" /> exception.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" /> exception, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</para>
        </returns>
        <param name="fileName">
          <attribution license="cc4" from="Microsoft" modified="false" />A string that contains the path and name of the file to be sent. This parameter can be null. </param>
        <param name="preBuffer">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent. This parameter can be null. </param>
        <param name="postBuffer">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent. This parameter can be null. </param>
        <param name="flags">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes. This parameter can be null. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-defined object that contains state information for this request. This parameter can be null. </param>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(class System.Byte[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="socket_flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="buffer " />is <see langword="null" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="remoteEP " />is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0. </para>
          <para>-or-</para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para> -or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">
          <para>Requires permission to make a connection to the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Connect" qualify="true" />.</para>
        </permission>
        <example>
          <para>For an outline of an asynchronous operation, see
      the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For
      the complete example, see the <see cref="T:System.Net.Sockets.Socket" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method starts an asynchronous send operation to the remote host specified in the <paramref name="remoteEP" /> parameter. Calling the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method gives you the ability to send data within a separate execution thread. Although intended for connectionless protocols, <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> works with both connectionless and connection-oriented protocols.</para>
          <para>You can create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate and pass its name to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method. To do this, at the very minimum, your <paramref name="state" /> parameter must contain the connected or default <see cref="T:System.Net.Sockets.Socket" /> being used for communication. If your callback needs more information, you can create a small class to hold the <see cref="T:System.Net.Sockets.Socket" />, and the other required information. Pass an instance of this class to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method should invoke the <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />, the system will use a separate thread to execute the specified callback method, and will block on <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> until the <see cref="T:System.Net.Sockets.Socket" /> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method, use the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information about writing callback methods see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">[&lt;topic://cpconcallbacksample&gt;]</a></format>.</para>
          <para>If you are using a connection-oriented protocol, you must first call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.Sockets.Socket.Accept" />, or <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method, or <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> will ignore the <paramref name="remoteEP" /> parameter and send data to the <see cref="T:System.Net.EndPoint" /> established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.Sockets.Socket.Accept" />, or <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.</para>
          <para>If you are using a connectionless protocol, you do not need to establish a default remote host with the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />. You only need to do this if you intend to call the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method. If you do call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />, the <paramref name="remoteEP" /> parameter will override the specified default remote host for that send operation only. You are also not required to call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method. In this case, the underlying service provider will assign the most appropriate local network address and port number. Use a port number of zero if you want the underlying service provider to select a free port. If you need to identify the assigned local network address and port number, you can use the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property after the <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> method successfully completes.</para>
          <para>If you want to send data to a broadcast address, you must first call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method and set the socket option to <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />. -You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <para>If you specify the <see cref="F:System.Net.Sockets.SocketFlags.DontRoute" /> flag as the <paramref name="socketflags" /> parameter, the data you are sending will not be routed. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <see cref="T:System.Net.Sockets.Socket" /> methods. After the first use of a particular context (a specific asynchronous <see cref="T:System.Net.Sockets.Socket" /> method, a specific <see cref="T:System.Net.Sockets.Socket" /> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends data asynchronously to a specific remote host.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the data to send. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based position in <paramref name="buffer" /> at which to begin sending data. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to send. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains state information for this request. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP)" />
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint local_end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint local_end) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="local_end" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="local_end">
          <para>The local <see cref="T:System.Net.EndPoint" qualify="true" /> to be associated with the socket.</para>
        </param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP " />is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <exception cref="T:System.Security.SecurityException"> A caller in the call stack does not have the required permission.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to accept connections on the endpoint defined by <paramref name="localEP" />. See <see cref="F:System.Net.NetworkAccess.Accept" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method if you need to use a specific local endpoint. You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> before you can call the <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method. You do not need to call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> before using the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method unless you need to use a specific local endpoint. You can use the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method on both connectionless and connection-oriented protocols.</para>
          <para>Before calling <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />, you must first create the local <see cref="T:System.Net.IPEndPoint" /> from which you intend to communicate data. If you do not care which local address is assigned, you can create an <see cref="T:System.Net.IPEndPoint" /> using <see cref="F:System.Net.IPAddress.Any" /> as the address parameter, and the underlying service provider will assign the most appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port is used, you can create an <see cref="T:System.Net.IPEndPoint" /> using 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000.</para>
          <para>If you use the above approach, you can discover what local network address and port number has been assigned by calling the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />. If you are using a connection-oriented protocol, <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> will not return the locally assigned network address until after you have made a call to the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method. If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</para>
          <para>If a UDP socket wants to receive interface information on received packets,  the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method should be explicitly called with the socket option set to <see cref="F:System.Net.Sockets.SocketOptionName.PacketInformation" /> immediately after calling the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method.</para>
          <block subset="none" type="note">
            <para>If you intend to receive multicast datagrams, you must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method with a multicast port number.</para>
          </block>
          <block subset="none" type="note">
            <para>You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method if you intend to receive connectionless datagrams using the <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> method.</para>
          </block>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" /> when calling the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="ILASM" Value=".property bool Blocking { public hidebysig specialname instance bool get_Blocking() public hidebysig specialname instance void set_Blocking(bool value) }" />
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> indicates that
   the current instance is in blocking mode;
<see langword="false" /> indicates that the current instance is in 
   non-blocking mode. </para>
        </value>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Net.Sockets.Socket.Blocking" /> property indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</para>
          <para>If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes. If you want execution to continue even though the requested operation is not complete, change the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property to false. The <see cref="P:System.Net.Sockets.Socket.Blocking" /> property has no effect on asynchronous methods. If you are sending and receiving data asynchronously and want to block execution, use the <see cref="T:System.Threading.ManualResetEvent" /> class.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Close()" />
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.Close" /> method closes the remote host connection and releases all managed and unmanaged resources associated with the <see cref="T:System.Net.Sockets.Socket" />. Upon closing, the <see cref="P:System.Net.Sockets.Socket.Connected" /> property is set to false.</para>
          <para>For connection-oriented protocols, it is recommended that you call <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> before calling the <see cref="M:System.Net.Sockets.Socket.Close" /> method. This ensures that all data is sent and received on the connected socket before it is closed.</para>
          <para>If you need to call <see cref="M:System.Net.Sockets.Socket.Close" /> without first calling <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />, you can ensure that data queued for outgoing transmission will be sent by setting the <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> <see cref="T:System.Net.Sockets.Socket" /> option to false and specifying a non-zero time-out interval. <see cref="M:System.Net.Sockets.Socket.Close" /> will then block until this data is sent or until the specified time-out expires. If you set <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> to false and specify a zero time-out interval, <see cref="M:System.Net.Sockets.Socket.Close" /> releases the connection and automatically discards outgoing queued data.</para>
          <block subset="none" type="note">
            <para>To set the <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> socket option to false, create a <see cref="T:System.Net.Sockets.LingerOption" />, set the enabled property to true, and set the <see cref="P:System.Net.Sockets.LingerOption.LingerTime" /> property to the desired time out period. Use this <see cref="T:System.Net.Sockets.LingerOption" /> along with the <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> socket option to call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.Close" /> method closes the remote host connection and releases all managed and unmanaged resources associated with the <see cref="T:System.Net.Sockets.Socket" />. Upon closing, the <see cref="P:System.Net.Sockets.Socket.Connected" /> property is set to false.</para>
          <para>For connection-oriented protocols, it is recommended that you call <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> before calling <see cref="M:System.Net.Sockets.Socket.Close" />. This ensures that all data is sent and received on the connected socket before it is closed.</para>
          <para>If you need to call <see cref="M:System.Net.Sockets.Socket.Close" /> without first calling <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />, you can ensure that data queued for outgoing transmission will be sent by setting the <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> option to false and specifying a non-zero time-out interval. <see cref="M:System.Net.Sockets.Socket.Close" /> will then block until this data is sent or until the specified time-out expires. If you set <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> to false and specify a zero time-out interval, <see cref="M:System.Net.Sockets.Socket.Close" /> releases the connection and automatically discards outgoing queued data.</para>
          <block subset="none" type="note">
            <para>To set the <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> socket option to false, create a <see cref="T:System.Net.Sockets.LingerOption" />, set the enabled property to true, and set the <see cref="P:System.Net.Sockets.LingerOption.LingerTime" /> property to the desired time-out period. Use this <see cref="T:System.Net.Sockets.LingerOption" /> along with the <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> socket option to call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent. </para>
        </summary>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />Wait up to <paramref name="timeout" /> seconds to send any remaining data, then close the socket.</param>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP)" />
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP " />is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <exception cref="T:System.Security.SecurityException"> A caller in the call stack does not have the required permission.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to make a connection to the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Connect" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you are using a connection-oriented protocol such as TCP, the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method synchronously establishes a network connection between <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> and the specified remote endpoint. If you are using a connectionless protocol, <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> establishes a default remote host. After you call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, you can send data to the remote device with the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method, or receive data from the remote device with the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method.</para>
          <para>If you are using a connectionless protocol such as UDP, you do not have to call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before sending and receiving data. You can use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> to synchronously communicate with a remote host. If you do call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method and set the socket option to <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />, or <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          <para>The <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method will block, unless you specifically set the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property to false prior to calling <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />. If you are using a connection-oriented protocol like TCP and you do disable blocking, <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" /> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, but has not yet completed successfully. Use the <see cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" /> method to determine when the <see cref="T:System.Net.Sockets.Socket" /> is finished connecting.</para>
          <block subset="none" type="note">
            <para>If you are using a connection-oriented protocol and did not call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> before calling <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> again with the desired endpoint.</para>
          </block>
          <block subset="none" type="note">
            <para>If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> methods to reconnect. This is a limitation of the underlying provider.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Establishes a connection to a remote host.</para>
        </summary>
        <param name="remoteEP">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Net.EndPoint" /> that represents the remote device. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you are using a connection-oriented protocol such as TCP, the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" /> method synchronously establishes a network connection between <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> and the specified remote endpoint. If you are using a connectionless protocol, <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" /> establishes a default remote host. After you call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" /> you can send data to the remote device with the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method, or receive data from the remote device with the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method.</para>
          <para>If you are using a connectionless protocol such as UDP, you do not have to call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" /> before sending and receiving data. You can use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> to synchronously communicate with a remote host. If you do call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" /> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method and set the socket option to <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />, or <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          <para>
            <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" /> method will block, unless you specifically set the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property to false prior to calling <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />. If you are using a connection-oriented protocol like TCP and you do disable blocking, <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" /> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, but has not yet completed successfully. Use the <see cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" /> method to determine when the <see cref="T:System.Net.Sockets.Socket" /> is finished connecting.</para>
          <block subset="none" type="note">
            <para>If you are using a connection-oriented protocol and did not call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> before calling <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" /> again with the desired endpoint.</para>
          </block>
          <block subset="none" type="note">
            <para>If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> methods to reconnect. This is a limitation of the underlying provider.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Establishes a connection to a remote host. The host is specified by an IP address and a port number.</para>
        </summary>
        <param name="address">
          <attribution license="cc4" from="Microsoft" modified="false" />The IP address of the remote host.</param>
        <param name="port">
          <attribution license="cc4" from="Microsoft" modified="false" />The port number of the remote host.</param>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is typically used immediately after a call to <see cref="M:System.Net.Dns.GetHostAddresses(System.String)" />, which can return multiple IP addresses for a single host. If you are using a connection-oriented protocol such as TCP, the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" /> method synchronously establishes a network connection between <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> and the specified remote endpoint. If you are using a connectionless protocol, <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" /> establishes a default remote host. After you call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" /> you can send data to the remote device with the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method, or receive data from the remote device with the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method.</para>
          <para>If you are using a connectionless protocol such as UDP, you do not have to call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" /> before sending and receiving data. You can use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> to synchronously communicate with a remote host. If you do call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" /> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method and set the socket option to <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />, or <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          <para>
            <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" /> method will block, unless you specifically set the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property to false prior to calling <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />. If you are using a connection-oriented protocol like TCP and you do disable blocking, <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" /> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, but has not yet completed successfully. Use the <see cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" /> method to determine when the <see cref="T:System.Net.Sockets.Socket" /> is finished connecting.</para>
          <block subset="none" type="note">
            <para>If you are using a connection-oriented protocol and did not call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> before calling <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" /> again with the desired endpoint.</para>
          </block>
          <block subset="none" type="note">
            <para>If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> methods to reconnect. This is a limitation of the underlying provider.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Establishes a connection to a remote host. The host is specified by an array of IP addresses and a port number.</para>
        </summary>
        <param name="addresses">
          <attribution license="cc4" from="Microsoft" modified="false" />The IP addresses of the remote host.</param>
        <param name="port">
          <attribution license="cc4" from="Microsoft" modified="false" />The port number of the remote host.</param>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you are using a connection-oriented protocol such as TCP, the <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" /> method synchronously establishes a network connection between <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> and the specified remote host. If you are using a connectionless protocol, <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" /> establishes a default remote host. After you call <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" /> you can send data to the remote device with the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method, or receive data from the remote device with the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method.</para>
          <para>If you are using a connectionless protocol such as UDP, you do not have to call <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" /> before sending and receiving data. You can use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> to synchronously communicate with a remote host. If you do call <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" /> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method and set the socket option to <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />, or <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          <para>
            <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" /> method will block, unless you specifically set the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property to false prior to calling <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />. If you are using a connection-oriented protocol like TCP and you do disable blocking, <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" /> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, but has not yet completed successfully. Use the <see cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" /> method to determine when the <see cref="T:System.Net.Sockets.Socket" /> is finished connecting.</para>
          <para>If IPv6 is enabled and the <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" /> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address. This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</para>
          <block subset="none" type="note">
            <para>If you are using a connection-oriented protocol and did not call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> before calling <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <see cref="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" /> again with the desired endpoint.</para>
          </block>
          <block subset="none" type="note">
            <para>If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" /> methods to reconnect. This is a limitation of the underlying provider.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Establishes a connection to a remote host. The host is specified by a host name and a port number.</para>
        </summary>
        <param name="host">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the remote host.</param>
        <param name="port">
          <attribution license="cc4" from="Microsoft" modified="false" />The port number of the remote host.</param>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you are using a connection-oriented protocol, the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method starts an asynchronous request for a connection to the remote host. If you are using a connectionless protocol, <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> establishes a default remote host. </para>
          <para>To be notified of completion, you must create a callback method that implements the EventHandler&lt;SocketAsyncEventArgs&gt; delegate and attach the callback to the <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event.</para>
          <para>The caller must set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> property to the <see cref="T:System.Net.IPEndPoint" /> of the remote host to connect to.</para>
          <para>The caller may set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" /> property to any user state object desired before calling the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </para>
          <para>If you are using a connectionless protocol such as UDP, you do not have to call <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> before sending and receiving data. You can use <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> and <see cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> to communicate with a remote host. If you do call <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method again with the desired endpoint. </para>
          <para>If you wish to set the default remote host to a broadcast address, you must first call <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" /> and set Broadcast to true. If this is not done, the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <para>The following properties and events on the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object are required:</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
              </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
              </para>
            </item>
          </list>
          <para>Optionally, a buffer may be provided which will atomically be sent on the socket after the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method succeeds. In this case, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property needs to be set to the buffer containing the data to send and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.</para>
          <para>If you are using a connection-oriented protocol and do not call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> before calling <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, the underlying service provider will assign the most appropriate local network address and port number. </para>
          <para>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <see cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> or <see cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</para>
          <para>The <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method throws <see cref="T:System.NotSupportedException" /> if the address family of the <see cref="T:System.Net.Sockets.Socket" /> and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" /> when calling this method, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous request for a connection to a remote host.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation. </para>
          <para>Returns false if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation. </para>
        </returns>
        <param name="e">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="ILASM" Value=".property bool Connected { public hidebysig specialname instance bool get_Connected() }" />
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> indicates that 
   the current instance was connected at
   the time of the
   last I/O operation;
<see langword="false" /> indicates that the 
   current instance is not connected.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The Connected property gets the connection state of the <see cref="T:System.Net.Sockets.Socket" /> as of the last I/O operation. When it returns false, the <see cref="T:System.Net.Sockets.Socket" /> was either never connected, or is no longer connected.</para>
          <para>The value of the <see cref="P:System.Net.Sockets.Socket.Connected" /> property reflects the state of the connection as of the most recent operation. If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call. If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</para>
          <para>If you call <see cref="Overload:System.Net.Sockets.Socket.Connect" /> on a User Datagram Protocol (UDP) socket, the <see cref="P:System.Net.Sockets.Socket.Connected" /> property always returns true; however, this action does not change the inherent connectionless nature of UDP.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you are using a connection-oriented protocol, you can use this method to close the socket. This method ends the connection and sets the <see cref="P:System.Net.Sockets.Socket.Connected" /> property to false. However, if <paramref name="reuseSocket" /> is true, you can reuse the socket.</para>
          <para>To ensure that all data is sent and received before the socket is closed, you should call <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> before calling the <see cref="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" /> method.</para>
          <para>If you need to call <see cref="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" /> without first calling <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />, you can set the <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> <see cref="T:System.Net.Sockets.Socket" /> option to false and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent. <see cref="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" /> then blocks until the data is sent or until the specified time-out expires. If you set <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> to false and specify a zero time-out interval, <see cref="M:System.Net.Sockets.Socket.Close" /> releases the connection and automatically discards outgoing queued data.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Closes the socket connection and allows reuse of the socket.</para>
        </summary>
        <param name="reuseSocket">
          <attribution license="cc4" from="Microsoft" modified="false" />true if this socket can be reused after the current connection is closed; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When using a connection-oriented protocol, calling the <see cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method requests a disconnect from a remote endpoint. If you set <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" /> to true in the <paramref name="e" /> parameter, the socket can be reused.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous request to disconnect from a remote endpoint.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation. </para>
          <para>Returns false if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</para>
        </returns>
        <param name="e">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Call Dispose when you are finished using the <see cref="T:System.Net.Sockets.Socket" />. The Dispose method leaves the <see cref="T:System.Net.Sockets.Socket" /> in an unusable state. After calling Dispose, you must release all references to the <see cref="T:System.Net.Sockets.Socket" /> so the garbage collector can reclaim the memory that the <see cref="T:System.Net.Sockets.Socket" /> was occupying.</para>
          <para>For more information, see <format type="text/html"><a href="A17B0066-71C2-4BA4-9822-8E19332FC213">Cleaning Up Unmanaged Resources</a></format> and <format type="text/html"><a href="eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9">Implementing a Dispose Method</a></format>.</para>
          <block subset="none" type="note">
            <para>Always call Dispose before you release your last reference to the <see cref="T:System.Net.Sockets.Socket" />. Otherwise, the resources it is using will not be freed until the garbage collector calls the <see cref="T:System.Net.Sockets.Socket" /> object's Finalize method.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Dispose(bool disposing)" />
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is called by the public Dispose() method and the <see cref="M:System.Object.Finalize" /> method. Dispose() invokes the protected Dispose(Boolean) method with the <paramref name="disposing" /> parameter set to true. <see cref="M:System.Object.Finalize" /> invokes Dispose with <paramref name="disposing" /> set to false.</para>
          <para>When the <paramref name="disposing" /> parameter is true, this method releases all resources held by any managed objects that this <see cref="T:System.Net.Sockets.Socket" /> references. This method invokes the Dispose() method of each referenced object.</para>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</para>
        </summary>
        <param name="disposing">
          <attribution license="cc4" from="Microsoft" modified="false" />true to release both managed and unmanaged resources; false to releases only unmanaged resources. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium. Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only). If a datagram must be fragmented, and the <see cref="P:System.Net.Sockets.Socket.DontFragment" /> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</para>
          <para>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The target process should use <see cref="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" /> to create the duplicate socket instance. </para>
          <para>If you call the <see cref="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" /> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <see cref="T:System.Net.Sockets.Socket" /> instances with the same underlying socket. This practice is strongly discouraged.</para>
          <para>If the process creating the socket uses asynchronous methods (<see cref="Overload:System.Net.Sockets.Socket.BeginReceive" /> or <see cref="Overload:System.Net.Sockets.Socket.BeginSend" />), the process must first set the <see cref="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" /> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <see cref="T:System.ArgumentNullException" /> to be thrown on the target process.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Duplicates the socket reference for the target process, and closes the socket for this process.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The socket reference to be passed to the target process.</para>
        </returns>
        <param name="targetProcessId">
          <attribution license="cc4" from="Microsoft" modified="false" />The ID of the target process where a duplicate of the socket reference is created.</param>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion. For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</para>
          <para>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult)" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">A <see cref="T:System.IAsyncResult" /> object that holds the state information for the asynchronous operation.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult " /> was not returned by the current instance from a call to the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> was previously called for this operation.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred during the operation. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see
      the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For the complete example, which uses the <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method, see the <see cref="T:System.Net.Sockets.Socket" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> completes a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />. Before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />, you need to create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate. This callback method executes in a separate thread, and is called by the system after the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method returns. It must accept the <paramref name="asyncResult" /> parameter returned from the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.</para>
          <para>Within the callback method, call the <see cref="P:System.IAsyncResult.AsyncState" /> method of the <paramref name="asyncResult" /> parameter to obtain the <see cref="T:System.Net.Sockets.Socket" /> on which the connection attempt is being made. After obtaining the <see cref="T:System.Net.Sockets.Socket" />, you can call the <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method to successfully complete the connection attempt.</para>
          <para>The <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method blocks until a connection is pending in the incoming connection queue. The <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method accepts the incoming connection and returns a new <see cref="T:System.Net.Sockets.Socket" /> that can be used to send data to and receive data from the remote host.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(unsigned int8[] buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(unsigned int8[] buffer, int32 bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="bytesTransferred">To be added.</param>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult)" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">A <see cref="T:System.IAsyncResult" /> object that holds the state information for the asynchronous operation.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult " /> was not returned by the current instance from a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for this operation.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred during the operation. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see
      the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For the complete example, which uses the <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method, see the <see cref="T:System.Net.Sockets.Socket" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> is a blocking method that completes the asynchronous remote host connection request started in the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</para>
          <para>Before calling <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />, you need to create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate. This callback method executes in a separate thread and is called by the system after <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> returns. The callback method must accept the <see cref="T:System.IAsyncResult" /> returned by the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method as a parameter.</para>
          <para>Within the callback method, call the <see cref="P:System.IAsyncResult.AsyncState" /> method of the <see cref="T:System.IAsyncResult" /> parameter to obtain the <see cref="T:System.Net.Sockets.Socket" /> on which the connection attempt is being made. After obtaining the <see cref="T:System.Net.Sockets.Socket" />, you can call the <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> method to successfully complete the connection attempt.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends a pending asynchronous connection request.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> completes a call to <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />. The <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> method blocks until the disconnect completes. For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends a pending asynchronous disconnect request.</para>
        </summary>
        <param name="asyncResult">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation. </param>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult)" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <para>A <see cref="T:System.IAsyncResult" /> object that holds the state information for the asynchronous operation.</para>
        </param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult " /> was not returned by the current instance from a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for this operation.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred during the operation. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see
      the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For the complete example, which uses the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> method, see the <see cref="T:System.Net.Sockets.Socket" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> method completes the asynchronous read operation started in the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</para>
          <para>Before calling <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />, you need to create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate. This callback method executes in a separate thread and is called by the system after <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> returns. The callback method must accept the <see cref="T:System.IAsyncResult" /> returned by the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method as a parameter.</para>
          <para>Within the callback method, call the <see cref="P:System.IAsyncResult.AsyncState" /> method of the <see cref="T:System.IAsyncResult" /> to obtain the state object passed to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method. Extract the receiving <see cref="T:System.Net.Sockets.Socket" /> from this state object. After obtaining the <see cref="T:System.Net.Sockets.Socket" />, you can call the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> method to successfully complete the read operation and return the number of bytes read.</para>
          <para>The <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> method will block until data is available. If you are using a connectionless protocol, <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> will read the first enqueued datagram available in the incoming network buffer. If you are using a connection-oriented protocol, the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> method will read as much data as is available up to the number of bytes you specified in the <paramref name="size" /> parameter of the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method. If the remote host shuts down the <see cref="T:System.Net.Sockets.Socket" /> connection with the <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> method, and all available data has been received, the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> method will complete immediately and return zero bytes.</para>
          <para>To obtain the received data, call the <see cref="P:System.IAsyncResult.AsyncState" /> method of the <see cref="T:System.IAsyncResult" />, and extract the buffer contained in the resulting state object.</para>
          <para>To cancel a pending <see cref="Overload:System.Net.Sockets.Socket.BeginReceive" />, call the <see cref="M:System.Net.Sockets.Socket.Close" /> method.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends a pending asynchronous read.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes received.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketError errorCode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint)" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint end_point) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary>
          <para>Ends an asynchronous call to receive
      data from a socket and store the endpoint associated with the socket that
      sent the data.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" qualify="true" /> containing the number of bytes received.</para>
        </returns>
        <remarks>
          <para> This method blocks if the asynchronous operation has not completed.</para>
          <para>The <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
method completes an asynchronous request that was started with a call to the
<see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method. The object specified for the 
<paramref name="asyncResult" /> parameter is required to be the same object as was returned 
by the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
method call that began the
request.</para>
          <para>If the <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
method is invoked via the <see cref="T:System.AsyncCallback" /> delegate specified to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method, the
<paramref name="asyncResult" /> parameter is the <see cref="T:System.IAsyncResult" /> 
argument passed to the
delegate's method.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult " /> was not returned by the current instance from a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for this operation.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred during the operation. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see
      the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For
      the complete example, see the <see cref="T:System.Net.Sockets.Socket" /> class overview.</para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint endPoint, valuetype System.Net.Sockets.IPPacketInformation ipPacketInformation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="endPoint">To be added.</param>
        <param name="ipPacketInformation">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult)" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <para>A <see cref="T:System.IAsyncResult" /> object that holds the state information for the asynchronous operation.</para>
        </param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult " /> was not returned by the current instance from a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for this operation.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred during the operation. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see
      the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For the complete example, which uses the <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> method, see the <see cref="T:System.Net.Sockets.Socket" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> completes the asynchronous send operation started in <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</para>
          <para>Before calling <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />, you need to create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate. This callback method executes in a separate thread and is called by the system after <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> returns. The callback method must accept the <see cref="T:System.IAsyncResult" /> returned by the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method as a parameter.</para>
          <para>Within the callback method, call the <see cref="P:System.IAsyncResult.AsyncState" /> method of the <see cref="T:System.IAsyncResult" /> parameter to obtain the sending <see cref="T:System.Net.Sockets.Socket" />. After obtaining the <see cref="T:System.Net.Sockets.Socket" />, you can call the <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> method to successfully complete the send operation and return the number of bytes sent.</para>
          <para>If you are using a connectionless protocol, <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> will block until the datagram is sent. If you are using a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> will block until some of the buffer was sent. If the return value from <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> indicates that the buffer was not completely sent, call the <see cref="Overload:System.Net.Sockets.Socket.BeginSend" /> method again, modifying the buffer to hold the unsent data.</para>
          <para>There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes. </para>
          </block>
          <block subset="none" type="note">
            <para>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends a pending asynchronous send.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketError errorCode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> completes the asynchronous send operation started in <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</para>
          <para>Before calling <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />, you must create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate. This callback method executes in a separate thread and is called by the system after <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> returns. The callback method must accept the <see cref="T:System.IAsyncResult" /> object returned by the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method as a parameter.</para>
          <para>Within the callback method, call the <see cref="P:System.IAsyncResult.AsyncState" /> method of the <see cref="T:System.IAsyncResult" /> parameter to obtain the sending <see cref="T:System.Net.Sockets.Socket" />. After obtaining the <see cref="T:System.Net.Sockets.Socket" />, you can call the <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> method to successfully complete the send operation.</para>
          <para>If you are using a connectionless protocol, <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> blocks until the datagram is sent. If you are using a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> blocks until the entire file is sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends a pending asynchronous send of a file.</para>
        </summary>
        <param name="asyncResult">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation. </param>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult)" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <para>A <see cref="T:System.IAsyncResult" /> object that holds the state information for the asynchronous operation.</para>
        </param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult " /> was not returned by the current instance from a call to the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for this operation.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred during the operation. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see
      the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> method.
      For
      the complete example, see the <see cref="T:System.Net.Sockets.Socket" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> completes the asynchronous send operation started in <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</para>
          <para>Before calling <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />, you need to create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate. This callback method executes in a separate thread and is called by the system after <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> returns. The callback method must accept the <see cref="T:System.IAsyncResult" /> returned by the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method as a parameter.</para>
          <para>Within the callback method, call the <see cref="P:System.IAsyncResult.AsyncState" /> method of the <see cref="T:System.IAsyncResult" /> parameter to obtain the sending <see cref="T:System.Net.Sockets.Socket" />. After obtaining the <see cref="T:System.Net.Sockets.Socket" />, you can call the <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> method to successfully complete the send operation and return the number of bytes sent.</para>
          <para>If you are using a connectionless protocol, <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> will block until the datagram is sent. If you are using a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> will block until the requested number of bytes are sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends a pending asynchronous send to a specific location.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <see cref="P:System.Net.Sockets.Socket.ExclusiveAddressUse" /> is false, multiple sockets can use the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port. If more than one socket attempts to use the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port. </para>
          <para>If <see cref="P:System.Net.Sockets.Socket.ExclusiveAddressUse" /> is true, the first use of the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method to attempt to bind to that port will fail until the original bound socket is destroyed. </para>
          <para>This property must be set before <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> is called; otherwise an <see cref="T:System.InvalidOperationException" /> will be thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Finalize()" />
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Net.Sockets.Socket" /> class finalizer calls the <see cref="M:System.Net.Sockets.Socket.Close" /> method to close the <see cref="T:System.Net.Sockets.Socket" /> and free resources associated with the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetHashCode()" />
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.GetHashCode" /> method returns a hash code of this instance. This value can be used as a key in hash tables.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a hash value for a <see cref="T:System.Net.Sockets.Socket" /> instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An integer hash value.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName)" />
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>The following example gets the state of the linger option and the size of the receive buffer, changes the values of both, then gets the new values.</para>
          <code lang="C#">using System;
using System.Net.Sockets;

class OptionTest{

  public static void Main() {

    // Get the current option values.
    Socket someSocket =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);

    LingerOption lingerOp =
      (LingerOption)someSocket.GetSocketOption(
                    SocketOptionLevel.Socket,
                    SocketOptionName.Linger);

    int receiveBuffer =
      (int)someSocket.GetSocketOption(
           SocketOptionLevel.Socket,
           SocketOptionName.ReceiveBuffer);

    Console.WriteLine(
      "Linger option is {0} and set to {1} seconds.",
      lingerOp.Enabled.ToString(),
      lingerOp.LingerTime.ToString() );

    Console.WriteLine(
      "Size of the receive buffer is {0} bytes.",
      receiveBuffer.ToString() );

    // Change the options.
    lingerOp = new LingerOption(true, 10);
    someSocket.SetSocketOption(
      SocketOptionLevel.Socket,
      SocketOptionName.Linger,
      lingerOp);

    someSocket.SetSocketOption(
      SocketOptionLevel.Socket,
      SocketOptionName.ReceiveBuffer,
      2048);

    Console.WriteLine(
      "The SetSocketOption method has been called.");
 
    // Get the new option values.
    lingerOp =
      (LingerOption)someSocket.GetSocketOption(
                    SocketOptionLevel.Socket,
                    SocketOptionName.Linger);

    receiveBuffer =
      (int)someSocket.GetSocketOption(
           SocketOptionLevel.Socket,
           SocketOptionName.ReceiveBuffer);

    Console.WriteLine(
      "Linger option is now {0} and set to {1} seconds.",
      lingerOp.Enabled.ToString(),
      lingerOp.LingerTime.ToString());

    Console.WriteLine(
      "Size of the receive buffer is now {0} bytes.",
      receiveBuffer.ToString());
  }
}
   </code>
          <para>The output is</para>
          <c>
            <para> Linger option is False and set to 0 seconds.</para>
            <para> Size of the receive buffer is 8192 bytes.</para>
            <para>The SetSocketOption method has been called.</para>
            <para> Linger option is now True and set to 10 seconds.</para>
            <para> Size of the receive buffer is now 2048 bytes.</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Net.Sockets.Socket" /> options determine the behavior of the current <see cref="T:System.Net.Sockets.Socket" />. Use this overload to get the <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" />, and <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> <see cref="T:System.Net.Sockets.Socket" /> options. For the <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> option, use <see cref="T:System.Net.Sockets.Socket" /> for the <paramref name="optionLevel" /> parameter. For <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> and <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, use <see cref="F:System.Net.Sockets.SocketOptionLevel.IP" />. If you want to set the value of any of the options listed above, use the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that represents the value of the option. When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class. When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class. When <paramref name="optionName" /> is any other value, the return value is an integer.</para>
        </returns>
        <param name="optionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values. </param>
        <param name="optionName">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, class System.Byte[] optionValue)" />
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="optionValue" /> is too small to store the value of the specified socket option.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket.</para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Net.Sockets.Socket" /> options determine the behavior of the current <see cref="T:System.Net.Sockets.Socket" />. Upon successful completion of this method, the array specified by the <paramref name="optionValue" /> parameter contains the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option.</para>
          <para>When the length of the <paramref name="optionValue" /> array is smaller than the number of bytes required to store the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option, <see cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use this overload for any sockets that are represented by Boolean values or integers.</para>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</para>
        </summary>
        <param name="optionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values. </param>
        <param name="optionName">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values. </param>
        <param name="optionValue">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that is to receive the option setting. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Byte[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength)" />
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="length">To be added.</param>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="optionLength" /> is smaller than the number of bytes required to store the value of the specified socket option.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket.</para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="optionLength" /> parameter sets the maximum size of the returned byte array. If the option value requires fewer bytes, the array will contain only that many bytes. If the option value requires more bytes, <see cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. Use this overload for any sockets that are represented by Boolean values or integers.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</para>
        </returns>
        <param name="optionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values. </param>
        <param name="optionName">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="ILASM" Value=".property valuetype System.IntPtr Handle { public hidebysig specialname instance valuetype System.IntPtr get_Handle() }" />
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.IntPtr" qualify="true" /> containing the operating system handle for the current instance.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"> Requires permission to access unmanaged code. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true" />.</permission>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, class System.Byte[] optionInValue, class System.Byte[] optionOutValue)" />
      <MemberSignature Language="C#" Value="public int IOControl (int ioctl_code, byte[] in_value, byte[] out_value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioctl_code, unsigned int8[] in_value, unsigned int8[] out_value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioctl_code" Type="System.Int32" />
        <Parameter Name="in_value" Type="System.Byte[]" />
        <Parameter Name="out_value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioctl_code">To be added.</param>
        <param name="in_value">To be added.</param>
        <param name="out_value">To be added.</param>
        <exception cref="T:System.InvalidOperationException">
          <para>An attempt was made to change the blocking mode.</para>
          <block subset="none" type="note">
            <para>Use the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property to change the blocking mode.</para>
          </block>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Requires permission to access unmanaged code. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true" />.</permission>
        <example>
          <para>The following example gets the number of bytes of available
      data to be read and writes the result to the console on a Windows system.
      The remote endpoint (remoteEndpoint) to connect to might need to be changed to a value that is valid on the current system.</para>
          <code lang="C#">using System;
using System.Net;
using System.Net.Sockets;

class App {

  static void Main() {

    IPAddress remoteAddress =
    Dns.Resolve(Dns.GetHostName()).AddressList[0];

    IPEndPoint remoteEndpoint =
      new IPEndPoint(remoteAddress, 80);

    Socket someSocket =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);

    someSocket.Connect(remoteEndpoint);

    int fionRead = 0x4004667F;
    byte[]inValue = {0x00, 0x00, 0x00, 0x00};
    byte[]outValue = {0x00, 0x00, 0x00, 0x00};

    someSocket.IOControl(fionRead, inValue, outValue);

    uint bytesAvail = BitConverter.ToUInt32(outValue, 0);
      
    Console.WriteLine(
      "There are {0} bytes available to be read.",
      bytesAvail.ToString() );
  }
}
      </code>
          <para>The output is</para>
          <c>
            <para>There are 0 bytes available to be read.</para>
          </c>
        </example>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" /> method provides low-level access to the operating system <see cref="T:System.Net.Sockets.Socket" /> underlying the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class. For more information, see the WSAIoctl documentation in the MSDN library.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes in the <paramref name="optionOutValue" /> parameter.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method provides low-level access to the operating system <see cref="T:System.Net.Sockets.Socket" /> underlying the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class. For more, see the WSAIoctl documentation in the MSDN library.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes in the <paramref name="optionOutValue" /> parameter.</para>
        </returns>
        <param name="ioControlCode">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform. </param>
        <param name="optionInValue">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation. </param>
        <param name="optionOutValue">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation. </param>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A socket is considered bound to a local port if it is explicitly bound by calling the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method, or implicitly bound by calling members like <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />, or <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method to bind to a well-known port so that clients may connect to them.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Net.Sockets.Socket.LingerState" /> property changes the way <see cref="M:System.Net.Sockets.Socket.Close" /> method behaves. This property when set modifies the conditions under which the connection can be reset by Winsock. Connection resets can still occur based on the IP protocol behavior. </para>
          <para>This property controls the length of time that a connection-oriented connection will remain open after a call to <see cref="M:System.Net.Sockets.Socket.Close" /> when data remains to be sent.</para>
          <para>When you call methods to send data to a peer, this data is placed in the outgoing network buffer. This property can be used to ensure that this data is sent to the remote host before the <see cref="M:System.Net.Sockets.TcpClient.Close" /> method drops the connection.</para>
          <para>To enable lingering, create a <see cref="T:System.Net.Sockets.LingerOption" /> instance containing the desired values, and set the <see cref="P:System.Net.Sockets.Socket.LingerState" /> property to this instance.</para>
          <para>The following table describes the behavior of the <see cref="M:System.Net.Sockets.Socket.Close" /> method for the possible values of the <see cref="P:System.Net.Sockets.LingerOption.Enabled" /> property and the <see cref="P:System.Net.Sockets.LingerOption.LingerTime" /> property stored in the <see cref="P:System.Net.Sockets.Socket.LingerState" /> property.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>LingerState.Enabled</para>
                </term>
                <description>
                  <para>LingerState.LingerTime</para>
                </description>
                <description>
                  <para>Behavior</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>false (disabled), the default value </para>
              </term>
              <description>
                <para>The time-out is not applicable, (default).</para>
              </description>
              <description>
                <para>Attempts to send pending data until the default IP protocol time-out expires.</para>
              </description>
            </item>
            <item>
              <term>
                <para>true (enabled)</para>
              </term>
              <description>
                <para>A nonzero time-out</para>
              </description>
              <description>
                <para>Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection. </para>
              </description>
            </item>
            <item>
              <term>
                <para>true (enabled)</para>
              </term>
              <description>
                <para>A zero timeout.</para>
              </description>
              <description>
                <para>Discards any pending data. For connection-oriented socket (TCP, for example), Winsock resets the connection. </para>
              </description>
            </item>
          </list>
          <para>The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection. In most cases, the time-out computed by the stack is more relevant than one defined by an application. This is the default behavior for a socket when the <see cref="P:System.Net.Sockets.Socket.LingerState" /> property is not set.</para>
          <para>When the <see cref="P:System.Net.Sockets.LingerOption.LingerTime" /> property stored in the <see cref="P:System.Net.Sockets.Socket.LingerState" /> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Listen(int32 backlog)" />
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Net.Sockets.SocketException">The <see cref="P:System.Net.Sockets.Socket.Connected" /> property of the current instance is true.<para>-or-</para><see langword="Bind" /> has not been called on the current instance.<para>-or-</para>An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> causes a connection-oriented <see cref="T:System.Net.Sockets.Socket" /> to listen for incoming connection attempts. The <paramref name="backlog" /> parameter specifies the number of incoming connections that can be queued for acceptance. To determine the maximum number of connections you can specify, retrieve the <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> value. <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> does not block.</para>
          <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use <see cref="M:System.Net.Sockets.Socket.Accept" /> or <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> to accept a connection from the queue.</para>
          <block subset="none" type="note">
            <para>You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method before calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
          <block subset="none" type="note">
            <para>The backlog parameter is limited to different values depending on the Operating System. You may specify a higher value, but the backlog will be limited based on the Operating System.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</para>
        </summary>
        <param name="backlog">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum length of the pending connections queue. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="ILASM" Value=".property class System.Net.EndPoint LocalEndPoint { public hidebysig specialname instance class System.Net.EndPoint get_LocalEndPoint() }" />
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para> The local <see cref="T:System.Net.EndPoint" qualify="true" />
associated with the current
instance.</para>
        </value>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property gets an <see cref="T:System.Net.EndPoint" /> that contains the local IP address and port number to which your <see cref="T:System.Net.Sockets.Socket" /> is bound. You must cast this <see cref="T:System.Net.EndPoint" /> to an <see cref="T:System.Net.IPEndPoint" /> before retrieving any information. You can then call the <see cref="P:System.Net.IPEndPoint.Address" /> method to retrieve the local <see cref="T:System.Net.IPAddress" />, and the <see cref="P:System.Net.IPEndPoint.Port" /> method to retrieve the local port number.</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is usually set after you make a call to the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method. If you allow the system to assign your socket's local IP address and port number, the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property will be set after the first I/O operation. For connection-oriented protocols, the first I/O operation would be a call to the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method. For connectionless protocols, the first I/O operation would be any of the send or receive calls.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the local endpoint.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Multicast is a scalable method for many-to-many communication on the Internet. A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address. </para>
          <para>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances. A TCP packet consists of 40 bytes of header plus the data being sent. When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic. On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion. The Nagle algorithm inhibits the sending of new TCP segments when new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged. </para>
          <para>The majority of network applications should use the Nagle algorithm.</para>
          <para>Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The operating system may support both IPv4 and IPv6 protocols.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode)" />
      <MemberSignature Language="C#" Value="public bool Poll (int time_us, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 time_us, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="time_us" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="time_us">To be added.</param>
        <exception cref="T:System.NotSupportedException">
          <paramref name="mode " />is not one of the values defined in the <see cref="T:System.Net.Sockets.SelectMode" /> enumeration.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" /> method will check the state of the <see cref="T:System.Net.Sockets.Socket" />. Specify <see cref="F:System.Net.Sockets.SelectMode.SelectRead" /> for the <paramref name="selectMode" /> parameter to determine if the <see cref="T:System.Net.Sockets.Socket" /> is readable. Specify <see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /> to determine if the <see cref="T:System.Net.Sockets.Socket" /> is writable. Use <see cref="F:System.Net.Sockets.SelectMode.SelectError" /> to detect an error condition. <see cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" /> will block execution until the specified time period, measured in <paramref name="microseconds" />, elapses. Set the <paramref name="microSeconds" /> parameter to a negative integer if you would like to wait indefinitely for a response. If you want to check the status of multiple sockets, you might prefer to use the <see cref="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" /> method.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Mode </para>
                </term>
                <description>
                  <para>Return Value </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>
                  <see cref="F:System.Net.Sockets.SelectMode.SelectRead" /> </para>
              </term>
              <description>
                <para>true if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending; </para>
                <para>-or- </para>
                <para>true if data is available for reading; </para>
                <para>-or- </para>
                <para>true if the connection has been closed, reset, or terminated; </para>
                <para>otherwise, returns false. </para>
              </description>
            </item>
            <item>
              <term>
                <para>
                  <see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /> </para>
              </term>
              <description>
                <para>true, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded; </para>
                <para>-or- </para>
                <para>true if data can be sent; </para>
                <para>otherwise, returns false. </para>
              </description>
            </item>
            <item>
              <term>
                <para>
                  <see cref="F:System.Net.Sockets.SelectMode.SelectError" /> </para>
              </term>
              <description>
                <para>true if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed; </para>
                <para>-or- </para>
                <para>true if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available; </para>
                <para>otherwise, returns false. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SelectMode" /> values. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="ILASM" Value=".property valuetype System.Net.Sockets.ProtocolType ProtocolType { public hidebysig specialname instance valuetype System.Net.Sockets.ProtocolType get_ProtocolType() }" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>One of the values defined in
      the <see cref="T:System.Net.Sockets.ProtocolType" /> enumeration. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Net.Sockets.Socket.ProtocolType" /> property is set when the <see cref="T:System.Net.Sockets.Socket" /> is created, and specifies the protocol used by that <see cref="T:System.Net.Sockets.Socket" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 Receive(class System.Byte[] buffer)" />
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer " />is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>An error occurred while accessing the socket.</para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.Security.SecurityException"> A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to accept connections. See <see cref="F:System.Net.NetworkAccess.Accept" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" /> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" /> from both connection-oriented and connectionless sockets.</para>
          <para>This overload only requires you to provide a receive buffer. The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <see cref="T:System.Net.Sockets.SocketFlags" /> value defaults to <see cref="F:System.Net.Sockets.SocketFlags.None" />.</para>
          <para>If you are using a connection-oriented protocol, you must either call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection prior to calling <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />. The <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" /> method will only read data that arrives from the remote host established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method. If you are using a connectionless protocol, you can also use the <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> method. <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> will allow you to receive data arriving from any host.</para>
          <para>If no data is available for reading, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" /> method will block until data is available, unless a time-out value was set by using <see cref="P:System.Net.Sockets.Socket.ReceiveTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" /> call will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" /> method will complete immediately and throw a <see cref="T:System.Net.Sockets.SocketException" />. You can use the <see cref="P:System.Net.Sockets.Socket.Available" /> property to determine if data is available for reading. When <see cref="P:System.Net.Sockets.Socket.Available" /> is non-zero, retry the receive operation.</para>
          <para>If you are using a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" /> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <see cref="T:System.Net.Sockets.Socket" /> connection with the <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> method, and all available data has been received, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" /> method will complete immediately and return zero bytes.</para>
          <para>If you are using a connectionless <see cref="T:System.Net.Sockets.Socket" />, <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" /> will read the first queued datagram from the destination address you specify in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method. If the datagram you receive is larger than the size of the <paramref name="buffer" /> parameter, <paramref name="buffer" /> gets filled with the first part of the message, the excess data is lost and a <see cref="T:System.Net.Sockets.SocketException" /> is thrown.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes received.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that is the storage location for the received data. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method reads data into the buffers parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.</para>
          <para>This overload requires you to provide one or more receive buffers.</para>
          <para>If you are using a connection-oriented protocol, you must either call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection prior to calling <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />. The <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" /> method will only read data that arrives from the remote host connection established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method. If you are using a connectionless protocol, you can also use the <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> method. <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> will allow you to receive data arriving from any host.</para>
          <para>If no data is available for reading, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" /> method will block until data is available, unless a time-out value was set by using <see cref="P:System.Net.Sockets.Socket.ReceiveTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" /> call will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" /> method will complete immediately and throw a <see cref="T:System.Net.Sockets.SocketException" />. You can use the <see cref="P:System.Net.Sockets.Socket.Available" /> property to determine if data is available for reading. When <see cref="P:System.Net.Sockets.Socket.Available" /> is non-zero, retry the receive operation.</para>
          <para>If you are using a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" /> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <see cref="T:System.Net.Sockets.Socket" /> connection with the <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> method, and all available data has been received, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" /> method will complete immediately and return zero bytes.</para>
          <para>If you are using a connectionless <see cref="T:System.Net.Sockets.Socket" />, <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> will read the first enqueued datagram from the destination address you specify in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method. If the datagram you receive is larger than the size of the <paramref name="buffers" /> parameter, <paramref name="buffers" /> gets filled with the first part of the message, the excess data is lost and a <see cref="T:System.Net.Sockets.SocketException" /> is thrown.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <para>Note   This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes received.</para>
        </returns>
        <param name="buffers">
          <attribution license="cc4" from="Microsoft" modified="false" />A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</param>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 Receive(class System.Byte[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags)" />
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags flags) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="flags">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer " />is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para> An error occurred while accessing the socket. </para>
          <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
        </exception>
        <exception cref="T:System.Security.SecurityException"> A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to accept connections. <block subset="none" type="note">See <see cref="F:System.Net.NetworkAccess.Accept" qualify="true" />.</block></permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" /> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" /> from both connection-oriented and connectionless sockets.</para>
          <para>This overload only requires you to provide a receive buffer and the necessary <see cref="T:System.Net.Sockets.SocketFlags" />. The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</para>
          <para>If you are using a connection-oriented protocol, you must either call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection prior to calling <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />. The <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" /> method will only read data that arrives from the remote host established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method. If you are using a connectionless protocol, you can also use the <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> method. <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> will allow you to receive data arriving from any host.</para>
          <para>If no data is available for reading, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" /> method will block until data is available. If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" /> method will complete immediately and throw a <see cref="T:System.Net.Sockets.SocketException" />. You can use the <see cref="P:System.Net.Sockets.Socket.Available" /> property to determine if data is available for reading. When <see cref="P:System.Net.Sockets.Socket.Available" /> is non-zero, retry your receive operation.</para>
          <para>If you are using a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" /> method will read as much data as is available up to the size of the buffer. If the remote host shuts down the <see cref="T:System.Net.Sockets.Socket" /> connection with the <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> method, and all available data has been received, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" /> method will complete immediately and return zero bytes.</para>
          <para>If you are using a connectionless <see cref="T:System.Net.Sockets.Socket" />, <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" /> will read the first enqueued datagram from the destination address you specify in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method. If the datagram you receive is larger than the size of the <paramref name="buffer" /> parameter, <paramref name="buffer" /> gets filled with the first part of the message, the excess data is lost and a <see cref="T:System.Net.Sockets.SocketException" /> is thrown.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes received.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that is the storage location for the received data. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method reads data into the <paramref name="buffers" /> parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.</para>
          <para>This overload requires you to provide one or more receive buffers. The <see cref="T:System.Net.Sockets.SocketFlags" /> value defaults to <see cref="F:System.Net.Sockets.SocketFlags.None" />.</para>
          <para>If you are using a connection-oriented protocol, you must either call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection prior to calling <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />. The <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> method will only read data that arrives from the remote host connection established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method. If you are using a connectionless protocol, you can also use the <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> method. <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> will allow you to receive data arriving from any host.</para>
          <para>If no data is available for reading, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> method will block until data is available, unless a time-out value was set by using <see cref="P:System.Net.Sockets.Socket.ReceiveTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> call throws a <see cref="T:System.Net.Sockets.SocketException" />. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> method will complete immediately and throw a <see cref="T:System.Net.Sockets.SocketException" />. You can use the <see cref="P:System.Net.Sockets.Socket.Available" /> property to determine if data is available for reading. When <see cref="P:System.Net.Sockets.Socket.Available" /> is non-zero, retry the receive operation.</para>
          <para>If you are using a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <see cref="T:System.Net.Sockets.Socket" /> connection with the <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> method, and all available data has been received, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> method will complete immediately and return zero bytes.</para>
          <para>If you are using a connectionless <see cref="T:System.Net.Sockets.Socket" />, <see cref="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> will read the first enqueued datagram from the destination address you specify in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method. If the datagram you receive is larger than the size of the <paramref name="buffers" /> parameter, <paramref name="buffers" /> gets filled with the first part of the message, the excess data is lost and a <see cref="T:System.Net.Sockets.SocketException" /> is thrown.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes received.</para>
        </returns>
        <param name="buffers">
          <attribution license="cc4" from="Microsoft" modified="false" />A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</param>
        <param name="socketFlags">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 Receive(class System.Byte[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags)" />
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags flags) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="flags">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para> -or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para> -or- </para>
          <para> An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to accept connections. See <see cref="F:System.Net.NetworkAccess.Accept" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method reads data into the <paramref name="buffer" /> parameter and returns the number of bytes successfully read. You can call <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> from both connection-oriented and connectionless sockets.</para>
          <para>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <see cref="T:System.Net.Sockets.SocketFlags" />. </para>
          <para>If you are using a connection-oriented protocol, you must either call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection prior to calling <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />. The <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method will only read data that arrives from the remote host established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method. If you are using a connectionless protocol, you can also use the <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> method. <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> will allow you to receive data arriving from any host.</para>
          <para>If no data is available for reading, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method will block until data is available, unless a time-out value was set by using <see cref="P:System.Net.Sockets.Socket.ReceiveTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> call will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method will complete immediately and throw a <see cref="T:System.Net.Sockets.SocketException" />. You can use the <see cref="P:System.Net.Sockets.Socket.Available" /> property to determine if data is available for reading. When <see cref="P:System.Net.Sockets.Socket.Available" /> is non-zero, retry your receive operation.</para>
          <para>If you are using a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method will read as much data as is available, up to the number of bytes specified by the <paramref name="size" /> parameter. If the remote host shuts down the <see cref="T:System.Net.Sockets.Socket" /> connection with the <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> method, and all available data has been received, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method will complete immediately and return zero bytes.</para>
          <para>If you are using a connectionless <see cref="T:System.Net.Sockets.Socket" />, <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will read the first queued datagram from the destination address you specify in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method. If the datagram you receive is larger than the size of the <paramref name="buffer" /> parameter, <paramref name="buffer" /> gets filled with the first part of the message, the excess data is lost and a <see cref="T:System.Net.Sockets.SocketException" /> is thrown.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes received.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that is the storage location for the received data. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to receive. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 Receive(class System.Byte[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags)" />
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="flags">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket.</para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">
          <para>Requires permission to accept a connection on the endpoint defined by the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property of the current instance. See <see cref="F:System.Net.NetworkAccess.Accept" qualify="true" />.</para>
        </permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> from both connection-oriented and connectionless sockets.</para>
          <para>If you are using a connection-oriented protocol, you must either call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection prior to calling <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />. The <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method will only read data that arrives from the remote host established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method. If you are using a connectionless protocol, you can also use the <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> method. <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" /> will allow you to receive data arriving from any host.</para>
          <para>If no data is available for reading, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method will block until data is available, unless a time-out value was set by using <see cref="P:System.Net.Sockets.Socket.ReceiveTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> call will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method will complete immediately and throw a <see cref="T:System.Net.Sockets.SocketException" />. An error occurred when attempting to access the socket. See Remarks below. You can use the <see cref="P:System.Net.Sockets.Socket.Available" /> property to determine if data is available for reading. When <see cref="P:System.Net.Sockets.Socket.Available" /> is non-zero, retry the receive operation.</para>
          <para>If you are using a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <see cref="T:System.Net.Sockets.Socket" /> connection with the <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> method, and all available data has been received, the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method will complete immediately and return zero bytes.</para>
          <para>If you are using a connectionless <see cref="T:System.Net.Sockets.Socket" />, <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will read the first queued datagram from the destination address you specify in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method. If the datagram you receive is larger than the size of the <paramref name="buffer" /> parameter, <paramref name="buffer" /> gets filled with the first part of the message, the excess data is lost and a <see cref="T:System.Net.Sockets.SocketException" /> is thrown.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes received.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that is the storage location for received data. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The location in <paramref name="buffer" /> to store the received data. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to receive. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, valuetype System.Net.Sockets.SocketError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method is used on connected sockets or bound connectionless sockets and is used to read incoming data. The socket's local address must be known.</para>
          <para>For bound connectionless sockets, this function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are silently discarded.</para>
          <para>The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> property on the <paramref name="e" /> parameter provides the Window Sockets service provider with additional information about the read request. For more information about how to use this parameter, see <see cref="T:System.Net.Sockets.SocketFlags" />. </para>
          <para>The following properties and events on the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object are required to successfully call this method:</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> if <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> is set</para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" /> if <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> is set</para>
            </item>
            <item>
              <para>
                <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
              </para>
            </item>
          </list>
          <para>The caller may set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" /> property to any user state object desired before calling the <see cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </para>
          <para>For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted. </para>
          <para>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the <paramref name="e" /> parameter. If the message is larger than the buffer, the buffer is filled with the first part of the message.</para>
          <para>For connection-oriented sockets, the <see cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a <see cref="T:System.Net.Sockets.SocketException" /> with the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketError" /> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure. In any case, a <see cref="T:System.Net.Sockets.SocketException" /> with the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketError" /> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation. </para>
          <para>Returns false if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</para>
        </returns>
        <param name="e">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 ReceiveFrom(class System.Byte[] buffer, class System.Net.EndPoint&amp; remoteEP)" />
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <summary>
          <para> Receives data from a socket and, for connectionless protocols, stores the
      endpoint associated with the socket that sent the data.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" qualify="true" />
containing the number of bytes received.</para>
        </returns>
        <remarks>
          <para>This method is equivalent to <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />(<paramref name="buffer" />, 0, <paramref name="buffer" />.Length,
<see cref="F:System.Net.Sockets.SocketFlags.None" qualify="true" />, <paramref name="remoteEP" />).</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="buffer" /> or <paramref name="remoteEP" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to accept connections from the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Accept" qualify="true" />.</permission>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 ReceiveFrom(class System.Byte[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP)" />
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags flags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags flags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <summary>
          <para> Receives data from a socket and, for connectionless protocols, stores the
      endpoint associated with the socket that sent the data.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" qualify="true" />
containing the number of bytes received.</para>
        </returns>
        <remarks>
          <para>This method is equivalent to <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />(<paramref name="buffer" />, 0, <paramref name="buffer" />.Length, <paramref name="socketFlags" />, <paramref name="remoteEP" />).</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="buffer" /> or <paramref name="remoteEP" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> specified an invalid value.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to accept connections from the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Accept" qualify="true" />.</permission>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 ReceiveFrom(class System.Byte[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP)" />
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags flags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags flags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="size">A <see cref="T:System.Int32" qualify="true" /> containing the number of bytes to receive.</param>
        <param name="flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <summary>
          <para> Receives data from a socket and, for connectionless protocols, stores the
      endpoint associated with the socket that sent the data.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" qualify="true" />
containing the number of bytes received.</para>
        </returns>
        <remarks>
          <para>This method is equivalent to <see cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />(<paramref name="buffer" />, 0, <paramref name="size" /> , <paramref name="socketFlags" />, <paramref name="remoteEP" /> ).</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="buffer" /> or <paramref name="remoteEP" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para> -or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket.</para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to accept connections from the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Accept" qualify="true" />.</permission>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 ReceiveFrom(class System.Byte[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP)" />
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">A <see cref="T:System.Int32" qualify="true" /> containing the zero-based position in <paramref name="buffer " />to begin storing the received data.</param>
        <param name="size">A <see cref="T:System.Int32" qualify="true" /> containing the number of bytes to receive.</param>
        <param name="flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <summary>
          <para> Receives data from a socket and,
      for connectionless protocols, stores the endpoint associated with the socket that sent
      the data.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" qualify="true" />
containing the number of bytes received.</para>
        </returns>
        <remarks>
          <para>For connectionless protocols, when this method successfully completes, <paramref name="remoteEP" /> contains the
   endpoint associated with the socket that sent the data.</para>
          <para>For connection-oriented protocols, <paramref name="remoteEP" /> is left unchanged.</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is required to be set before
this method is called or a <see cref="T:System.Net.Sockets.SocketException" />
is thrown.</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.Blocking" /> property of the socket determines
the behavior of this method when no incoming data is available. When
<see langword="false" />, the <see cref="T:System.Net.Sockets.SocketException" /> exception is thrown. When 
<see langword="true" />, this method blocks and 
waits for data to arrive.</para>
          <para>For <see cref="F:System.Net.Sockets.SocketType.Stream" qualify="true" /> socket types, if the
remote socket was shut down gracefully, and all data was received, this method
immediately returns zero, regardless of the blocking state.</para>
          <para>For message-oriented sockets, if the message is larger than the size of
<paramref name="buffer" />, the buffer is filled with the first part of the message, and the 
<see cref="T:System.Net.Sockets.SocketException" /> 
exception is thrown. For unreliable protocols, the excess data is lost; for
reliable protocols, the data is retained by the service provider.</para>
          <para>When the <see cref="F:System.Net.Sockets.SocketFlags.OutOfBand" /> flag is specified as part of the<paramref name="socketFlags " />parameter and the socket is configured for
in-line reception of out-of-band (OOB) data (using the <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> socket option) and OOB
data is available, only OOB data is returned.</para>
          <para>When the <see cref="F:System.Net.Sockets.SocketFlags.Peek" /> flag is specified as part of the
<paramref name="socketFlags" /> parameter, available data is copied into 
<paramref name="buffer" /> 
but is not removed from the system
buffer.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="buffer" /> or <paramref name="remoteEP" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket.</para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">
          <para>Requires permission to accept a connection on the endpoint defined by the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property of the current instance. See <see cref="F:System.Net.NetworkAccess.Accept" qualify="true" />.</para>
          <para>Requires permission to make a connection to the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Connect" qualify="true" />.</para>
        </permission>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method is used primarily to receive data on a connectionless socket. The socket's local address must be known.</para>
          <para>The caller must set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> property to the <see cref="T:System.Net.IPEndPoint" /> of the remote host from which the data is to be received. </para>
          <para>The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> property on the <paramref name="e" /> parameter provides the Window Sockets service provider with additional information about the read request. For more information about how to use this parameter, see <see cref="T:System.Net.Sockets.SocketFlags" />. </para>
          <para>The following properties and events on the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object are required to successfully call this method:</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
              </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
              </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
              </para>
            </item>
            <item>
              <para>
                <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
              </para>
            </item>
          </list>
          <para>The caller may set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" /> property to any user state object desired before calling the <see cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </para>
          <para>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> and <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" /> properties determine where in the buffer the data is placed and the amount of data.</para>
          <para>For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted. The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> and <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" /> properties determine where in the buffer the data is placed and the amount of data.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins to asynchronously receive data from a specified network device.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation. </para>
          <para>Returns false if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</para>
        </returns>
        <param name="e">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, valuetype System.Net.Sockets.IPPacketInformation ipPacketInformation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="ipPacketInformation">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <see cref="F:System.Net.Sockets.SocketType.Dgram" /> or <see cref="F:System.Net.Sockets.SocketType.Raw" /> before calling this method. This can be done when the socket is constructed using <see cref="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />. </para>
          <para>The caller must set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> property to the <see cref="T:System.Net.IPEndPoint" /> of the remote host from which the data is to be received. </para>
          <para>The following properties and events on the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object are required to successfully call this method:</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
              </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
              </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
              </para>
            </item>
            <item>
              <para>
                <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
              </para>
            </item>
          </list>
          <para>The caller may set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" /> property to any user state object desired before calling the <see cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </para>
          <para>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> and <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" /> properties determine where in the buffer the data is placed and the amount of data.</para>
          <para>The <see cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method automatically sets the <see cref="F:System.Net.Sockets.SocketOptionName.PacketInformation" /> socket option to true the first time it is called for a given <see cref="T:System.Net.Sockets.Socket" />. However, the <see cref="T:System.Net.Sockets.IPPacketInformation" /> object will only be valid for packets which arrive at the local computer after the socket option has been set. If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method or implicitly by one of the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />, or <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> methods) and the first call to the <see cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method, calls to <see cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method will result in invalid <see cref="T:System.Net.Sockets.IPPacketInformation" /> objects for these packets.</para>
          <para>To ensure that all <see cref="T:System.Net.Sockets.IPPacketInformation" /> objects are valid, an application should set the <see cref="F:System.Net.Sockets.SocketOptionName.PacketInformation" /> socket option to true before it is bound to a local endpoint using the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" /> method.</para>
          <para>An application can examine the resulting <see cref="T:System.Net.Sockets.IPPacketInformation" /> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation. </para>
          <para>Returns false if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</para>
        </returns>
        <param name="e">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This option applies to synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> calls only. If the time-out period is exceeded, the <see cref="Overload:System.Net.Sockets.Socket.Receive" /> method will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="ILASM" Value=".property class System.Net.EndPoint RemoteEndPoint { public hidebysig specialname instance class System.Net.EndPoint get_RemoteEndPoint() }" />
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para> The remote <see cref="T:System.Net.EndPoint" qualify="true" />
associated with the current instance.</para>
        </value>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you are using a connection-oriented protocol, the <see cref="P:System.Net.Sockets.Socket.RemoteEndPoint" /> property gets the <see cref="T:System.Net.EndPoint" /> that contains the remote IP address and port number to which the <see cref="T:System.Net.Sockets.Socket" /> is connected. If you are using a connectionless protocol, <see cref="P:System.Net.Sockets.Socket.RemoteEndPoint" /> contains the default remote IP address and port number with which the <see cref="T:System.Net.Sockets.Socket" /> will communicate. You must cast this <see cref="T:System.Net.EndPoint" /> to an <see cref="T:System.Net.IPEndPoint" /> before retrieving any information. You can then call the <see cref="P:System.Net.IPEndPoint.Address" /> method to retrieve the remote <see cref="T:System.Net.IPAddress" />, and the <see cref="P:System.Net.IPEndPoint.Port" /> method to retrieve the remote port number.</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.RemoteEndPoint" /> is set after a call to either <see cref="M:System.Net.Sockets.Socket.Accept" /> or <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />. If you try to access this property earlier, <see cref="P:System.Net.Sockets.Socket.RemoteEndPoint" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the remote endpoint.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds)" />
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">All of the following parameters are <see langword="null" /> or empty: <paramref name="checkRead" />, <paramref name="checkWrite" />, and <paramref name="checkError" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing one of the sockets. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <example>
          <para>The following example determines the status of the socket instance named
      socket3 and writes the result to the console.</para>
          <code lang="C#">using System;
using System.Collections;
using System.Net.Sockets;

class SelectTest {

  public static void Main() {

    Socket socket1 =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);
    Socket socket2 =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);
    Socket socket3 =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);

    ArrayList readList = new ArrayList();
    ArrayList writeList = new ArrayList();
    ArrayList errorList = new ArrayList();

    readList.Add(socket1);
    readList.Add(socket2);
    readList.Add(socket3);
    errorList.Add(socket1);
    errorList.Add(socket3);

    // readList.Contains(Socket3) returns true
    // if Socket3 is in ReadList.
    Console.WriteLine(
      "socket3 is placed in readList and errorList.");
    Console.WriteLine(
      "socket3 is {0}in readList.",
      readList.Contains(socket3) ? "" : "not " );
    Console.WriteLine(
      "socket3 is {0}in writeList.",
      writeList.Contains(socket3) ? "" : "not " );
    Console.WriteLine(
      "socket3 is {0}in errorList.",
      errorList.Contains(socket3) ? "" : "not " );

    Socket.Select(readList, writeList, errorList, 10);
    Console.WriteLine("The Select method has been called.");
    Console.WriteLine(
      "socket3 is {0}in readList.",
      readList.Contains(socket3) ? "" : "not " );
    Console.WriteLine(
      "socket3 is {0}in writeList.",
      writeList.Contains(socket3) ? "" : "not " );
    Console.WriteLine(
      "socket3 is {0}in errorList.",
      errorList.Contains(socket3) ? "" : "not " );
  }
}
   </code>
          <para>The output is</para>
          <c>
            <para>socket3 is placed in readList and errorList.</para>
            <para>socket3 is in readList.</para>
            <para>socket3 is not in writeList.</para>
            <para>socket3 is in errorList.</para>
            <para>The Select method has been called.</para>
            <para>socket3 is not in readList.</para>
            <para>socket3 is not in writeList.</para>
            <para>socket3 is not in errorList.</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" /> is a static method that determines the status of one or more <see cref="T:System.Net.Sockets.Socket" /> instances. You must place one or more sockets into an <see cref="T:System.Collections.IList" /> before you can use the <see cref="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" /> method. Check for readability by calling <see cref="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" /> with the <see cref="T:System.Collections.IList" /> as the <paramref name="checkRead" /> parameter. To check your sockets for writability, use the <paramref name="checkWrite" /> parameter. For detecting error conditions, use <paramref name="checkError" />. After calling <see cref="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />, the <see cref="T:System.Collections.IList" /> will be filled with only those sockets that satisfy the conditions.</para>
          <para>If you are in a listening state, readability means that a call to <see cref="M:System.Net.Sockets.Socket.Accept" /> will succeed without blocking. If you have already accepted the connection, readability means that data is available for reading. In these cases, all receive operations will succeed without blocking. Readability can also indicate whether the remote <see cref="T:System.Net.Sockets.Socket" /> has shut down the connection; in that case a call to <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will return immediately, with zero bytes returned.</para>
          <para>
            <see cref="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" /> returns when at least one of the sockets of interest (the sockets in the <paramref name="checkRead" />, <paramref name="checkWrite" />, and <paramref name="checkError" /> lists) meets its specified criteria, or the <paramref name="microSeconds" /> parameter is exceeded, whichever comes first. Setting <paramref name="microSeconds" /> to -1 specifies an infinite time-out.</para>
          <para>If you make a nonblocking call to <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, writability means that you have connected successfully. If you already have a connection established, writability means that all send operations will succeed without blocking.</para>
          <para>If you have made a non-blocking call to <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, the <paramref name="checkerror" /> parameter identifies sockets that have not connected successfully.</para>
          <block subset="none" type="note">
            <para>Use the <see cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" /> method if you only want to determine the status of a single <see cref="T:System.Net.Sockets.Socket" />.</para>
          </block>
          <block subset="none" type="note">
            <para>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.</para>
          </block>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines the status of one or more sockets.</para>
        </summary>
        <param name="checkRead">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability. </param>
        <param name="checkWrite">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability. </param>
        <param name="checkError">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors. </param>
        <param name="microSeconds">
          <attribution license="cc4" from="Microsoft" modified="false" />The time-out value, in microseconds. A -1 value indicates an infinite time-out.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 Send(class System.Byte[] buffer)" />
      <MemberSignature Language="C#" Value="public int Send (byte[] buf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buf) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buf" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buf">A <see cref="T:System.Byte" qualify="true" /> array containing data to send to the socket.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer " />is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>An error occurred while accessing the socket.</para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" /> synchronously sends data to the remote host specified in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method and returns the number of bytes successfully sent. <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" /> can be used for both connection-oriented and connectionless protocols.</para>
          <para>This overload requires a buffer that contains the data you want to send. The <see cref="T:System.Net.Sockets.SocketFlags" /> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</para>
          <para>If you are using a connectionless protocol, you must call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before calling this method, or <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you are using a connection-oriented protocol, you must either use <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or use <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection.</para>
          <para>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method. If you do not use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method, you will have to call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before each call to <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />. You can use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> even after you have established a default remote host with <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />. You can also change the default remote host prior to calling <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" /> by making another call to <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />.</para>
          <para>If you are using a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" /> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <see cref="P:System.Net.Sockets.Socket.SendTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" /> call will throw a <see cref="T:System.Net.Sockets.SocketException" />. In nonblocking mode, <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" /> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" /> can be used for both connection-oriented and connectionless protocols.</para>
          <para>This overload requires at least one buffer that contains the data you want to send.</para>
          <para>If you are using a connectionless protocol, you must call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before calling this method, or <see cref="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you are using a connection-oriented protocol, you must either use <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or use <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection.</para>
          <para>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method. If you do not use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method, you will have to call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before each call to <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />. You can use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> even after you have established a default remote host with <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />. You can also change the default remote host prior to calling <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> by making another call to <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />.</para>
          <para>If you are using a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <see cref="P:System.Net.Sockets.Socket.SendTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> call will throw a <see cref="T:System.Net.Sockets.SocketException" />. In nonblocking mode, <see cref="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </returns>
        <param name="buffers">
          <attribution license="cc4" from="Microsoft" modified="false" />A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent. </param>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 Send(class System.Byte[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags)" />
      <MemberSignature Language="C#" Value="public int Send (byte[] buf, System.Net.Sockets.SocketFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buf, valuetype System.Net.Sockets.SocketFlags flags) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buf" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buf">To be added.</param>
        <param name="flags">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer " />is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> synchronously sends data to the remote host established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method and returns the number of bytes successfully sent. The <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method can be used for both connection-oriented and connectionless protocols.</para>
          <para>This overload requires a buffer that contains the data you want to send and a bitwise combination of <see cref="T:System.Net.Sockets.SocketFlags" />. The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer. If you specify the <see cref="F:System.Net.Sockets.SocketFlags.DontRoute" /> flag as the <paramref name="socketflags" /> parameter value, the data you are sending will not be routed. </para>
          <para>If you are using a connectionless protocol, you must call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before calling this method, or <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you are using a connection-oriented protocol, you must either use <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or use <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection.</para>
          <para>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method. If you do not use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method, you will have to call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method before each call to <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />. You can use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> even after you have established a default remote host with <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />. You can also change the default remote host prior to calling <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> by making another call to <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />.</para>
          <para>If you are using a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <see cref="P:System.Net.Sockets.Socket.SendTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> call will throw a <see cref="T:System.Net.Sockets.SocketException" />. In nonblocking mode, <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This overload requires at least one buffer that contains the data you want to send. The <see cref="T:System.Net.Sockets.SocketFlags" /> value defaults to 0. If you specify the <see cref="F:System.Net.Sockets.SocketFlags.DontRoute" /> flag as the <paramref name="socketFlags" /> parameter, the data you are sending will not be routed. </para>
          <para>If you are using a connectionless protocol, you must call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before calling this method, or <see cref="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you are using a connection-oriented protocol, you must either use <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or use <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection.</para>
          <para>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method. If you do not use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method, you will have to call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before each call to <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />. You can use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> even after you have established a default remote host with <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />. You can also change the default remote host prior to calling <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> by making another call to <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />.</para>
          <para>If you are using a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <see cref="P:System.Net.Sockets.Socket.SendTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> call will throw a <see cref="T:System.Net.Sockets.SocketException" />. In non-blocking mode, <see cref="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </returns>
        <param name="buffers">
          <attribution license="cc4" from="Microsoft" modified="false" />A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="socketFlags">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 Send(class System.Byte[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags)" />
      <MemberSignature Language="C#" Value="public int Send (byte[] buf, int size, System.Net.Sockets.SocketFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buf, int32 size, valuetype System.Net.Sockets.SocketFlags flags) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buf" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buf">To be added.</param>
        <param name="flags">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para> -or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values. </para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket.</para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> synchronously sends data to the remote host established in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method and returns the number of bytes successfully sent. <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> can be used for both connection-oriented and connectionless protocols.</para>
          <para>This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <see cref="T:System.Net.Sockets.SocketFlags" />. If you specify the <see cref="F:System.Net.Sockets.SocketFlags.DontRoute" /> flag as the <paramref name="socketflags" /> parameter, the data you are sending will not be routed. </para>
          <para>If you are using a connectionless protocol, you must call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before calling this method, or <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you are using a connection-oriented protocol, you must either use <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or use <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection.</para>
          <para>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method. If you do not use the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method, you will have to call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method before each call to the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method. You can use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> even after you have established a default remote host with <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />. You can also change the default remote host prior to calling <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> by making another call to <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />.</para>
          <para>With a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will block until the requested number of bytes are sent, unless a time-out was set by using <see cref="P:System.Net.Sockets.Socket.SendTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> call will throw a <see cref="T:System.Net.Sockets.SocketException" />. In nonblocking mode, <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>You must ensure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </returns>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to send. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, valuetype System.Net.Sockets.SocketError errorCode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 Send(class System.Byte[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags)" />
      <MemberSignature Language="C#" Value="public int Send (byte[] buf, int offset, int size, System.Net.Sockets.SocketFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buf, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buf" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buf">To be added.</param>
        <param name="flags">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0. </para>
          <para>-or- </para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para> -or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> synchronously sends data to the remote host specified in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method and returns the number of bytes successfully sent. <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> can be used for both connection-oriented and connectionless protocols.</para>
          <para>In this overload, if you specify the <see cref="F:System.Net.Sockets.SocketFlags.DontRoute" /> flag as the <paramref name="socketflags" /> parameter, the data you are sending will not be routed. </para>
          <para>If you are using a connectionless protocol, you must call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before calling this method or <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. If you are using a connection-oriented protocol, you must either use <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or use <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection.</para>
          <para>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />. If you do not use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />, you will have to call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before each call to <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />. It is okay to use <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> even after you have established a default remote host with <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />. You can also change the default remote host prior to calling <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> by making another call to <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />.</para>
          <para>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <para>If you are using a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> will block until the requested number of bytes are sent, unless a time-out was set by using <see cref="P:System.Net.Sockets.Socket.SendTimeout" />. If the time-out value was exceeded, the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> call will throw a <see cref="T:System.Net.Sockets.SocketException" />. In nonblocking mode, <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </returns>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The position in the data buffer at which to begin sending data. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to send. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buf, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buf, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, valuetype System.Net.Sockets.SocketError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buf" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buf">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="size">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method is used to write outgoing data from one or more buffers on a connection-oriented socket. This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation. </para>
          <para>The <see cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method starts an asynchronous send operation to the remote host established in the <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" />, <see cref="Overload:System.Net.Sockets.Socket.Connect" />, or <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</para>
          <para>The following properties and events on the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object are required to successfully call this method:</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> if <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> is set</para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" /> if <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> is set</para>
            </item>
            <item>
              <para>
                <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
              </para>
            </item>
          </list>
          <para>The caller may set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" /> property to any user state object desired before calling the <see cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </para>
          <para>The <see cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method will throw an exception if you do not first call <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" />, <see cref="Overload:System.Net.Sockets.Socket.Connect" />, or <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />. </para>
          <para>Calling the <see cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method gives you the ability to send data within a separate execution thread.</para>
          <para>For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider. If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <see cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method throws a <see cref="T:System.Net.Sockets.SocketException" /> with the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketError" /> set to the native Winsock WSAEMSGSIZE error code (10040).</para>
          <para>Note that the successful completion of the <see cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method does not indicate that the data was successfully delivered.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation. </para>
          <para>Returns false if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</para>
        </returns>
        <param name="e">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A larger buffer size might delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This overload sends the file <paramref name="fileName" /> to the connected socket. The <paramref name="flags" /> parameter defaults to <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> (0), and the <paramref name="preBuffer" /> and <paramref name="postBuffer" /> parameters default to null. If <paramref name="fileName" /> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards ("..\\myfile.txt") and UNC share names ("\\\\shared directory\\myfile.txt") are supported. If the file is not found, the exception <see cref="T:System.IO.FileNotFoundException" /> is thrown.</para>
          <para>This method uses the TransmitFile function found in the Windows Sockets 2 API. For more information about the TransmitFile function and its flags, see the Windows Sockets documentation in the MSDN Library.</para>
          <para>
            <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> synchronously sends a file to the remote host specified in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method. <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> can be used for both connection-oriented and for connectionless protocols.</para>
          <para>If you are using a connectionless protocol, you must call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before calling this method, otherwise <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> throws a <see cref="T:System.Net.Sockets.SocketException" /> exception. If you are using a connection-oriented protocol, you must either use <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection or use <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection.</para>
          <para>If you are using a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> blocks until the file is sent. In nonblocking mode, <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</para>
        </summary>
        <param name="fileName">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.String" /> that contains the path and name of the file to be sent. This parameter can be null. </param>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This overload requires the name of the file you want to send and a bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values. The <paramref name="preBuffer" /> parameter contains any data you want to precede the file. <paramref name="postBuffer" /> contains data you want to follow the file. If <paramref name="fileName" /> is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards ("..\\myfile.txt") and UNC share names ("\\\\shared directory\\myfile.txt") are supported.</para>
          <para>The <paramref name="flags" /> parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</para>
          <para>This method uses the TransmitFile function found in the Windows Sockets 2 API. For more information about the TransmitFile function and its flags, see the Windows Sockets documentation in the MSDN Library.</para>
          <para>
            <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> synchronously sends a file to the remote host specified in the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> or <see cref="M:System.Net.Sockets.Socket.Accept" /> method. <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> can be used for both connection-oriented and for connectionless protocols.</para>
          <para>If you are using a connectionless protocol, you must call <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> before calling this method; otherwise <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> throws a <see cref="T:System.Net.Sockets.SocketException" />. If you are using a connection-oriented protocol, you must either use <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> to establish a remote host connection, or use <see cref="M:System.Net.Sockets.Socket.Accept" /> to accept an incoming connection.</para>
          <para>If you are using a connection-oriented protocol, <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> blocks until the entire file is sent. In nonblocking mode, <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.SendFile(System.String)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</para>
        </summary>
        <param name="fileName">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.String" /> that contains the path and name of the file to be sent. This parameter can be null. </param>
        <param name="preBuffer">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent. This parameter can be null. </param>
        <param name="postBuffer">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent. This parameter can be null. </param>
        <param name="flags">
          <attribution license="cc4" from="Microsoft" modified="false" />One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values. </param>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method is used to send a collection of files or in memory data buffers to remote host. The <see cref="T:System.Net.Sockets.Socket" /> must already be connected to the remote host.</para>
          <para>If a <see cref="T:System.Net.Sockets.SendPacketsElement" /> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards and UNC share names are supported. If the file is not found, <see cref="T:System.IO.FileNotFoundException" /> is thrown.</para>
          <para>To be notified of completion, you must create a callback method that implements the EventHandler&lt;SocketAsyncEventArgs&gt; delegate and attach the callback to the <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event.</para>
          <para>The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" /> property on the <paramref name="e" /> parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</para>
          <para>The following properties and events on the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object are required to successfully call this method:</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
              </para>
            </item>
            <item>
              <para>
                <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
              </para>
            </item>
          </list>
          <para>The caller may set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" /> property to any user state object desired before calling the <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </para>
          <para>This method uses the TransmitPackets function found in the Windows Sockets 2 API. For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</para>
          <para>Although intended for connection-oriented protocols, the <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method also works for connectionless protocols, provided that you first call the <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" />, <see cref="Overload:System.Net.Sockets.Socket.Connect" />, or <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> throws a <see cref="T:System.Net.Sockets.SocketException" /> exception.</para>
          <para>The <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method is optimized according to the operating system on which it is used. On Windows server editions, the <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method is optimized for high performance. </para>
          <para>On Windows client editions, the <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method is optimized for minimum memory and resource utilization.</para>
          <para>Use of the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseKernelApc" /> flag in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" /> property on the <paramref name="e" /> parameter can deliver significant performance benefits. If the thread initiating the <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching. Note that there is a difference between kernel and user-mode APCs. Kernel APCs launch when a thread is in a wait state. User-mode APCs launch when a thread is in an alertable wait state</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation. </para>
          <para>Returns false if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</para>
        </returns>
        <param name="e">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This option applies to synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> calls only. If the time-out period is exceeded, the <see cref="Overload:System.Net.Sockets.Socket.Send" /> method will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 SendTo(class System.Byte[] buffer, class System.Net.EndPoint remoteEP)" />
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remote_end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remote_end) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remote_end">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="buffer or remoteEP " />is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to make a connection to the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Connect" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the <paramref name="buffer" /> parameter, and the <see cref="T:System.Net.Sockets.SocketFlags" /> value defaults to 0.</para>
          <para>If you are using a connectionless protocol, you do not need to establish a default remote host with the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />. You only need to do this if you intend to call the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method. If you do call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />, the <paramref name="remoteEP" /> parameter will override the specified default remote host for that send operation only. You are also not required to call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property after the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method successfully completes.</para>
          <para>Although intended for connectionless protocols, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method or accept an incoming connection request using the <see cref="M:System.Net.Sockets.Socket.Accept" /> method. If you do not establish or accept a remote host connection, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. You can also establish a default remote host for a connectionless protocol prior to calling the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method. In either of these cases, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will ignore the <paramref name="remoteEP" /> parameter and only send data to the connected or default remote host.</para>
          <para>Blocking sockets will block until the all of the bytes in the buffer are sent. Since a nonblocking <see cref="T:System.Net.Sockets.Socket" /> completes immediately, it might not send all of the bytes in the <paramref name="buffer" />. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <paramref name="buffer" />. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <para>If you are using a connectionless protocol in blocking mode, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method and set the socket option to <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends data to the specified endpoint.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes sent.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the data to be sent. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 SendTo(class System.Byte[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP)" />
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags flags, System.Net.EndPoint remote_end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags flags, class System.Net.EndPoint remote_end) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="buffer or remoteEP " />is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to make a connection to the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Connect" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the <paramref name="buffer" />. If you specify the <see cref="F:System.Net.Sockets.SocketFlags.DontRoute" /> flag as the <paramref name="socketflags" /> parameter, the data you are sending will not be routed. </para>
          <para>If you are using a connectionless protocol, you do not need to establish a default remote host with the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />. You only need to do this if you intend to call the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method. If you do call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />, the <paramref name="remoteEP" /> parameter will override the specified default remote host for that send operation only. You are also not required to call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property after the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method successfully completes.</para>
          <para>Although intended for connectionless protocols, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method or accept an incoming connection request using the <see cref="M:System.Net.Sockets.Socket.Accept" /> method. If you do not establish or accept a remote host connection, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. You can also establish a default remote host for a connectionless protocol prior to calling the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method. In either of these cases, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will ignore the <paramref name="remoteEP" /> parameter and only send data to the connected or default remote host.</para>
          <para>Blocking sockets will block until the requested all of the bytes in the <paramref name="buffer" /> are sent. Since a nonblocking <see cref="T:System.Net.Sockets.Socket" /> completes immediately, it might not send all of the bytes in the <paramref name="buffer" />. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <paramref name="buffer" />. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <para>If you are using a connectionless protocol in blocking mode, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method and set the socket option to <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes sent.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the data to be sent. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 SendTo(class System.Byte[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP)" />
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags flags, System.Net.EndPoint remote_end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags flags, class System.Net.EndPoint remote_end) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="buffer or remoteEP " />is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para> -or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to make a connection to the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Connect" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In this overload, the buffer offset defaults to 0. If you specify the <see cref="F:System.Net.Sockets.SocketFlags.DontRoute" /> flag as the <paramref name="socketflags" /> parameter, the data you are sending will not be routed. </para>
          <para>If you are using a connectionless protocol, you do not need to establish a default remote host with the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />. You only need to do this if you intend to call the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method. If you do call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />, the <paramref name="remoteEP" /> parameter will override the specified default remote host for that send operation only. You are also not required to call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property after the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method successfully completes.</para>
          <para>Although intended for connectionless protocols, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method or accept an incoming connection request using the <see cref="M:System.Net.Sockets.Socket.Accept" /> method. If you do not establish or accept a remote host connection, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. You can also establish a default remote host for a connectionless protocol prior to calling the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method. In either of these cases, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will ignore the <paramref name="remoteEP" /> parameter and only send data to the connected or default remote host.</para>
          <para>Blocking sockets will block until the requested number of bytes are sent. Since a nonblocking <see cref="T:System.Net.Sockets.Socket" /> completes immediately, it might not send all of the bytes requested in a single operation. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <para>If you are using a connectionless protocol in blocking mode, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method and set the socket option to <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes sent.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the data to be sent. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to send. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 SendTo(class System.Byte[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP)" />
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, System.Net.EndPoint remote_end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, class System.Net.EndPoint remote_end) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="buffer or remoteEP " />is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0. </para>
          <para>-or- </para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para> -or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>An asynchronous call is pending and a blocking method has been called.</para>
        </exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <para>
            <paramref name="socketFlags" /> is not a valid combination of values.</para>
          <para>-or-</para>
          <para>An error occurred while accessing the socket. </para>
          <para>
            <block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block>
          </para>
        </exception>
        <exception cref="T:System.Security.SecurityException"> A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Net.SocketPermission">Requires permission to make a connection to the endpoint defined by <paramref name="remoteEP" />. See <see cref="F:System.Net.NetworkAccess.Connect" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In this overload, if you specify the <see cref="F:System.Net.Sockets.SocketFlags.DontRoute" /> flag as the <paramref name="socketflags" /> parameter, the data you are sending will not be routed. </para>
          <para>If you are using a connectionless protocol, you do not need to establish a default remote host with the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />. You only need to do this if you intend to call the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> method. If you do call the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />, the <paramref name="remoteEP" /> parameter will override the specified default remote host for that send operation only. You are also not required to call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property after the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method successfully completes.</para>
          <para>Although intended for connectionless protocols, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> method or accept an incoming connection request using the <see cref="M:System.Net.Sockets.Socket.Accept" /> method. If you do not establish or accept a remote host connection, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. You can also establish a default remote host for a connectionless protocol prior to calling the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method. In either of these cases, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will ignore the <paramref name="remoteEP" /> parameter and only send data to the connected or default remote host.</para>
          <para>Blocking sockets will block until the requested number of bytes are sent. Since a non-blocking <see cref="T:System.Net.Sockets.Socket" /> completes immediately, it might not send all of the bytes requested in a single operation. It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> method means that the underlying system has had room to buffer your data for a network send. </para>
          <para>If you are using a connectionless protocol in blocking mode, <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> method and set the socket option to <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />. You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes sent.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the data to be sent. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The position in the data buffer at which to begin sending data. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to send. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method starts an asynchronous send operation to the remote host specified in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> property of the <paramref name="e" /> parameter. Calling the <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method gives you the ability to send data within a separate execution thread. Although this method is intended for connectionless protocols, <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> works with both connectionless and connection-oriented protocols.</para>
          <para>To be notified of completion, you must create a callback method that implements the EventHandler&lt;SocketAsyncEventArgs&gt; delegate and attach the callback to the <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event.</para>
          <para>The following properties and events on the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object are required to successfully call this method:</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
              </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
              </para>
            </item>
            <item>
              <para>
                <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
              </para>
            </item>
            <item>
              <para>
                <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
              </para>
            </item>
          </list>
          <para>The caller may set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" /> property to any user state object desired before calling the <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </para>
          <para>If you are using a connection-oriented protocol, you must first call the <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" />, <see cref="Overload:System.Net.Sockets.Socket.Connect" />, or <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method. Otherwise <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. When using a connection-oriented protocol, the <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method will ignore the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> property and send data to the <see cref="T:System.Net.EndPoint" /> established in the <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" />, <see cref="Overload:System.Net.Sockets.Socket.Connect" />, or <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</para>
          <para>If you are using a connectionless protocol, you do not need to establish a default remote host with the <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" />, <see cref="Overload:System.Net.Sockets.Socket.Connect" />, or <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />. You only need to do this if you intend to call the <see cref="Overload:System.Net.Sockets.Socket.BeginSend" /> or <see cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> methods. If you do call the <see cref="Overload:System.Net.Sockets.Socket.BeginConnect" />, <see cref="Overload:System.Net.Sockets.Socket.Connect" />, or <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method prior to calling <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> property will override the specified default remote host for that send operation only. You are also not required to call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> method. In this case, the underlying service provider will assign the most appropriate local network IP address and port number. Use a port number of zero if you want the underlying service provider to select a free port. If you need to identify the assigned local network IP address and port number, you can use the <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property after the <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event is signaled and the associated delegates are called.</para>
          <para>If you want to send data to a broadcast address, you must first call the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" /> method and set the socket option for <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" /> to true. You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          <para>If you specify the DontRoute flag in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> property, the data you are sending will not be routed.</para>
          <para>For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport. If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> will throw a <see cref="T:System.Net.Sockets.SocketException" />. The successful completion of a <see cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method does not indicate that the data was successfully delivered.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sends data asynchronously to a specific remote host.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation. </para>
          <para>Returns false if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</para>
        </returns>
        <param name="e">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Net.Sockets.Socket" /> options determine the behavior of the current <see cref="T:System.Net.Sockets.Socket" />. Set <paramref name="optionValue" /> to true to enable the option, or to false to disable the option.</para>
          <para>
            <see cref="T:System.Net.Sockets.Socket" /> options are grouped by level of protocol support.</para>
          <para>Listed below are the various <see cref="T:System.Net.Sockets.Socket" /> options that can be set using this overload. These options are grouped by the appropriate <see cref="T:System.Net.Sockets.SocketOptionLevel" /> value. If you intend to set any of these options, be sure to use the appropriate <see cref="T:System.Net.Sockets.SocketOptionLevel" /> value for the <paramref name="optionLevel" /> parameter. The option you choose to set must be specified in the <paramref name="optionName" /> parameter. If you want to get the current value of any of the options listed, use the <see cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" /> method.</para>
          <para>
            <see cref="F:System.Net.Sockets.SocketOptionLevel.Socket" /> options that can be set using this overload.</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.AcceptConnection" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.Debug" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.KeepAlive" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.ReuseAddress" /> </para>
            </item>
          </list>
          <para>
            <see cref="F:System.Net.Sockets.SocketOptionLevel.IP" /> options that can be set using this overload.</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.HeaderIncluded" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.MulticastLoopback" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.UseLoopback" /> </para>
            </item>
          </list>
          <para>
            <see cref="F:System.Net.Sockets.SocketOptionLevel.Tcp" /> options that can be set using this overload.</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.BsdUrgent" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.Expedited" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.NoDelay" /> </para>
            </item>
          </list>
          <para>
            <see cref="F:System.Net.Sockets.SocketOptionLevel.Udp" /> options that can be set using this overload.</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.NoChecksum" /> </para>
            </item>
          </list>
          <para>For more information on these options, refer to the <see cref="T:System.Net.Sockets.SocketOptionName" /> enumeration.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" /> exception, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</para>
        </summary>
        <param name="optionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values. </param>
        <param name="optionName">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values. </param>
        <param name="optionValue">
          <attribution license="cc4" from="Microsoft" modified="false" />The value of the option, represented as a <see cref="T:System.Boolean" />. </param>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, class System.Byte[] optionValue)" />
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"> Requires permission to access unmanaged code. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Net.Sockets.Socket" /> options determine the behavior of the current <see cref="T:System.Net.Sockets.Socket" />. Use this overload to set those <see cref="T:System.Net.Sockets.Socket" /> options that require a byte array as an option value.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</para>
        </summary>
        <param name="optionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values. </param>
        <param name="optionName">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values. </param>
        <param name="optionValue">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that represents the value of the option. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue)" />
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Some options require permission to access unmanaged code. All the options that do not require permission are noted in the tables in the Description section. All options not so noted require this permission. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Net.Sockets.Socket" /> options determine the behavior of the current <see cref="T:System.Net.Sockets.Socket" />. For an option with a <see cref="T:System.Boolean" /> data type, specify a nonzero value to enable the option, and a zero value to disable the option. For an option with an integer data type, specify the appropriate value. <see cref="T:System.Net.Sockets.Socket" /> options are grouped by level of protocol support.</para>
          <para>Listed below are the various <see cref="T:System.Net.Sockets.Socket" /> options that can be set using this overload. These options are grouped by the appropriate <see cref="T:System.Net.Sockets.SocketOptionLevel" />. If you intend to set any of these options, be sure to use the appropriate <see cref="T:System.Net.Sockets.SocketOptionLevel" /> for the <paramref name="optionLevel" /> parameter. The option you choose to set must be specified in the <paramref name="optionName" /> parameter. If you want to get the current value of any of the options listed, use the <see cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" /> method.</para>
          <para>
            <see cref="F:System.Net.Sockets.SocketOptionLevel.Socket" /> options that can be set using this overload.</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.Broadcast" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.DontLinger" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.Debug" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.Error" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.KeepAlive" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.ReceiveBuffer" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.ReceiveTimeout" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.ReuseAddress" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.SendBuffer" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.SendTimeout" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.Type" /> </para>
            </item>
          </list>
          <para>
            <see cref="F:System.Net.Sockets.SocketOptionLevel.IP" /> options that can be set using this overload.</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.HeaderIncluded" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.IPOptions" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.IpTimeToLive" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.MulticastInterface" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.MulticastLoopback" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.MulticastTimeToLive" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.TypeOfService" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.UseLoopback" /> </para>
            </item>
          </list>
          <para>
            <see cref="F:System.Net.Sockets.SocketOptionLevel.Tcp" /> options that can be set using this overload.</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.BsdUrgent" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.Expedited" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.NoDelay" /> </para>
            </item>
          </list>
          <para>
            <see cref="F:System.Net.Sockets.SocketOptionLevel.Udp" /> options that can be set using this overload.</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.ChecksumCoverage" /> </para>
            </item>
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.NoChecksum" /> </para>
            </item>
          </list>
          <para>
            <see cref="F:System.Net.Sockets.SocketOptionLevel.IPv6" /> options that can be set using this overload.</para>
          <list type="bullet">
            <item>
              <para>
                <see cref="F:System.Net.Sockets.SocketOptionName.HopLimit" /> </para>
            </item>
          </list>
          <para>For more information about these options, refer to the <see cref="T:System.Net.Sockets.SocketOptionName" /> enumeration.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</para>
        </summary>
        <param name="optionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values. </param>
        <param name="optionName">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values. </param>
        <param name="optionValue">
          <attribution license="cc4" from="Microsoft" modified="false" />A value of the option. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue)" />
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="optionLevel" />, <paramref name="optionName" />, or <paramref name="optionValue" /> specified an invalid value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">The <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> and <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> options require permission to access unmanaged code. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Net.Sockets.Socket" /> options determine the behavior of the current <see cref="T:System.Net.Sockets.Socket" />. Use this overload to set the <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" />, and <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> <see cref="T:System.Net.Sockets.Socket" /> options. For the <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> option, use <see cref="T:System.Net.Sockets.Socket" /> for the <paramref name="optionLevel" /> parameter. For <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> and <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, use <see cref="F:System.Net.Sockets.SocketOptionLevel.IP" />. If you want to get the current value of any of the options listed above, use the <see cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" /> method.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</para>
        </summary>
        <param name="optionLevel">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values. </param>
        <param name="optionName">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values. </param>
        <param name="optionValue">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how)" />
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket. <para><block subset="none" type="note">For additional information on causes of the <see langword=" SocketException" />, see the <see cref="T:System.Net.Sockets.SocketException" qualify="true" /> class.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When using a connection-oriented <see cref="T:System.Net.Sockets.Socket" />, always call the <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> method before closing the <see cref="T:System.Net.Sockets.Socket" />. This ensures that all data is sent and received on the connected socket before it is closed.</para>
          <para>Call the <see cref="M:System.Net.Sockets.Socket.Close" /> method to free all managed and unmanaged resources associated with the <see cref="T:System.Net.Sockets.Socket" />. Do not attempt to reuse the <see cref="T:System.Net.Sockets.Socket" /> after closing.</para>
          <para>The following table shows the <see cref="T:System.Net.Sockets.SocketShutdown" /> enumeration values that are valid for the <paramref name="how" /> parameter.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value </para>
                </term>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Send </para>
              </term>
              <description>
                <para>Disable sending on this <see cref="T:System.Net.Sockets.Socket" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Receive </para>
              </term>
              <description>
                <para>Disable receiving on this <see cref="T:System.Net.Sockets.Socket" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Both </para>
              </term>
              <description>
                <para>Disable both sending and receiving on this <see cref="T:System.Net.Sockets.Socket" />. </para>
              </description>
            </item>
          </list>
          <para>Setting <paramref name="how" /> to <see cref="F:System.Net.Sockets.SocketShutdown.Send" /> specifies that subsequent calls to <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> are not allowed. If you are using a connectionless <see cref="T:System.Net.Sockets.Socket" />, specifying <see cref="F:System.Net.Sockets.SocketShutdown.Send" /> will have no effect.</para>
          <para>Setting <paramref name="how" /> to <see cref="F:System.Net.Sockets.SocketShutdown.Receive" /> specifies that subsequent calls to <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" /> are not allowed. This has no effect on lower protocol layers. If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> : </para>
          <list type="bullet">
            <item>
              <para>Data is in the incoming network buffer waiting to be received.</para>
            </item>
            <item>
              <para>More data has arrived.</para>
            </item>
          </list>
          <para>If you are using a connectionless protocol, datagrams are accepted and queued. However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender. Using <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> on a connectionless <see cref="T:System.Net.Sockets.Socket" /> is not recommended.</para>
          <para>Setting <paramref name="how" /> to <see cref="F:System.Net.Sockets.SocketShutdown.Both" /> disables both sends and receives as described above.</para>
          <block subset="none" type="note">
            <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" /> when calling the <see cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" /> method, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
          </block>
          <block subset="none" type="note">
            <para>This member outputs trace information when you enable network tracing in your application. For more information, see <format type="text/html"><a href="E993B7C3-087F-45D8-9C02-9DDED936D804">[&lt;topic://conUsingNetworkTracing&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
        <param name="how">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="ILASM" Value=".property valuetype System.Net.Sockets.SocketType SocketType { public hidebysig specialname instance valuetype System.Net.Sockets.SocketType get_SocketType() }" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>One of the values defined in
      the <see cref="T:System.Net.Sockets.SocketType" /> enumeration.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="P:System.Net.Sockets.Socket.SocketType" /> is read-only and is set when the <see cref="T:System.Net.Sockets.Socket" /> is created.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The operating system may support both IPv4 and IPv6 protocols.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether IPv4 support is available and enabled on the current host.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The operating system may support both IPv4 and IPv6 protocols.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="ILASM" Value=".method private final hidebysig virtual void System.IDisposable.Dispose()" />
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Call <see cref="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" /> when you are finished using the <see cref="T:System.Net.Sockets.Socket" />. The <see cref="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" /> method leaves the <see cref="T:System.Net.Sockets.Socket" /> in an unusable state. After calling <see cref="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />, you must release all references to the <see cref="T:System.Net.Sockets.Socket" /> so the garbage collector can reclaim the memory that the <see cref="T:System.Net.Sockets.Socket" /> was occupying. For more information, see <format type="text/html"><a href="A17B0066-71C2-4BA4-9822-8E19332FC213">[&lt;topic://cpconCleaningUpUnmanagedResources&gt;]</a></format> and <format type="text/html"><a href="EB4E1AF0-3B48-4FBC-AD4E-FC2F64138BF9">[&lt;topic://cpconImplementingDisposeMethod&gt;]</a></format>. </para>
          <para>Note: Always call <see cref="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" /> before you release your last reference to the <see cref="T:System.Net.Sockets.Socket" />. Otherwise, the resources it is using will not be freed until the garbage collector calls the <see cref="T:System.Net.Sockets.Socket" /> object's Finalize method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases all resources used by the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</para>
          <para>The TTL value may be set to a value from 0 to 255. When this property is not set, the default TTL value for a socket is 32. </para>
          <para>Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</para>
          <para>If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Set this property to true for a <see cref="T:System.Net.Sockets.Socket" /> you intend to call <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />. Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Specifies whether the socket should only use Overlapped I/O mode.</para>
        </summary>
      </Docs>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>