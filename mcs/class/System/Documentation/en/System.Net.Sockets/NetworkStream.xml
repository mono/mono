<?xml version="1.0" encoding="utf-8"?>
<Type Name="NetworkStream" FullName="System.Net.Sockets.NetworkStream" FullNameSP="System_Net_Sockets_NetworkStream" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public NetworkStream extends System.IO.Stream" />
  <TypeSignature Language="C#" Value="public class NetworkStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetworkStream extends System.IO.Stream implements class System.IDisposable" />
  <MemberOfLibrary>Networking</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.x.x</AssemblyVersion>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The <see cref="T:System.Net.Sockets.NetworkStream" /> class provides methods for sending and receiving data over <see cref="F:System.Net.Sockets.SocketType.Stream" /> sockets in blocking mode. For more information about blocking versus nonblocking <see cref="T:System.Net.Sockets.Socket" />s, see <format type="text/html"><a href="FD85BC88-E06C-467D-A30D-9FD7CFFCFCA1">Using an Asynchronous Client Socket</a></format>. You can use the <see cref="T:System.Net.Sockets.NetworkStream" /> class for both synchronous and asynchronous data transfer. For more information about synchronous and asynchronous communication, see <format type="text/html"><a href="10D22735-BD37-42C1-A2BE-C1932F979A7D">Sockets</a></format>. </para>
      <para>To create a <see cref="T:System.Net.Sockets.NetworkStream" />, you must provide a connected <see cref="T:System.Net.Sockets.Socket" />. You can also specify what <see cref="T:System.IO.FileAccess" /> permission the <see cref="T:System.Net.Sockets.NetworkStream" /> has over the provided <see cref="T:System.Net.Sockets.Socket" />. By default, closing the <see cref="T:System.Net.Sockets.NetworkStream" /> does not close the provided <see cref="T:System.Net.Sockets.Socket" />. If you want the <see cref="T:System.Net.Sockets.NetworkStream" /> to have permission to close the provided <see cref="T:System.Net.Sockets.Socket" />, you must specify true for the value of the <paramref name="ownsSocket" /> parameter.</para>
      <para>Use the <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> methods for simple single thread synchronous blocking I/O. If you want to process your I/O using separate threads, consider using the <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> and <see cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" /> methods, or the <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> and <see cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" /> methods for communication.</para>
      <para>The <see cref="T:System.Net.Sockets.NetworkStream" /> does not support random access to the network data stream. The value of the <see cref="P:System.Net.Sockets.NetworkStream.CanSeek" /> property, which indicates whether the stream supports seeking, is always false; reading the <see cref="P:System.Net.Sockets.NetworkStream.Position" /> property, reading the <see cref="P:System.Net.Sockets.NetworkStream.Length" /> property, or calling the <see cref="M:System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)" /> method will throw a <see cref="T:System.NotSupportedException" />.</para>
      <para>Read and write operations can be performed simultaneously on an instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class without the need for synchronization. As long as there is one unique thread for the write operations and one unique thread for the read operations, there will be no cross-interference between read and write threads and no synchronization is required. </para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides the underlying stream of data for network access.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Net.Sockets.Socket socket)" />
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="socket" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">
          <para>The <see cref="P:System.Net.Sockets.Socket.Blocking" /> property of <paramref name="socket" /> is <see langword="false" />.</para>
          <para> -or-</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.Connected" /> property of <paramref name="socket" /> is <see langword="false" />.</para>
          <para> -or-</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of <paramref name="socket" /> is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Net.Sockets.NetworkStream" /> is created with read/write access to the specified <see cref="T:System.Net.Sockets.Socket" />. The <see cref="T:System.Net.Sockets.NetworkStream" /> does not own the underlying <see cref="T:System.Net.Sockets.Socket" />, so calling the <see cref="M:System.Net.Sockets.NetworkStream.Close" /> method does not close the <see cref="T:System.Net.Sockets.Socket" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
        <param name="socket">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Net.Sockets.Socket socket, bool ownsSocket)" />
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, bool ownsSocket) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="socket" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">
          <para>The <see cref="P:System.Net.Sockets.Socket.Blocking" /> property of <paramref name="socket" /> is <see langword="false" />.</para>
          <para> -or-</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.Connected" /> property of <paramref name="socket" /> is <see langword="false" />.</para>
          <para> -or-</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of <paramref name="socket" /> is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Net.Sockets.NetworkStream" /> is created with read/write access to the specified <see cref="T:System.Net.Sockets.Socket" />. If the value of <paramref name="ownsSocket" /> parameter is true, the <see cref="T:System.Net.Sockets.NetworkStream" /> takes ownership of the underlying <see cref="T:System.Net.Sockets.Socket" />, and calling the <see cref="M:System.Net.Sockets.NetworkStream.Close" /> method also closes the underlying <see cref="T:System.Net.Sockets.Socket" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified <see cref="T:System.Net.Sockets.Socket" /> ownership.</para>
        </summary>
        <param name="socket">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data. </param>
        <param name="ownsSocket">
          <attribution license="cc4" from="Microsoft" modified="false" />Set to true to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the <see cref="T:System.Net.Sockets.Socket" />; otherwise, false. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access)" />
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="socket" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">
          <para>The <see cref="P:System.Net.Sockets.Socket.Blocking" /> property of <paramref name="socket" /> is <see langword="false" />.</para>
          <para> -or-</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.Connected" /> property of <paramref name="socket" /> is <see langword="false" />.</para>
          <para> -or-</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of <paramref name="socket" /> is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Net.Sockets.NetworkStream" /> is created with the specified access to the specified <see cref="T:System.Net.Sockets.Socket" />. With this constructor, the <see cref="T:System.Net.Sockets.NetworkStream" /> does not own the underlying <see cref="T:System.Net.Sockets.Socket" />, so calling the <see cref="M:System.Net.Sockets.NetworkStream.Close" /> method does not close the underlying <see cref="T:System.Net.Sockets.Socket" />.</para>
          <para>The <paramref name="access" /> parameter sets the <see cref="P:System.Net.Sockets.NetworkStream.CanRead" /> and <see cref="P:System.Net.Sockets.NetworkStream.CanWrite" /> properties of the <see cref="T:System.Net.Sockets.NetworkStream" />. If you specify <see cref="F:System.IO.FileAccess.Write" />, then the <see cref="T:System.Net.Sockets.NetworkStream" /> allows calls to the <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> method. If you specify <see cref="F:System.IO.FileAccess.Read" />, then the <see cref="T:System.Net.Sockets.NetworkStream" /> allows calls to the <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> method. If you specify <see cref="F:System.IO.FileAccess.ReadWrite" />, both method calls are allowed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified access rights.</para>
        </summary>
        <param name="socket">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specify the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided <see cref="T:System.Net.Sockets.Socket" />. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access, bool ownsSocket)" />
      <MemberSignature Language="C#" Value="public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.Socket socket, valuetype System.IO.FileAccess access, bool ownsSocket) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="socket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="socket" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">
          <para>The <see cref="P:System.Net.Sockets.Socket.Blocking" /> property of <paramref name="socket" /> is <see langword="false" />.</para>
          <para> -or-</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.Connected" /> property of <paramref name="socket" /> is <see langword="false" />.</para>
          <para> -or-</para>
          <para>The <see cref="P:System.Net.Sockets.Socket.SocketType" /> property of <paramref name="socket" /> is not <see cref="F:System.Net.Sockets.SocketType.Stream" />.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Net.Sockets.NetworkStream" /> is created with read/write access to the specified <see cref="T:System.Net.Sockets.Socket" />. If the value of the <paramref name="ownsSocket" /> parameter is true, the <see cref="T:System.Net.Sockets.NetworkStream" /> takes ownership of the underlying <see cref="T:System.Net.Sockets.Socket" />, and calling the <see cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" /> method also closes the underlying <see cref="T:System.Net.Sockets.Socket" />.</para>
          <para>The <paramref name="access" /> parameter sets the <see cref="P:System.Net.Sockets.NetworkStream.CanRead" /> and <see cref="P:System.Net.Sockets.NetworkStream.CanWrite" /> properties of the <see cref="T:System.Net.Sockets.NetworkStream" />. If you specify <see cref="F:System.IO.FileAccess.Write" />, then the <see cref="T:System.Net.Sockets.NetworkStream" /> allows calls to the <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> method. If you specify <see cref="F:System.IO.FileAccess.Read" />, then the <see cref="T:System.Net.Sockets.NetworkStream" /> allows calls to the <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> method. If you specify <see cref="F:System.IO.FileAccess.ReadWrite" />, both method calls are allowed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class for the specified <see cref="T:System.Net.Sockets.Socket" /> with the specified access rights and the specified <see cref="T:System.Net.Sockets.Socket" /> ownership.</para>
        </summary>
        <param name="socket">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Net.Sockets.Socket" /> that the <see cref="T:System.Net.Sockets.NetworkStream" /> will use to send and receive data. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitwise combination of the <see cref="T:System.IO.FileAccess" /> values that specifies the type of access given to the <see cref="T:System.Net.Sockets.NetworkStream" /> over the provided <see cref="T:System.Net.Sockets.Socket" />. </param>
        <param name="ownsSocket">
          <attribution license="cc4" from="Microsoft" modified="false" />Set to true to indicate that the <see cref="T:System.Net.Sockets.NetworkStream" /> will take ownership of the <see cref="T:System.Net.Sockets.Socket" />; otherwise, false. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.IAsyncResult BeginRead(class System.Byte[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state)" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>An error occurred while accessing the underlying socket.</para>
          <para>
            <block subset="none" type="note">Any exception thrown by the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" qualify="true" /> method is caught and rethrown as an <see langword="IOException" /> with the original exception stored in the <see cref="P:System.Exception.InnerException" /> property.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" qualify="true" /> method. For the complete example, see
   the <see cref="T:System.Net.Sockets.Socket" qualify="true" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method starts asynchronously reading data from the incoming network buffers. Calling the <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method gives you the ability to receive data within a separate execution thread.</para>
          <para>You must create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate and pass its name to the <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method. At the very minimum, your <paramref name="state" /> parameter must contain the <see cref="T:System.Net.Sockets.NetworkStream" />. Because you will want to obtain the received data within your callback method, you should create a small class or structure to hold a read buffer and any other useful information. Pass the structure or class instance to the <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method should call the <see cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />, the system will wait until data is received or an error occurs, and then the system will use a separate thread to execute the specified callback method, and blocks on <see cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" /> until the provided <see cref="T:System.Net.Sockets.NetworkStream" /> reads data or throws an exception. If you want the original thread to block after you call the <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method, use the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method. Call <see cref="M:System.Threading.EventWaitHandle.Set" /> in the callback method when you want the original thread to continue executing. For additional information about writing callback methods, see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">Callback Sample</a></format>.</para>
          <para>The <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method reads as much data as is available, up to the number of bytes specified by the <paramref name="size" /> parameter.</para>
          <block subset="none" type="note">
            <para>If you receive an <see cref="T:System.IO.IOException" />, check the <see cref="P:System.Exception.InnerException" /> property to determine if it was caused by a <see cref="T:System.Net.Sockets.SocketException" />. If so, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</para>
          </block>
          <para>Read and write operations can be performed simultaneously on an instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class without the need for synchronization. As long as there is one unique thread for the write operations and one unique thread for the read operations, there will be no cross-interference between read and write threads and no synchronization is required. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that is the location in memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The location in <paramref name="buffer" /> to begin storing the data. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate that is executed when <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> completes. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains any additional user-defined data. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.IAsyncResult BeginWrite(class System.Byte[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state)" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 size, class System.AsyncCallback callback, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>An error occurred while accessing the underlying socket. </para>
          <para>
            <block subset="none" type="note">Any exception thrown by the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" qualify="true" /> method is caught and rethrown as an <see langword="IOException" /> with the original exception stored in the <see cref="P:System.Exception.InnerException" /> property.</block>
          </para>
        </exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" qualify="true" />
method. For the complete example, see the <see cref="T:System.Net.Sockets.Socket" qualify="true" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method starts an asynchronous send operation to the remote host. Calling the <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method gives you the ability to send data within a separate execution thread.</para>
          <para>You must create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate and pass its name to the <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method. At the very minimum, your <paramref name="state" /> parameter must contain the <see cref="T:System.Net.Sockets.NetworkStream" />. If your callback needs more information, you can create a small class or structure to hold the <see cref="T:System.Net.Sockets.NetworkStream" /> and the other required information. Pass the structure or class instance to the <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method through the <paramref name="state" /> parameter.</para>
          <para>Your callback method should implement the <see cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" /> method. When your application calls <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />, the system uses a separate thread to execute the specified callback method, and blocks on <see cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" /> until the <see cref="T:System.Net.Sockets.NetworkStream" /> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method, use the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method. Call <see cref="M:System.Threading.EventWaitHandle.Set" /> in the callback method when you want the original thread to continue executing. For additional information about writing callback methods, see <format type="text/html"><a href="6DDD7866-9804-4571-84DE-83F5CC017A5A">Callback Sample</a></format>.</para>
          <block subset="none" type="note">
            <para>If you receive an <see cref="T:System.IO.IOException" />, check the <see cref="P:System.Exception.InnerException" /> property to determine if it was caused by a <see cref="T:System.Net.Sockets.SocketException" />. If so, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</para>
          </block>
          <para>Read and write operations can be performed simultaneously on an instance of the <see cref="T:System.Net.Sockets.NetworkStream" /> class without the need for synchronization. As long as there is one unique thread for the write operations and one unique thread for the read operations, there will be no cross-interference between read and write threads and no synchronization is required. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous write to a stream.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.IAsyncResult" /> that represents the asynchronous call.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The location in <paramref name="buffer" /> to begin sending the data. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />. </param>
        <param name="callback">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.AsyncCallback" /> delegate that is executed when <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> completes. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains any additional user-defined data. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="ILASM" Value=".property bool CanRead { public hidebysig virtual specialname bool get_CanRead() }" />
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> indicates that the current stream supports reading; 
<see langword="false" />. indicates that the current stream does not 
   support reading.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <see cref="P:System.Net.Sockets.NetworkStream.CanRead" /> is true, <see cref="T:System.Net.Sockets.NetworkStream" /> allows calls to the <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> method. Provide the appropriate <see cref="T:System.IO.FileAccess" /> enumerated value in the constructor to set the readability and writability of the <see cref="T:System.Net.Sockets.NetworkStream" />. The <see cref="P:System.Net.Sockets.NetworkStream.CanRead" /> property is set when the <see cref="T:System.Net.Sockets.NetworkStream" /> is initialized.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> supports reading.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="ILASM" Value=".property bool CanSeek { public hidebysig virtual specialname bool get_CanSeek() }" />
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="false" />.</para>
        </value>
        <remarks>
          <para> This property is read-only. </para>
          <block subset="none" type="note">
            <para>This property overrides <see cref="P:System.IO.Stream.CanSeek" qualify="true" />.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the stream supports seeking. This property is not currently supported.This property always returns false.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property is present because it is inherited from <see cref="T:System.IO.Stream" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether timeout properties are usable for <see cref="T:System.Net.Sockets.NetworkStream" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="ILASM" Value=".property bool CanWrite { public hidebysig virtual specialname bool get_CanWrite() }" />
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> indicates that the current stream supports writing; 
<see langword="false" /> 
indicates that the current stream does not support writing.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <see cref="P:System.Net.Sockets.NetworkStream.CanWrite" /> is true, <see cref="T:System.Net.Sockets.NetworkStream" /> allows calls to the <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> method. Provide the appropriate <see cref="T:System.IO.FileAccess" /> enumerated value in the constructor to set the readability and writability of the <see cref="T:System.Net.Sockets.NetworkStream" />. The <see cref="P:System.Net.Sockets.NetworkStream.CanWrite" /> property is set when the <see cref="T:System.Net.Sockets.NetworkStream" /> is initialized.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> supports writing.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Close()" />
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.NetworkStream.Close" /> method frees both unmanaged and managed resources associated with the <see cref="T:System.Net.Sockets.NetworkStream" />. If the <see cref="T:System.Net.Sockets.NetworkStream" /> owns the underlying <see cref="T:System.Net.Sockets.Socket" />, it is closed as well. </para>
          <para>If a <see cref="T:System.Net.Sockets.NetworkStream" /> was associated with a <see cref="T:System.Net.Sockets.TcpClient" />, the <see cref="M:System.Net.Sockets.NetworkStream.Close" /> method will close the TCP connection, but not dispose of the associated <see cref="T:System.Net.Sockets.TcpClient" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Closes the <see cref="T:System.Net.Sockets.NetworkStream" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" /> method frees both unmanaged and managed resources associated with the <see cref="T:System.Net.Sockets.NetworkStream" />. If the <see cref="T:System.Net.Sockets.NetworkStream" /> owns the underlying <see cref="T:System.Net.Sockets.Socket" />, it is closed as well. </para>
          <para>If a <see cref="T:System.Net.Sockets.NetworkStream" /> was associated with a <see cref="T:System.Net.Sockets.TcpClient" />, the <see cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" /> method will close the TCP connection, but not dispose of the associated <see cref="T:System.Net.Sockets.TcpClient" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Closes the <see cref="T:System.Net.Sockets.NetworkStream" /> after waiting the specified time to allow data to be sent.</para>
        </summary>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit signed integer that specifies the number of milliseconds to wait to send any remaining data before closing.</param>
      </Docs>
    </Member>
    <Member MemberName="DataAvailable">
      <MemberSignature Language="ILASM" Value=".property bool DataAvailable { public hidebysig virtual specialname bool get_DataAvailable() }" />
      <MemberSignature Language="C#" Value="public virtual bool DataAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DataAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> indicates that data is available to be
   read; <see langword="false" />
   indicates that there is no data available to be read.</para>
        </value>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="P:System.Net.Sockets.NetworkStream.DataAvailable" /> property to determine if data is ready to be read. If <see cref="P:System.Net.Sockets.NetworkStream.DataAvailable" /> is true, a call to <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> returns immediately. If the remote host shuts down or closes the connection, <see cref="P:System.Net.Sockets.NetworkStream.DataAvailable" /> may throw a <see cref="T:System.Net.Sockets.SocketException" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether data is available on the <see cref="T:System.Net.Sockets.NetworkStream" /> to be read.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Dispose(bool disposing)" />
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is called by the public Dispose method and the <see cref="M:System.Object.Finalize" /> method. Dispose invokes the protected Dispose(Boolean) method with the <paramref name="disposing" /> parameter set to true. <see cref="M:System.Object.Finalize" /> invokes Dispose with <paramref name="disposing" /> set to false.</para>
          <para>When the <paramref name="disposing" /> parameter is true, this method releases all resources held by any managed objects that this <see cref="T:System.Net.Sockets.NetworkStream" /> references. This method invokes the Dispose method of each referenced object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.NetworkStream" /> and optionally releases the managed resources.</para>
        </summary>
        <param name="disposing">
          <attribution license="cc4" from="Microsoft" modified="false" />true to release both managed and unmanaged resources; false to release only unmanaged resources. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 EndRead(class System.IAsyncResult asyncResult)" />
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult ar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult ar) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ar" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="ar">A <see cref="T:System.IAsyncResult" /> object that holds the state information for the asynchronous operation. </param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">An error occurred while accessing the underlying socket. <para><block subset="none" type="note">This method catches all exceptions thrown by the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" qualify="true" /> method.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" qualify="true" /> method.
   For the complete example, see the <see cref="T:System.Net.Sockets.Socket" qualify="true" /> class overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" /> method completes the asynchronous read operation started in the <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method.</para>
          <para>Before calling <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />, you need to create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate. This callback method executes in a separate thread and is called by the system after <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> returns. The callback method must accept the <see cref="T:System.IAsyncResult" /> returned from the <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method as a parameter.</para>
          <para>Within the callback method, call the <see cref="P:System.IAsyncResult.AsyncState" /> property of the <see cref="T:System.IAsyncResult" /> to obtain the state object passed to the <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method. Extract the receiving <see cref="T:System.Net.Sockets.NetworkStream" /> from this state object. After obtaining the <see cref="T:System.Net.Sockets.NetworkStream" />, call the <see cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" /> method to successfully complete the read operation and return the number of bytes read.</para>
          <para>The <see cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" /> method blocks until data is available. The <see cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" /> method reads as much data as is available up to the number of bytes specified in the <paramref name="size" /> parameter of the <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method. If the remote host shuts down the <see cref="T:System.Net.Sockets.Socket" /> connection and all available data has been received, the <see cref="M:System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)" /> method completes immediately and returns zero bytes.</para>
          <para>To obtain the received data, call the <see cref="P:System.IAsyncResult.AsyncState" /> property of the <see cref="T:System.IAsyncResult" />, and extract the buffer contained in the resulting state object.</para>
          <block subset="none" type="note">
            <para>If you receive an <see cref="T:System.IO.IOException" />, check the <see cref="P:System.Exception.InnerException" /> property to determine if it was caused by a <see cref="T:System.Net.Sockets.SocketException" />. If so, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Handles the end of an asynchronous read.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void EndWrite(class System.IAsyncResult asyncResult)" />
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult ar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult ar) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ar" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="ar">A <see cref="T:System.IAsyncResult" /> object that holds the state information for the asynchronous operation. </param>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">An error occurred while accessing the underlying socket. <para><block subset="none" type="note">This method catches all exceptions thrown by the <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" qualify="true" /> method.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <example>
          <para>For an outline of an asynchronous operation, see the <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" qualify="true" /> method.
   For the complete example, see the <see cref="T:System.Net.Sockets.Socket" qualify="true" /> class
   overview.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" /> completes the asynchronous send operation started in <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</para>
          <para>Before calling <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />, you need to create a callback method that implements the <see cref="T:System.AsyncCallback" /> delegate. This callback method executes in a separate thread and is called by the system after <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> returns. The callback method must accept the <see cref="T:System.IAsyncResult" /> returned from the <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method as a parameter.</para>
          <para>Within the callback method, call the <see cref="P:System.IAsyncResult.AsyncState" /> property of the <paramref name="IAsyncResult" /> parameter to obtain the <see cref="T:System.Net.Sockets.NetworkStream" />. After obtaining the <see cref="T:System.Net.Sockets.NetworkStream" />, you can call the <see cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" /> method to successfully complete the send operation and return the number of bytes sent.</para>
          <para>The <see cref="M:System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)" /> method blocks until the requested number of bytes are sent.</para>
          <block subset="none" type="note">
            <para>If you receive an <see cref="T:System.IO.IOException" />, check the <see cref="P:System.Exception.InnerException" /> property to determine if it was caused by a <see cref="T:System.Net.Sockets.SocketException" />. If so, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Handles the end of an asynchronous write.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Finalize()" />
      <MemberSignature Language="C#" Value="~NetworkStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.Object.Finalize" />. Application code should not call this method; an object's <see cref="M:System.Object.Finalize" /> method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <see cref="M:System.GC.SuppressFinalize(System.Object)" /> method.</para>
          <para>For more information about using the Finalize method, see <format type="text/html"><a href="FD376774-1643-499B-869E-9546A3AEEA70">Finalize Methods and Destructors</a></format>, <format type="text/html"><a href="A17B0066-71C2-4BA4-9822-8E19332FC213">Cleaning Up Unmanaged Resources</a></format>, and <format type="text/html"><a href="8026CB68-FE93-43FC-96C1-C09AD7D64CD3">Overriding the Finalize Method</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases all resources used by the <see cref="T:System.Net.Sockets.NetworkStream" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Flush()" />
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.NetworkStream.Flush" /> method implements the <see cref="M:System.IO.Stream.Flush" /> method; however, because <see cref="T:System.Net.Sockets.NetworkStream" /> is not buffered, it has no affect on network streams. Calling the <see cref="M:System.Net.Sockets.NetworkStream.Flush" /> method does not throw an exception.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Flushes data from the stream. This method is reserved for future use.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="ILASM" Value=".property int64 Length { public hidebysig virtual specialname int64 get_Length() }" />
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>To be added.</value>
        <remarks>
          <block subset="none" type="note">
            <para> The <see cref="T:System.IO.Stream" /> base class implements this property to return the length of the data
      available on the stream. This functionality is not supported in
      the <see cref="T:System.Net.Sockets.NetworkStream" /> class.</para>
            <para>This property overrides <see cref="P:System.IO.Stream.Length" qualify="true" />.</para>
          </block>
        </remarks>
        <exception cref="T:System.NotSupportedException">Any attempt to access this property. </exception>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the length of the data available on the stream. This property is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="ILASM" Value=".property int64 Position { public hidebysig virtual specialname int64 get_Position() public hidebysig virtual specialname void set_Position(int64 value) }" />
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>To be added.</value>
        <remarks>
          <block subset="none" type="note">
            <para> The <see cref="T:System.IO.Stream" /> base class implements this property to return or set the
      current position in the stream. This functionality is not supported in the <see cref="T:System.Net.Sockets.NetworkStream" />
      class.</para>
            <para>This property overrides <see cref="P:System.IO.Stream.Position" qualify="true" />.</para>
          </block>
        </remarks>
        <exception cref="T:System.NotSupportedException">Any attempt to access this property.</exception>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the current position in the stream. This property is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 Read(class System.Byte[] buffer, int32 offset, int32 size)" />
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.IO.IOException">An error occurred while accessing the underlying socket. <para><block subset="none" type="note">This method catches all exceptions thrown by the <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" qualify="true" /> method.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method reads data into the <paramref name="buffer" /> parameter and returns the number of bytes successfully read. If no data is available for reading, the <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> method returns 0. The <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> operation reads as much data as is available, up to the number of bytes specified by the <paramref name="size" /> parameter. If the remote host shuts down the connection, and all available data has been received, the <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> method completes immediately and return zero bytes.</para>
          <block subset="none" type="note">
            <para>Check to see if the <see cref="T:System.Net.Sockets.NetworkStream" /> is readable by calling the <see cref="P:System.Net.Sockets.NetworkStream.CanRead" /> property. If you attempt to read from a <see cref="T:System.Net.Sockets.NetworkStream" /> that is not readable, you will get an <see cref="T:System.IO.IOException" />.</para>
          </block>
          <block subset="none" type="note">
            <para>If you receive an <see cref="T:System.IO.IOException" />, check the <see cref="P:System.Exception.InnerException" /> property to determine if it was caused by a <see cref="T:System.Net.Sockets.SocketException" />. If so, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads data from the <see cref="T:System.Net.Sockets.NetworkStream" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes read from the <see cref="T:System.Net.Sockets.NetworkStream" />.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that is the location in memory to store data read from the <see cref="T:System.Net.Sockets.NetworkStream" />. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The location in <paramref name="buffer" /> to begin storing the data to. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to read from the <see cref="T:System.Net.Sockets.NetworkStream" />. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Readable">
      <MemberSignature Language="C#" Value="protected bool Readable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Readable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You must derive from the <see cref="T:System.Net.Sockets.NetworkStream" /> class to use the <see cref="P:System.Net.Sockets.NetworkStream.Readable" /> property. If <see cref="P:System.Net.Sockets.NetworkStream.Readable" /> is true, <see cref="T:System.Net.Sockets.NetworkStream" /> allows calls to the <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> method. You can also determine whether a <see cref="T:System.Net.Sockets.NetworkStream" /> is readable by checking the publicly accessible <see cref="P:System.Net.Sockets.NetworkStream.CanRead" /> property.</para>
          <para>The <see cref="P:System.Net.Sockets.NetworkStream.Readable" /> property is set when the <see cref="T:System.Net.Sockets.NetworkStream" /> is initialized.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> can be read.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the read operation does not complete within the time specified by this property, the read operation throws an <see cref="T:System.IO.IOException" />.</para>
          <block subset="none" type="note">
            <para>This property affects only synchronous reads performed by calling the <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> method. This property does not affect asynchronous reads performed by calling the <see cref="M:System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the amount of time that a read operation blocks waiting for data. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin)" />
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <remarks>
          <block subset="none" type="note">
            <para> The <see cref="T:System.IO.Stream" /> base class uses this method to set the current
      position in the stream. This functionality is not supported in the <see cref="T:System.Net.Sockets.NetworkStream" />
      class.</para>
            <para>This method overrides <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" qualify="true" />.</para>
          </block>
        </remarks>
        <exception cref="T:System.NotSupportedException">Any call to this method.</exception>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the current position of the stream to the given value. This method is not currently supported and always throws a <see cref="T:System.NotSupportedException" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The position in the stream.</para>
        </returns>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />This parameter is not used. </param>
        <param name="origin">
          <attribution license="cc4" from="Microsoft" modified="false" />This parameter is not used. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void SetLength(int64 value)" />
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <block subset="none" type="note">
            <para>The <see cref="T:System.IO.Stream" />
   base class uses this method to set the length of the data available on the
   stream. This functionality is not supported in the <see cref="T:System.Net.Sockets.NetworkStream" /> class.</para>
            <para>This method overrides <see cref="M:System.IO.Stream.SetLength(System.Int64)" qualify="true" />.</para>
          </block>
        </remarks>
        <exception cref="T:System.NotSupportedException">Any call to this method.</exception>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the length of the stream. This method always throws a <see cref="T:System.NotSupportedException" />.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />This parameter is not used. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Socket">
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Socket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Socket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Classes deriving from <see cref="T:System.Net.Sockets.NetworkStream" /> can use this property to get the underlying <see cref="T:System.Net.Sockets.Socket" />. Use the underlying <see cref="T:System.Net.Sockets.Socket" /> returned from the <see cref="P:System.Net.Sockets.NetworkStream.Socket" /> property if you require access beyond that which <see cref="T:System.Net.Sockets.NetworkStream" /> provides.</para>
          <block subset="none" type="note">
            <para>This property is accessible only through this class or a derived class.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the underlying <see cref="T:System.Net.Sockets.Socket" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Call <see cref="M:System.Net.Sockets.NetworkStream.System#IDisposable#Dispose" /> when you are finished using the <see cref="T:System.Net.Sockets.NetworkStream" />. The <see cref="M:System.Net.Sockets.NetworkStream.System#IDisposable#Dispose" /> method leaves the <see cref="T:System.Net.Sockets.NetworkStream" /> in an unusable state. After calling <see cref="M:System.Net.Sockets.NetworkStream.System#IDisposable#Dispose" />, you must release all references to the <see cref="T:System.Net.Sockets.NetworkStream" /> so the garbage collector can reclaim the memory that the <see cref="T:System.Net.Sockets.NetworkStream" /> was occupying. For more information about using the Dispose method, see <format type="text/html"><a href="a17b0066-71c2-4ba4-9822-8e19332fc213">Cleaning Up Unmanaged Resources</a></format> and <format type="text/html"><a href="eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9">Implementing a Dispose Method</a></format>. </para>
          <block subset="none" type="note">
            <para>Always call <see cref="M:System.Net.Sockets.NetworkStream.System#IDisposable#Dispose" /> before you release your last reference to the <see cref="T:System.Net.Sockets.NetworkStream" />. Otherwise, the resources it is using are not freed until the garbage collector calls the <see cref="T:System.Net.Sockets.NetworkStream" /> object's Finalize method. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases all resources used by the <see cref="T:System.Net.Sockets.NetworkStream" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Write(class System.Byte[] buffer, int32 offset, int32 size)" />
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="offset" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="offset" /> &gt; <paramref name="buffer" />.Length. </para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="size" /> &gt; <paramref name="buffer" />.Length - <paramref name="offset" />.</para>
        </exception>
        <exception cref="T:System.IO.IOException">An error occurred while accessing the underlying socket. <para><block subset="none" type="note">This method catches all exceptions thrown by the <see cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" qualify="true" /> method.</block></para></exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> method starts at the specified <paramref name="offset" /> and sends <paramref name="size" /> bytes from the contents of <paramref name="buffer" /> to the network. The <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> method blocks until the requested number of bytes is sent or a <see cref="T:System.Net.Sockets.SocketException" /> is thrown. If you receive a <see cref="T:System.Net.Sockets.SocketException" />, use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code, and refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</para>
          <block subset="none" type="note">
            <para>Check to see if the <see cref="T:System.Net.Sockets.NetworkStream" /> is writable by accessing the <see cref="P:System.Net.Sockets.NetworkStream.CanWrite" /> property. If you attempt to write to a <see cref="T:System.Net.Sockets.NetworkStream" /> that is not writable, you will get an <see cref="T:System.IO.IOException" />. If you receive an <see cref="T:System.IO.IOException" />, check the <see cref="P:System.Exception.InnerException" /> property to determine if it was caused by a <see cref="T:System.Net.Sockets.SocketException" />.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes data to the <see cref="T:System.Net.Sockets.NetworkStream" />.</para>
        </summary>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type <see cref="T:System.Byte" /> that contains the data to write to the <see cref="T:System.Net.Sockets.NetworkStream" />. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The location in <paramref name="buffer" /> from which to start writing data. </param>
        <param name="size">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to write to the <see cref="T:System.Net.Sockets.NetworkStream" />. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Writeable">
      <MemberSignature Language="C#" Value="protected bool Writeable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Writeable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You must derive from the <see cref="T:System.Net.Sockets.NetworkStream" /> class to use the <see cref="P:System.Net.Sockets.NetworkStream.Writeable" /> property. If <see cref="P:System.Net.Sockets.NetworkStream.Writeable" /> is true, <see cref="T:System.Net.Sockets.NetworkStream" /> allows calls to the <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> method. You can also determine whether a <see cref="T:System.Net.Sockets.NetworkStream" /> is writable by checking the publicly accessible <see cref="P:System.Net.Sockets.NetworkStream.CanWrite" /> property.</para>
          <para>The <see cref="P:System.Net.Sockets.NetworkStream.Writeable" /> property is set when the <see cref="T:System.Net.Sockets.NetworkStream" /> is initialized.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.NetworkStream" /> is writable.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the write operation does not complete within the time specified by this property, the write operation throws a <see cref="T:System.IO.IOException" />.</para>
          <block subset="none" type="note">
            <para>This property affects only synchronous write operations performed by calling the <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> method. This property does not affect asynchronous writes performed by calling the <see cref="M:System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the amount of time that a write operation blocks waiting for data. </para>
        </summary>
      </Docs>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>