<?xml version="1.0" encoding="utf-8"?>
<Type Name="CodeTypeDeclaration" FullName="System.CodeDom.CodeTypeDeclaration">
  <TypeSignature Language="C#" Value="public class CodeTypeDeclaration : System.CodeDom.CodeTypeMember" Maintainer="auto" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit CodeTypeDeclaration extends System.CodeDom.CodeTypeMember" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00]</AssemblyPublicKey>
    <AssemblyVersion>1.0.3300.0</AssemblyVersion>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the &lt;link location="node:gtk-sharp/programming/threads"&gt;Gtk# Thread Programming&lt;/link&gt; for details.</ThreadSafetyStatement>
  <Base>
    <BaseTypeName>System.CodeDom.CodeTypeMember</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>
        <see cref="T:System.CodeDom.CodeTypeDeclaration" /> can be used to represent code that declares a class, structure, interface, or enumeration. <see cref="T:System.CodeDom.CodeTypeDeclaration" /> can be used to declare a type that is nested within another type.</para>
      <para>The <see cref="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" /> property specifies the base type or base types of the type being declared. The <see cref="P:System.CodeDom.CodeTypeDeclaration.Members" /> property contains the type members, which can include methods, fields, properties, comments and other types. The <see cref="P:System.CodeDom.CodeTypeDeclaration.TypeAttributes" /> property indicates the <see cref="T:System.Reflection.TypeAttributes" /> values for the type declaration, which indicate the type category of the type. The <see cref="P:System.CodeDom.CodeTypeDeclaration.IsClass" />, <see cref="P:System.CodeDom.CodeTypeDeclaration.IsStruct" />, <see cref="P:System.CodeDom.CodeTypeDeclaration.IsEnum" />, and <see cref="P:System.CodeDom.CodeTypeDeclaration.IsInterface" /> methods indicate whether the type is a class, structure, enumeration, or interface type, respectively.</para>
      <block subset="none" type="note">
        <para>Some programming languages only support the declaration of reference types, or classes. To check a language-specific CodeDOM code generator for support for declaring interfaces, enumerations, or value types, call the <see cref="M:System.CodeDom.Compiler.ICodeGenerator.Supports(System.CodeDom.Compiler.GeneratorSupport)" /> method to test for the appropriate <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> flags. <see cref="F:System.CodeDom.Compiler.GeneratorSupport.DeclareInterfaces" /> indicates support for interfaces, <see cref="F:System.CodeDom.Compiler.GeneratorSupport.DeclareEnums" /> indicates support for enumerations, and <see cref="F:System.CodeDom.Compiler.GeneratorSupport.DeclareValueTypes" /> indicates support for value types such as structures.</para>
      </block>
      <para>You can build a class or a structure implementation in one complete declaration, or spread the implementation across multiple declarations. The <see cref="P:System.CodeDom.CodeTypeDeclaration.IsPartial" /> property indicates whether the type declaration is complete or partial. Not all code generators support partial type declarations, so you should test for this support by calling the <see cref="M:System.CodeDom.Compiler.ICodeGenerator.Supports(System.CodeDom.Compiler.GeneratorSupport)" /> method with the flag <see cref="F:System.CodeDom.Compiler.GeneratorSupport.PartialTypes" />.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Represents a type declaration for a class, structure, interface, or enumeration.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CodeTypeDeclaration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.CodeDom.CodeTypeDeclaration" /> class.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CodeTypeDeclaration (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.CodeDom.CodeTypeDeclaration" /> class with the specified name.</para>
        </summary>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name for the new type. </param>
      </Docs>
    </Member>
    <Member MemberName="BaseTypes">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeReferenceCollection BaseTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeReferenceCollection BaseTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <see cref="T:System.CodeDom.CodeTypeReferenceCollection" /> containing list of types from which this type is derived.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To generate a class in Visual Basic that does not inherit from a base type, but that does implement one or more interfaces, you must include <see cref="T:System.Object" /> as the first item in the <see cref="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" /> collection. </para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 2.0 you do not need the <see cref="T:System.CodeDom.CodeTypeReference" /> for <see cref="T:System.Object" /> if the interface you are implementing already exists and you are referring to it by type. For example, if you are implementing the <see cref="T:System.Collections.ICollection" /> interface and add it to the collection with this statement, ctd.BaseTypes.Add(New CodeTypeReference(typeof(ICollection))), you do not need the preceding ctd.BaseTypes.Add(New CodeTypeReference(GetType(Object))) statement.</para>
          </block>
          <para />
          <para>The following code illustrates the addition of a <see cref="T:System.CodeDom.CodeTypeReference" /> to the collection that refers to <see cref="T:System.Object" />.</para>
          <para>[Visual Basic]</para>
          <code>Dim ctd As New CodeTypeDeclaration("Class1")
ctd.IsClass = True
ctd.BaseTypes.Add(New CodeTypeReference(GetType(Object)))
ctd.BaseTypes.Add(New CodeTypeReference("Interface1"))</code>
          <para>[C#]</para>
          <code>CodeTypeDeclaration ctd = new CodeTypeDeclaration("Class1");
ctd.IsClass = true;
ctd.BaseTypes.Add(new CodeTypeReference(typeof(Object)));
ctd.BaseTypes.Add(new CodeTypeReference("Interface1"));</code>
          <para>The preceding code generates the equivalent of the following Visual Basic code.</para>
          <code>Public Class Class1
Implements Interface1</code>
          <para>However, the Visual Basic code actually generated is the following.</para>
          <code>Public Class Class1
Inherits Object
Implements Interface1</code>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the base types of the type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'bool'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value indicating whether the type is a class or reference type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public bool IsEnum { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'bool'</value>
        <remarks>
          <example>
            <code lang="C#">
		CodeTypeDeclaration colorEnum=new CodeTypeDeclaration("Colors");
		colorEnum.IsEnum=true;
		CodeMemberField memBlue=new CodeMemberField(typeof(int),"BLUE");
		memBlue.InitExpression=new CodeSnippetExpression("2");
		colorEnum.Members.Add(memBlue);
		colorEnum.Members.Add(new CodeMemberField(typeof(int),"Green"));
  </code>
Generates the following code for the C# generator:
<code lang="C#">
    public enum Colors {

        BLUE = 2,

        Green,
    }
</code></example>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value indicating whether the type is an enumeration.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'bool'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value indicating whether the type is an interface.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsPartial">
      <MemberSignature Language="C#" Value="public bool IsPartial { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPartial" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can build a class or structure implementation in one complete declaration, or spread the implementation across multiple declarations. Implementations are commonly supplied in one complete type declaration. In this case, set the type declaration <see cref="P:System.CodeDom.CodeTypeDeclaration.IsPartial" /> property to false, which indicates that the type declaration represents all details for the class or structure implementation.</para>
          <para>A partial type declaration makes it easier to build different portions of a class or structure implementation in different modules of your application. The partial type declarations can be stored in one source file, or spread across multiple source files that are eventually compiled together to form the combined type implementation.</para>
          <para>The C# language supports partial type declarations of classes and structures through the partial keyword. Visual Basic supports partial type declarations of classes and structures with the Partial keyword. Not all code generators support partial type declarations, so you should test for this support by calling the <see cref="M:System.CodeDom.Compiler.ICodeGenerator.Supports(System.CodeDom.Compiler.GeneratorSupport)" /> method with the flag <see cref="F:System.CodeDom.Compiler.GeneratorSupport.PartialTypes" />.</para>
          <block subset="none" type="note">
            <para>Partial type declarations are supported for classes and structures. If you specify a partial type declaration for an enumeration or interface, the generated code produces compiler errors.</para>
          </block>
          <para>When supplying a class or structure implementation across multiple declarations, set the <see cref="P:System.CodeDom.CodeTypeDeclaration.IsPartial" /> property to true for the initial declaration and all supplemental declarations. The initial declaration must fully specify the type signature, including access modifiers, inherited types, and implemented interfaces. The supplementary declarations do not need to re-specify the type signature. A compiler error typically results if you redefine the type signature in a supplementary declaration.</para>
          <para>Visual Studio 2005 uses partial types to separate user-generated code from designer code. In Visual Basic Windows Application projects, the user code is placed in a partial class that is not qualified by the Partial keyword; the designer-provided code appears in the partial class that has the Partial keyword. In C#, both the user code and designer code appear in partial classes identified by the partial keyword.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value indicating whether the type declaration is complete or partial.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsStruct">
      <MemberSignature Language="C#" Value="public bool IsStruct { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStruct" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'bool'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value indicating whether the type is a value type (struct).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Members">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeMemberCollection Members { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeMemberCollection Members" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeMemberCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added: an object of type 'CodeTypeMemberCollection'</value>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the collection of class members for the represented type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PopulateBaseTypes">
      <MemberSignature Language="C#" Value="public event EventHandler PopulateBaseTypes;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PopulateBaseTypes" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when the <see cref="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" /> collection is accessed for the first time.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PopulateMembers">
      <MemberSignature Language="C#" Value="public event EventHandler PopulateMembers;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PopulateMembers" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when the <see cref="P:System.CodeDom.CodeTypeDeclaration.Members" /> collection is accessed for the first time.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="TypeAttributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes TypeAttributes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes TypeAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters>
      </Parameters>
      <Docs>
        <value>To be added: an object of type 'Reflection.TypeAttributes'</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Reflection.TypeAttributes" /> property contains the same type of values used by <see cref="N:System.Reflection" /> when investigating a type at run time. Many of these flags do not correspond to the type declaration syntax for some languages. As a result, only the following flags are significant to <see cref="T:System.CodeDom.CodeTypeDeclaration" /> : <see cref="F:System.Reflection.TypeAttributes.Class" />, <see cref="F:System.Reflection.TypeAttributes.Interface" />, <see cref="F:System.Reflection.TypeAttributes.Abstract" />, <see cref="F:System.Reflection.TypeAttributes.Sealed" />, <see cref="F:System.Reflection.TypeAttributes.Public" />, <see cref="F:System.Reflection.TypeAttributes.NotPublic" />, <see cref="F:System.Reflection.TypeAttributes.NestedPublic" />, and <see cref="F:System.Reflection.TypeAttributes.NestedPrivate" />.</para>
          <block subset="none" type="note">
            <para>Some of the flags such as <see cref="F:System.Reflection.TypeAttributes.Abstract" /> overlap with the meaning of flags in the <see cref="P:System.CodeDom.CodeTypeMember.Attributes" /> property of <see cref="T:System.CodeDom.CodeTypeDeclaration" /> that is inherited from <see cref="T:System.CodeDom.CodeTypeMember" />. The <see cref="P:System.CodeDom.CodeTypeMember.Attributes" /> property is a side effect of the <see cref="T:System.CodeDom.CodeTypeDeclaration" /> class inheriting from <see cref="T:System.CodeDom.CodeTypeMember" /> so that classes can be nested. The flags in the <see cref="P:System.CodeDom.CodeTypeDeclaration.TypeAttributes" /> property should be used instead of the flags in the <see cref="P:System.CodeDom.CodeTypeMember.Attributes" /> property.</para>
          </block>
          <block subset="none" type="note">
            <para>The pattern for setting the visibility flags (flags containing the words Public or Nested) is to mask out all visibility flags using the <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> and then set the desired visibility flag. For example, the C# code statement to identify the <see cref="T:System.CodeDom.CodeTypeDeclaration" /> (named cd) as an internal class is cd.TypeAttributes = (cd.TypeAttributes &amp; ~TypeAttributes.VisibilityMask) | TypeAttributes.NotPublic;.  The code to set the same value in Visual Basic is cd.TypeAttributes = (cd.TypeAttributes And (TypeAttributes.VisibilityMask Xor -1)) Or TypeAttributes.NotPublic. Setting the <see cref="P:System.CodeDom.CodeTypeDeclaration.TypeAttributes" /> property directly to a visibility flag (cd.TypeAttributes = TypeAttributes.NotPublic;) erases all other flags that might be set. </para>
            <para />
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the attributes of the type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="TypeParameters">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeParameterCollection TypeParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeParameterCollection TypeParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A generic type declaration contains one or more unspecified types known as type parameters. A type parameter name stands for the type within the body of the generic declaration. For example, the generic declaration for the <see cref="T:System.Collections.Generic.List`1" /> class contains the type parameter <paramref name="T" />.</para>
          <para>For more information on generics, see <format type="text/html"><a href="afdd5477-6770-4686-8297-f58a4d749daf">Generics in the .NET Framework Class Library</a></format>. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type parameters for the type declaration.</para>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>