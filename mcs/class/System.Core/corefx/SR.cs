//
// This file was generated by resx2sr tool
//

partial class SR
{
	public const string ReducibleMustOverrideReduce = "reducible nodes must override Expression.Reduce()";
	public const string MustReduceToDifferent = "node cannot reduce to itself or null";
	public const string ReducedNotCompatible = "cannot assign from the reduced node type to the original node type";
	public const string SetterHasNoParams = "Setter must have parameters.";
	public const string PropertyCannotHaveRefType = "Property cannot have a managed pointer type.";
	public const string IndexesOfSetGetMustMatch = "Indexing parameters of getter and setter must match.";
	public const string AccessorsCannotHaveVarArgs = "Accessor method should not have VarArgs.";
	public const string AccessorsCannotHaveByRefArgs = "Accessor indexes cannot be passed ByRef.";
	public const string BoundsCannotBeLessThanOne = "Bounds count cannot be less than 1";
	public const string TypeMustNotBeByRef = "Type must not be ByRef";
	public const string TypeMustNotBePointer = "Type must not be a pointer type";
	public const string TypeDoesNotHaveConstructorForTheSignature = "Type doesn't have constructor with a given signature";
	public const string SetterMustBeVoid = "Setter should have void type.";
	public const string PropertyTypeMustMatchGetter = "Property type must match the value type of getter";
	public const string PropertyTypeMustMatchSetter = "Property type must match the value type of setter";
	public const string BothAccessorsMustBeStatic = "Both accessors must be static.";
	public const string OnlyStaticFieldsHaveNullInstance = "Static field requires null instance, non-static field requires non-null instance.";
	public const string OnlyStaticPropertiesHaveNullInstance = "Static property requires null instance, non-static property requires non-null instance.";
	public const string OnlyStaticMethodsHaveNullInstance = "Static method requires null instance, non-static method requires non-null instance.";
	public const string PropertyTypeCannotBeVoid = "Property cannot have a void type.";
	public const string InvalidUnboxType = "Can only unbox from an object or interface type to a value type.";
	public const string ExpressionMustBeWriteable = "Expression must be writeable";
	public const string ArgumentMustNotHaveValueType = "Argument must not have a value type.";
	public const string MustBeReducible = "must be reducible node";
	public const string AllTestValuesMustHaveSameType = "All test values must have the same type.";
	public const string AllCaseBodiesMustHaveSameType = "All case bodies and the default body must have the same type.";
	public const string DefaultBodyMustBeSupplied = "Default body must be supplied if case bodies are not System.Void.";
	public const string LabelMustBeVoidOrHaveExpression = "Label type must be System.Void if an expression is not supplied";
	public const string LabelTypeMustBeVoid = "Type must be System.Void for this label argument";
	public const string QuotedExpressionMustBeLambda = "Quoted expression must be a lambda";
	public const string VariableMustNotBeByRef = "Variable '{0}' uses unsupported type '{1}'. Reference types are not supported for variables.";
	public const string DuplicateVariable = "Found duplicate parameter '{0}'. Each ParameterExpression in the list must be a unique object.";
	public const string StartEndMustBeOrdered = "Start and End must be well ordered";
	public const string FaultCannotHaveCatchOrFinally = "fault cannot be used with catch or finally clauses";
	public const string TryMustHaveCatchFinallyOrFault = "try must have at least one catch, finally, or fault clause";
	public const string BodyOfCatchMustHaveSameTypeAsBodyOfTry = "Body of catch must have the same type as body of try.";
	public const string ExtensionNodeMustOverrideProperty = "Extension node must override the property {0}.";
	public const string UserDefinedOperatorMustBeStatic = "User-defined operator method '{0}' must be static.";
	public const string UserDefinedOperatorMustNotBeVoid = "User-defined operator method '{0}' must not be void.";
	public const string CoercionOperatorNotDefined = "No coercion operator is defined between types '{0}' and '{1}'.";
	public const string UnaryOperatorNotDefined = "The unary operator {0} is not defined for the type '{1}'.";
	public const string BinaryOperatorNotDefined = "The binary operator {0} is not defined for the types '{1}' and '{2}'.";
	public const string ReferenceEqualityNotDefined = "Reference equality is not defined for the types '{0}' and '{1}'.";
	public const string OperandTypesDoNotMatchParameters = "The operands for operator '{0}' do not match the parameters of method '{1}'.";
	public const string OverloadOperatorTypeDoesNotMatchConversionType = "The return type of overload method for operator '{0}' does not match the parameter type of conversion method '{1}'.";
	public const string ConversionIsNotSupportedForArithmeticTypes = "Conversion is not supported for arithmetic types without operator overloading.";
	public const string ArgumentMustBeArray = "Argument must be array";
	public const string ArgumentMustBeBoolean = "Argument must be boolean";
	public const string EqualityMustReturnBoolean = "The user-defined equality method '{0}' must return a boolean value.";
	public const string ArgumentMustBeFieldInfoOrPropertyInfo = "Argument must be either a FieldInfo or PropertyInfo";
	public const string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod = "Argument must be either a FieldInfo, PropertyInfo or MethodInfo";
	public const string ArgumentMustBeInstanceMember = "Argument must be an instance member";
	public const string ArgumentMustBeInteger = "Argument must be of an integer type";
	public const string ArgumentMustBeArrayIndexType = "Argument for array index must be of type Int32";
	public const string ArgumentMustBeSingleDimensionalArrayType = "Argument must be single-dimensional, zero-based array type";
	public const string ArgumentTypesMustMatch = "Argument types do not match";
	public const string CannotAutoInitializeValueTypeElementThroughProperty = "Cannot auto initialize elements of value type through property '{0}', use assignment instead";
	public const string CannotAutoInitializeValueTypeMemberThroughProperty = "Cannot auto initialize members of value type through property '{0}', use assignment instead";
	public const string IncorrectTypeForTypeAs = "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither";
	public const string CoalesceUsedOnNonNullType = "Coalesce used with type that cannot be null";
	public const string ExpressionTypeCannotInitializeArrayType = "An expression of type '{0}' cannot be used to initialize an array of type '{1}'";
	public const string ArgumentTypeDoesNotMatchMember = " Argument type '{0}' does not match the corresponding member type '{1}'";
	public const string ArgumentMemberNotDeclOnType = " The member '{0}' is not declared on type '{1}' being created";
	public const string ExpressionTypeDoesNotMatchReturn = "Expression of type '{0}' cannot be used for return type '{1}'";
	public const string ExpressionTypeDoesNotMatchAssignment = "Expression of type '{0}' cannot be used for assignment to type '{1}'";
	public const string ExpressionTypeDoesNotMatchLabel = "Expression of type '{0}' cannot be used for label of type '{1}'";
	public const string ExpressionTypeNotInvocable = "Expression of type '{0}' cannot be invoked";
	public const string FieldNotDefinedForType = "Field '{0}' is not defined for type '{1}'";
	public const string InstanceFieldNotDefinedForType = "Instance field '{0}' is not defined for type '{1}'";
	public const string FieldInfoNotDefinedForType = "Field '{0}.{1}' is not defined for type '{2}'";
	public const string IncorrectNumberOfIndexes = "Incorrect number of indexes";
	public const string IncorrectNumberOfLambdaDeclarationParameters = "Incorrect number of parameters supplied for lambda declaration";
	public const string IncorrectNumberOfMembersForGivenConstructor = " Incorrect number of members for constructor";
	public const string IncorrectNumberOfArgumentsForMembers = "Incorrect number of arguments for the given members ";
	public const string LambdaTypeMustBeDerivedFromSystemDelegate = "Lambda type parameter must be derived from System.MulticastDelegate";
	public const string MemberNotFieldOrProperty = "Member '{0}' not field or property";
	public const string MethodContainsGenericParameters = "Method {0} contains generic parameters";
	public const string MethodIsGeneric = "Method {0} is a generic method definition";
	public const string MethodNotPropertyAccessor = "The method '{0}.{1}' is not a property accessor";
	public const string PropertyDoesNotHaveGetter = "The property '{0}' has no 'get' accessor";
	public const string PropertyDoesNotHaveSetter = "The property '{0}' has no 'set' accessor";
	public const string PropertyDoesNotHaveAccessor = "The property '{0}' has no 'get' or 'set' accessors";
	public const string NotAMemberOfType = "'{0}' is not a member of type '{1}'";
	public const string NotAMemberOfAnyType = "'{0}' is not a member of any type";
	public const string ExpressionNotSupportedForType = "The expression '{0}' is not supported for type '{1}'";
	public const string UnsupportedExpressionType = "The expression type '{0}' is not supported";
	public const string ParameterExpressionNotValidAsDelegate = "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'";
	public const string PropertyNotDefinedForType = "Property '{0}' is not defined for type '{1}'";
	public const string InstancePropertyNotDefinedForType = "Instance property '{0}' is not defined for type '{1}'";
	public const string InstancePropertyWithoutParameterNotDefinedForType = "Instance property '{0}' that takes no argument is not defined for type '{1}'";
	public const string InstancePropertyWithSpecifiedParametersNotDefinedForType = "Instance property '{0}{1}' is not defined for type '{2}'";
	public const string InstanceAndMethodTypeMismatch = "Method '{0}' declared on type '{1}' cannot be called with instance of type '{2}'";
	public const string TypeContainsGenericParameters = "Type {0} contains generic parameters";
	public const string TypeIsGeneric = "Type {0} is a generic type definition";
	public const string TypeMissingDefaultConstructor = "Type '{0}' does not have a default constructor";
	public const string ElementInitializerMethodNotAdd = "Element initializer method must be named 'Add'";
	public const string ElementInitializerMethodNoRefOutParam = "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter";
	public const string ElementInitializerMethodWithZeroArgs = "Element initializer method must have at least 1 parameter";
	public const string ElementInitializerMethodStatic = "Element initializer method must be an instance method";
	public const string TypeNotIEnumerable = "Type '{0}' is not IEnumerable";
	public const string UnexpectedCoalesceOperator = "Unexpected coalesce operator.";
	public const string InvalidCast = "Cannot cast from type '{0}' to type '{1}";
	public const string UnhandledBinary = "Unhandled binary: {0}";
	public const string UnhandledBinding = "Unhandled binding ";
	public const string UnhandledBindingType = "Unhandled Binding Type: {0}";
	public const string UnhandledConvert = "Unhandled convert: {0}";
	public const string UnhandledUnary = "Unhandled unary: {0}";
	public const string UnknownBindingType = "Unknown binding type";
	public const string UserDefinedOpMustHaveConsistentTypes = "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types.";
	public const string UserDefinedOpMustHaveValidReturnType = "The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type.";
	public const string LogicalOperatorMustHaveBooleanOperators = "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators.";
	public const string MethodWithArgsDoesNotExistOnType = "No method '{0}' on type '{1}' is compatible with the supplied arguments.";
	public const string GenericMethodWithArgsDoesNotExistOnType = "No generic method '{0}' on type '{1}' is compatible with the supplied type arguments and arguments. No type arguments should be provided if the method is non-generic. ";
	public const string MethodWithMoreThanOneMatch = "More than one method '{0}' on type '{1}' is compatible with the supplied arguments.";
	public const string PropertyWithMoreThanOneMatch = "More than one property '{0}' on type '{1}' is compatible with the supplied arguments.";
	public const string IncorrectNumberOfTypeArgsForFunc = "An incorrect number of type arguments were specified for the declaration of a Func type.";
	public const string IncorrectNumberOfTypeArgsForAction = "An incorrect number of type arguments were specified for the declaration of an Action type.";
	public const string ArgumentCannotBeOfTypeVoid = "Argument type cannot be System.Void.";
	public const string OutOfRange = "{0} must be greater than or equal to {1}";
	public const string LabelTargetAlreadyDefined = "Cannot redefine label '{0}' in an inner block.";
	public const string LabelTargetUndefined = "Cannot jump to undefined label '{0}'.";
	public const string ControlCannotLeaveFinally = "Control cannot leave a finally block.";
	public const string ControlCannotLeaveFilterTest = "Control cannot leave a filter test.";
	public const string AmbiguousJump = "Cannot jump to ambiguous label '{0}'.";
	public const string ControlCannotEnterTry = "Control cannot enter a try block.";
	public const string ControlCannotEnterExpression = "Control cannot enter an expression--only statements can be jumped into.";
	public const string NonLocalJumpWithValue = "Cannot jump to non-local label '{0}' with a value. Only jumps to labels defined in outer blocks can pass values.";
	public const string ExtensionNotReduced = "Extension should have been reduced.";
	public const string CannotCompileConstant = "CompileToMethod cannot compile constant '{0}' because it is a non-trivial value, such as a live object. Instead, create an expression tree that can construct this value.";
	public const string CannotCompileDynamic = "Dynamic expressions are not supported by CompileToMethod. Instead, create an expression tree that uses System.Runtime.CompilerServices.CallSite.";
	public const string InvalidLvalue = "Invalid lvalue for assignment: {0}.";
	public const string UnknownLiftType = "unknown lift type: '{0}'.";
	public const string UndefinedVariable = "variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined";
	public const string CannotCloseOverByRef = "Cannot close over byref parameter '{0}' referenced in lambda '{1}'";
	public const string UnexpectedVarArgsCall = "Unexpected VarArgs call to method '{0}'";
	public const string RethrowRequiresCatch = "Rethrow statement is valid only inside a Catch block.";
	public const string TryNotAllowedInFilter = "Try expression is not allowed inside a filter body.";
	public const string MustRewriteToSameNode = "When called from '{0}', rewriting a node of type '{1}' must return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type.";
	public const string MustRewriteChildToSameType = "Rewriting child expression from type '{0}' to type '{1}' is not allowed, because it would change the meaning of the operation. If this is intentional, override '{2}' and change it to allow this rewrite.";
	public const string MustRewriteWithoutMethod = "Rewritten expression calls operator method '{0}', but the original node had no operator method. If this is intentional, override '{1}' and change it to allow this rewrite.";
	public const string InvalidNullValue = "The value null is not of type '{0}' and cannot be used in this collection.";
	public const string InvalidObjectType = "The value '{0}' is not of type '{1}' and cannot be used in this collection.";
	public const string TryNotSupportedForMethodsWithRefArgs = "TryExpression is not supported as an argument to method '{0}' because it has an argument with by-ref type. Construct the tree so the TryExpression is not nested inside of this expression.";
	public const string TryNotSupportedForValueTypeInstances = "TryExpression is not supported as a child expression when accessing a member on type '{0}' because it is a value type. Construct the tree so the TryExpression is not nested inside of this expression.";
	public const string EnumerationIsDone = "Enumeration has either not started or has already finished.";
	public const string TestValueTypeDoesNotMatchComparisonMethodParameter = "Test value of type '{0}' cannot be used for the comparison method parameter of type '{1}'";
	public const string SwitchValueTypeDoesNotMatchComparisonMethodParameter = "Switch value of type '{0}' cannot be used for the comparison method parameter of type '{1}'";
	public const string PdbGeneratorNeedsExpressionCompiler = "DebugInfoGenerator created by CreatePdbGenerator can only be used with LambdaExpression.CompileToMethod.";
	public const string InvalidArgumentValue = "Invalid argument value";
	public const string NonEmptyCollectionRequired = "Non-empty collection required";
	public const string CollectionModifiedWhileEnumerating = "Collection was modified; enumeration operation may not execute.";
	public const string ExpressionMustBeReadable = "Expression must be readable";
	public const string ExpressionTypeDoesNotMatchMethodParameter = "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'";
	public const string ExpressionTypeDoesNotMatchParameter = "Expression of type '{0}' cannot be used for parameter of type '{1}'";
	public const string ExpressionTypeDoesNotMatchConstructorParameter = "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'";
	public const string IncorrectNumberOfMethodCallArguments = "Incorrect number of arguments supplied for call to method '{0}'";
	public const string IncorrectNumberOfLambdaArguments = "Incorrect number of arguments supplied for lambda invocation";
	public const string IncorrectNumberOfConstructorArguments = "Incorrect number of arguments for constructor";
	public const string OperatorNotImplementedForType = "The operator '{0}' is not implemented for type '{1}'";
	public const string NonStaticConstructorRequired = "The constructor should not be static";
	public const string NonAbstractConstructorRequired = "Can't compile a NewExpression with a constructor declared on an abstract class";
	public const string FirstArgumentMustBeCallSite = "First argument of delegate must be CallSite";
	public const string NoOrInvalidRuleProduced = "No or Invalid rule produced";
	public const string TypeMustBeDerivedFromSystemDelegate = "Type must be derived from System.Delegate";
	public const string TypeParameterIsNotDelegate = "Type parameter is {0}. Expected a delegate.";
	public const string ArgumentTypeCannotBeVoid = "Argument type cannot be void";
	public const string ArgCntMustBeGreaterThanNameCnt = "Argument count must be greater than number of named arguments.";
	public const string BinderNotCompatibleWithCallSite = "The result type '{0}' of the binder '{1}' is not compatible with the result type '{2}' expected by the call site.";
	public const string BindingCannotBeNull = "Bind cannot return null.";
	public const string DynamicBinderResultNotAssignable = "The result type '{0}' of the dynamic binding produced by binder '{1}' is not compatible with the result type '{2}' expected by the call site.";
	public const string DynamicBindingNeedsRestrictions = "The result of the dynamic binding produced by the object with type '{0}' for the binder '{1}' needs at least one restriction.";
	public const string DynamicObjectResultNotAssignable = "The result type '{0}' of the dynamic binding produced by the object with type '{1}' for the binder '{2}' is not compatible with the result type '{3}' expected by the call site.";
	public const string InvalidMetaObjectCreated = "An IDynamicMetaObjectProvider {0} created an invalid DynamicMetaObject instance.";
	public const string AmbiguousMatchInExpandoObject = "More than one key matching '{0}' was found in the ExpandoObject.";
	public const string CollectionReadOnly = "Collection is read-only.";
	public const string KeyDoesNotExistInExpando = "The specified key '{0}' does not exist in the ExpandoObject.";
	public const string SameKeyExistsInExpando = "An element with the same key '{0}' already exists in the ExpandoObject.";
	public const string EmptyEnumerable = "Enumeration yielded no results";
	public const string MoreThanOneElement = "Sequence contains more than one element";
	public const string MoreThanOneMatch = "Sequence contains more than one matching element";
	public const string NoElements = "Sequence contains no elements";
	public const string NoMatch = "Sequence contains no matching element";
	public const string ParallelPartitionable_NullReturn = "The return value must not be null.";
	public const string ParallelPartitionable_IncorretElementCount = "The returned array's length must equal the number of partitions requested.";
	public const string ParallelPartitionable_NullElement = "Elements returned must not be null.";
	public const string PLINQ_CommonEnumerator_Current_NotStarted = "Enumeration has not started. MoveNext must be called to initiate enumeration.";
	public const string PLINQ_ExternalCancellationRequested = "The query has been canceled via the token supplied to WithCancellation.";
	public const string PLINQ_DisposeRequested = "The query enumerator has been disposed.";
	public const string ParallelQuery_DuplicateTaskScheduler = "The WithTaskScheduler operator may be used at most once in a query.";
	public const string ParallelQuery_DuplicateDOP = "The WithDegreeOfParallelism operator may be used at most once in a query.";
	public const string ParallelQuery_DuplicateExecutionMode = "The WithExecutionMode operator may be used at most once in a query.";
	public const string PartitionerQueryOperator_NullPartitionList = "Partitioner returned null instead of a list of partitions.";
	public const string PartitionerQueryOperator_WrongNumberOfPartitions = "Partitioner returned a wrong number of partitions.";
	public const string PartitionerQueryOperator_NullPartition = "Partitioner returned a null partition.";
	public const string ParallelQuery_DuplicateWithCancellation = "The WithCancellation operator may by used at most once in a query.";
	public const string ParallelQuery_DuplicateMergeOptions = "The WithMergeOptions operator may be used at most once in a query.";
	public const string PLINQ_EnumerationPreviouslyFailed = "The query enumerator previously threw an exception.";
	public const string ParallelQuery_PartitionerNotOrderable = "AsOrdered may not be used with a partitioner that is not orderable.";
	public const string ParallelQuery_InvalidAsOrderedCall = "AsOrdered may only be called on the result of AsParallel, ParallelEnumerable.Range, or ParallelEnumerable.Repeat.";
	public const string ParallelQuery_InvalidNonGenericAsOrderedCall = "Non-generic AsOrdered may only be called on the result of the non-generic AsParallel.";
	public const string ParallelEnumerable_BinaryOpMustUseAsParallel = "The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.";
	public const string ParallelEnumerable_WithQueryExecutionMode_InvalidMode = "The executionMode argument contains an invalid value.";
	public const string ParallelEnumerable_WithMergeOptions_InvalidOptions = "The mergeOptions argument contains an invalid value.";
	public const string ArgumentNotIEnumerableGeneric = "{0} is not IEnumerable<>";
	public const string ArgumentNotValid = "Argument {0} is not valid";
	public const string NoMethodOnType = "There is no method '{0}' on type '{1}'";
	public const string NoMethodOnTypeMatchingArguments = "There is no method '{0}' on type '{1}' that matches the specified arguments";
	public const string EnumeratingNullEnumerableExpression = "Cannot enumerate a query created from a null IEnumerable<>";
}
