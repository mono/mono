//
// This file was generated by resx2sr tool
//

partial class SR
{
	public const string ReducibleMustOverrideReduce = "reducible nodes must override Expression.Reduce()";
	public const string MustReduceToDifferent = "node cannot reduce to itself or null";
	public const string ReducedNotCompatible = "cannot assign from the reduced node type to the original node type";
	public const string SetterHasNoParams = "Setter must have parameters.";
	public const string PropertyCannotHaveRefType = "Property cannot have a managed pointer type.";
	public const string IndexesOfSetGetMustMatch = "Indexing parameters of getter and setter must match.";
	public const string AccessorsCannotHaveVarArgs = "Accessor method should not have VarArgs.";
	public const string AccessorsCannotHaveByRefArgs = "Accessor indexes cannot be passed ByRef.";
	public const string BoundsCannotBeLessThanOne = "Bounds count cannot be less than 1";
	public const string TypeMustNotBeByRef = "Type must not be ByRef";
	public const string TypeMustNotBePointer = "Type must not be a pointer type";
	public const string SetterMustBeVoid = "Setter should have void type.";
	public const string PropertyTypeMustMatchGetter = "Property type must match the value type of getter";
	public const string PropertyTypeMustMatchSetter = "Property type must match the value type of setter";
	public const string BothAccessorsMustBeStatic = "Both accessors must be static.";
	public const string OnlyStaticFieldsHaveNullInstance = "Static field requires null instance, non-static field requires non-null instance.";
	public const string OnlyStaticPropertiesHaveNullInstance = "Static property requires null instance, non-static property requires non-null instance.";
	public const string OnlyStaticMethodsHaveNullInstance = "Static method requires null instance, non-static method requires non-null instance.";
	public const string PropertyTypeCannotBeVoid = "Property cannot have a void type.";
	public const string InvalidUnboxType = "Can only unbox from an object or interface type to a value type.";
	public const string ExpressionMustBeWriteable = "Expression must be writeable";
	public const string ArgumentMustNotHaveValueType = "Argument must not have a value type.";
	public const string MustBeReducible = "must be reducible node";
	public const string AllTestValuesMustHaveSameType = "All test values must have the same type.";
	public const string AllCaseBodiesMustHaveSameType = "All case bodies and the default body must have the same type.";
	public const string DefaultBodyMustBeSupplied = "Default body must be supplied if case bodies are not System.Void.";
	public const string LabelMustBeVoidOrHaveExpression = "Label type must be System.Void if an expression is not supplied";
	public const string LabelTypeMustBeVoid = "Type must be System.Void for this label argument";
	public const string QuotedExpressionMustBeLambda = "Quoted expression must be a lambda";
	public const string VariableMustNotBeByRef = "Variable '{0}' uses unsupported type '{1}'. Reference types are not supported for variables.";
	public const string DuplicateVariable = "Found duplicate parameter '{0}'. Each ParameterExpression in the list must be a unique object.";
	public const string StartEndMustBeOrdered = "Start and End must be well ordered";
	public const string FaultCannotHaveCatchOrFinally = "fault cannot be used with catch or finally clauses";
	public const string TryMustHaveCatchFinallyOrFault = "try must have at least one catch, finally, or fault clause";
	public const string BodyOfCatchMustHaveSameTypeAsBodyOfTry = "Body of catch must have the same type as body of try.";
	public const string ExtensionNodeMustOverrideProperty = "Extension node must override the property {0}.";
	public const string UserDefinedOperatorMustBeStatic = "User-defined operator method '{0}' must be static.";
	public const string UserDefinedOperatorMustNotBeVoid = "User-defined operator method '{0}' must not be void.";
	public const string CoercionOperatorNotDefined = "No coercion operator is defined between types '{0}' and '{1}'.";
	public const string UnaryOperatorNotDefined = "The unary operator {0} is not defined for the type '{1}'.";
	public const string BinaryOperatorNotDefined = "The binary operator {0} is not defined for the types '{1}' and '{2}'.";
	public const string ReferenceEqualityNotDefined = "Reference equality is not defined for the types '{0}' and '{1}'.";
	public const string OperandTypesDoNotMatchParameters = "The operands for operator '{0}' do not match the parameters of method '{1}'.";
	public const string OverloadOperatorTypeDoesNotMatchConversionType = "The return type of overload method for operator '{0}' does not match the parameter type of conversion method '{1}'.";
	public const string ConversionIsNotSupportedForArithmeticTypes = "Conversion is not supported for arithmetic types without operator overloading.";
	public const string ArgumentMustBeArray = "Argument must be array";
	public const string ArgumentMustBeBoolean = "Argument must be boolean";
	public const string EqualityMustReturnBoolean = "The user-defined equality method '{0}' must return a boolean value.";
	public const string ArgumentMustBeFieldInfoOrPropertyInfo = "Argument must be either a FieldInfo or PropertyInfo";
	public const string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod = "Argument must be either a FieldInfo, PropertyInfo or MethodInfo";
	public const string ArgumentMustBeInstanceMember = "Argument must be an instance member";
	public const string ArgumentMustBeInteger = "Argument must be of an integer type";
	public const string ArgumentMustBeArrayIndexType = "Argument for array index must be of type Int32";
	public const string ArgumentMustBeSingleDimensionalArrayType = "Argument must be single-dimensional, zero-based array type";
	public const string ArgumentTypesMustMatch = "Argument types do not match";
	public const string CannotAutoInitializeValueTypeElementThroughProperty = "Cannot auto initialize elements of value type through property '{0}', use assignment instead";
	public const string CannotAutoInitializeValueTypeMemberThroughProperty = "Cannot auto initialize members of value type through property '{0}', use assignment instead";
	public const string IncorrectTypeForTypeAs = "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither";
	public const string CoalesceUsedOnNonNullType = "Coalesce used with type that cannot be null";
	public const string ExpressionTypeCannotInitializeArrayType = "An expression of type '{0}' cannot be used to initialize an array of type '{1}'";
	public const string ArgumentTypeDoesNotMatchMember = " Argument type '{0}' does not match the corresponding member type '{1}'";
	public const string ArgumentMemberNotDeclOnType = " The member '{0}' is not declared on type '{1}' being created";
	public const string ExpressionTypeDoesNotMatchReturn = "Expression of type '{0}' cannot be used for return type '{1}'";
	public const string ExpressionTypeDoesNotMatchAssignment = "Expression of type '{0}' cannot be used for assignment to type '{1}'";
	public const string ExpressionTypeDoesNotMatchLabel = "Expression of type '{0}' cannot be used for label of type '{1}'";
	public const string ExpressionTypeNotInvocable = "Expression of type '{0}' cannot be invoked";
	public const string FieldNotDefinedForType = "Field '{0}' is not defined for type '{1}'";
	public const string InstanceFieldNotDefinedForType = "Instance field '{0}' is not defined for type '{1}'";
	public const string FieldInfoNotDefinedForType = "Field '{0}.{1}' is not defined for type '{2}'";
	public const string IncorrectNumberOfIndexes = "Incorrect number of indexes";
	public const string IncorrectNumberOfLambdaDeclarationParameters = "Incorrect number of parameters supplied for lambda declaration";
	public const string IncorrectNumberOfMembersForGivenConstructor = " Incorrect number of members for constructor";
	public const string IncorrectNumberOfArgumentsForMembers = "Incorrect number of arguments for the given members ";
	public const string LambdaTypeMustBeDerivedFromSystemDelegate = "Lambda type parameter must be derived from System.MulticastDelegate";
	public const string MemberNotFieldOrProperty = "Member '{0}' not field or property";
	public const string MethodContainsGenericParameters = "Method {0} contains generic parameters";
	public const string MethodIsGeneric = "Method {0} is a generic method definition";
	public const string MethodNotPropertyAccessor = "The method '{0}.{1}' is not a property accessor";
	public const string PropertyDoesNotHaveGetter = "The property '{0}' has no 'get' accessor";
	public const string PropertyDoesNotHaveSetter = "The property '{0}' has no 'set' accessor";
	public const string PropertyDoesNotHaveAccessor = "The property '{0}' has no 'get' or 'set' accessors";
	public const string NotAMemberOfType = "'{0}' is not a member of type '{1}'";
	public const string NotAMemberOfAnyType = "'{0}' is not a member of any type";
	public const string UnsupportedExpressionType = "The expression type '{0}' is not supported";
	public const string ParameterExpressionNotValidAsDelegate = "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'";
	public const string PropertyNotDefinedForType = "Property '{0}' is not defined for type '{1}'";
	public const string InstancePropertyNotDefinedForType = "Instance property '{0}' is not defined for type '{1}'";
	public const string InstancePropertyWithoutParameterNotDefinedForType = "Instance property '{0}' that takes no argument is not defined for type '{1}'";
	public const string InstancePropertyWithSpecifiedParametersNotDefinedForType = "Instance property '{0}{1}' is not defined for type '{2}'";
	public const string InstanceAndMethodTypeMismatch = "Method '{0}' declared on type '{1}' cannot be called with instance of type '{2}'";
	public const string TypeContainsGenericParameters = "Type {0} contains generic parameters";
	public const string TypeIsGeneric = "Type {0} is a generic type definition";
	public const string TypeMissingDefaultConstructor = "Type '{0}' does not have a default constructor";
	public const string ElementInitializerMethodNotAdd = "Element initializer method must be named 'Add'";
	public const string ElementInitializerMethodNoRefOutParam = "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter";
	public const string ElementInitializerMethodWithZeroArgs = "Element initializer method must have at least 1 parameter";
	public const string ElementInitializerMethodStatic = "Element initializer method must be an instance method";
	public const string TypeNotIEnumerable = "Type '{0}' is not IEnumerable";
	public const string UnhandledBinary = "Unhandled binary: {0}";
	public const string UnhandledBinding = "Unhandled binding ";
	public const string UnhandledBindingType = "Unhandled Binding Type: {0}";
	public const string UnhandledUnary = "Unhandled unary: {0}";
	public const string UnknownBindingType = "Unknown binding type";
	public const string UserDefinedOpMustHaveConsistentTypes = "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types.";
	public const string UserDefinedOpMustHaveValidReturnType = "The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type.";
	public const string LogicalOperatorMustHaveBooleanOperators = "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators.";
	public const string MethodWithArgsDoesNotExistOnType = "No method '{0}' on type '{1}' is compatible with the supplied arguments.";
	public const string GenericMethodWithArgsDoesNotExistOnType = "No generic method '{0}' on type '{1}' is compatible with the supplied type arguments and arguments. No type arguments should be provided if the method is non-generic. ";
	public const string MethodWithMoreThanOneMatch = "More than one method '{0}' on type '{1}' is compatible with the supplied arguments.";
	public const string PropertyWithMoreThanOneMatch = "More than one property '{0}' on type '{1}' is compatible with the supplied arguments.";
	public const string IncorrectNumberOfTypeArgsForFunc = "An incorrect number of type arguments were specified for the declaration of a Func type.";
	public const string IncorrectNumberOfTypeArgsForAction = "An incorrect number of type arguments were specified for the declaration of an Action type.";
	public const string ArgumentCannotBeOfTypeVoid = "Argument type cannot be System.Void.";
	public const string OutOfRange = "{0} must be greater than or equal to {1}";
	public const string LabelTargetAlreadyDefined = "Cannot redefine label '{0}' in an inner block.";
	public const string LabelTargetUndefined = "Cannot jump to undefined label '{0}'.";
	public const string ControlCannotLeaveFinally = "Control cannot leave a finally block.";
	public const string ControlCannotLeaveFilterTest = "Control cannot leave a filter test.";
	public const string AmbiguousJump = "Cannot jump to ambiguous label '{0}'.";
	public const string ControlCannotEnterTry = "Control cannot enter a try block.";
	public const string ControlCannotEnterExpression = "Control cannot enter an expression--only statements can be jumped into.";
	public const string NonLocalJumpWithValue = "Cannot jump to non-local label '{0}' with a value. Only jumps to labels defined in outer blocks can pass values.";
	public const string CannotCompileConstant = "CompileToMethod cannot compile constant '{0}' because it is a non-trivial value, such as a live object. Instead, create an expression tree that can construct this value.";
	public const string CannotCompileDynamic = "Dynamic expressions are not supported by CompileToMethod. Instead, create an expression tree that uses System.Runtime.CompilerServices.CallSite.";
	public const string InvalidLvalue = "Invalid lvalue for assignment: {0}.";
	public const string UndefinedVariable = "variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined";
	public const string CannotCloseOverByRef = "Cannot close over byref parameter '{0}' referenced in lambda '{1}'";
	public const string UnexpectedVarArgsCall = "Unexpected VarArgs call to method '{0}'";
	public const string RethrowRequiresCatch = "Rethrow statement is valid only inside a Catch block.";
	public const string TryNotAllowedInFilter = "Try expression is not allowed inside a filter body.";
	public const string MustRewriteToSameNode = "When called from '{0}', rewriting a node of type '{1}' must return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type.";
	public const string MustRewriteChildToSameType = "Rewriting child expression from type '{0}' to type '{1}' is not allowed, because it would change the meaning of the operation. If this is intentional, override '{2}' and change it to allow this rewrite.";
	public const string MustRewriteWithoutMethod = "Rewritten expression calls operator method '{0}', but the original node had no operator method. If this is intentional, override '{1}' and change it to allow this rewrite.";
	public const string InvalidNullValue = "The value null is not of type '{0}' and cannot be used in this collection.";
	public const string InvalidObjectType = "The value '{0}' is not of type '{1}' and cannot be used in this collection.";
	public const string TryNotSupportedForMethodsWithRefArgs = "TryExpression is not supported as an argument to method '{0}' because it has an argument with by-ref type. Construct the tree so the TryExpression is not nested inside of this expression.";
	public const string TryNotSupportedForValueTypeInstances = "TryExpression is not supported as a child expression when accessing a member on type '{0}' because it is a value type. Construct the tree so the TryExpression is not nested inside of this expression.";
	public const string EnumerationIsDone = "Enumeration has either not started or has already finished.";
	public const string TestValueTypeDoesNotMatchComparisonMethodParameter = "Test value of type '{0}' cannot be used for the comparison method parameter of type '{1}'";
	public const string SwitchValueTypeDoesNotMatchComparisonMethodParameter = "Switch value of type '{0}' cannot be used for the comparison method parameter of type '{1}'";
	public const string PdbGeneratorNeedsExpressionCompiler = "DebugInfoGenerator created by CreatePdbGenerator can only be used with LambdaExpression.CompileToMethod.";
	public const string InvalidArgumentValue = "Invalid argument value";
	public const string NonEmptyCollectionRequired = "Non-empty collection required";
	public const string CollectionModifiedWhileEnumerating = "Collection was modified; enumeration operation may not execute.";
	public const string ExpressionMustBeReadable = "Expression must be readable";
	public const string ExpressionTypeDoesNotMatchMethodParameter = "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'";
	public const string ExpressionTypeDoesNotMatchParameter = "Expression of type '{0}' cannot be used for parameter of type '{1}'";
	public const string ExpressionTypeDoesNotMatchConstructorParameter = "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'";
	public const string IncorrectNumberOfMethodCallArguments = "Incorrect number of arguments supplied for call to method '{0}'";
	public const string IncorrectNumberOfLambdaArguments = "Incorrect number of arguments supplied for lambda invocation";
	public const string IncorrectNumberOfConstructorArguments = "Incorrect number of arguments for constructor";
	public const string NonStaticConstructorRequired = "The constructor should not be static";
	public const string NonAbstractConstructorRequired = "Can't compile a NewExpression with a constructor declared on an abstract class";
	public const string FirstArgumentMustBeCallSite = "First argument of delegate must be CallSite";
	public const string NoOrInvalidRuleProduced = "No or Invalid rule produced";
	public const string TypeMustBeDerivedFromSystemDelegate = "Type must be derived from System.Delegate";
	public const string TypeParameterIsNotDelegate = "Type parameter is {0}. Expected a delegate.";
	public const string ArgumentTypeCannotBeVoid = "Argument type cannot be void";
	public const string ArgCntMustBeGreaterThanNameCnt = "Argument count must be greater than number of named arguments.";
	public const string BinderNotCompatibleWithCallSite = "The result type '{0}' of the binder '{1}' is not compatible with the result type '{2}' expected by the call site.";
	public const string BindingCannotBeNull = "Bind cannot return null.";
	public const string DynamicBinderResultNotAssignable = "The result type '{0}' of the dynamic binding produced by binder '{1}' is not compatible with the result type '{2}' expected by the call site.";
	public const string DynamicBindingNeedsRestrictions = "The result of the dynamic binding produced by the object with type '{0}' for the binder '{1}' needs at least one restriction.";
	public const string DynamicObjectResultNotAssignable = "The result type '{0}' of the dynamic binding produced by the object with type '{1}' for the binder '{2}' is not compatible with the result type '{3}' expected by the call site.";
	public const string InvalidMetaObjectCreated = "An IDynamicMetaObjectProvider {0} created an invalid DynamicMetaObject instance.";
	public const string AmbiguousMatchInExpandoObject = "More than one key matching '{0}' was found in the ExpandoObject.";
	public const string CollectionReadOnly = "Collection is read-only.";
	public const string KeyDoesNotExistInExpando = "The specified key '{0}' does not exist in the ExpandoObject.";
	public const string SameKeyExistsInExpando = "An element with the same key '{0}' already exists in the ExpandoObject.";
	public const string Arg_KeyNotFoundWithKey = "The given key '{0}' was not present in the dictionary.";
	public const string EmptyEnumerable = "Enumeration yielded no results";
	public const string MoreThanOneElement = "Sequence contains more than one element";
	public const string MoreThanOneMatch = "Sequence contains more than one matching element";
	public const string NoElements = "Sequence contains no elements";
	public const string NoMatch = "Sequence contains no matching element";
	public const string ParallelPartitionable_NullReturn = "The return value must not be null.";
	public const string ParallelPartitionable_IncorretElementCount = "The returned array's length must equal the number of partitions requested.";
	public const string ParallelPartitionable_NullElement = "Elements returned must not be null.";
	public const string PLINQ_CommonEnumerator_Current_NotStarted = "Enumeration has not started. MoveNext must be called to initiate enumeration.";
	public const string PLINQ_ExternalCancellationRequested = "The query has been canceled via the token supplied to WithCancellation.";
	public const string PLINQ_DisposeRequested = "The query enumerator has been disposed.";
	public const string ParallelQuery_DuplicateTaskScheduler = "The WithTaskScheduler operator may be used at most once in a query.";
	public const string ParallelQuery_DuplicateDOP = "The WithDegreeOfParallelism operator may be used at most once in a query.";
	public const string ParallelQuery_DuplicateExecutionMode = "The WithExecutionMode operator may be used at most once in a query.";
	public const string PartitionerQueryOperator_NullPartitionList = "Partitioner returned null instead of a list of partitions.";
	public const string PartitionerQueryOperator_WrongNumberOfPartitions = "Partitioner returned a wrong number of partitions.";
	public const string PartitionerQueryOperator_NullPartition = "Partitioner returned a null partition.";
	public const string ParallelQuery_DuplicateWithCancellation = "The WithCancellation operator may by used at most once in a query.";
	public const string ParallelQuery_DuplicateMergeOptions = "The WithMergeOptions operator may be used at most once in a query.";
	public const string PLINQ_EnumerationPreviouslyFailed = "The query enumerator previously threw an exception.";
	public const string ParallelQuery_PartitionerNotOrderable = "AsOrdered may not be used with a partitioner that is not orderable.";
	public const string ParallelQuery_InvalidAsOrderedCall = "AsOrdered may only be called on the result of AsParallel, ParallelEnumerable.Range, or ParallelEnumerable.Repeat.";
	public const string ParallelQuery_InvalidNonGenericAsOrderedCall = "Non-generic AsOrdered may only be called on the result of the non-generic AsParallel.";
	public const string ParallelEnumerable_BinaryOpMustUseAsParallel = "The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.";
	public const string ParallelEnumerable_WithQueryExecutionMode_InvalidMode = "The executionMode argument contains an invalid value.";
	public const string ParallelEnumerable_WithMergeOptions_InvalidOptions = "The mergeOptions argument contains an invalid value.";
	public const string ArgumentNotIEnumerableGeneric = "{0} is not IEnumerable<>";
	public const string ArgumentNotValid = "Argument {0} is not valid";
	public const string NoMethodOnType = "There is no method '{0}' on type '{1}'";
	public const string NoMethodOnTypeMatchingArguments = "There is no method '{0}' on type '{1}' that matches the specified arguments";
	public const string EnumeratingNullEnumerableExpression = "Cannot enumerate a query created from a null IEnumerable<>";
	public const string ArgumentOutOfRange_NeedNonNegNum = "Non negative number is required.";
	public const string ArgumentOutOfRange_NeedValidPipeAccessRights = "Invalid PipeAccessRights value.";
	public const string Argument_InvalidOffLen = "Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.";
	public const string Argument_NeedNonemptyPipeName = "pipeName cannot be an empty string.";
	public const string Argument_NonContainerInvalidAnyFlag = "This flag may not be set on a pipe.";
	public const string Argument_EmptyServerName = "serverName cannot be an empty string.  Use \\\\\\\".\\\\\\\" for current machine.";
	public const string Argument_InvalidHandle = "Invalid handle.";
	public const string ArgumentNull_Buffer = "Buffer cannot be null.";
	public const string ArgumentNull_ServerName = "serverName cannot be null. Use \\\".\\\" for current machine.";
	public const string ArgumentOutOfRange_AnonymousReserved = "The pipeName \\\"anonymous\\\" is reserved.";
	public const string ArgumentOutOfRange_TransmissionModeByteOrMsg = "For named pipes, transmission mode can be TransmissionMode.Byte or PipeTransmissionMode.Message. For anonymous pipes, transmission mode can be TransmissionMode.Byte.";
	public const string ArgumentOutOfRange_DirectionModeInOutOrInOut = "For named pipes, the pipe direction can be PipeDirection.In, PipeDirection.Out or PipeDirection.InOut. For anonymous pipes, the pipe direction can be PipeDirection.In or PipeDirection.Out.";
	public const string ArgumentOutOfRange_ImpersonationInvalid = "TokenImpersonationLevel.None, TokenImpersonationLevel.Anonymous, TokenImpersonationLevel.Identification, TokenImpersonationLevel.Impersonation or TokenImpersonationLevel.Delegation required.";
	public const string ArgumentOutOfRange_OptionsInvalid = "options contains an invalid flag.";
	public const string ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable = "HandleInheritability.None or HandleInheritability.Inheritable required.";
	public const string ArgumentOutOfRange_InvalidTimeout = "Timeout must be non-negative or equal to -1 (Timeout.Infinite)";
	public const string ArgumentOutOfRange_MaxNumServerInstances = "maxNumberOfServerInstances must either be a value between 1 and 254, or NamedPipeServerStream.MaxAllowedServerInstances (to obtain the maximum number allowed by system resources).";
	public const string ArgumentOutOfRange_NeedPosNum = "Positive number required.";
	public const string InvalidOperation_PipeNotYetConnected = "Pipe hasn't been connected yet.";
	public const string InvalidOperation_PipeDisconnected = "Pipe is in a disconnected state.";
	public const string InvalidOperation_PipeHandleNotSet = "Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?";
	public const string InvalidOperation_PipeNotAsync = "Pipe is not opened in asynchronous mode.";
	public const string InvalidOperation_PipeReadModeNotMessage = "ReadMode is not of PipeTransmissionMode.Message.";
	public const string InvalidOperation_PipeAlreadyConnected = "Already in a connected state.";
	public const string InvalidOperation_PipeAlreadyDisconnected = "Already in a disconnected state.";
	public const string IO_EOF_ReadBeyondEOF = "Unable to read beyond the end of the stream.";
	public const string IO_FileNotFound = "Unable to find the specified file.";
	public const string IO_FileNotFound_FileName = "Could not find file '{0}'.";
	public const string IO_AlreadyExists_Name = "Cannot create \\\"{0}\\\" because a file or directory with the same name already exists.";
	public const string IO_FileExists_Name = "The file '{0}' already exists.";
	public const string IO_IO_PipeBroken = "Pipe is broken.";
	public const string IO_OperationAborted = "IO operation was aborted unexpectedly.";
	public const string IO_SharingViolation_File = "The process cannot access the file '{0}' because it is being used by another process.";
	public const string IO_SharingViolation_NoFileName = "The process cannot access the file because it is being used by another process.";
	public const string IO_PipeBroken = "Pipe is broken.";
	public const string IO_InvalidPipeHandle = "Invalid pipe handle.";
	public const string IO_PathNotFound_Path = "Could not find a part of the path '{0}'.";
	public const string IO_PathNotFound_NoPathName = "Could not find a part of the path.";
	public const string IO_PathTooLong = "The specified file name or path is too long, or a component of the specified path is too long.";
	public const string NotSupported_UnreadableStream = "Stream does not support reading.";
	public const string NotSupported_UnseekableStream = "Stream does not support seeking.";
	public const string NotSupported_UnwritableStream = "Stream does not support writing.";
	public const string NotSupported_AnonymousPipeUnidirectional = "Anonymous pipes can only be in one direction.";
	public const string NotSupported_AnonymousPipeMessagesNotSupported = "Anonymous pipes do not support PipeTransmissionMode.Message ReadMode.";
	public const string ObjectDisposed_PipeClosed = "Cannot access a closed pipe.";
	public const string UnauthorizedAccess_IODenied_Path = "Access to the path '{0}' is denied.";
	public const string UnauthorizedAccess_IODenied_NoPathName = "Access to the path is denied.";
	public const string ArgumentOutOfRange_FileLengthTooBig = "Specified file length was too large for the file system.";
	public const string PlatformNotSupported_MessageTransmissionMode = "Message transmission mode is not supported on this platform.";
	public const string PlatformNotSupported_RemotePipes = "Access to remote named pipes is not supported on this platform.";
	public const string PlatformNotSupported_InvalidPipeNameChars = "The name of a pipe on this platform must be a valid file name or a valid absolute path to a file name.";
	public const string ObjectDisposed_StreamClosed = "Cannot access a closed Stream.";
	public const string PlatformNotSupported_OperatingSystemError = "The operating system returned error '{0}' indicating that the operation is not supported.";
	public const string IO_AllPipeInstancesAreBusy = "All pipe instances are busy.";
	public const string IO_PathTooLong_Path = "The path '{0}' is too long, or a component of the specified path is too long.";
	public const string UnauthorizedAccess_NotOwnedByCurrentUser = "Could not connect to the pipe because it was not owned by the current user.";
	public const string UnauthorizedAccess_ClientIsNotCurrentUser = "Client connection (user id {0}) was refused because it was not owned by the current user (id {1}).";
	public const string net_invalidversion = "This protocol version is not supported.";
	public const string net_noseek = "This stream does not support seek operations.";
	public const string net_invasync = "Cannot block a call on this socket while an earlier asynchronous call is in progress.";
	public const string net_io_timeout_use_gt_zero = "Timeout can be only be set to 'System.Threading.Timeout.Infinite' or a value > 0.";
	public const string net_notconnected = "The operation is not allowed on non-connected sockets.";
	public const string net_notstream = "The operation is not allowed on non-stream oriented sockets.";
	public const string net_stopped = "Not listening. You must call the Start() method before calling this method.";
	public const string net_udpconnected = "Cannot send packets to an arbitrary host while connected.";
	public const string net_readonlystream = "The stream does not support writing.";
	public const string net_writeonlystream = "The stream does not support reading.";
	public const string net_InvalidAddressFamily = "The AddressFamily {0} is not valid for the {1} end point, use {2} instead.";
	public const string net_InvalidEndPointAddressFamily = "The supplied EndPoint of AddressFamily {0} is not valid for this Socket, use {1} instead.";
	public const string net_InvalidSocketAddressSize = "The supplied {0} is an invalid size for the {1} end point.";
	public const string net_invalidAddressList = "None of the discovered or specified addresses match the socket address family.";
	public const string net_completed_result = "This operation cannot be performed on a completed asynchronous result object.";
	public const string net_protocol_invalid_family = "'{0}' Client can only accept InterNetwork or InterNetworkV6 addresses.";
	public const string net_protocol_invalid_multicast_family = "Multicast family is not the same as the family of the '{0}' Client.";
	public const string net_sockets_zerolist = "The parameter {0} must contain one or more elements.";
	public const string net_sockets_blocking = "The operation is not allowed on a non-blocking Socket.";
	public const string net_sockets_useblocking = "Use the Blocking property to change the status of the Socket.";
	public const string net_sockets_select = "The operation is not allowed on objects of type {0}. Use only objects of type {1}.";
	public const string net_sockets_toolarge_select = "The {0} list contains too many items; a maximum of {1} is allowed.";
	public const string net_sockets_empty_select = "All lists are either null or empty.";
	public const string net_sockets_mustbind = "You must call the Bind method before performing this operation.";
	public const string net_sockets_mustlisten = "You must call the Listen method before performing this operation.";
	public const string net_sockets_mustnotlisten = "You may not perform this operation after calling the Listen method.";
	public const string net_sockets_mustnotbebound = "The socket must not be bound or connected.";
	public const string net_sockets_namedmustnotbebound = "{0}: The socket must not be bound or connected.";
	public const string net_sockets_invalid_ipaddress_length = "The number of specified IP addresses has to be greater than 0.";
	public const string net_sockets_invalid_optionValue = "The specified value is not a valid '{0}'.";
	public const string net_sockets_invalid_optionValue_all = "The specified value is not valid.";
	public const string net_sockets_invalid_dnsendpoint = "The parameter {0} must not be of type DnsEndPoint.";
	public const string net_sockets_disconnectedConnect = "Once the socket has been disconnected, you can only reconnect again asynchronously, and only to a different EndPoint.  BeginConnect must be called on a thread that won't exit until the operation has been completed.";
	public const string net_sockets_disconnectedAccept = "Once the socket has been disconnected, you can only accept again asynchronously.  BeginAccept must be called on a thread that won't exit until the operation has been completed.";
	public const string net_tcplistener_mustbestopped = "The TcpListener must not be listening before performing this operation.";
	public const string net_socketopinprogress = "An asynchronous socket operation is already in progress using this SocketAsyncEventArgs instance.";
	public const string net_buffercounttoosmall = "The Buffer space specified by the Count property is insufficient for the AcceptAsync method.";
	public const string net_multibuffernotsupported = "Multiple buffers cannot be used with this method.";
	public const string net_ambiguousbuffers = "Buffer and BufferList properties cannot both be non-null.";
	public const string net_io_writefailure = "Unable to write data to the transport connection: {0}.";
	public const string net_io_readfailure = "Unable to read data from the transport connection: {0}.";
	public const string net_io_invalidasyncresult = "The IAsyncResult object was not returned from the corresponding asynchronous method on this class.";
	public const string net_io_invalidendcall = "{0} can only be called once for each asynchronous operation.";
	public const string net_value_cannot_be_negative = "The specified value cannot be negative.";
	public const string ArgumentOutOfRange_Bounds_Lower_Upper = "Argument must be between {0} and {1}.";
	public const string net_sockets_connect_multiconnect_notsupported = "Sockets on this platform are invalid for use after a failed connection attempt.";
	public const string net_sockets_dualmode_receivefrom_notsupported = "This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.";
	public const string net_sockets_accept_receive_notsupported = "This platform does not support receiving data with Socket.AcceptAsync.  Instead, make a separate call to Socket.ReceiveAsync.";
	public const string net_sockets_duplicateandclose_notsupported = "This platform does not support Socket.DuplicateAndClose.  Instead, create a new socket.";
	public const string net_sockets_transmitfileoptions_notsupported = "This platform does not support TransmitFileOptions other than TransmitFileOptions.UseDefaultWorkerThread.";
	public const string ArgumentOutOfRange_PathLengthInvalid = "The path '{0}' is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and {1} characters, inclusive.";
	public const string net_io_readwritefailure = "Unable to transfer data on the transport connection: {0}.";
	public const string PlatformNotSupported_AcceptSocket = "Accepting into an existing Socket is not supported on this platform.";
	public const string PlatformNotSupported_IOControl = "Socket.IOControl handles Windows-specific control codes and is not supported on this platform.";
	public const string PlatformNotSupported_IPProtectionLevel = "IP protection level cannot be controlled on this platform.";
	public const string InvalidOperation_BufferNotExplicitArray = "This operation may only be performed when the buffer was set using the SetBuffer overload that accepts an array.";
	public const string InvalidOperation_IncorrectToken = "The result of the operation was already consumed and may not be used again.";
	public const string InvalidOperation_MultipleContinuations = "Another continuation was already registered.";
	public const string Argument_InvalidOidValue = "The OID value was invalid.";
	public const string Argument_InvalidValue = "Value was invalid.";
	public const string Arg_CryptographyException = "Error occurred during a cryptographic operation.";
	public const string Cryptography_ArgECDHKeySizeMismatch = "The keys from both parties must be the same size to generate a secret agreement.";
	public const string Cryptography_ArgECDHRequiresECDHKey = "Keys used with the ECDiffieHellmanCng algorithm must have an algorithm group of ECDiffieHellman.";
	public const string Cryptography_TlsRequiresLabelAndSeed = "The TLS key derivation function requires both the label and seed properties to be set.";
	public const string Cryptography_TlsRequires64ByteSeed = "The TLS key derivation function requires a seed value of exactly 64 bytes.";
	public const string Cryptography_BadHashSize_ForAlgorithm = "The provided value of {0} bytes does not match the expected size of {1} bytes for the algorithm ({2}).";
	public const string Cryptography_Config_EncodedOIDError = "Encoded OID length is too large (greater than 0x7f bytes).";
	public const string Cryptography_CSP_NoPrivateKey = "Object contains only the public half of a key pair. A private key must also be provided.";
	public const string Cryptography_Der_Invalid_Encoding = "ASN1 corrupted data.";
	public const string Cryptography_DSA_KeyGenNotSupported = "DSA keys can be imported, but new key generation is not supported on this platform.";
	public const string Cryptography_Encryption_MessageTooLong = "The message exceeds the maximum allowable length for the chosen options ({0}).";
	public const string Cryptography_ECXmlSerializationFormatRequired = "XML serialization of an elliptic curve key requires using an overload which specifies the XML format to be used.";
	public const string Cryptography_ECC_NamedCurvesOnly = "Only named curves are supported on this platform.";
	public const string Cryptography_HashAlgorithmNameNullOrEmpty = "The hash algorithm name cannot be null or empty.";
	public const string Cryptography_InvalidOID = "Object identifier (OID) is unknown.";
	public const string Cryptography_CurveNotSupported = "The specified curve '{0}' or its parameters are not valid for this platform.";
	public const string Cryptography_InvalidCurveOid = "The specified Oid is not valid. The Oid.FriendlyName or Oid.Value property must be set.";
	public const string Cryptography_InvalidCurveKeyParameters = "The specified key parameters are not valid. Q.X and Q.Y are required fields. Q.X, Q.Y must be the same length. If D is specified it must be the same length as Q.X and Q.Y for named curves or the same length as Order for explicit curves.";
	public const string Cryptography_InvalidDsaParameters_MissingFields = "The specified DSA parameters are not valid; P, Q, G and Y are all required.";
	public const string Cryptography_InvalidDsaParameters_MismatchedPGY = "The specified DSA parameters are not valid; P, G and Y must be the same length (the key size).";
	public const string Cryptography_InvalidDsaParameters_MismatchedQX = "The specified DSA parameters are not valid; Q and X (if present) must be the same length.";
	public const string Cryptography_InvalidDsaParameters_MismatchedPJ = "The specified DSA parameters are not valid; J (if present) must be shorter than P.";
	public const string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey = "The specified DSA parameters are not valid; Seed, if present, must be 20 bytes long for keys shorter than 1024 bits.";
	public const string Cryptography_InvalidDsaParameters_QRestriction_ShortKey = "The specified DSA parameters are not valid; Q must be 20 bytes long for keys shorter than 1024 bits.";
	public const string Cryptography_InvalidDsaParameters_QRestriction_LargeKey = "The specified DSA parameters are not valid; Q's length must be one of 20, 32 or 64 bytes.";
	public const string Cryptography_InvalidECCharacteristic2Curve = "The specified Characteristic2 curve parameters are not valid. Polynomial, A, B, G.X, G.Y, and Order are required. A, B, G.X, G.Y must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed.";
	public const string Cryptography_InvalidECPrimeCurve = "The specified prime curve parameters are not valid. Prime, A, B, G.X, G.Y and Order are required and must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed.";
	public const string Cryptography_InvalidECNamedCurve = "The specified named curve parameters are not valid. Only the Oid parameter must be set.";
	public const string Cryptography_InvalidKeySize = "Specified key is not a valid size for this algorithm.";
	public const string Cryptography_InvalidKey_SemiWeak = "Specified key is a known semi-weak key for '{0}' and cannot be used.";
	public const string Cryptography_InvalidKey_Weak = "Specified key is a known weak key for '{0}' and cannot be used.";
	public const string Cryptography_InvalidIVSize = "Specified initialization vector (IV) does not match the block size for this algorithm.";
	public const string Cryptography_InvalidOperation = "This operation is not supported for this class.";
	public const string Cryptography_InvalidPadding = "Padding is invalid and cannot be removed.";
	public const string Cryptography_InvalidRsaParameters = "The specified RSA parameters are not valid; both Exponent and Modulus are required fields.";
	public const string Cryptography_InvalidPaddingMode = "Specified padding mode is not valid for this algorithm.";
	public const string Cryptography_Invalid_IA5String = "The string contains a character not in the 7 bit ASCII character set.";
	public const string Cryptography_KeyTooSmall = "The key is too small for the requested operation.";
	public const string Cryptography_MissingIV = "The cipher mode specified requires that an initialization vector (IV) be used.";
	public const string Cryptography_MissingKey = "No asymmetric key object has been associated with this formatter object.";
	public const string Cryptography_MissingOID = "Required object identifier (OID) cannot be found.";
	public const string Cryptography_MustTransformWholeBlock = "TransformBlock may only process bytes in block sized increments.";
	public const string Cryptography_NotValidPrivateKey = "Key is not a valid private key.";
	public const string Cryptography_NotValidPublicOrPrivateKey = "Key is not a valid public or private key.";
	public const string Cryptography_OAEP_Decryption_Failed = "Error occurred while decoding OAEP padding.";
	public const string Cryptography_OpenInvalidHandle = "Cannot open an invalid handle.";
	public const string Cryptography_PartialBlock = "The input data is not a complete block.";
	public const string Cryptography_PasswordDerivedBytes_FewBytesSalt = "Salt is not at least eight bytes.";
	public const string Cryptography_RC2_EKS40 = "EffectiveKeySize value must be at least 40 bits.";
	public const string Cryptography_RC2_EKSKS = "KeySize value must be at least as large as the EffectiveKeySize value.";
	public const string Cryptography_RC2_EKSKS2 = "EffectiveKeySize must be the same as KeySize in this implementation.";
	public const string Cryptography_Rijndael_BlockSize = "BlockSize must be 128 in this implementation.";
	public const string Cryptography_RSA_DecryptWrongSize = "The length of the data to decrypt is not valid for the size of this key.";
	public const string Cryptography_SignHash_WrongSize = "The provided hash value is not the expected size for the specified hash algorithm.";
	public const string Cryptography_TransformBeyondEndOfBuffer = "Attempt to transform beyond end of buffer.";
	public const string Cryptography_CipherModeNotSupported = "The specified CipherMode '{0}' is not supported.";
	public const string Cryptography_UnknownHashAlgorithm = "'{0}' is not a known hash algorithm.";
	public const string Cryptography_UnknownPaddingMode = "Unknown padding mode used.";
	public const string Cryptography_UnexpectedTransformTruncation = "CNG provider unexpectedly terminated encryption or decryption prematurely.";
	public const string Cryptography_Unmapped_System_Typed_Error = "The system cryptographic library returned error '{0}' of type '{1}'";
	public const string Cryptography_UnsupportedPaddingMode = "The specified PaddingMode is not supported.";
	public const string NotSupported_Method = "Method not supported.";
	public const string NotSupported_SubclassOverride = "Method not supported. Derived class must override.";
	public const string Cryptography_AlgorithmTypesMustBeVisible = "Algorithms added to CryptoConfig must be accessable from outside their assembly.";
	public const string Cryptography_AddNullOrEmptyName = "CryptoConfig cannot add a mapping for a null or empty name.";
	public const string Argument_Invalid_SafeHandleInvalidOrClosed = "The method cannot be called with an invalid or closed SafeHandle.";
	public const string Cryptography_ArgExpectedECDiffieHellmanCngPublicKey = "DeriveKeyMaterial requires an ECDiffieHellmanCngPublicKey.";
	public const string Cryptography_ArgDSARequiresDSAKey = "Keys used with the DSACng algorithm must have an algorithm group of DSA.";
	public const string Cryptography_ArgECDsaRequiresECDsaKey = "Keys used with the ECDsaCng algorithm must have an algorithm group of ECDsa.";
	public const string Cryptography_ArgRSARequiresRSAKey = "Keys used with the RSACng algorithm must have an algorithm group of RSA.";
	public const string Cryptography_CngKeyWrongAlgorithm = "This key is for algorithm '{0}'. Expected '{1}'.";
	public const string Cryptography_InvalidAlgorithmGroup = "The algorithm group '{0}' is invalid.";
	public const string Cryptography_InvalidAlgorithmName = "The algorithm name '{0}' is invalid.";
	public const string Cryptography_InvalidCipherMode = "Specified cipher mode is not valid for this algorithm.";
	public const string Cryptography_InvalidKeyBlobFormat = "The key blob format '{0}' is invalid.";
	public const string Cryptography_InvalidProviderName = "The provider name '{0}' is invalid.";
	public const string Cryptography_KeyBlobParsingError = "Key Blob not in expected format.";
	public const string Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag = "The CNG key handle being opened was detected to be ephemeral, but the EphemeralKey open option was not specified.";
	public const string Cryptography_WeakKey = "Specified key is a known weak key for this algorithm and cannot be used.";
	public const string PlatformNotSupported_CryptographyCng = "Windows Cryptography Next Generation (CNG) is not supported on this platform.";
	public const string CountdownEvent_Increment_AlreadyZero = "The event is already signaled and cannot be incremented.";
	public const string CountdownEvent_Increment_AlreadyMax = "The increment operation would cause the CurrentCount to overflow.";
	public const string CountdownEvent_Decrement_BelowZero = "Invalid attempt made to decrement the event's count below zero.";
	public const string Common_OperationCanceled = "The operation was canceled.";
	public const string Barrier_Dispose = "The barrier has been disposed.";
	public const string Barrier_SignalAndWait_InvalidOperation_ZeroTotal = "The barrier has no registered participants.";
	public const string Barrier_SignalAndWait_ArgumentOutOfRange = "The specified timeout must represent a value between -1 and Int32.MaxValue, inclusive.";
	public const string Barrier_RemoveParticipants_InvalidOperation = "The participantCount argument is greater than the number of participants that haven't yet arrived at the barrier in this phase.";
	public const string Barrier_RemoveParticipants_ArgumentOutOfRange = "The participantCount argument must be less than or equal the number of participants.";
	public const string Barrier_RemoveParticipants_NonPositive_ArgumentOutOfRange = "The participantCount argument must be a positive value.";
	public const string Barrier_InvalidOperation_CalledFromPHA = "This method may not be called from within the postPhaseAction.";
	public const string Barrier_AddParticipants_NonPositive_ArgumentOutOfRange = "The participantCount argument must be a positive value.";
	public const string Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded = "The number of threads using the barrier exceeded the total number of registered participants.";
	public const string BarrierPostPhaseException = "The postPhaseAction failed with an exception.";
	public const string Barrier_ctor_ArgumentOutOfRange = "The participantCount argument must be non-negative and less than or equal to 32767.";
	public const string Barrier_AddParticipants_Overflow_ArgumentOutOfRange = "Adding participantCount participants would result in the number of participants exceeding the maximum number allowed.";
	public const string SynchronizationLockException_IncorrectDispose = "The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock.";
	public const string SynchronizationLockException_MisMatchedWrite = "The write lock is being released without being held.";
	public const string LockRecursionException_UpgradeAfterReadNotAllowed = "Upgradeable lock may not be acquired with read lock held.";
	public const string LockRecursionException_UpgradeAfterWriteNotAllowed = "Upgradeable lock may not be acquired with write lock held in this mode. Acquiring Upgradeable lock gives the ability to read along with an option to upgrade to a writer.";
	public const string SynchronizationLockException_MisMatchedUpgrade = "The upgradeable lock is being released without being held.";
	public const string SynchronizationLockException_MisMatchedRead = "The read lock is being released without being held.";
	public const string LockRecursionException_WriteAfterReadNotAllowed = "Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock.";
	public const string LockRecursionException_RecursiveWriteNotAllowed = "Recursive write lock acquisitions not allowed in this mode.";
	public const string LockRecursionException_ReadAfterWriteNotAllowed = "A read lock may not be acquired with the write lock held in this mode.";
	public const string LockRecursionException_RecursiveUpgradeNotAllowed = "Recursive upgradeable lock acquisitions not allowed in this mode.";
	public const string LockRecursionException_RecursiveReadNotAllowed = "Recursive read lock acquisitions not allowed in this mode.";
	public const string Overflow_UInt16 = "Value was either too large or too small for a UInt16.";
	public const string ReaderWriterLock_Timeout = "The operation has timed out. {0}";
	public const string ArgumentOutOfRange_TimeoutMilliseconds = "Timeout value in milliseconds must be nonnegative and less than or equal to Int32.MaxValue, or -1 for an infinite timeout.";
	public const string ReaderWriterLock_NotOwner = "Attempt to release a lock that is not owned by the calling thread. {0}";
	public const string ExceptionFromHResult = "(Exception from HRESULT: 0x{0:X})";
	public const string ReaderWriterLock_InvalidLockCookie = "The specified lock cookie is invalid for this operation. {0}";
	public const string ReaderWriterLock_RestoreLockWithOwnedLocks = "ReaderWriterLock.RestoreLock was called without releasing all locks acquired since the call to ReleaseLock.";
	public const string HostExecutionContextManager_InvalidOperation_NotNewCaptureContext = "Cannot apply a context that has been marshaled across AppDomains, that was not acquired through a Capture operation or that has already been the argument to a Set call.";
	public const string HostExecutionContextManager_InvalidOperation_CannotOverrideSetWithoutRevert = "Must override both HostExecutionContextManager.SetHostExecutionContext and HostExecutionContextManager.Revert.";
	public const string HostExecutionContextManager_InvalidOperation_CannotUseSwitcherOtherThread = "Undo operation must be performed on the thread where the corresponding context was Set.";
	public const string Arg_NonZeroLowerBound = "The lower bound of target array must be zero.";
	public const string Arg_WrongType = "The value '{0}' is not of type '{1}' and cannot be used in this generic collection.";
	public const string Arg_ArrayPlusOffTooSmall = "Destination array is not long enough to copy all the items in the collection. Check array index and length.";
	public const string ArgumentOutOfRange_SmallCapacity = "capacity was less than the current size.";
	public const string Argument_AddingDuplicate = "An item with the same key has already been added. Key: {0}";
	public const string InvalidOperation_ConcurrentOperationsNotSupported = "Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.";
	public const string InvalidOperation_EmptyQueue = "Queue empty.";
	public const string InvalidOperation_EnumOpCantHappen = "Enumeration has either not started or has already finished.";
	public const string InvalidOperation_EnumFailedVersion = "Collection was modified; enumeration operation may not execute.";
	public const string InvalidOperation_EmptyStack = "Stack empty.";
	public const string InvalidOperation_EnumNotStarted = "Enumeration has not started. Call MoveNext.";
	public const string InvalidOperation_EnumEnded = "Enumeration already finished.";
	public const string NotSupported_KeyCollectionSet = "Mutating a key collection derived from a dictionary is not allowed.";
	public const string NotSupported_ValueCollectionSet = "Mutating a value collection derived from a dictionary is not allowed.";
	public const string Arg_ArrayLengthsDiffer = "Array lengths must be the same.";
	public const string Arg_BitArrayTypeUnsupported = "Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[].";
	public const string Arg_HSCapacityOverflow = "HashSet capacity is too big.";
	public const string Arg_HTCapacityOverflow = "Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.";
	public const string Arg_InsufficientSpace = "Insufficient space in the target location to copy the information.";
	public const string Arg_RankMultiDimNotSupported = "Only single dimensional arrays are supported for the requested action.";
	public const string Argument_ArrayTooLarge = "The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.";
	public const string Argument_InvalidArrayType = "Target array type is not compatible with the type of items in the collection.";
	public const string ArgumentOutOfRange_BiggerThanCollection = "Must be less than or equal to the size of the collection.";
	public const string ArgumentOutOfRange_Index = "Index was out of range. Must be non-negative and less than the size of the collection.";
	public const string ExternalLinkedListNode = "The LinkedList node does not belong to current LinkedList.";
	public const string LinkedListEmpty = "The LinkedList is empty.";
	public const string LinkedListNodeIsAttached = "The LinkedList node already belongs to a LinkedList.";
	public const string NotSupported_SortedListNestedWrite = "This operation is not supported on SortedList nested types because they require modifying the original SortedList.";
	public const string SortedSet_LowerValueGreaterThanUpperValue = "Must be less than or equal to upperValue.";
	public const string Serialization_InvalidOnDeser = "OnDeserialization method was called while the object was not being deserialized.";
	public const string Serialization_MismatchedCount = "The serialized Count information doesn't match the number of items.";
	public const string Serialization_MissingKeys = "The keys for this dictionary are missing.";
	public const string Serialization_MissingValues = "The values for this dictionary are missing.";
	public const string Argument_MapNameEmptyString = "Map name cannot be an empty string.";
	public const string Argument_EmptyFile = "A positive capacity must be specified for a Memory Mapped File backed by an empty file.";
	public const string Argument_NewMMFWriteAccessNotAllowed = "MemoryMappedFileAccess.Write is not permitted when creating new memory mapped files. Use MemoryMappedFileAccess.ReadWrite instead.";
	public const string Argument_ReadAccessWithLargeCapacity = "When specifying MemoryMappedFileAccess.Read access, the capacity must not be larger than the file size.";
	public const string Argument_NewMMFAppendModeNotAllowed = "FileMode.Append is not permitted when creating new memory mapped files. Instead, use MemoryMappedFileView to ensure write-only access within a specified region.";
	public const string Argument_NewMMFTruncateModeNotAllowed = "FileMode.Truncate is not permitted when creating new memory mapped files.";
	public const string ArgumentNull_MapName = "Map name cannot be null.";
	public const string ArgumentNull_FileStream = "fileStream cannot be null.";
	public const string ArgumentOutOfRange_CapacityLargerThanLogicalAddressSpaceNotAllowed = "The capacity cannot be greater than the size of the system's logical address space.";
	public const string ArgumentOutOfRange_NeedPositiveNumber = "A positive number is required.";
	public const string ArgumentOutOfRange_PositiveOrDefaultCapacityRequired = "The capacity must be greater than or equal to 0. 0 represents the size of the file being mapped.";
	public const string ArgumentOutOfRange_PositiveOrDefaultSizeRequired = "The size must be greater than or equal to 0. If 0 is specified, the view extends from the specified offset to the end of the file mapping.";
	public const string ArgumentOutOfRange_CapacityGEFileSizeRequired = "The capacity may not be smaller than the file size.";
	public const string IO_NotEnoughMemory = "Not enough memory to map view.";
	public const string InvalidOperation_CantCreateFileMapping = "Cannot create file mapping.";
	public const string NotSupported_MMViewStreamsFixedLength = "MemoryMappedViewStreams are fixed length.";
	public const string ObjectDisposed_ViewAccessorClosed = "Cannot access a closed accessor.";
	public const string ObjectDisposed_StreamIsClosed = "Cannot access a closed Stream.";
	public const string PlatformNotSupported_NamedMaps = "Named maps are not supported.";
}
