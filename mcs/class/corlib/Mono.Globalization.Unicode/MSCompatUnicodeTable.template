using System;
using System.Globalization;

namespace Mono.Globalization.Unicode
{
	internal class MSCompatUnicodeTable
	{

static System.IO.TextWriter Output = Console.Out;
static SortKeyBuffer buf = new SortKeyBuffer ();

#region private debugging thingy
public static void Main ()
{
	buf.AdjustBufferSize (1);

	for (int i = 0; i <= char.MaxValue; i++) {
		if (IsIgnorable (i))
			continue;

		string expansion = GetExpansion ((char) i);
		if (expansion != null) {
			foreach (char c in expansion)
				FillSortKeyRaw (c);
		}
		else
			FillSortKeyRaw (i);

		byte [] data = buf.GetResultAndReset ();
		foreach (byte b in data)
			Output.Write ("{0:X02} ", b);
		Output.WriteLine (" : {0:X04}, {1}",
			i, Char.GetUnicodeCategory ((char) i));
	}
	Output.Close ();
}

static void FillSortKeyRaw (int i)
{
	if (0x3400 <= i && i <= 0x4DB5) {
		FillCJKExtensionSortKeyRaw (i);
		return;
	}

	UnicodeCategory uc = char.GetUnicodeCategory ((char) i);
	switch (uc) {
	case UnicodeCategory.PrivateUse:
		FillPrivateUseSortKeyRaw (i);
		return;
	case UnicodeCategory.Surrogate:
		FillSurrogateSortKeyRaw (i);
		return;
	}

	if (HasSpecialWeight ((char) i))
		buf.AppendKana (
			categories [i], level1 [i], level2 [i], level3 [i],
			IsJapaneseSmallLetter ((char) i),
			GetJapaneseDashType ((char) i),
			!IsHiragana ((char) i),
			IsHalfWidthKana ((char) i)
			);
	else
		buf.AppendNormal (
			categories [i], level1 [i], level2 [i], level3 [i]);
}

static void FillCJKExtensionSortKeyRaw (int i)
{
	int diff = i - 0x3400;

	buf.AppendCJKExtension (
		(byte) (0x10 + diff / 254),
		(byte) (diff % 254 + 2));
}

static void FillPrivateUseSortKeyRaw (int i)
{
	int diff = i - 0xE000;
	buf.AppendNormal (
		(byte) (0xE5 + diff / 254),
		(byte) (diff % 254 + 2),
		0,
		0);
}

static void FillSurrogateSortKeyRaw (int i)
{
	int diffbase = 0;
	int segment = 0;
	byte lower = 0;

	if (i < 0xD840) {
		diffbase = 0xD800;
		segment = 0x41;
		lower = (byte) ((i == 0xD800) ? 0x3E : 0x3F);
	} else if (0xD840 <= i && i < 0xD880) {
		diffbase = 0xD840;
		segment = 0xF2;
		lower = 0x3E;
	} else if (0xDB80 <= i && i < 0xDC00) {
		diffbase = 0xDB80 - 0x40;
		segment = 0xFE;
		lower = 0x3E;
	} else {
		diffbase = 0xDC00 - 0xF8 + 2;
		segment = 0x41;
		lower = 0x3F;
	}
	int diff = i - diffbase;

	buf.AppendNormal (
		(byte) (segment + diff / 254),
		(byte) (diff % 254 + 2),
		lower,
		lower);
}
#endregion


		// FIXME: fill the table
		static char [] tailorings = new char [] {};

		public static bool IsIgnorable (int i)
		{
			UnicodeCategory uc = Char.GetUnicodeCategory ((char) i);
			// This check eliminates some extraneous code areas
			if (uc == UnicodeCategory.OtherNotAssigned)
				return true;
			// Some characters in Surrogate area are ignored.
			if (0xD880 <= i && i < 0xDB80)
				return true;
			return ignorableFlags [i] == 7;
		}
		// Verifier:
		// for (int i = 0; i <= char.MaxValue; i++)
		//	if (Char.GetUnicodeCategory ((char) i)
		//		== UnicodeCategory.OtherNotAssigned 
		//		&& ignorableFlags [i] != 7)
		//		Console.WriteLine ("{0:X04}", i);

		public static bool IsIgnorableSymbol (int i)
		{
			return (ignorableFlags [i] & 0x2) != 0;
		}

		public static bool IsIgnorableNonSpacing (int i)
		{
			return (ignorableFlags [i] & 0x4) != 0;
		}

		public static int ToKanaTypeInsensitive (int i)
		{
			// Note that IgnoreKanaType does not treat half-width
			// katakana as equivalent to full-width ones.

			// Thus, it is so simple ;-)
			return (0x3041 <= i && i <= 0x3094) ? i + 0x60 : i;
		}

		public static int ToWidthCompat (int i)
		{
			int v = widthCompat [i];
			return v != 0 ? v : i;
		}

		#region Utilities

		public static string GetExpansion (char c)
		{
			switch (c) {
			case '\u00C6':
				return "AE";
			case '\u00DE':
				return "TH";
			case '\u00DF':
				return "ss";
			case '\u00E6':
				return "ae";
			case '\u00FE':
				return "th";
			case '\u0132':
				return "IJ";
			case '\u0133':
				return "ij";
			case '\u0152':
				return "OE";
			case '\u0153':
				return "oe";
			case '\u01C4':
				return "DZ\u030C"; // surprisingly Windows works fine here
			case '\u01C5':
				return "Dz\u030C";
			case '\u01C6':
				return "dz\u030C";
			case '\u01C7':
				return "LJ";
			case '\u01C8':
				return "Lj";
			case '\u01C9':
				return "lj";
			case '\u01CA':
				return "NJ";
			case '\u01CB':
				return "Nj";
			case '\u01CC':
				return "nj";
			case '\u01E2':
				return "A\u0304E\u0304"; // LAMESPEC: should be \u00C6\u0304
			case '\u01E3':
				return "a\u0304e\u0304"; // LAMESPEC: should be \u00E6\u0304
			case '\u01F1':
				return "DZ";
			case '\u01F2':
				return "Dz";
			case '\u01F3':
				return "dz";
			case '\u01FC':
				return "A\u0301E\u0301"; // LAMESPEC: should be \u00C6\u0301
			case '\u01FD':
				return "a\u0301e\u0301"; // LAMESPEC: should be \u00C6\u0301
			case '\u05F0':
				return "\u05D5\u05D5";
			case '\u05F1':
				return "\u05D5\u05D9";
			case '\u05F2':
				return "\u05D9\u05D9";
			case '\uFB00':
				return "ff";
			case '\uFB01':
				return "fi";
			case '\uFB02':
				return "fl";
			}
//			if ('\u1113' <= c && c <= '\u115F') Korean Jamo
//				return true;
			return null;
		}
		#endregion


		#region Level 4 properties (Kana)

		public static bool HasSpecialWeight (char c)
		{
			if (c < '\u3041')
				return false;
			else if (c < '\u3100')
				return true;
			else if (c < '\u32D0')
				return false;
			else if (c < '\u32FF')
				return true;
			else if (c < '\uFF66')
				return false;
			else if (c < '\uFF9F')
				return true;
			return false;
		}

		public static byte GetJapaneseDashType (char c)
		{
			switch (c) {
			case '\u309D':
			case '\u309E':
			case '\u30FD':
			case '\u30FE':
			case '\uFF70':
				return 4;
			case '\u30FC':
				return 5;
			}
			return 3;
		}

		public static bool IsHalfWidthKana (char c)
		{
			return '\uFF66' <= c && c <= '\uFF9D';
		}

		public static bool IsHiragana (char c)
		{
			return '\u3041' <= c && c <= '\u3094';
		}

		public static bool IsJapaneseSmallLetter (char c)
		{
			if ('\uFF67' <= c && c <= '\uFF6F')
				return true;
			if ('\u3040' < c && c < '\u30FA') {
				switch (c) {
				case '\u3041':
				case '\u3043':
				case '\u3045':
				case '\u3047':
				case '\u3049':
				case '\u3063':
				case '\u3083':
				case '\u3085':
				case '\u3087':
				case '\u308E':
				case '\u30A1':
				case '\u30A3':
				case '\u30A5':
				case '\u30A7':
				case '\u30A9':
				case '\u30C3':
				case '\u30E3':
				case '\u30E5':
				case '\u30E7':
				case '\u30EE':
					return true;
				}
			}
			return false;
		}

		#endregion


		// For "categories", 0 means no primary weight. 6 means 
		// variable weight
		// For expanded character the value is never filled (i.e. 0).
		// Those arrays will be split into blocks (<3400 and >F800)
		// level 4 is computed.

		// public static bool HasSpecialWeight (char c)
		// { return level1 [(int) c] == 6; }

		//
		// autogenerated code or icall to fill array runs here
		//


