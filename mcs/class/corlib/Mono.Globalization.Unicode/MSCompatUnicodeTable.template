using System;
using System.Globalization;

using Util = Mono.Globalization.Unicode.MSCompatUnicodeTableUtil;

namespace Mono.Globalization.Unicode
{
	internal class TailoringInfo
	{
		public readonly int LCID;
		public readonly int TailoringIndex;
		public readonly int TailoringCount;
		public readonly bool FrenchSort;

		public TailoringInfo (int lcid, int tailoringIndex, int tailoringCount, bool frenchSort)
		{
			LCID = lcid;
			TailoringIndex = tailoringIndex;
			TailoringCount = tailoringCount;
			FrenchSort = frenchSort;
		}
	}

	internal class MSCompatUnicodeTable
	{
		public static ushort [] CjkCHS {
			get { return cjkCHS; }
		}

		public static ushort [] CjkCHT {
			get { return cjkCHT; }
		}

		public static ushort [] CjkJA {
			get { return cjkJA; }
		}

		public static ushort [] CjkKO {
			get { return cjkKO; }
		}

		public static byte [] CjkKOLv2 {
			get { return cjkKOlv2; }
		}

		public static TailoringInfo GetTailoringInfo (int lcid)
		{
			for (int i = 0; i < tailoringInfos.Length; i++)
				if (tailoringInfos [i].LCID == lcid)
					return tailoringInfos [i];
			return null;
		}

		public static byte Categories (int cp)
		{
			int idx = Util.Category.ToIndex (cp);
			return idx < 0 ? byte.MinValue : categories [idx];
		}

		public static byte Level1 (int cp)
		{
			int idx = Util.Level1.ToIndex (cp);
			return idx < 0 ? byte.MinValue : level1 [idx];
		}

		public static byte Level2 (int cp)
		{
			int idx = Util.Level2.ToIndex (cp);
			return idx < 0 ? byte.MinValue : level2 [idx];
		}

		public static byte Level3 (int cp)
		{
			int idx = Util.Level3.ToIndex (cp);
			return idx < 0 ? byte.MinValue : level3 [idx];
		}

		public static bool IsIgnorable (int cp)
		{
			UnicodeCategory uc = Char.GetUnicodeCategory ((char) cp);
			// This check eliminates some extraneous code areas
			if (uc == UnicodeCategory.OtherNotAssigned)
				return true;
			// Some characters in Surrogate area are ignored.
			if (0xD880 <= cp && cp < 0xDB80)
				return true;
			int i = Util.Ignorable.ToIndex (cp);
			return i >= 0 && ignorableFlags [i] == 7;
		}
		// Verifier:
		// for (int i = 0; i <= char.MaxValue; i++)
		//	if (Char.GetUnicodeCategory ((char) i)
		//		== UnicodeCategory.OtherNotAssigned 
		//		&& ignorableFlags [i] != 7)
		//		Console.WriteLine ("{0:X04}", i);

		public static bool IsIgnorableSymbol (int cp)
		{
			int i = Util.Ignorable.ToIndex (cp);
			return i >= 0 && (ignorableFlags [i] & 0x2) != 0;
		}

		public static bool IsIgnorableNonSpacing (int cp)
		{
			int i = Util.Ignorable.ToIndex (cp);
			return i >= 0 && (ignorableFlags [i] & 0x4) != 0;
		}

		public static int ToKanaTypeInsensitive (int i)
		{
			// Note that IgnoreKanaType does not treat half-width
			// katakana as equivalent to full-width ones.

			// Thus, it is so simple ;-)
			return (0x3041 <= i && i <= 0x3094) ? i + 0x60 : i;
		}

		public static int ToWidthCompat (int cp)
		{
			int i = Util.WidthCompat.ToIndex (cp);
			int v = i >= 0 ? widthCompat [i] : 0;
			return v != 0 ? v : cp;
		}

		#region Utilities

		// FIXME: this is just a stub. Should be replaced by an
		// implementation which uses tailorings table.
		public static string GetExpansion (char c)
		{
			switch (c) {
			case '\u00C6':
				return "AE";
			case '\u00DE':
				return "TH";
			case '\u00DF':
				return "ss";
			case '\u00E6':
				return "ae";
			case '\u00FE':
				return "th";
			case '\u0132':
				return "IJ";
			case '\u0133':
				return "ij";
			case '\u0152':
				return "OE";
			case '\u0153':
				return "oe";
			case '\u01C4':
				return "DZ\u030C"; // surprisingly Windows works fine here
			case '\u01C5':
				return "Dz\u030C";
			case '\u01C6':
				return "dz\u030C";
			case '\u01C7':
				return "LJ";
			case '\u01C8':
				return "Lj";
			case '\u01C9':
				return "lj";
			case '\u01CA':
				return "NJ";
			case '\u01CB':
				return "Nj";
			case '\u01CC':
				return "nj";
			case '\u01E2':
				return "A\u0304E\u0304"; // LAMESPEC: should be \u00C6\u0304
			case '\u01E3':
				return "a\u0304e\u0304"; // LAMESPEC: should be \u00E6\u0304
			case '\u01F1':
				return "DZ";
			case '\u01F2':
				return "Dz";
			case '\u01F3':
				return "dz";
			case '\u01FC':
				return "A\u0301E\u0301"; // LAMESPEC: should be \u00C6\u0301
			case '\u01FD':
				return "a\u0301e\u0301"; // LAMESPEC: should be \u00C6\u0301
			case '\u05F0':
				return "\u05D5\u05D5";
			case '\u05F1':
				return "\u05D5\u05D9";
			case '\u05F2':
				return "\u05D9\u05D9";
			case '\uFB00':
				return "ff";
			case '\uFB01':
				return "fi";
			case '\uFB02':
				return "fl";
			}
			return null;
		}
		#endregion


		#region Level 4 properties (Kana)

		public static bool HasSpecialWeight (char c)
		{
			if (c < '\u3041')
				return false;
			else if (c < '\u3100')
				return true;
			else if (c < '\u32D0')
				return false;
			else if (c < '\u32FF')
				return true;
			else if (c < '\uFF66')
				return false;
			else if (c < '\uFF9F')
				return true;
			return false;
		}

		public static byte GetJapaneseDashType (char c)
		{
			switch (c) {
			case '\u309D':
			case '\u309E':
			case '\u30FD':
			case '\u30FE':
			case '\uFF70':
				return 4;
			case '\u30FC':
				return 5;
			}
			return 3;
		}

		public static bool IsHalfWidthKana (char c)
		{
			return '\uFF66' <= c && c <= '\uFF9D';
		}

		public static bool IsHiragana (char c)
		{
			return '\u3041' <= c && c <= '\u3094';
		}

		public static bool IsJapaneseSmallLetter (char c)
		{
			if ('\uFF67' <= c && c <= '\uFF6F')
				return true;
			if ('\u3040' < c && c < '\u30FA') {
				switch (c) {
				case '\u3041':
				case '\u3043':
				case '\u3045':
				case '\u3047':
				case '\u3049':
				case '\u3063':
				case '\u3083':
				case '\u3085':
				case '\u3087':
				case '\u308E':
				case '\u30A1':
				case '\u30A3':
				case '\u30A5':
				case '\u30A7':
				case '\u30A9':
				case '\u30C3':
				case '\u30E3':
				case '\u30E5':
				case '\u30E7':
				case '\u30EE':
					return true;
				}
			}
			return false;
		}

		#endregion


		// For "categories", 0 means no primary weight. 6 means 
		// variable weight
		// For expanded character the value is never filled (i.e. 0).
		// Those arrays will be split into blocks (<3400 and >F800)
		// level 4 is computed.

		// public static bool HasSpecialWeight (char c)
		// { return level1 [(int) c] == 6; }

		//
		// autogenerated code or icall to fill array runs here
		//


