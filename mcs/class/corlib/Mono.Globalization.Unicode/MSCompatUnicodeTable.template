using System;
using System.Globalization;

namespace Mono.Globalization.Unicode
{
	internal class MSCompatUnicodeTable
	{

static System.IO.TextWriter Output = Console.Out;

#region private debugging thingy
public static void Main ()
{
	for (int i = 0; i <= char.MaxValue; i++) {
		if (IsIgnorable (i))
			continue;
		int cur = 1;
		byte lv2 = 0;
		byte [] data = GetSortKeyRaw (i);
		foreach (byte b in data) {
			if (cur == 2 && lv2 == 0)
				lv2 = b;
			Output.Write ("{0:X02} ", b);
			if (b == 1)
				cur++;
		}
		if (data [0] == 0xE || data [0] == 0xC ||
			char.IsSurrogate ((char) i))
			lv2 = 1;
		Output.WriteLine (" : {0:X} (), {2}    {3}{4:X02}  {5:X02}  ",
			i,
			i < 0x20 ? ' ' : (char) i,
			Char.GetUnicodeCategory ((char) i),
			lv2 != 1 ? '&' : ' ',
			lv2,
			1
			);
	}
	Output.Close ();
}

static byte [] tmp = new byte [256];

static byte [] GetSortKeyRaw (int i)
{
	if (0xAC00 <= i && i <= 0xD7A3)
		return GetHangleSyllableSortKeyRaw (i, 0x52);

	UnicodeCategory uc = char.GetUnicodeCategory ((char) i);
	switch (uc) {
	case UnicodeCategory.PrivateUse:
		return GetPrivateUseSortKeyRaw (i);
	case UnicodeCategory.Surrogate:
		return GetSurrogateSortKeyRaw (i);
	}

	int n = 0;
	tmp [n++] = categories [i];
	tmp [n++] = level1 [i];
	tmp [n++] = 1;
	if (level2 [i] != 0)
		tmp [n++] = level2 [i];
	tmp [n++] = 1;
	if (level3 [i] != 0)
		tmp [n++] = level3 [i];
	tmp [n++] = 1;

	if (HasSpecialWeight ((char) i)) {
		if (IsJapaneseSmallLetter ((char) i))
			tmp [n++] = 0xC4;
		tmp [n++] = 0xFF;
		byte v = GetJapaneseDashType ((char) i);
		if (v != 3)
			tmp [n++] = v;
		tmp [n++] = 0x02;
		if (!IsHiragana ((char) i))
			tmp [n++] = 0xC4;
		tmp [n++] = 0xFF;
		if (IsHalfWidthKana ((char) i))
		tmp [n++] = 0xC4;
		tmp [n++] = 0xFF;
	}
	tmp [n++] = 1; // level4
	tmp [n++] = 0;
	byte [] ret = new byte [n];
	Array.Copy (tmp, ret, n);
	return ret;
}

static byte [] GetHangleSyllableSortKeyRaw (int i, byte segment)
{
	int ri = i - 0xAC00;
	ri = ri + ri / 0x24C + 1;
	return new byte [] {
		(byte) (segment + ri / 254),
		(byte) (ri % 254 + 2),
		1, 1, 1, 1, 0
		};
}

static byte [] GetPrivateUseSortKeyRaw (int i)
{
	int diff = i - 0xE000;
	return new byte [] {
		(byte) (0xE5 + diff / 254),
		(byte) (diff % 254 + 2),
		1, 1, 1, 1, 0
		};
}

static byte [] GetSurrogateSortKeyRaw (int i)
{
	bool isSpecialArea = (0xD840 <= i && i < 0xD880 || 0xDB80 <= i && i < 0xDC00);
	int diff = i - (isSpecialArea ? i < 0xD8B0 ? 0xD840 : 0xDB80 : 0xD800);
	int segment = isSpecialArea ? 0xFE : 0x41;
	byte lower = (byte) (0xD840 <= i && i < 0xDC00 ? 0x3E : 0x3F);
	return new byte [] {
		(byte) (segment + diff / 254),
		(byte) (diff % 254 + 2),
		1,
		lower, 1,
		lower, 1,
		1,
		0
		};
}
#endregion


		// FIXME: fill the table
		static char [] tailorings = new char [] {};

		public static bool IsIgnorable (int i)
		{
			UnicodeCategory uc = Char.GetUnicodeCategory ((char) i);
			// This check eliminates some extraneous code areas
			if (uc == UnicodeCategory.OtherNotAssigned)
				return true;
			// Some characters in Surrogate area are ignored.
			if (0xD880 <= i && i < 0xDB80)
				return true;
			return ignorableFlags [i] == 7;
		}
		// Verifier:
		// for (int i = 0; i <= char.MaxValue; i++)
		//	if (Char.GetUnicodeCategory ((char) i)
		//		== UnicodeCategory.OtherNotAssigned 
		//		&& ignorableFlags [i] != 7)
		//		Console.WriteLine ("{0:X04}", i);

		public static bool IsIgnorableSymbol (int i)
		{
			return (ignorableFlags [i] & 0x2) != 0;
		}

		public static bool IsIgnorableNonSpacing (int i)
		{
			return (ignorableFlags [i] & 0x4) != 0;
		}

		public static int ToKanatypeInsensitive (int i)
		{
			// Note that IgnoreKanaType does not treat half-width
			// katakana as equivalent to full-width ones.

			// Thus, it is so simple ;-)
			return (0x3041 <= i && i <= 0x3094) ? i + 0x60 : i;
		}

		public static int ToWidthCompat (int i)
		{
			int v = widthCompat [i];
			return v != 0 ? v : i;
		}

		#region Utilities

		public static string GetExpansion (char c)
		{
			switch (c) {
			case '\u00C6':
				return "AE";
			case '\u00DE':
				return "TH";
			case '\u00DF':
				return "ss";
			case '\u00E6':
				return "ae";
			case '\u00FE':
				return "th";
			case '\u0132':
				return "IJ";
			case '\u0133':
				return "ij";
			case '\u0152':
				return "OE";
			case '\u0153':
				return "oe";
			case '\u01C4':
				return "DZ\u030C"; // surprisingly Windows works fine here
			case '\u01C5':
				return "Dz\u030C";
			case '\u01C6':
				return "dz\u030C";
			case '\u01C7':
				return "LJ";
			case '\u01C8':
				return "Lj";
			case '\u01C9':
				return "lj";
			case '\u01CA':
				return "NJ";
			case '\u01CB':
				return "Nj";
			case '\u01CC':
				return "nj";
			case '\u01E2':
				return "A\u0304E\u0304"; // LAMESPEC: should be \u00C6\u0304
			case '\u01E3':
				return "a\u0304e\u0304"; // LAMESPEC: should be \u00E6\u0304
			case '\u01F1':
				return "DZ";
			case '\u01F2':
				return "Dz";
			case '\u01F3':
				return "dz";
			case '\u01FC':
				return "A\u0301E\u0301"; // LAMESPEC: should be \u00C6\u0301
			case '\u01FD':
				return "a\u0301e\u0301"; // LAMESPEC: should be \u00C6\u0301
			case '\u05F0':
				return "\u05D5\u05D5";
			case '\u05F1':
				return "\u05D5\u05D9";
			case '\u05F2':
				return "\u05D9\u05D9";
			case '\uFB00':
				return "ff";
			case '\uFB01':
				return "fi";
			case '\uFB02':
				return "fl";
			}
//			if ('\u1113' <= c && c <= '\u115F') Korean Jamo
//				return true;
			return null;
		}
		#endregion


		#region Level 4 properties (Kana)

		public static bool HasSpecialWeight (char c)
		{
			if (c < '\u3041')
				return false;
			else if (c < '\u3100')
				return true;
			else if (c < '\uFF60' || c == '\uFF65')
				return false;
			else if (c < '\uFF9F')
				return true;
			return true;
		}

		public static byte GetJapaneseDashType (char c)
		{
			switch (c) {
			case '\u309D':
			case '\u309E':
			case '\u30FD':
			case '\u30FE':
			case '\uFF70':
				return 4;
			case '\u30FC':
				return 5;
			}
			return 3;
		}

		public static bool IsHalfWidthKana (char c)
		{
			return '\uFF66' <= c && c <= '\uFF9D';
		}

		public static bool IsHiragana (char c)
		{
			return '\u3041' <= c && c <= '\u3094';
		}

		public static bool IsJapaneseSmallLetter (char c)
		{
			if ('\uFF67' <= c && c <= '\uFF6F')
				return true;
			if ('\u3040' < c && c < '\u30FA') {
				switch (c) {
				case '\u3041':
				case '\u3043':
				case '\u3045':
				case '\u3047':
				case '\u3049':
				case '\u3083':
				case '\u3085':
				case '\u3087':
				case '\u308E':
				case '\u30A1':
				case '\u30A3':
				case '\u30A5':
				case '\u30A7':
				case '\u30A9':
				case '\u30E3':
				case '\u30E5':
				case '\u30E7':
				case '\u30EE':
					return true;
				}
			}
			return false;
		}

		#endregion


		// For "categories", 0 means no primary weight. 6 means 
		// variable weight
		// For expanded character the value is never filled (i.e. 0).
		// Those arrays will be split into blocks (<3400 and >F800)
		// level 4 is computed.

		// public static bool HasSpecialWeight (char c)
		// { return level1 [(int) c] == 6; }

		//
		// autogenerated code or icall to fill array runs here
		//


