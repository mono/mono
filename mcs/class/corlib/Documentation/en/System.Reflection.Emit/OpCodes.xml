<?xml version="1.0" encoding="utf-8"?>
<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <TypeSignature Maintainer="auto" Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the &lt;link location="node:gtk-sharp/programming/threads"&gt;Gtk# Thread Programming&lt;/link&gt; for details.</ThreadSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics". The documentation is available online; see <see cref="http://go.microsoft.com/fwlink/?LinkID=99212">ECMA C# and Common Language Infrastructure Standards</see> on MSDN and <see cref="http://go.microsoft.com/fwlink/?LinkID=65552">Standard ECMA-335 - Common Language Infrastructure (CLI)</see> on the Ecma International Web site.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>58 </para>
              </term>
              <description>
                <para>add </para>
              </description>
              <description>
                <para>Adds two numeric values, returning a new numeric value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value1" /> is added to <paramref name="value2" />.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>Overflow is not detected for integer operations (for proper overflow handling, see <see cref="F:System.Reflection.Emit.OpCodes.Add_Ovf" />).</para>
          <para>Integer addition wraps, rather than saturates. For example, assuming 8-bit integers where <paramref name="value1" /> is set to 255 and <paramref name="value2" /> is set to 1, the wrapped result is 0 rather than 256.</para>
          <para>Floating-point overflow returns +inf (PositiveInfinity) or -inf (NegativeInfinity).</para>
          <para>The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, int32 and float; int32 and int64), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>operand </para>
                </term>
                <description>
                  <para>value1 type </para>
                </description>
                <description>
                  <para>value2 type </para>
                </description>
                <description>
                  <para>result type </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>native int </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int64 </para>
              </description>
              <description>
                <para>int64 </para>
              </description>
              <description>
                <para>int64 </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>native int </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>native int </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>F </para>
              </description>
              <description>
                <para>F </para>
              </description>
              <description>
                <para>F </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>native int  </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
          </list>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the add opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Adds two values and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>D6 </para>
              </term>
              <description>
                <para>add.ovf </para>
              </description>
              <description>
                <para>Adds two signed integer values with an overflow check. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value1" /> is added to <paramref name="value2" /> with a check for overflow.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result is not represented in the result type.</para>
          <para>You can perform this operation on signed integers. For floating-point values, use <see cref="F:System.Reflection.Emit.OpCodes.Add" />.</para>
          <para>The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, int32 and float; int32 and int64), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>operand </para>
                </term>
                <description>
                  <para>value1 type </para>
                </description>
                <description>
                  <para>value2 type </para>
                </description>
                <description>
                  <para>result type </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>native int </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int64 </para>
              </description>
              <description>
                <para>int64 </para>
              </description>
              <description>
                <para>int64 </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>native int </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>native int </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>F </para>
              </description>
              <description>
                <para>F </para>
              </description>
              <description>
                <para>F </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>native int  </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
          </list>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the add.ovf opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>D7 </para>
              </term>
              <description>
                <para>add.ovf.un </para>
              </description>
              <description>
                <para>Adds two unsigned integer values with an overflow check. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value1" /> is added to <paramref name="value2" /> with a check for overflow.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result is not represented in the result type.</para>
          <para>You can perform this operation on signed integers. For floating-point values, use <see cref="F:System.Reflection.Emit.OpCodes.Add" />.</para>
          <para>The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, int32 and float; int32 and int64), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>operand </para>
                </term>
                <description>
                  <para>value1 type </para>
                </description>
                <description>
                  <para>value2 type </para>
                </description>
                <description>
                  <para>result type </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>native int </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>int64 </para>
              </description>
              <description>
                <para>int64 </para>
              </description>
              <description>
                <para>int64 </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>native int </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>native int </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>F </para>
              </description>
              <description>
                <para>F </para>
              </description>
              <description>
                <para>F </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>&amp; </para>
              </description>
              <description>
                <para>native int  </para>
              </description>
              <description>
                <para>&amp; </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>int32 </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
            <item>
              <term>
                <para>add </para>
              </term>
              <description>
                <para>* </para>
              </description>
              <description>
                <para>native int </para>
              </description>
              <description>
                <para>* </para>
              </description>
            </item>
          </list>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the add.ovf.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Instruction </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>5F </para>
              </term>
              <description>
                <para>and </para>
              </description>
              <description>
                <para>Determines the bitwise AND of two integer values. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value1" /> and <paramref name="value2" /> are popped from the stack; the bitwise AND of the two values is computed.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The and instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</para>
          <para>And is an integer-specific operation.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the and opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 00 </para>
              </term>
              <description>
                <para>arglist </para>
              </description>
              <description>
                <para>Returns an argument list handle for the current method. </para>
              </description>
            </item>
          </list>
          <para>No evaluation stack behaviors are performed by this operation.</para>
          <para>The arglist instruction returns an opaque handle (an unmanaged pointer, of type native int) that represents the argument list of the current method. This handle is valid only during the lifetime of the current method. You can, however, pass the handle to other methods as long as the current method is on the thread of control. You can only execute the arglist instruction within a method that takes a variable number of arguments.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the arglist opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an unmanaged pointer to the argument list of the current method.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>3B &lt; int32 &gt; </para>
              </term>
              <description>
                <para>beq <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at offset <paramref name="target" /> if the two values are equal. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The beq instruction transfers control to the specified target instruction if <paramref name="value1" /> is equal to <paramref name="value2" />. The effect is the same as performing a ceq instruction followed by a brtrue branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>The acceptable operand types are encapsulated below: </para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</para>
          <para>Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <see cref="F:System.Reflection.Emit.OpCodes.Leave" /> instruction instead).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the beq opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if two values are equal.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>2E &lt; int8 &gt; </para>
              </term>
              <description>
                <para>beq.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at offset <paramref name="target" /> if equal, short form </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The beq.s instruction transfers control to the specified target instruction if <paramref name="value1" /> is equal to <paramref name="value2" />. The effect is the same as performing a ceq instruction followed by a brtrue branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>The acceptable operand types are encapsulated below: </para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</para>
          <para>Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <see cref="F:System.Reflection.Emit.OpCodes.Leave" /> instruction instead).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the beq.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) if two values are equal.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>3C &lt;int32&gt; </para>
              </term>
              <description>
                <para>bge <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is greater than or equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The bge instruction transfers control to the specified target instruction if <paramref name="value1" /> is greater than or equal to <paramref name="value2" />. The effect is identical to performing a clt.un instruction followed by a brfalse branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the bge opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if the first value is greater than or equal to the second value.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>2F &lt;int8&gt; </para>
              </term>
              <description>
                <para>bge.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is greater than or equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The bge.s instruction transfers control to the specified target instruction if <paramref name="value1" /> is greater than or equal to <paramref name="value2" />. The effect is identical to performing a clt.un instruction followed by a brfalse branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the bge.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>41 &lt;int32&gt; </para>
              </term>
              <description>
                <para>bge.un <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is greater than or equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The bge.un instruction transfers control to the specified target instruction if <paramref name="value1" /> is greater than or equal to <paramref name="value2" />, when compared using unsigned integer or unordered float values. The effect is identical to performing a clt instruction followed by a brfalse branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the bge.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>34 &lt; int8 &gt; </para>
              </term>
              <description>
                <para>bge.un.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is greater than or equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The bge.un.s instruction transfers control to the specified target instruction if <paramref name="value1" /> is greater than or equal to <paramref name="value2" />, when compared using unsigned integer or unordered float values. The effect is identical to performing a clt instruction followed by a brfalse branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the bge.un.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>3D &lt; int32 &gt; </para>
              </term>
              <description>
                <para>bgt <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is greater than the second value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is greater than <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The bgt instruction transfers control to the specified target instruction if <paramref name="value1" /> is greater than <paramref name="value2" />. The effect is identical to performing a cgt instruction followed by a brtrue branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the bgt opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if the first value is greater than the second value.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>30 &lt; int8 &gt; </para>
              </term>
              <description>
                <para>bgt.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is greater than the second value, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is greater than <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The bgt.s instruction transfers control to the specified target instruction if <paramref name="value1" /> is greater than <paramref name="value2" />. The effect is identical to performing a cgt instruction followed by a brtrue branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the bgt.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) if the first value is greater than the second value.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>42 &lt; int32 &gt; </para>
              </term>
              <description>
                <para>bgt.un <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is greater than <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The bgt.un instruction transfers control to the specified target instruction if <paramref name="value1" /> is greater than <paramref name="value2" />, when compared using unsigned integer or unordered float values. The effect is identical to performing a cgt.un instruction followed by a brtrue branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the bgt.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>35 &lt; int8 &gt; </para>
              </term>
              <description>
                <para>bgt.un.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is greater than <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The bgt.un.s instruction transfers control to the specified target instruction if <paramref name="value1" /> is greater than <paramref name="value2" />, when compared using unsigned integer or unordered float values. The effect is identical to performing a cgt.un instruction followed by a brtrue branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the bgt.un.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>3E &lt;int32&gt; </para>
              </term>
              <description>
                <para>ble <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is less than or equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The ble instruction transfers control to the specified target instruction if <paramref name="value1" /> is less than or equal to <paramref name="value2" />. The effect is identical to performing a cgt instruction (cgt.un for floats) followed by a brfalse branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ble opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if the first value is less than or equal to the second value.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>31 &lt;int8&gt; </para>
              </term>
              <description>
                <para>ble.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is less than or equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The ble.s instruction transfers control to the specified target instruction if <paramref name="value1" /> is less than or equal to <paramref name="value2" />. The effect is identical to performing a cgt instruction (cgt.un for floats) instruction followed by a brfalse branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ble.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>43 &lt;int32&gt; </para>
              </term>
              <description>
                <para>ble.un <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is less than or equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The ble.un instruction transfers control to the specified target instruction if <paramref name="value1" /> is less than or equal to <paramref name="value2" />, when compared using unsigned integer or unordered float values. The effect is identical to performing a cgt.un instruction (cgt for floats) followed by a brfalse branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ble.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>36 &lt;int8&gt; </para>
              </term>
              <description>
                <para>ble.un.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is less than or equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The ble.un.s instruction transfers control to the specified target instruction if <paramref name="value1" /> is less than or equal to <paramref name="value2" />, when compared using unsigned integer or unordered float values. The effect is identical to performing a cgt.un instruction (cgt for floats) followed by a brfalse branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ble.un.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>3F &lt; int32 &gt; </para>
              </term>
              <description>
                <para>blt <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is less than the second value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is less than <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The blt instruction transfers control to the specified target instruction if <paramref name="value1" /> is less than or equal to <paramref name="value2" />. The effect is identical to performing a clt instruction followed by a brtrue branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the blt opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if the first value is less than the second value.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>32 &lt; int8 &gt; </para>
              </term>
              <description>
                <para>blt.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is less than the second value, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is less than <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The blt.s instruction transfers control to the specified target instruction if <paramref name="value1" /> is less than <paramref name="value2" />. The effect is identical to performing a clt instruction followed by a brtrue branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the blt.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) if the first value is less than the second value.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>44 &lt; int32 &gt; </para>
              </term>
              <description>
                <para>blt.un <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is less than <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The blt.un instruction transfers control to the specified target instruction if <paramref name="value1" /> is less than <paramref name="value2" />, when compared using unsigned integer or unordered float values. The effect is identical to performing a clt.un instruction followed by a brtrue branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the blt.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>37 &lt; int8 &gt; </para>
              </term>
              <description>
                <para>blt.un.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is less than <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The blt.un instruction transfers control to the specified target instruction if <paramref name="value1" /> is less than <paramref name="value2" />, when compared using unsigned integer or unordered float values. The effect is identical to performing a clt.un instruction followed by a brtrue branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the blt.un.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>40 &lt; int32 &gt; </para>
              </term>
              <description>
                <para>bne.un <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is not equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The bne.un instruction transfers control to the specified target instruction if <paramref name="value1" /> is not equal to <paramref name="value2" />, when compared using unsigned integer or unordered float values. The effect is identical to performing a ceq instruction followed by a brfalse branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the bne.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>33 &lt; int8 &gt; </para>
              </term>
              <description>
                <para>bne.un.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; if <paramref name="value1" /> is not equal to <paramref name="value2" />, the branch operation is performed.</para>
            </item>
          </list>
          <para>The bne.un instruction transfers control to the specified target instruction if <paramref name="value1" /> is not equal to <paramref name="value2" />, when compared using unsigned integer or unordered float values. The effect is identical to performing a ceq instruction followed by a brfalse branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the bne.un.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>8C &lt; T &gt; </para>
              </term>
              <description>
                <para>box <paramref name="valTypeToken" /> </para>
              </description>
              <description>
                <para>Convert a value type (of the type specified in <paramref name="valTypeToken" />) to a true object reference. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value type is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value type is popped from the stack; the box operation is performed.</para>
            </item>
            <item>
              <para>An object reference to the resulting "boxed" value type is pushed onto the stack.</para>
            </item>
          </list>
          <para>A value type has two separate representations within the Common Language Infrastructure (CLI): </para>
          <list type="bullet">
            <item>
              <para>A 'raw' form used when a value type is embedded within another object or on the stack.</para>
            </item>
            <item>
              <para>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</para>
            </item>
          </list>
          <para>The box instruction converts the 'raw' (unboxed) value type into an object reference (type O). This is accomplished by creating a new object and copying the data from the value type into the newly allocated object. <paramref name="valTypeToken" /> is a metadata token indicating the type of the value type on the stack.</para>
          <para>
            <see cref="T:System.OutOfMemoryException" /> is thrown if there is insufficient memory to satisfy the request.</para>
          <para>
            <see cref="T:System.TypeLoadException" /> is thrown if the class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the box opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts a value type to an object reference (type O).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>38 &lt; int32 &gt; </para>
              </term>
              <description>
                <para>br <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branches to a target instruction at the specified offset. </para>
              </description>
            </item>
          </list>
          <para>No evaluation stack behaviors are performed by this operation.</para>
          <para>The br instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the br opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unconditionally transfers control to a target instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>2B &lt; int8 &gt; </para>
              </term>
              <description>
                <para>br.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branches to a target instruction at the specified offset, short form. </para>
              </description>
            </item>
          </list>
          <para>No evaluation stack behaviors are performed by this operation.</para>
          <para>The br.s instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the br.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unconditionally transfers control to a target instruction (short form).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>01 </para>
              </term>
              <description>
                <para>break </para>
              </description>
              <description>
                <para>inform a debugger that a breakpoint has been reached. </para>
              </description>
            </item>
          </list>
          <para>No evaluation stack behaviors are performed by this operation.</para>
          <para>The break instruction is for debugging support. It signals the CLI to inform the debugger that a break point has been tripped. It has no other effect on the interpreter state.</para>
          <para>The break instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</para>
          <para>The break instruction can trap to a debugger, do nothing, or raise a security exception. The exact behavior is implementation-defined.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the break opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>39 &lt; int32 &gt; </para>
              </term>
              <description>
                <para>brfalse <paramref name="target" /> </para>
                <para>brnull <paramref name="target" /> </para>
                <para>brzero <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branches to a target instruction at the specified offset if false. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack by a previous operation.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack; if <paramref name="value" /> is false, branch to <paramref name="target" />.</para>
            </item>
          </list>
          <para>The brfalse instruction (and its aliases brnull and brzero) transfers control to the specified target instruction if <paramref name="value" /> (of type int32, int64, object reference O, managed pointer &amp;, transient pointer *, native int) is zero (false). If <paramref name="value" /> is non-zero (true) execution continues at the next instruction.</para>
          <para>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the brfalse opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if <paramref name="value" /> is false, a null reference (Nothing in Visual Basic), or zero.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>2C &lt; int8 &gt; </para>
              </term>
              <description>
                <para>brfalse.s <paramref name="target" /> </para>
                <para>brnull.s <paramref name="target" /> </para>
                <para>brzero.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branches to a target instruction at the specified offset if false, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack by a previous operation.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack; if <paramref name="value" /> is false, branch to <paramref name="target" />.</para>
            </item>
          </list>
          <para>The brfalse.s instruction (and its aliases brnull and brzero) transfers control to the specified target instruction if <paramref name="value" /> (of type int32, int64, object reference O, managed pointer &amp;, transient pointer *, native int) is zero (false). If <paramref name="value" /> is non-zero (true) execution continues at the next instruction.</para>
          <para>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the brfalse.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if <paramref name="value" /> is false, a null reference, or zero.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>3A &lt; int32 &gt; </para>
              </term>
              <description>
                <para>brtrue <paramref name="target" /> </para>
                <para>brinst <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to a target instruction at the specified offset if non-zero (true). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack by a previous operation.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack; if <paramref name="value" /> is true, branch to <paramref name="target" />.</para>
            </item>
          </list>
          <para>The brtrue instruction transfers control to the specified target instruction if <paramref name="value" /> (type native int) is nonzero (true). If <paramref name="value" /> is zero (false) execution continues at the next instruction.</para>
          <para>If <paramref name="value" /> is an object reference (type O) then brinst (an alias for brtrue) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <see cref="F:System.Reflection.Emit.OpCodes.Ldnull" />).</para>
          <para>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the brtrue opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction if <paramref name="value" /> is true, not null, or non-zero.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>2D &lt; int8 &gt; </para>
              </term>
              <description>
                <para>brtrue.s <paramref name="target" /> </para>
                <para>brinst.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Branch to a target instruction at the specified offset if non-zero (true), short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack by a previous operation.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack; if <paramref name="value" /> is true, branch to <paramref name="target" />.</para>
            </item>
          </list>
          <para>The brtrue.s instruction transfers control to the specified target instruction if <paramref name="value" /> (type native int) is nonzero (true). If <paramref name="value" /> is zero (false) execution continues at the next instruction.</para>
          <para>If <paramref name="value" /> is an object reference (type O) then brinst (an alias for brtrue) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <see cref="F:System.Reflection.Emit.OpCodes.Ldnull" />).</para>
          <para>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the brtrue.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control to a target instruction (short form) if <paramref name="value" /> is true, not null, or non-zero.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>28 &lt; T &gt; </para>
              </term>
              <description>
                <para>call <paramref name="methodDesc" /> </para>
              </description>
              <description>
                <para>Call the method described by <paramref name="methodDesc" />. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>Method arguments <paramref name="arg1" /> through <paramref name="argN" /> are pushed onto the stack.</para>
            </item>
            <item>
              <para>Method arguments <paramref name="arg1" /> through <paramref name="argN" /> are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor. When complete, a return value is generated by the callee method and sent to the caller.</para>
            </item>
            <item>
              <para>The return value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The call instruction calls the method indicated by the method descriptor passed with the instruction. The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used. The call instruction can be immediately preceded by a tail (<see cref="F:System.Reflection.Emit.OpCodes.Tailcall" />) prefix instruction to specify that the current method state should be released before transferring control. If the call transfers control to a method of higher trust than the origin method, the stack frame is not released. Instead, the execution continues silently as if the tail had not been supplied. The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function. In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" /> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" />).</para>
          <para>The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. There are three important special cases: </para>
          <para>1. Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments. The instance reference must not be a null reference. The signature carried in the metadata does not contain an entry in the parameter list for the this pointer; instead, it uses a bit to indicate whether the method requires passing the this pointer.</para>
          <para>2. It is valid to call a virtual method using call (rather than callvirt); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</para>
          <para>3. Note that a delegate's Invoke method can be called with either the call or callvirt instruction.</para>
          <para>
            <see cref="T:System.Security.SecurityException" /> may be thrown if system security does not grant the caller access to the called method. The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</para>
          <block subset="none" type="note">
            <para>When calling methods of System.Object on value types, consider using the constrained prefix with the callvirt instruction instead of emitting a call instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the constrained prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a MethodImpl. These issues are described in more detail in the <see cref="F:System.Reflection.Emit.OpCodes.Constrained" /> opcode.</para>
          </block>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overloads can use the call opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, MethodInfo) </para>
            </item>
            <item>
              <para>ILGenerator.EmitCall(OpCode, MethodInfo, Type[]) </para>
            </item>
          </list>
          <block subset="none" type="note">
            <para>The <see cref="M:System.Reflection.Emit.ILGenerator.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])" /> method is provided for varargs calls. Use the <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method for normal calls. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Calls the method indicated by the passed method descriptor.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>29 &lt; T &gt; </para>
              </term>
              <description>
                <para>calli <paramref name="callSiteDescr" /> </para>
              </description>
              <description>
                <para>Calls the method pointed to with arguments described by the calling convention. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>Method arguments <paramref name="arg1" /> through <paramref name="argN" /> are pushed onto the stack.</para>
            </item>
            <item>
              <para>The method entry pointer is pushed onto the stack.</para>
            </item>
            <item>
              <para>Method arguments <paramref name="arg1" /> through <paramref name="argN" /> and the method entry pointer are popped from the stack; the call to the method is performed. When complete, a return value is generated by the callee method and sent to the caller.</para>
            </item>
            <item>
              <para>The return value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The calli instruction calls the method entry pointer with the arguments <paramref name="arg1" /> through <paramref name="argN" />. The types of these arguments are described by the specific calling convention (<paramref name="callSiteDesc" />). The calli instruction may be immediately preceded by a tail prefix (<see cref="F:System.Reflection.Emit.OpCodes.Tailcall" />) to specify that the current method state should be released before transferring control. If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the tail had not been supplied.</para>
          <para>The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature). Such a pointer can be created using the <see cref="F:System.Reflection.Emit.OpCodes.Ldftn" /> or <see cref="F:System.Reflection.Emit.OpCodes.Ldvirtftn" /> instructions, or passed in from native code.</para>
          <para>The calling convention is not checked dynamically, so code that uses a calli instruction does not work correctly if the destination does not actually use the specified calling convention.</para>
          <para>The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</para>
          <para>
            <see cref="T:System.Security.SecurityException" /> may be thrown if the system security does not grant the caller access to the called method. The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])" /> methods can be used to perform a calli instruction on the stack. Note that calli should be called through the below methods rather than using the <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> class to place the instruction directly on the stack.</para>
          <list type="bullet">
            <item>
              <para>ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</para>
            </item>
            <item>
              <para>ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>6F &lt; T &gt; </para>
              </term>
              <description>
                <para>callvirt <paramref name="method" /> </para>
              </description>
              <description>
                <para>Calls a specific method associated with <paramref name="obj" />. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="obj" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>Method arguments <paramref name="arg1" /> through <paramref name="argN" /> are pushed onto the stack.</para>
            </item>
            <item>
              <para>Method arguments <paramref name="arg1" /> through <paramref name="argN" /> and the object reference <paramref name="obj" /> are popped from the stack; the method call is performed with these arguments and control is transferred to the method in <paramref name="obj" /> referred to by the method metadata token. When complete, a return value is generated by the callee method and sent to the caller.</para>
            </item>
            <item>
              <para>The return value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The callvirt instruction calls a late-bound method on an object. That is, the method is chosen based on the runtime type of <paramref name="obj" /> rather than the compile-time class visible in the method pointer. Callvirt can be used to call both virtual and instance methods. The callvirt instruction may be immediately preceded by a tail (<see cref="F:System.Reflection.Emit.OpCodes.Tailcall" />) prefix to specify that the current stack frame should be released before transferring control. If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</para>
          <para>The method metadata token provides the name, class and signature of the method to call. The class associated with <paramref name="obj" /> is the class of which it is an instance. If the class defines a non-static method that matches the indicated method name and signature, this method is called. Otherwise all classes in the base class chain of this class are checked in order. It is an error if no method is found.</para>
          <para>Callvirt pops the object and the associated arguments off the evaluation stack before calling the method. If the method has a return value, it is pushed on the stack upon method completion. On the callee side, the <paramref name="obj" /> parameter is accessed as argument 0, <paramref name="arg1" /> as argument 1, and so on.</para>
          <para>The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The instance reference <paramref name="obj" /> (always required for callvirt) must be pushed before any of the user-visible arguments. The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</para>
          <para>Note that a virtual method can also be called using the <see cref="F:System.Reflection.Emit.OpCodes.Call" /> instruction.</para>
          <para>
            <see cref="T:System.MissingMethodException" /> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with <paramref name="obj" /> or any of its base classes. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if obj is null.</para>
          <para>
            <see cref="T:System.Security.SecurityException" /> is thrown if system security does not grant the caller access to the called method. The security check may occur when the CIL is converted to native code rather than at run time.</para>
          <block subset="none" type="note">
            <para>When calling methods of System.Object on value types, consider using the constrained prefix with the callvirt instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the constrained prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a MethodImpl. These issues are described in more detail in the <see cref="F:System.Reflection.Emit.OpCodes.Constrained" /> opcode.</para>
          </block>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the callvirt opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, MethodInfo) </para>
            </item>
            <item>
              <para>ILGenerator.EmitCall(OpCode, MethodInfo, Type[]) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>74 &lt; T &gt; </para>
              </term>
              <description>
                <para>castclass <paramref name="class" /> </para>
              </description>
              <description>
                <para>Casts an object to a new object of type <paramref name="class" />. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference is pushed onto the stack.</para>
            </item>
            <item>
              <para>The object reference is popped from the stack; the referenced object is cast as the specified <paramref name="class" />.</para>
            </item>
            <item>
              <para>If successful, a new object reference is pushed onto the stack.</para>
            </item>
          </list>
          <para>The castclass instruction attempts to cast the object reference (type O) atop the stack to a specified class. The new class is specified by a metadata token indicating the desired class. If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <see cref="T:System.InvalidCastException" /> is thrown. If the object reference is a null reference, castclass succeeds and returns the new object as a null reference.</para>
          <para>
            <see cref="T:System.InvalidCastException" /> is thrown if obj cannot be cast to class.</para>
          <para>
            <see cref="T:System.TypeLoadException" /> is thrown if class cannot be found. This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the castclass opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Attempts to cast an object passed by reference to the specified class.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 01 </para>
              </term>
              <description>
                <para>ceq </para>
              </description>
              <description>
                <para>Pushes 1 if <paramref name="value1" /> equals <paramref name="value2" />; else pushes 0. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value1" /> is compared to <paramref name="value2" />.</para>
            </item>
            <item>
              <para>If <paramref name="value1" /> is equal to <paramref name="value2" />, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ceq instruction compares <paramref name="value1" /> and <paramref name="value2" />. If <paramref name="value1" /> is equal to <paramref name="value2" />, then 1 (of type int32) is pushed on the stack. Otherwise 0 (of type int32) is pushed on the stack.</para>
          <para>For floating-point number, ceq will return 0 if the numbers are unordered (either or both are NaN). The infinite values are equal to themselves.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ceq opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares two values. If they are equal, the integer value 1 (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 02 </para>
              </term>
              <description>
                <para>cgt </para>
              </description>
              <description>
                <para>Pushes 1 if <paramref name="value1" /> is greater than <paramref name="value2" />; else pushes 0. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; cgt tests if <paramref name="value1" /> is greater than <paramref name="value2" />.</para>
            </item>
            <item>
              <para>If <paramref name="value1" /> is greater than <paramref name="value2" />, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</para>
            </item>
          </list>
          <para>The cgt instruction compares <paramref name="value1" /> and <paramref name="value2" />. If <paramref name="value1" /> is strictly greater than <paramref name="value2" />, then an int32 value of 1 is pushed on the stack. Otherwise, an int32 value of 0 is pushed on the stack.</para>
          <list type="bullet">
            <item>
              <para>For floating-point numbers, cgt returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</para>
            </item>
          </list>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the cgt opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares two values. If the first value is greater than the second, the integer value 1 (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 03 </para>
              </term>
              <description>
                <para>cgt.un </para>
              </description>
              <description>
                <para>Pushes 1 if <paramref name="value1" /> is greater than <paramref name="value2" />; else pushes 0 (unsigned values). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; cgt.un tests if <paramref name="value1" /> is greater than <paramref name="value2" />.</para>
            </item>
            <item>
              <para>If <paramref name="value1" /> is greater than <paramref name="value2" />, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</para>
            </item>
          </list>
          <para>An int32 value of 1 is pushed on the stack if any of the following is true : </para>
          <para>For floating-point numbers, <paramref name="value1" /> is not ordered with respect to <paramref name="value2" />.</para>
          <para>For integer values, <paramref name="value1" /> is strictly greater than <paramref name="value2" /> when considered as unsigned numbers.</para>
          <para>Otherwise an int32 value of 0 is pushed on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the cgt.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares two unsigned or unordered values. If the first value is greater than the second, the integer value 1 (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>C3 </para>
              </term>
              <description>
                <para>ckfinite </para>
              </description>
              <description>
                <para>throw <see cref="T:System.ArithmeticException" /> if value is not a finite number. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack..</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the ckfinite instruction is performed on it.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is pushed back onto the stack if no exception is thrown.</para>
            </item>
          </list>
          <para>The ckfinite instruction throws <see cref="T:System.ArithmeticException" /> if <paramref name="value" /> (a floating-point number) is either a "not a number" value (NaN) or a +- infinity value. Ckfinite leaves the value on the stack if no exception is thrown. Execution is unspecified if <paramref name="value" /> is not a floating-point number.</para>
          <para>
            <see cref="T:System.ArithmeticException" /> is thrown if <paramref name="value" /> is not a 'normal' number.</para>
          <para>Note that a special exception or a derived class of <see cref="T:System.ArithmeticException" /> may be more appropriate, passing the incorrect value to the exception handler.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ckfinite opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 04 </para>
              </term>
              <description>
                <para>clt </para>
              </description>
              <description>
                <para>Pushes 1 if <paramref name="value1" /> is less than <paramref name="value2" />; else pushes 0. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: <paramref name="value1" /> is pushed onto the stack.</para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; clt tests if <paramref name="value1" /> is less than <paramref name="value2" />.</para>
            </item>
            <item>
              <para>If <paramref name="value1" /> is less than <paramref name="value2" />, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</para>
            </item>
          </list>
          <para>The clt instruction compares <paramref name="value1" /> and <paramref name="value2" />. If <paramref name="value1" /> is strictly less than <paramref name="value2" />, then an int32 value of 1 is pushed on the stack. Otherwise, an int32 value of 0 is pushed on the stack.</para>
          <list type="bullet">
            <item>
              <para>For floating-point numbers, clt returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</para>
            </item>
          </list>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the clt opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares two values. If the first value is less than the second, the integer value 1 (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 05 </para>
              </term>
              <description>
                <para>clt.un </para>
              </description>
              <description>
                <para>Pushes 1 if <paramref name="value1" /> is less than <paramref name="value2" />; else pushes 0 (unsigned values). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; clt.un tests if <paramref name="value1" /> is less than <paramref name="value2" />.</para>
            </item>
            <item>
              <para>If <paramref name="value1" /> is less than <paramref name="value2" />, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</para>
            </item>
          </list>
          <para>The clt.un instruction compares <paramref name="value1" /> and <paramref name="value2" />. An int32 value of 1 is pushed on the stack if any of the following is true: </para>
          <list type="bullet">
            <item>
              <para>
                <paramref name="value1" /> is strictly less than <paramref name="value2" /> (as for clt).</para>
            </item>
            <item>
              <para>For floating-point numbers, <paramref name="value1" /> is not ordered with respect to <paramref name="value2" />.</para>
            </item>
            <item>
              <para>For integer values, <paramref name="value1" /> is strictly less than <paramref name="value2" /> when considered as unsigned numbers.</para>
            </item>
          </list>
          <para>Otherwise, an int32 value of 0 is pushed on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the clt.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />. If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 (int32) is pushed onto the evaluation stack; otherwise 0 (int32) is pushed onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 16 &lt;T&gt;</para>
              </term>
              <description>
                <para>constrained. <paramref name="thisType" /></para>
              </description>
              <description>
                <para>Call a virtual method on a type constrained to be type T. </para>
              </description>
            </item>
          </list>
          <para>The constrained prefix is permitted only on a callvirt instruction. </para>
          <para>The state of the MSIL stack at this point must be as follows: </para>
          <list type="ordered">
            <item>
              <para>A managed pointer, <paramref name="ptr" />, is pushed onto the stack. The type of <paramref name="ptr" /> must be a managed pointer (&amp;) to <paramref name="thisType" />. Note that this is different from the case of an unprefixed callvirt instruction, which expects a reference of <paramref name="thisType" />.</para>
            </item>
            <item>
              <para>Method arguments <paramref name="arg1" /> through <paramref name="argN" /> are pushed onto the stack, just as with an unprefixed callvirt instruction.</para>
            </item>
          </list>
          <para>The constrained prefix is designed to allow callvirt instructions to be made in a uniform way independent of whether <paramref name="thisType" /> is a value type or a reference type.</para>
          <para>When a callvirt <paramref name="method" /> instruction has been prefixed by constrained <paramref name="thisType" />, the instruction is executed as follows: </para>
          <list type="bullet">
            <item>
              <para>If <paramref name="thisType" /> is a reference type (as opposed to a value type) then <paramref name="ptr" /> is dereferenced and passed as the 'this' pointer to the callvirt of <paramref name="method" />.</para>
            </item>
            <item>
              <para>If <paramref name="thisType" /> is a value type and <paramref name="thisType" /> implements <paramref name="method" /> then <paramref name="ptr" /> is passed unmodified as the 'this' pointer to a call <paramref name="method" /> instruction, for the implementation of <paramref name="method" /> by <paramref name="thisType" />.</para>
            </item>
            <item>
              <para>If <paramref name="thisType" /> is a value type and <paramref name="thisType" /> does not implement <paramref name="method" /> then <paramref name="ptr" /> is dereferenced, boxed, and passed as the 'this' pointer to the callvirt <paramref name="method" /> instruction.</para>
            </item>
          </list>
          <para>This last case can occur only when <paramref name="method" /> was defined on <see cref="T:System.Object" />, <see cref="T:System.ValueType" />, or <see cref="T:System.Enum" /> and not overridden by <paramref name="thisType" />. In this case, the boxing causes a copy of the original object to be made. However, because none of the methods of <see cref="T:System.Object" />, <see cref="T:System.ValueType" />, and <see cref="T:System.Enum" /> modify the state of the object, this fact cannot be detected.  </para>
          <para>The constrained prefix supports IL generators that create generic code. Normally the callvirt instruction is not valid on value types. Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of <paramref name="ptr" /> and the method being called. However, when <paramref name="ptr" /> is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</para>
          <para>The constrained opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether <paramref name="ptr" /> is a value type or a reference type. Although it is intended for the case where <paramref name="thisType" /> is a generic type variable, the constrained prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types. </para>
          <para>Using the constrained prefix also avoids potential versioning problems with value types. If the constrained prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object. For example, if a value type V overrides the Object.ToString() method, a call V.ToString() instruction is emitted; if it does not, a box instruction and a callvirt Object.ToString() instruction are emitted. A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added. </para>
          <para>The constrained prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a MethodImpl. If the constrained prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time. Using the constrained prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the constrained opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Constrains the type on which a virtual method call is made.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>D3 </para>
              </term>
              <description>
                <para>conv.i </para>
              </description>
              <description>
                <para>Convert to native int, pushing native int on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.i opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a float64 to a float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field. See <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" /> and <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" /> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.i opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to native int.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>67 </para>
              </term>
              <description>
                <para>conv.i1 </para>
              </description>
              <description>
                <para>Convert to int8, pushing int32 on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.i1 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a float64 to a float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field. See <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" /> and <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" /> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.i1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to int8, then extends (pads) it to int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>68 </para>
              </term>
              <description>
                <para>conv.i2 </para>
              </description>
              <description>
                <para>Convert to int16, pushing int32 on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.i2 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a float64 to a float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field. See <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" /> and <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" /> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.i2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to int16, then extends (pads) it to int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>69 </para>
              </term>
              <description>
                <para>conv.i4 </para>
              </description>
              <description>
                <para>Convert to int32, pushing int32 on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.i4 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a float64 to a float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field. See <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" /> and <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" /> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.i4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>6A </para>
              </term>
              <description>
                <para>conv.i8 </para>
              </description>
              <description>
                <para>Convert to int64, pushing int64 on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.i8 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a float64 to a float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field. See <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" /> and <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" /> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.i8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to int64.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>D4 </para>
              </term>
              <description>
                <para>conv.ovf.i </para>
              </description>
              <description>
                <para>Convert to a native int (on the stack as native int) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.i opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.i opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the signed value on top of the evaluation stack to signed native int, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>8A </para>
              </term>
              <description>
                <para>conv.ovf.i.un </para>
              </description>
              <description>
                <para>Converts an unsigned value to a native int (on the stack as native int) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.i.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.i.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned value on top of the evaluation stack to signed native int, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>B3 </para>
              </term>
              <description>
                <para>conv.ovf.i1 </para>
              </description>
              <description>
                <para>Convert to an int8 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.i1 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.i1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the signed value on top of the evaluation stack to signed int8 and extends it to int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>82 </para>
              </term>
              <description>
                <para>conv.ovf.i1.un </para>
              </description>
              <description>
                <para>Converts an unsigned value to an int8 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.i1.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.i1.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned value on top of the evaluation stack to signed int8 and extends it to int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>B5 </para>
              </term>
              <description>
                <para>conv.ovf.i2 </para>
              </description>
              <description>
                <para>Convert to an int16 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.i2 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.i2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the signed value on top of the evaluation stack to signed int16 and extending it to int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>83 </para>
              </term>
              <description>
                <para>conv.ovf.i2.un </para>
              </description>
              <description>
                <para>Converts an unsigned value to an int16 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.i2.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.i2.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned value on top of the evaluation stack to signed int16 and extends it to int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>B7 </para>
              </term>
              <description>
                <para>conv.ovf.i4 </para>
              </description>
              <description>
                <para>Convert to an int32 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.i4 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.i4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the signed value on top of the evaluation stack to signed int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>84 </para>
              </term>
              <description>
                <para>conv.ovf.i4.un </para>
              </description>
              <description>
                <para>Converts an unsigned value to an int32 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.i4.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.i4.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned value on top of the evaluation stack to signed int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>B9 </para>
              </term>
              <description>
                <para>conv.ovf.i8 </para>
              </description>
              <description>
                <para>Convert to an int64 (on the stack as int64) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.i8 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.i8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the signed value on top of the evaluation stack to signed int64, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>85 </para>
              </term>
              <description>
                <para>conv.ovf.i8.un </para>
              </description>
              <description>
                <para>Converts an unsigned value to an int64 (on the stack as int64) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.i8.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.i8.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned value on top of the evaluation stack to signed int64, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>D5 </para>
              </term>
              <description>
                <para>conv.ovf.u </para>
              </description>
              <description>
                <para>Convert to an unsigned native int (on the stack as native int) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.u opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.u opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the signed value on top of the evaluation stack to unsigned native int, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>8B </para>
              </term>
              <description>
                <para>conv.ovf.u.un </para>
              </description>
              <description>
                <para>Converts un unsigned value to an unsigned native int (on the stack as native int) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.u.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.uvf.u.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned value on top of the evaluation stack to unsigned native int, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>B4 </para>
              </term>
              <description>
                <para>conv.ovf.u1 </para>
              </description>
              <description>
                <para>Convert to an unsigned int8 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.u1 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.u1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the signed value on top of the evaluation stack to unsigned int8 and extends it to int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>86 </para>
              </term>
              <description>
                <para>conv.ovf.u1.un </para>
              </description>
              <description>
                <para>Converts an unsigned value to an unsigned int8 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.u1.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.u1.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned value on top of the evaluation stack to unsigned int8 and extends it to int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>B6 </para>
              </term>
              <description>
                <para>conv.ovf.u2 </para>
              </description>
              <description>
                <para>Convert to an unsigned int16 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.u2 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.u2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the signed value on top of the evaluation stack to unsigned int16 and extends it to int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>87 </para>
              </term>
              <description>
                <para>conv.ovf.u2.un </para>
              </description>
              <description>
                <para>Converts an unsigned value to an unsigned int16 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.u2.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.u2.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned value on top of the evaluation stack to unsigned int16 and extends it to int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>B8 </para>
              </term>
              <description>
                <para>conv.ovf.u4 </para>
              </description>
              <description>
                <para>Convert to an unsigned int32 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.u4 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.u4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the signed value on top of the evaluation stack to unsigned int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>88 </para>
              </term>
              <description>
                <para>conv.ovf.u4.un </para>
              </description>
              <description>
                <para>Converts an unsigned value to an unsigned int32 (on the stack as int32) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.u4.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.u4.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned value on top of the evaluation stack to unsigned int32, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>BA </para>
              </term>
              <description>
                <para>conv.ovf.u8 </para>
              </description>
              <description>
                <para>Convert to an unsigned int64 (on the stack as int64) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.u8 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.u8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the signed value on top of the evaluation stack to unsigned int64, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>89 </para>
              </term>
              <description>
                <para>conv.ovf.u8.un </para>
              </description>
              <description>
                <para>Converts an unsigned value to an unsigned int64 (on the stack as int64) and throw an exception on overflow. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.ovf.u8.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</para>
          <para>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.ovf.i or conv.ovf.u are used, in which case the result is also native int).</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.ovf.u8.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned value on top of the evaluation stack to unsigned int64, throwing <see cref="T:System.OverflowException" /> on overflow.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>76 </para>
              </term>
              <description>
                <para>conv.r.un </para>
              </description>
              <description>
                <para>Convert unsigned integer to floating-point, pushing F on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.r.un opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a float64 to a float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the <paramref name="result" /> returned is unspecified. The conv.r.un operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a float32, if this is wide enough to represent the integer without loss of precision, or else a float64.</para>
          <para>No exceptions are ever thrown when using this field.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.r.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the unsigned integer value on top of the evaluation stack to float32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>6B </para>
              </term>
              <description>
                <para>conv.r4 </para>
              </description>
              <description>
                <para>Convert to float32, pushing F on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.r4 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an float64 to an float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.r4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to float32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>6C </para>
              </term>
              <description>
                <para>conv.r8 </para>
              </description>
              <description>
                <para>Convert to float64, pushing F on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.r8 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an float64 to an float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.r8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to float64.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>E0 </para>
              </term>
              <description>
                <para>conv.u </para>
              </description>
              <description>
                <para>Convert to unsigned native int, pushing native int on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.u opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an float64 to an float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field. See <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" /> and <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" /> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.u opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to unsigned native int, and extends it to native int.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>D2 </para>
              </term>
              <description>
                <para>conv.u1 </para>
              </description>
              <description>
                <para>Convert to int8, pushing int32 on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.u1 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an float64 to an float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field. See <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" /> and <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" /> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.u1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to unsigned int8, and extends it to int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>D1 </para>
              </term>
              <description>
                <para>conv.u2 </para>
              </description>
              <description>
                <para>Convert to int16, pushing int32 on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.u2 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an float64 to an float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field. See <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" /> and <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" /> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.u2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to unsigned int16, and extends it to int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>6D </para>
              </term>
              <description>
                <para>conv.u4 </para>
              </description>
              <description>
                <para>Convert to unsigned int32, pushing int32 on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.u4 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an float64 to an float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field. See <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" /> and <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" /> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.u4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to unsigned int32, and extends it to int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>6E </para>
              </term>
              <description>
                <para>conv.u8 </para>
              </description>
              <description>
                <para>Convert to int64, pushing int64 on stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and the conversion operation is attempted.</para>
            </item>
            <item>
              <para>If the conversion is successful, the resulting value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The conv.u8 opcode converts the <paramref name="value" /> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to int32 when they are loaded onto the evaluation stack (unless conv.i or conv.u is used, in which case the result is also native int). Floating-point values are converted to the F type.</para>
          <para>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an float64 to an float32, precision can be lost. If <paramref name="value" /> is too large to fit in a float32 (F), positive infinity (if <paramref name="value" /> is positive) or negative infinity (if <paramref name="value" /> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an int32, the value is sign-extended to fill the slot.</para>
          <para>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</para>
          <para>No exceptions are ever thrown when using this field. See <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" /> and <see cref="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" /> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the conv.u8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the value on top of the evaluation stack to unsigned int64, and extends it to int64.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 17 </para>
              </term>
              <description>
                <para>cpblk </para>
              </description>
              <description>
                <para>Copy data from one memory block to another. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The destination address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The source address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The number of bytes to copy is pushed onto the stack.</para>
            </item>
            <item>
              <para>The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</para>
            </item>
          </list>
          <para>The cpblk instruction copies a number (type unsigned int32) of bytes from a source address (of type *, native int, or &amp;) to a destination address (of type *, native int, or &amp;). The behavior of cpblk is unspecified if the source and destination areas overlap.</para>
          <para>cpblk assumes that both the source and destination addressed are aligned to the natural size of the machine. The cpblk instruction can be immediately preceded by the unaligned.&lt;prefix&gt; instruction to indicate that either the source or the destination is unaligned.</para>
          <para>The operation of the cpblk instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> may be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the cpblk opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies a specified number bytes from a source address to a destination address.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>70 &lt; T &gt; </para>
              </term>
              <description>
                <para>cpobj <paramref name="classTok" /> </para>
              </description>
              <description>
                <para>Copies a value type from a source object to a destination object. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The destination object reference is pushed onto the stack.</para>
            </item>
            <item>
              <para>The source object reference is pushed onto the stack.</para>
            </item>
            <item>
              <para>The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</para>
            </item>
          </list>
          <para>The behavior of cpobj is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token <paramref name="classTok" /> (a typeref or typedef), or if <paramref name="classTok" /> does not represent a value type.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> may be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the cpobj opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the value type located at the address of an object (type &amp;, * or native int) to the address of the destination object (type &amp;, * or native int).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>5B </para>
              </term>
              <description>
                <para>div </para>
              </description>
              <description>
                <para>Divides two values to return a quotient or floating-point result. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value1" /> is divided by <paramref name="value2" />.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>
            <paramref name="result" /> = <paramref name="value1" /> div value2 satisfies the following conditions: </para>
          <para>| <paramref name="result" /> | = | <paramref name="value1" /> | / | <paramref name="value2" /> |, and: </para>
          <para>sign(<paramref name="result" />) = +, if sign(<paramref name="value1" />) = sign(<paramref name="value2" />), or -, if sign(<paramref name="value1" />) ~= sign(<paramref name="value2" />) </para>
          <para>The div instruction computes the result and pushes it on the stack.</para>
          <para>Integer division truncates towards zero.</para>
          <para>Division of a finite number by zero produces the correctly signed infinite value.</para>
          <para>Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value. Any number divided by infinity will produce a zero value.</para>
          <para>Integral operations throw <see cref="T:System.ArithmeticException" /> if the result cannot be represented in the result type. This can happen if <paramref name="value1" /> is the maximum negative value, and <paramref name="value2" /> is -1.</para>
          <para>Integral operations throw <see cref="T:System.DivideByZeroException" /> if <paramref name="value2" /> is zero.</para>
          <para>Note that on Intel-based platforms an <see cref="T:System.OverflowException" /> is thrown when computing (minint div -1). Floating-point operations never throw an exception (they produce NaNs or infinities instead).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the div opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Divides two values and pushes the result as a floating-point (type F) or quotient (type int32) onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>5C </para>
              </term>
              <description>
                <para>div.un </para>
              </description>
              <description>
                <para>Divides two values, unsigned, returning a quotient. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value1" /> is divided by <paramref name="value2" />.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The div.un instruction computes <paramref name="value1" /> divided by <paramref name="value2" />, both taken as unsigned integers, and pushes the <paramref name="result" /> on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the div.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Divides two unsigned integer values and pushes the result (int32) onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>25 </para>
              </term>
              <description>
                <para>dup </para>
              </description>
              <description>
                <para>Duplicates the value on the top of the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped off of the stack for duplication.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is pushed back onto the stack.</para>
            </item>
            <item>
              <para>A duplicate value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The dup instruction duplicates the top element of the stack, and leaves two identical values atop it.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the dup opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 11 </para>
              </term>
              <description>
                <para>endfilter </para>
              </description>
              <description>
                <para>End filter clause of SEH exception handling. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack; endfilter is executed and control is transferred to the exception handler.</para>
            </item>
          </list>
          <para>
            <paramref name="Value" /> (which must be of type int32 and is one of a specific set of values) is returned from the filter clause. It should be one of: </para>
          <list type="bullet">
            <item>
              <para>exception_continue_search (<paramref name="value" /> = 0) to continue searching for an exception handler </para>
            </item>
            <item>
              <para>exception_execute_handler (<paramref name="value" /> = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located. Upon discovery, the handler is executed.</para>
            </item>
          </list>
          <para>Other integer values will produce unspecified results.</para>
          <para>The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block. The endfilter instruction must be the last instruction in the filter's code block (hence there can only be one endfilter for any single filter block). After executing the endfilter instruction, control logically flows back to the CLI exception handling mechanism.</para>
          <para>Control cannot be transferred into a filter block except through the exception mechanism. Control cannot be transferred out of a filter block except through the use of a throw instruction or by executing the final endfilter instruction. You cannot embed a try block within a filter block. If an exception is thrown inside the filter block, it is intercepted and a value of 0 (exception_continue_search) is returned.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the endfilter opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control from the filter clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>DC </para>
              </term>
              <description>
                <para>endfinally </para>
                <para>endfault </para>
              </description>
              <description>
                <para>Ends the finally or fault clause of an exception block. </para>
              </description>
            </item>
          </list>
          <para>There are no stack transition behaviors for this instruction.</para>
          <para>Endfinally and endfault signal the end of the finally or fault clause so that stack unwinding can continue until the exception handler is invoked. The endfinally or endfault instruction transfers control back to the CLI exception mechanism. The mechanism then searches for the next finally clause in the chain if the protected block was exited with a leave instruction. If the protected block was exited with an exception, the CLI will search for the next finally or fault, or enter the exception handler chosen during the first pass of exception handling.</para>
          <para>An endfinally instruction might only appear lexically within a finally block. Unlike the endfilter instruction, there is no requirement that the block end with an endfinally instruction, and there can be as many endfinally instructions within the block as required. These same restrictions apply to the endfault instruction and the fault block.</para>
          <para>Control cannot be transferred into a finally (or fault) block except through the exception mechanism. Control cannot be transferred out of a finally (or fault) block except through the use of a throw instruction or executing the endfinally (or endfault) instruction. In particular, you cannot "fall out" of a finally (or fault) block or to execute a <see cref="F:System.Reflection.Emit.OpCodes.Ret" /> or <see cref="F:System.Reflection.Emit.OpCodes.Leave" /> instruction within a finally (or fault) block.</para>
          <para>Note that the endfault and endfinally instructions are aliases - they correspond to the same opcode.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the endfinally (endfault) opcode, as well as the ILGenerator method <see cref="M:System.Reflection.Emit.ILGenerator.EndExceptionBlock" />.</para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
            <item>
              <para>ILGenerator.EndExceptionBlock() </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Transfers control from the fault or finally clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 18 </para>
              </term>
              <description>
                <para>initblk </para>
              </description>
              <description>
                <para>Set each location in a block of memory to a given value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A starting address is pushed onto the stack.</para>
            </item>
            <item>
              <para>An initialization value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The number of bytes to initialize is pushed onto the stack.</para>
            </item>
            <item>
              <para>The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</para>
            </item>
          </list>
          <para>The initblk instruction sets the number (unsigned int32) of bytes starting at the specified address (of type native int, &amp;, or *) to the initialization value (of type unsigned int8). initblk assumes that the starting address is aligned to the natural size of the machine.</para>
          <para>The operation of the initblk instructions can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> may be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the initblk opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a specified block of memory at a specific address to a given size and initial value.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 15 &lt; T &gt; </para>
              </term>
              <description>
                <para>initobj <paramref name="typeTok" /> </para>
              </description>
              <description>
                <para>Initializes a value type. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The address of the value type to initialize is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value type at the specified address is initialized as type <paramref name="typeTok" />.</para>
            </item>
          </list>
          <para>The initobj instruction initializes each field of the value type specified by the pushed address (of type native int, &amp;, or *) to a null reference or a 0 of the appropriate primitive type. After this method is called, the instance is ready for a constructor method to be called. If <paramref name="typeTok" /> is a reference type, this instruction has the same effect as ldnull followed by stind.ref.</para>
          <para>Unlike <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />, initobj does not call the constructor method. Initobj is intended for initializing value types, while newobj is used to allocate and initialize objects.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the initobj opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>75 &lt; T &gt; </para>
              </term>
              <description>
                <para>isinst <paramref name="class" /> </para>
              </description>
              <description>
                <para>Tests if an object reference is an instance of <paramref name="class" />, returning either a null reference or an instance of that class or interface. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference is pushed onto the stack.</para>
            </item>
            <item>
              <para>The object reference is popped from the stack and tested to see if it is an instance of the class passed in <paramref name="class" />.</para>
            </item>
            <item>
              <para>The result (either an object reference or a null reference) is pushed onto the stack.</para>
            </item>
          </list>
          <para>
            <paramref name="Class" /> is a metadata token indicating the desired class. If the class of the object on the top of the stack implements <paramref name="class" /> (if <paramref name="class" /> is an interface) or is a derived class of <paramref name="class" /> (if <paramref name="class" /> is a regular class) then it is cast to type <paramref name="class" /> and the result is pushed on the stack, exactly as though <see cref="F:System.Reflection.Emit.OpCodes.Castclass" /> had been called. Otherwise, a null reference is pushed on the stack. If the object reference itself is a null reference, then isinst likewise returns a null reference.</para>
          <para>
            <see cref="T:System.TypeLoadException" /> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the isinst opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Tests whether an object reference (type O) is an instance of a particular class.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>27 &lt; T &gt; </para>
              </term>
              <description>
                <para>jmp <paramref name="method" /> </para>
              </description>
              <description>
                <para>Exit current method and jump to specified method. </para>
              </description>
            </item>
          </list>
          <para>There are no stack transition behaviors for this instruction.</para>
          <para>The jmp (jump) instruction transfers control to the method specified by <paramref name="method" />, which is a metadata token for a method reference. The current arguments are transferred to the destination method.</para>
          <para>The evaluation stack must be empty when this instruction is executed. The calling convention, number and type of arguments at the destination address must match that of the current method.</para>
          <para>The jmp instruction cannot be used to transferred control out of a try, filter, catch, or finally block.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the jmp opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, MethodInfo) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Exits current method and jumps to specified method.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 09 &lt; unsigned int16 &gt; </para>
              </term>
              <description>
                <para>ldarg <paramref name="index" /> </para>
              </description>
              <description>
                <para>Load argument at <paramref name="index" /> onto stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The argument value at <paramref name="index" /> is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldarg instruction pushes the argument indexed at <paramref name="index" />, where arguments are indexed from 0 onwards, onto the evaluation stack. The ldarg instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</para>
          <para>For procedures that take a variable-length argument list, the ldarg instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <see cref="F:System.Reflection.Emit.OpCodes.Arglist" /> instruction for more details).</para>
          <para>Arguments that hold an integer value smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldarg opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, short) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an argument (referenced by a specified index value) onto the stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>02 </para>
              </term>
              <description>
                <para>ldarg.0 </para>
              </description>
              <description>
                <para>Load argument 0 onto stack </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The argument value at index 0 is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldarg.0 instruction is an efficient encoding for loading the argument value at index 0.</para>
          <para>The ldarg.0 instruction pushes the argument indexed at 0 onto the evaluation stack. The ldarg.0 instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</para>
          <para>Arguments that hold an integer value smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldarg.0 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the argument at index 0 onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>03 </para>
              </term>
              <description>
                <para>ldarg.1 </para>
              </description>
              <description>
                <para>Load argument 1 onto stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The argument value at index 1 is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldarg.1 instruction is an efficient encoding for loading the argument value at index 1.</para>
          <para>The ldarg.1 instruction pushes the argument indexed at 1 onto the evaluation stack. The ldarg.1 instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</para>
          <para>Arguments that hold an integer value smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldarg.1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the argument at index 1 onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>04 </para>
              </term>
              <description>
                <para>ldarg.2 </para>
              </description>
              <description>
                <para>Load argument 2 onto stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The argument value at index 2 is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldarg.2 instruction is an efficient encoding for loading the argument value at index 2.</para>
          <para>The ldarg.2 instruction pushes the argument indexed at 2 onto the evaluation stack. The ldarg.2 instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</para>
          <para>Arguments that hold an integer value smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldarg.2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the argument at index 2 onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>05 </para>
              </term>
              <description>
                <para>ldarg.3 </para>
              </description>
              <description>
                <para>Load argument 3 onto stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The argument value at index 3 is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldarg.3 instruction is an efficient encoding for loading the argument value at index 3.</para>
          <para>The ldarg.3 instruction pushes the argument indexed at 3 onto the evaluation stack. The ldarg.3 instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</para>
          <para>Arguments that hold an integer value smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldarg.3 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the argument at index 3 onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>0E &lt; unsigned int8 &gt; </para>
              </term>
              <description>
                <para>ldarg.s <paramref name="index" /> </para>
              </description>
              <description>
                <para>Load argument at <paramref name="index" /> onto stack, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The argument value at <paramref name="index" /> is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldarg.s instruction is an efficient encoding for loading arguments indexed from 4 through 255.</para>
          <para>The ldarg.s instruction pushes the argument indexed at <paramref name="index" />, where arguments are indexed from 0 onwards, onto the evaluation stack. The ldarg.s instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</para>
          <para>For procedures that take a variable-length argument list, the ldarg.s instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <see cref="F:System.Reflection.Emit.OpCodes.Arglist" /> instruction for more details).</para>
          <para>Arguments that hold an integer value smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldarg.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, byte) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the argument (referenced by a specified short form index) onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 0A &lt; unsigned int16 &gt; </para>
              </term>
              <description>
                <para>ldarga <paramref name="index" /> </para>
              </description>
              <description>
                <para>Fetch the address of argument indexed by <paramref name="index" />. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The address <paramref name="addr" /> of the argument indexed by <paramref name="index" /> is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldarga instruction fetches the address (of type *) of the argument indexed by <paramref name="index" />, where arguments are indexed from 0 onwards. The address <paramref name="addr" /> is always aligned to a natural boundary on the target machine.</para>
          <para>For procedures that take a variable-length argument list, the ldarga instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</para>
          <para>ldarga is used for by-ref parameter passing. For other cases, <see cref="F:System.Reflection.Emit.OpCodes.Ldarg" /> and <see cref="F:System.Reflection.Emit.OpCodes.Starg" /> should be used.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldarga opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, short) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Load an argument address onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>0F &lt; unsigned int8 &gt; </para>
              </term>
              <description>
                <para>ldarga.s <paramref name="index" /> </para>
              </description>
              <description>
                <para>Fetch the address of argument indexed by <paramref name="index" />, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The address <paramref name="addr" /> of the argument indexed by <paramref name="index" /> is pushed onto the stack.</para>
            </item>
          </list>
          <para>ldarga.s (the short form of ldarga) should be used for argument numbers 0 through 255, and is a more efficient encoding.</para>
          <para>The ldarga.s instruction fetches the address (of type *) of the argument indexed by <paramref name="index" />, where arguments are indexed from 0 onwards. The address <paramref name="addr" /> is always aligned to a natural boundary on the target machine.</para>
          <para>For procedures that take a variable-length argument list, the ldarga.s instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</para>
          <para>ldarga.s is used for by-ref parameter passing. For other cases, <see cref="F:System.Reflection.Emit.OpCodes.Ldarg_S" /> and <see cref="F:System.Reflection.Emit.OpCodes.Starg_S" /> should be used.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldarga.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, byte) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Load an argument address, in short form, onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>20 &lt; int32 &gt; </para>
              </term>
              <description>
                <para>ldc.i4 <paramref name="num" /> </para>
              </description>
              <description>
                <para>Pushes the value <paramref name="num" /> onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value <paramref name="num" /> is pushed onto the stack.</para>
            </item>
          </list>
          <para>Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8. All short encodings push 4 byte integers on the stack. Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms. There are three ways to push an 8 byte integer constant onto the stack </para>
          <para>1. Use the <see cref="F:System.Reflection.Emit.OpCodes.Ldc_I8" /> instruction for constants that must be expressed in more than 32 bits.</para>
          <para>2. Use the <see cref="F:System.Reflection.Emit.OpCodes.Ldc_I4" /> instruction followed by a <see cref="F:System.Reflection.Emit.OpCodes.Conv_I8" /> for constants that require 9 to 32 bits.</para>
          <para>3. Use a short form instruction followed by a <see cref="F:System.Reflection.Emit.OpCodes.Conv_I8" /> for constants that can be expressed in 8 or fewer bits.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, int) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes a supplied value of type int32 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>16 </para>
              </term>
              <description>
                <para>ldc.i4.0 </para>
              </description>
              <description>
                <para>Pushes 0 onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value 0 is pushed onto the stack.</para>
            </item>
          </list>
          <para>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.0 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the integer value of 0 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>17 </para>
              </term>
              <description>
                <para>ldc.i4.1 </para>
              </description>
              <description>
                <para>Pushes 1 onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value 1 is pushed onto the stack.</para>
            </item>
          </list>
          <para>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the integer value of 1 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>18 </para>
              </term>
              <description>
                <para>ldc.i4.2 </para>
              </description>
              <description>
                <para>Pushes 2 onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value 2 is pushed onto the stack.</para>
            </item>
          </list>
          <para>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the integer value of 2 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>19 </para>
              </term>
              <description>
                <para>ldc.i4.3 </para>
              </description>
              <description>
                <para>Pushes 3 onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value 3 is pushed onto the stack.</para>
            </item>
          </list>
          <para>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.3 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the integer value of 3 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>1A </para>
              </term>
              <description>
                <para>ldc.i4.4 </para>
              </description>
              <description>
                <para>Pushes 4 onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value 4 is pushed onto the stack.</para>
            </item>
          </list>
          <para>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the integer value of 4 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>1B </para>
              </term>
              <description>
                <para>ldc.i4.5 </para>
              </description>
              <description>
                <para>Pushes 5 onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value 5 is pushed onto the stack.</para>
            </item>
          </list>
          <para>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.5 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the integer value of 5 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>1C </para>
              </term>
              <description>
                <para>ldc.i4.6 </para>
              </description>
              <description>
                <para>Pushes 6 onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value 6 is pushed onto the stack.</para>
            </item>
          </list>
          <para>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.6 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the integer value of 6 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>1D </para>
              </term>
              <description>
                <para>ldc.i4.7 </para>
              </description>
              <description>
                <para>Pushes 7 onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value 7 is pushed onto the stack.</para>
            </item>
          </list>
          <para>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.7 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the integer value of 7 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>1E </para>
              </term>
              <description>
                <para>ldc.i4.8 </para>
              </description>
              <description>
                <para>Pushes 8 onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value 8 is pushed onto the stack.</para>
            </item>
          </list>
          <para>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the integer value of 8 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>15 </para>
              </term>
              <description>
                <para>ldc.i4.m1 </para>
              </description>
              <description>
                <para>Pushes -1 onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value -1 is pushed onto the stack.</para>
            </item>
          </list>
          <para>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.m1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the integer value of -1 onto the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>1F &lt; int8 &gt; </para>
              </term>
              <description>
                <para>ldc.i4.s <paramref name="num" /> </para>
              </description>
              <description>
                <para>Pushes <paramref name="num" /> onto the stack as int32, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value <paramref name="num" /> is pushed onto the stack.</para>
            </item>
          </list>
          <para>ldc.i4.s is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i4.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, byte) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the supplied int8 value onto the evaluation stack as an int32, short form.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>21 &lt; int64 &gt; </para>
              </term>
              <description>
                <para>ldc.i8 <paramref name="num" /> </para>
              </description>
              <description>
                <para>Pushes <paramref name="num" /> onto the stack as int64. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value <paramref name="num" /> is pushed onto the stack.</para>
            </item>
          </list>
          <para>This encoding pushes an int64 value onto the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.i8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, long) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes a supplied value of type int64 onto the evaluation stack as an int64.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>22 &lt; float32 &gt; </para>
              </term>
              <description>
                <para>ldc.r4 <paramref name="num" /> </para>
              </description>
              <description>
                <para>Pushes <paramref name="num" /> onto the stack as F. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value <paramref name="num" /> is pushed onto the stack.</para>
            </item>
          </list>
          <para>This encoding pushes a float32 value onto the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.r4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, single) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes a supplied value of type float32 onto the evaluation stack as type F (float).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>23 &lt; float64 &gt; </para>
              </term>
              <description>
                <para>ldc.r8 <paramref name="num" /> </para>
              </description>
              <description>
                <para>Pushes <paramref name="num" /> onto the stack as F. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value <paramref name="num" /> is pushed onto the stack.</para>
            </item>
          </list>
          <para>This encoding pushes a float64 value onto the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldc.r8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, double) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes a supplied value of type float64 onto the evaluation stack as type F (float).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>A3 &lt;T&gt;</para>
              </term>
              <description>
                <para>ldelem <paramref name="typeTok" /></para>
              </description>
              <description>
                <para>Loads the element at <paramref name="index" /> onto the top of the stack as type <paramref name="typeTok" />. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects, and hence represented by a value of type O.</para>
          <para>The type of the return value is specified by the token <paramref name="typeTok" /> in the instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the upper bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>97 </para>
              </term>
              <description>
                <para>ldelem.i </para>
              </description>
              <description>
                <para>Loads the element with type native int at <paramref name="index" /> onto the top of the stack as a native int. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.i instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.i is native int.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.i opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element with type native int at a specified array index onto the top of the evaluation stack as a native int.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>90 </para>
              </term>
              <description>
                <para>ldelem.i1 </para>
              </description>
              <description>
                <para>Loads the element with type int8 at <paramref name="index" /> onto the top of the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.i1 instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.i1 is int8.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.i1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element with type int8 at a specified array index onto the top of the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>92 </para>
              </term>
              <description>
                <para>ldelem.i2 </para>
              </description>
              <description>
                <para>Loads the element with type int16 at <paramref name="index" /> onto the top of the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.i2 instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.i2 is int16.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.i2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element with type int16 at a specified array index onto the top of the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>94 </para>
              </term>
              <description>
                <para>ldelem.i4 </para>
              </description>
              <description>
                <para>Loads the element with type int32 at <paramref name="index" /> onto the top of the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.i4 instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.i4 is int32.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.i4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element with type int32 at a specified array index onto the top of the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>96 </para>
              </term>
              <description>
                <para>ldelem.i8 </para>
              </description>
              <description>
                <para>Loads the element with type int64 at <paramref name="index" /> onto the top of the stack as an int64. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.i8 instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.i8 is int64.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.i8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element with type int64 at a specified array index onto the top of the evaluation stack as an int64.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>98 </para>
              </term>
              <description>
                <para>ldelem.r4 </para>
              </description>
              <description>
                <para>Loads the element with type float32 at <paramref name="index" /> onto the top of the stack as a type F. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.r4 instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.r4 is float32.</para>
          <para>Floating-point values are converted to type F when loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.r4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element with type float32 at a specified array index onto the top of the evaluation stack as type F (float).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>99 </para>
              </term>
              <description>
                <para>ldelem.r8 </para>
              </description>
              <description>
                <para>Loads the element with type float64 at <paramref name="index" /> onto the top of the stack as type F. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.r8 instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.r8 is float64.</para>
          <para>Floating-point values are converted to type F when loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.r8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element with type float64 at a specified array index onto the top of the evaluation stack as type F (float).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>9A </para>
              </term>
              <description>
                <para>ldelem.ref </para>
              </description>
              <description>
                <para>Loads the element with an object reference at <paramref name="index" /> onto the top of the stack as type O. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.ref instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.ref is type O (object reference).</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.ref opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type O (object reference).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>91 </para>
              </term>
              <description>
                <para>ldelem.u1 </para>
              </description>
              <description>
                <para>Loads the element with type unsigned int8 at <paramref name="index" /> onto the top of the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.u1 instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.u1 is int8.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.u1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element with type unsigned int8 at a specified array index onto the top of the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>93 </para>
              </term>
              <description>
                <para>ldelem.u2 </para>
              </description>
              <description>
                <para>Loads the element with type unsigned int16 at index onto the top of the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.u2 instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.u2 is int16.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.u2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element with type unsigned int16 at a specified array index onto the top of the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>95 </para>
              </term>
              <description>
                <para>ldelem.u4 </para>
              </description>
              <description>
                <para>Loads the element with type unsigned int32 at index onto the top of the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the value stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelem.u4 instruction loads the value of the element with index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O.</para>
          <para>The return value for ldelem.u4 is int32.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if array does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelem.u4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the element with type unsigned int32 at a specified array index onto the top of the evaluation stack as an int32.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>8F &lt; T &gt; </para>
              </term>
              <description>
                <para>ldelema <paramref name="class" /> </para>
              </description>
              <description>
                <para>Loads the address of the array element at <paramref name="index" /> onto the top of the evaluation stack as type &amp; (managed pointer). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value <paramref name="index" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="index" /> and <paramref name="array" /> are popped from the stack; the address stored at position <paramref name="index" /> in <paramref name="array" /> is looked up.</para>
            </item>
            <item>
              <para>The address is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldelema is used to retrieve the address of an object at a particular index in an array of objects (of type <paramref name="class" />). The ldelema instruction loads the address of the value at index <paramref name="index" /> (type native int) in the zero-based one-dimensional array <paramref name="array" /> and places it on the top of the stack. Arrays are objects and hence represented by a value of type O. The value must be of type <paramref name="class" /> passed with the instruction.</para>
          <para>The return value for ldelema is a managed pointer (type &amp;).</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldelema opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the address of the array element at a specified array index onto the top of the evaluation stack as type &amp; (managed pointer).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>7B &lt; T &gt; </para>
              </term>
              <description>
                <para>ldfld <paramref name="field" /> </para>
              </description>
              <description>
                <para>Pushes the value of a field in a specified object onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference (or pointer) is pushed onto the stack.</para>
            </item>
            <item>
              <para>The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</para>
            </item>
            <item>
              <para>The value stored in the field is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldfld instruction pushes the value of a field located in an object onto the stack. The object must be on the stack as an object reference (type O), a managed pointer (type &amp;), an unmanaged pointer (type native int), a transient pointer (type *), or an instance of a value type. The use of an unmanaged pointer is not permitted in verifiable code. The object's field is specified by a metadata token that must refer to a field member. The return type is the same as the one associated with the field. The field may be either an instance field (in which case the object must not be a null reference) or a static field.</para>
          <para>The ldfld instruction can be preceded by either or both of the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> and <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> prefixes.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if the object is null and the field is not static.</para>
          <para>
            <see cref="T:System.MissingFieldException" /> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldfld opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, FieldInfo) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Finds the value of a field in the object whose reference is currently on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>7C &lt; T &gt; </para>
              </term>
              <description>
                <para>ldflda <paramref name="field" /> </para>
              </description>
              <description>
                <para>Pushes the address of <paramref name="field" /> in a specified object onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference (or pointer) is pushed onto the stack.</para>
            </item>
            <item>
              <para>The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</para>
            </item>
            <item>
              <para>The address of the specified field is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldflda instruction pushes the address of a field located in an object onto the stack. The object must be on the stack as an object reference (type O), a managed pointer (type &amp;), an unmanaged pointer (type native int), a transient pointer (type *), or an instance of a value type. The use of an unmanaged pointer is not permitted in verifiable code. The object's field is specified by a metadata token that must refer to a field member.</para>
          <para>The value returned by ldflda is a managed pointer (type &amp;) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type native int).</para>
          <para>The ldflda instruction can be preceded by either or both of the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> and <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> prefixes.</para>
          <para>
            <see cref="T:System.InvalidOperationException" /> is thrown if the object is not within the application domain from which it is being accessed. The address of a field that is not inside the accessing application domain cannot be loaded.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if the object is null and the field is not static.</para>
          <para>
            <see cref="T:System.MissingFieldException" /> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldflda opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, FieldInfo) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Finds the address of a field in the object whose reference is currently on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 06 &lt; T &gt; </para>
              </term>
              <description>
                <para>ldftn <paramref name="method" /> </para>
              </description>
              <description>
                <para>Pushes a pointer to a method referenced by <paramref name="method" /> on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The unmanaged pointer to a specific method is pushed onto the stack.</para>
            </item>
          </list>
          <para>The specific method (<paramref name="method" />) can be called using the <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</para>
          <para>The value returned points to native code using the calling convention specified by the <paramref name="method" /> metadata token. Thus, a method pointer can be easily passed to unmanaged native code (specifically, as a callback routine).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldftn opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, MethodInfo) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes an unmanaged pointer (type native int) to the native code implementing a specific method onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>4D </para>
              </term>
              <description>
                <para>ldind.i </para>
              </description>
              <description>
                <para>Loads the native int value at address <paramref name="addr" /> onto the stack as a native int. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldind.i instruction indirectly loads a native int value from the specified address (of type native int, &amp;, or *) onto the stack as a native int.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.i opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads a value of type native int as a native int onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>46 </para>
              </term>
              <description>
                <para>ldind.i1 </para>
              </description>
              <description>
                <para>Loads the int8 value at address <paramref name="addr" /> onto the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched value is pushed onto the stack..</para>
            </item>
          </list>
          <para>The ldind.i1 instruction indirectly loads an int8 value from the specified address (of type native int, &amp;, or *) onto the stack as an int32.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.i1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads a value of type int8 as an int32 onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>48 </para>
              </term>
              <description>
                <para>ldind.i2 </para>
              </description>
              <description>
                <para>Loads the int16 value at address <paramref name="addr" /> onto the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldind.i2 instruction indirectly loads an int16 value from the specified address (of type native int, &amp;, or *) onto the stack as an int32.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.i2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads a value of type int16 as an int32 onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>4A </para>
              </term>
              <description>
                <para>ldind.i4 </para>
              </description>
              <description>
                <para>Loads the int32 value at address <paramref name="addr" /> onto the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldind.i4 instruction indirectly loads an int32 value from the specified address (of type native int, &amp;, or *) onto the stack as an int32.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.i4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads a value of type int32 as an int32 onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>4C </para>
              </term>
              <description>
                <para>ldind.i8 </para>
              </description>
              <description>
                <para>Loads the int64 value at address <paramref name="addr" /> onto the stack as an int64. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldind.i8 instruction indirectly loads an int64 value from the specified address (of type native int, &amp;, or *) onto the stack as an int64.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.i8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads a value of type int64 as an int64 onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>4E </para>
              </term>
              <description>
                <para>ldind.r4 </para>
              </description>
              <description>
                <para>Loads the float32 value at address <paramref name="addr" /> onto the stack as a type F. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldind.r4 instruction indirectly loads a float32 value from the specified address (of type native int, &amp;, or *) onto the stack as a type F.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.r4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads a value of type float32 as a type F (float) onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>4F </para>
              </term>
              <description>
                <para>ldind.r8 </para>
              </description>
              <description>
                <para>Loads the float64 value at address <paramref name="addr" /> onto the stack as a type F. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldind.r8 instruction indirectly loads a float64 value from the specified address (of type native int, &amp;, or *) onto the stack as a float64.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.r8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads a value of type float64 as a type F (float) onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>50 </para>
              </term>
              <description>
                <para>ldind.ref </para>
              </description>
              <description>
                <para>Loads the object reference at address <paramref name="addr" /> onto the stack as a type O </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the object reference located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched reference is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldind.ref instruction indirectly loads the object reference the specified address (of type native int, &amp;, or *) onto the stack as type O.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.ref opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an object reference as a type O (object reference) onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>47 </para>
              </term>
              <description>
                <para>ldind.u1 </para>
              </description>
              <description>
                <para>Loads the unsigned int8 value at address <paramref name="addr" /> onto the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldind.u1 instruction indirectly loads an unsigned int8 value from the specified address (of type native int, &amp;, or *) onto the stack as an int32.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.u1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads a value of type unsigned int8 as an int32 onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>49 </para>
              </term>
              <description>
                <para>ldind.u2 </para>
              </description>
              <description>
                <para>Loads the unsigned int16 value at address <paramref name="addr" /> onto the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldind.u2 instruction indirectly loads an unsigned int16 value from the specified address (of type native int, &amp;, or *) onto the stack as an int32.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.u2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads a value of type unsigned int16 as an int32 onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>4B </para>
              </term>
              <description>
                <para>ldind.u4 </para>
              </description>
              <description>
                <para>Loads the unsigned int32 value at address <paramref name="addr" /> onto the stack as an int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack; the value located at the address is fetched.</para>
            </item>
            <item>
              <para>The fetched value is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldind.u4 instruction indirectly loads an unsigned int32 value from the specified address (of type native int, &amp;, or *) onto the stack as an int32.</para>
          <para>All of the ldind instructions are shortcuts for a <see cref="F:System.Reflection.Emit.OpCodes.Ldobj" /> instruction that specifies the corresponding built-in value class.</para>
          <para>Note that integer values of less than 4 bytes are extended to int32 (not native int) when they are loaded onto the evaluation stack. Floating-point values are converted to F type when loaded onto the evaluation stack.</para>
          <para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the ldind instructions are used in a manner consistent with the type of the pointer.</para>
          <para>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <see cref="T:System.NullReferenceException" /> can occur (see the <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloca" /> and <see cref="F:System.Reflection.Emit.OpCodes.Ldarga" />) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> can be thrown if an invalid address is detected.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldind.u4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads a value of type unsigned int32 as an int32 onto the evaluation stack indirectly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>8E </para>
              </term>
              <description>
                <para>ldlen </para>
              </description>
              <description>
                <para>Pushes the length (of type natural unsigned int) of an array on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to an array is pushed onto the stack.</para>
            </item>
            <item>
              <para>The array reference is popped from the stack and the length is computed.</para>
            </item>
            <item>
              <para>The length is pushed onto the stack.</para>
            </item>
          </list>
          <para>Arrays are objects and hence represented by a value of type O. The length is returned as a natural unsigned int.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if the array reference is a null reference.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldlen opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 0C &lt; unsigned int16 &gt; </para>
              </term>
              <description>
                <para>ldloc <paramref name="index" /> </para>
              </description>
              <description>
                <para>Loads the local variable at index <paramref name="index" /> onto stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The local variable value at the specified index is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldloc instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards. Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true. There are 65,535 (2^16-1) local variables possible (0-65,534). Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method. If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</para>
          <para>The ldloc.0, ldloc.1, ldloc.2, and ldloc.3 instructions provide an efficient encoding for accessing the first four local variables.</para>
          <para>The type of the value is the same as the type of the local variable, which is specified in the method header. See Partition I. Local variables that are smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overloads can use the ldloc opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, LocalBuilder) </para>
            </item>
            <item>
              <para>ILGenerator.Emit(OpCode, short) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the local variable at a specific index onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>06 </para>
              </term>
              <description>
                <para>ldloc.0 </para>
              </description>
              <description>
                <para>Loads the local variable at index 0 onto the evaluation stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The local variable value at the index 0 is pushed onto the stack.</para>
            </item>
          </list>
          <para>ldloc.0 is an especially efficient encoding for <see cref="F:System.Reflection.Emit.OpCodes.Ldloc" />, allowing access to the local variable at index 0.</para>
          <para>The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldloc.0 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the local variable at index 0 onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>07 </para>
              </term>
              <description>
                <para>ldloc.1 </para>
              </description>
              <description>
                <para>Loads the local variable at index 1 onto the evaluation stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The local variable value at the index 1 is pushed onto the stack.</para>
            </item>
          </list>
          <para>ldloc.1 is an especially efficient encoding for <see cref="F:System.Reflection.Emit.OpCodes.Ldloc" />, allowing access to the local variable at index 1.</para>
          <para>The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldloc.1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the local variable at index 1 onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>08 </para>
              </term>
              <description>
                <para>ldloc.2 </para>
              </description>
              <description>
                <para>Loads the local variable at index 2 onto the evaluation stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The local variable value at the index 2 is pushed onto the stack.</para>
            </item>
          </list>
          <para>ldloc.2 is an especially efficient encoding for <see cref="F:System.Reflection.Emit.OpCodes.Ldloc" />, allowing access to the local variable at index 2.</para>
          <para>The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldloc.2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the local variable at index 2 onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>09 </para>
              </term>
              <description>
                <para>ldloc.3 </para>
              </description>
              <description>
                <para>Loads the local variable at index 3 onto the evaluation stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The local variable value at the index 3 is pushed onto the stack.</para>
            </item>
          </list>
          <para>ldloc.3 is an especially efficient encoding for <see cref="F:System.Reflection.Emit.OpCodes.Ldloc" />, allowing access to the local variable at index 3.</para>
          <para>The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldloc.3 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the local variable at index 3 onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>11 &lt; unsigned int8 &gt; </para>
              </term>
              <description>
                <para>ldloc.s <paramref name="index" /> </para>
              </description>
              <description>
                <para>Loads the local variable at index <paramref name="index" /> onto stack, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The local variable value at the specified index is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldloc.s instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards. Local variables are initialized to 0 before entering the method if the initialize flag on the method is true. There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than ldloc.</para>
          <para>The type of the value is the same as the type of the local variable, which is specified in the method header. See Partition I. Local variables that are smaller than 4 bytes long are expanded to type int32 when they are loaded onto the stack. Floating-point values are expanded to their native size (type F).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overloads can use the ldloc.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, LocalBuilder) </para>
            </item>
            <item>
              <para>ILGenerator.Emit(OpCode, byte) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the local variable at a specific index onto the evaluation stack, short form.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE OD &lt; unsigned int16 &gt; </para>
              </term>
              <description>
                <para>ldloca <paramref name="index" /> </para>
              </description>
              <description>
                <para>Loads the address of the local variable at <paramref name="index" /> onto the evaluation stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The address stored in the local variable at the specified index is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldloca instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards. The value pushed on the stack is already aligned correctly for use with instructions like <see cref="F:System.Reflection.Emit.OpCodes.Ldind_I" /> and <see cref="F:System.Reflection.Emit.OpCodes.Stind_I" />. The result is a transient pointer (type *).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldloca opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, short) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the address of the local variable at a specific index onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>12 &lt; unsigned int8 &gt; </para>
              </term>
              <description>
                <para>ldloca.s <paramref name="index" /> </para>
              </description>
              <description>
                <para>Loads the address of the local variable at <paramref name="index" /> onto the evaluation stack, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The address stored in the local variable at the specified index is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldloca.s instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards. The value pushed on the stack is already aligned correctly for use with instructions like <see cref="F:System.Reflection.Emit.OpCodes.Ldind_I" /> and <see cref="F:System.Reflection.Emit.OpCodes.Stind_I" />. The result is a transient pointer (type *).</para>
          <para>The ldloca.s instruction provides an efficient encoding for use with the local variables 0 through 255.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldloca.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, byte) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the address of the local variable at a specific index onto the evaluation stack, short form.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>14 </para>
              </term>
              <description>
                <para>ldnull </para>
              </description>
              <description>
                <para>push a null reference onto the stack </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A null object reference is pushed onto the stack.</para>
            </item>
          </list>
          <para>ldnull pushes a null reference (type O) on the stack. This is used to initialize locations before they are populated with data, or when they become deprecated.</para>
          <para>ldnull provides a null reference that is size-independent.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldnull opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes a null reference (type O) onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>71 &lt; T &gt; </para>
              </term>
              <description>
                <para>ldobj <paramref name="class" /> </para>
              </description>
              <description>
                <para>Copy instance of value type <paramref name="class" /> to the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The address of a value type object is pushed onto the stack.</para>
            </item>
            <item>
              <para>The address is popped from the stack and the instance at that particular address is looked up.</para>
            </item>
            <item>
              <para>The value of the object stored at that address is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldobj instruction is used to pass a value type as a parameter.</para>
          <para>The ldobj instruction copies the value pointed to by <paramref name="addrOfValObj" /> (of type &amp;, *, or native int) to the top of the stack. The number of bytes copied depends on the size of the class (as specified by the <paramref name="class" /> parameter). The <paramref name="class" /> parameter is a metadata token representing the value type.</para>
          <para>The operation of the ldobj instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.TypeLoadException" /> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldobj opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the value type object pointed to by an address to the top of the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>7E &lt; T &gt; </para>
              </term>
              <description>
                <para>ldsfld <paramref name="field" /> </para>
              </description>
              <description>
                <para>Push the value of <paramref name="field" /> on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value of the specific field is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldsfld instruction pushes the value of a static (shared among all instances of a class) field on the stack. The return type is that associated with the passed metadata token <paramref name="field" />.</para>
          <para>The ldsfld instruction can have a <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> prefix.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldsfld opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, FieldInfo) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the value of a static field onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>7F &lt; T &gt; </para>
              </term>
              <description>
                <para>ldsflda <paramref name="field" /> </para>
              </description>
              <description>
                <para>Push the address of <paramref name="field" /> on the stack </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The address of a specific field is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldsflda instruction pushes the address of a static (shared among all instances of a class) field on the stack. The address may be represented as a transient pointer (type *) if the metadata token <paramref name="field" /> refers to a type whose memory is managed. Otherwise, it corresponds to an unmanaged pointer (type native int). Note that <paramref name="field" /> may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</para>
          <para>The ldsflda instruction can have a <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> prefix.</para>
          <para>
            <see cref="T:System.MissingFieldException" /> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldsflda opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, FieldInfo) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the address of a static field onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>72 &lt; T &gt; </para>
              </term>
              <description>
                <para>ldstr <paramref name="mdToken" /> </para>
              </description>
              <description>
                <para>Pushes a string object for the metadata string token <paramref name="mdToken" />. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to a string is pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldstr instruction pushes an object reference (type O) to a new string object representing the specific string literal stored in the metadata. The ldstr instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</para>
          <para>The Common Language Infrastructure (CLI) guarantees that the result of two ldstr instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldstr opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, string) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes a new object reference to a string literal stored in the metadata.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>D0 &lt; T &gt; </para>
              </term>
              <description>
                <para>ldtoken <paramref name="token" /> </para>
              </description>
              <description>
                <para>Converts a metadata token to its runtime representation. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The passed token is converted to a RuntimeHandle and pushed onto the stack.</para>
            </item>
          </list>
          <para>The ldtoken instruction pushes a RuntimeHandle for the specified metadata token. A RuntimeHandle can be a fieldref/fielddef, a methodref/methoddef, or a typeref/typedef.</para>
          <para>The value pushed on the stack can be used in calls to Reflection methods in the system class library.</para>
          <para>For information on runtime handles, see the following classes: <see cref="T:System.RuntimeFieldHandle" />, <see cref="T:System.RuntimeTypeHandle" />, and <see cref="T:System.RuntimeMethodHandle" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overloads can use the ldtoken opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, MethodInfo) </para>
            </item>
            <item>
              <para>ILGenerator.Emit(OpCode, FieldInfo) </para>
            </item>
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 07 &lt; T &gt; </para>
              </term>
              <description>
                <para>ldvirtftn <paramref name="method" /> </para>
              </description>
              <description>
                <para>Pushes the pointer to an object's virtual method <paramref name="method" /> on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference is pushed onto the stack.</para>
            </item>
            <item>
              <para>The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token <paramref name="method" />) is looked up.</para>
            </item>
            <item>
              <para>The pointer to <paramref name="method" /> is pushed onto the stack.</para>
            </item>
          </list>
          <para>The resulting unmanaged pointer pushed onto the stack by the ldvirtftn instruction can be called using the <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</para>
          <para>The unmanaged pointer points to native code using the calling convention specified by in the metadata token <paramref name="method" />. As a result, the method pointer can be passed to unmanaged native code (for example, as a callback routine) if that routine expects the corresponding calling convention.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ldvirtftn opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, MethodInfo) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes an unmanaged pointer (type native int) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>DD &lt; int32 &gt; </para>
              </term>
              <description>
                <para>leave <paramref name="target" /> </para>
              </description>
              <description>
                <para>Exits a protected region of code. </para>
              </description>
            </item>
          </list>
          <para>There is no stack transition behavior specified for this instruction.</para>
          <para>The leave instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>The leave instruction is similar to the br instruction, but it can be used to exit a try, filter, or catch block whereas the ordinary branch instructions can only be used in such a block to transfer control within it. The leave instruction empties the evaluation stack and ensures that the appropriate surrounding finally blocks are executed.</para>
          <para>You cannot use a leave instruction to exit a finally block. To ease code generation for exception handlers it is valid from within a catch block to use a leave instruction to transfer control to any instruction within the associated try block.</para>
          <para>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overloads can use the leave opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Exits a protected region of code, unconditionally transferring control to a specific target instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>DE &lt; int8 &gt; </para>
              </term>
              <description>
                <para>leave.s <paramref name="target" /> </para>
              </description>
              <description>
                <para>Exit a protected region of code, short form. </para>
              </description>
            </item>
          </list>
          <para>There is no stack transition behavior specified for this instruction.</para>
          <para>The leave.s instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</para>
          <para>The leave.s instruction is similar to the br instruction, but it can be used to exit a try, filter, or catch block whereas the ordinary branch instructions can only be used in such a block to transfer control within it. The leave.s instruction empties the evaluation stack and ensures that the appropriate surrounding finally blocks are executed.</para>
          <para>You cannot use a leave.s instruction to exit a finally block. To ease code generation for exception handlers it is valid from within a catch block to use a leave.s instruction to transfer control to any instruction within the associated try block.</para>
          <para>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the leave.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 0F </para>
              </term>
              <description>
                <para>localloc </para>
              </description>
              <description>
                <para>Allocate space from the local heap. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The number of bytes to be allocated is pushed onto the stack.</para>
            </item>
            <item>
              <para>The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</para>
            </item>
            <item>
              <para>A pointer to the first byte of the allocated memory is pushed onto the stack.</para>
            </item>
          </list>
          <para>The localloc instruction allocates <paramref name="size" /> (type natural unsigned int) bytes from the local dynamic memory pool and returns the address (a transient pointer, type *) of the first allocated byte. The block of memory returned is initialized to 0 only if the initialize flag on the method is true. When the current method executes a <see cref="F:System.Reflection.Emit.OpCodes.Ret" />, the local memory pool is made available for reuse.</para>
          <para>The resulting address is aligned so that any primitive data type can be stored there using the stind instructions (such as <see cref="F:System.Reflection.Emit.OpCodes.Stind_I4" />) and loaded using the ldind instructions (such as <see cref="F:System.Reflection.Emit.OpCodes.Ldind_I4" />).</para>
          <para>The localloc instruction cannot occur within a filter, catch, finally, or fault block.</para>
          <para>
            <see cref="T:System.StackOverflowException" /> is thrown if there is insufficient memory to service the request.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the localloc opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type *) of the first allocated byte onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>C6 &lt; T &gt; </para>
              </term>
              <description>
                <para>mkrefany <paramref name="class" /> </para>
              </description>
              <description>
                <para>Pushes a typed reference of type <paramref name="class" /> onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A pointer to piece of data is pushed onto the stack.</para>
            </item>
            <item>
              <para>The pointer is popped and converted to a typed reference of type <paramref name="class" />.</para>
            </item>
            <item>
              <para>The typed reference is pushed onto the stack.</para>
            </item>
          </list>
          <para>The mkrefany instruction supports the passing of dynamically typed references. The pointer must be of type &amp;, *, or native int, and hold the valid address of a piece of data. <paramref name="Class" /> is the class token describing the type of the data referenced by the pointer. Mkrefany pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type <paramref name="class" />.</para>
          <para>The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter. The callee can then use the <see cref="F:System.Reflection.Emit.OpCodes.Refanytype" /> and <see cref="F:System.Reflection.Emit.OpCodes.Refanyval" /> instructions to retrieve the type (class) and the address respectively.</para>
          <para>
            <see cref="T:System.TypeLoadException" /> is thrown if <paramref name="class" /> cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the mkrefany opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes a typed reference to an instance of a specific type onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>5A </para>
              </term>
              <description>
                <para>mul </para>
              </description>
              <description>
                <para>Multiplies two values on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value1" /> is multiplied by <paramref name="value2" />.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The mul instruction multiplies <paramref name="value1" /> by <paramref name="value2" /> and pushes the result on the stack. Integer operations silently truncate the upper bits on overflow.</para>
          <para>See <see cref="F:System.Reflection.Emit.OpCodes.Mul_Ovf" /> for an integer-specific multiply operation with overflow handling.</para>
          <para>For floating-point types, 0 * infinity = NaN.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the mul opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Multiplies two values and pushes the result on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>D8 </para>
              </term>
              <description>
                <para>mul.ovf </para>
              </description>
              <description>
                <para>Multiplies two integer values on the stack with an overflow check. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value1" /> is multiplied by <paramref name="value2" />, with an overflow check.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The mul.ovf instruction multiplies integer <paramref name="value1" /> by integer <paramref name="value2" /> and pushes the result on the stack. An exception is thrown if the result will not fit in the result type.</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the mul.ovf opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>D9 </para>
              </term>
              <description>
                <para>mul.ovf.un </para>
              </description>
              <description>
                <para>Multiplies two unsigned values on the stack with an overflow check. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value1" /> is multiplied by <paramref name="value2" />, with an overflow check.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The mul.ovf.un instruction multiplies unsigned integer <paramref name="value1" /> by unsigned integer <paramref name="value2" /> and pushes the result on the stack. An exception is thrown if the result will not fit in the result type.</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the mul.ovf.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>65 </para>
              </term>
              <description>
                <para>neg </para>
              </description>
              <description>
                <para>Negates the value currently on top of the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is popped from the stack and negated.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The neg instruction negates value and pushes the result on top of the stack. The return type is the same as the operand type.</para>
          <para>Negation of integral values is standard two's complement negation. In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number. To detect this overflow use the <see cref="F:System.Reflection.Emit.OpCodes.Sub_Ovf" /> instruction instead (that is, subtract from 0).</para>
          <para>Negating a floating-point number cannot overflow, and negating NaN returns NaN.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the neg opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Negates a value and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>8D &lt; T &gt; </para>
              </term>
              <description>
                <para>newarr <paramref name="etype" /> </para>
              </description>
              <description>
                <para>Creates a new array with elements of type <paramref name="etype" />. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The number of elements in the array is pushed onto the stack.</para>
            </item>
            <item>
              <para>The number of elements is popped from the stack and the array is created.</para>
            </item>
            <item>
              <para>An object reference to the new array is pushed onto the stack.</para>
            </item>
          </list>
          <para>The newarr instruction pushes an object reference (type O) to a new zero-based, one-dimensional array whose elements are of type <paramref name="etype" /> (a metadata token describing the type). The number of elements in the new array should be specified as a native int. Valid array indexes range from zero to the maximum number of elements minus one.</para>
          <para>The elements of an array can be any type, including value types.</para>
          <para>Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<see cref="T:System.Int32" />, and so on). Elements of the array are initialized to 0 of the appropriate type.</para>
          <para>Nonzero-based one-dimensional arrays and multidimensional arrays are created using <see cref="F:System.Reflection.Emit.OpCodes.Newobj" /> rather than newarr. More commonly, they are created using the methods of the <see cref="T:System.Array" /> class in the .NET Framework.</para>
          <para>
            <see cref="T:System.OutOfMemoryException" /> is thrown if there is insufficient memory to satisfy the request.</para>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if <paramref name="numElems" /> is less than 0.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the newarr opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>73 &lt; T &gt; </para>
              </term>
              <description>
                <para>newobj <paramref name="ctor" /> </para>
              </description>
              <description>
                <para>Allocates an uninitialized object or value type and calls the constructor method <paramref name="ctor" />. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>Arguments <paramref name="arg1" /> through <paramref name="argn" /> are pushed on the stack in sequence.</para>
            </item>
            <item>
              <para>Arguments <paramref name="argn" /> through <paramref name="arg1" /> are popped from the stack and passed to <paramref name="ctor" /> for object creation.</para>
            </item>
            <item>
              <para>A reference to the new object is pushed onto the stack.</para>
            </item>
          </list>
          <para>The newobj instruction creates a new object or a new instance of a value type. <paramref name="Ctor" /> is a metadata token (a methodref or methoddef that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</para>
          <para>The newobj instruction allocates a new instance of the class associated with <paramref name="ctor" /> and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate. It then calls the constructor <paramref name="ctor" /> with the given arguments along with the newly created instance. After the constructor has been called, the now initialized object reference (type O) is pushed on the stack.</para>
          <para>From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</para>
          <para>All zero-based, one-dimensional arrays are created using <see cref="F:System.Reflection.Emit.OpCodes.Newarr" />, not newobj. On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using newobj.</para>
          <para>Value types are not usually created using newobj. They are usually allocated either as arguments or local variables, using newarr (for zero-based, one-dimensional arrays), or as fields of objects. Once allocated, they are initialized using <see cref="F:System.Reflection.Emit.OpCodes.Initobj" />. However, the newobj instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</para>
          <para>
            <see cref="T:System.OutOfMemoryException" /> is thrown if there is insufficient memory to satisfy the request.</para>
          <para>
            <see cref="T:System.MissingMethodException" /> is thrown if a constructor method <paramref name="ctor" /> with the indicated name, class and signature could not be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the newobj opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, ConstructorInfo) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new object or a new instance of a value type, pushing an object reference (type O) onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>00 </para>
              </term>
              <description>
                <para>nop </para>
              </description>
              <description>
                <para>Performs an operation without behavior. </para>
              </description>
            </item>
          </list>
          <para>There is no stack transitional behavior defined for this instruction.</para>
          <para>The nop operation does nothing. It is intended to fill in space if opcodes are patched.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the nop opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Fills space if opcodes are patched. No meaningful operation is performed although a processing cycle can be consumed.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>66 </para>
              </term>
              <description>
                <para>not </para>
              </description>
              <description>
                <para>Computes the bitwise complement of a value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value" /> is popped from the stack and its bitwise complement computed.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The not instruction computes the bitwise complement of an integer value and pushes the result onto the stack. The return type is the same as the operand type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the not opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>60 </para>
              </term>
              <description>
                <para>or </para>
              </description>
              <description>
                <para>Computes the bitwise OR of two integer values, returns an integer. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack and their bitwise OR computed.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The or instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</para>
          <para>Or is an integer-specific operation.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the or opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>26 </para>
              </term>
              <description>
                <para>pop </para>
              </description>
              <description>
                <para>Pops the top value from the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The top value is popped from the stack.</para>
            </item>
          </list>
          <para>The pop instruction removes the top element from the stack.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the pop opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes the value currently on top of the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a reserved instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a reserved instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a reserved instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a reserved instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a reserved instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a reserved instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a reserved instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a reserved instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 1E</para>
              </term>
              <description>
                <para>readonly.</para>
              </description>
              <description>
                <para>Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability. </para>
              </description>
            </item>
          </list>
          <para>This prefix can only appear immediately preceding the ldelema instruction and calls to the special Address method on arrays. Its effect on the subsequent operation is twofold: </para>
          <list type="ordered">
            <item>
              <para>At run time, no type check operation is performed. Note that there is normally an implicit type check for the ldelema and stelem instructions when used on reference type arrays. There is never a run-time type check for value classes, so readonly is a no-op in that case. </para>
            </item>
            <item>
              <para>The verifier treats the result of the address-of operation as a managed pointer with restricted mutability. </para>
            </item>
          </list>
          <para>The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated. For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix). In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only. </para>
          <para>A managed pointer restricted in this fashion can be used only in the following ways:  </para>
          <list type="bullet">
            <item>
              <para>As the <paramref name="object" /> parameter for the ldfld, ldflda, stfld, call, or constrained callvirt instructions.</para>
            </item>
            <item>
              <para>As the <paramref name="pointer" /> parameter to the ldobj instruction or to one of the ldind instructions.</para>
            </item>
            <item>
              <para>As the <paramref name="source" /> parameter to the cpobj instruction. </para>
            </item>
          </list>
          <para>All other operations disallowed, including the stobj, initobj, or mkrefany operations, or any of the stind instructions.  </para>
          <para>The purpose of the readonly prefix is to avoid a type check when fetching an element from an array in generic code. For example, the expression arr[i].m(), where the element type of the array arr is a generic type that has been constrained to have an interface with method m, might compile to the following MSIL.</para>
          <code>ldloc arr
ldloc i
readonly.
ldelema !0    // Loads the pointer to the object.
             // Load the arguments to the call.
constrained. !0
callvirt m</code>
          <para>Without the readonly prefix, the ldelema instruction would perform a type check in the case where !0 was a reference type. Not only is this type check inefficient, but it is semantically incorrect. The type check for ldelema is an exact match, which is too strong. If the array held subclasses of type !0, the code above would fail the type check. </para>
          <para>The address of the array element is fetched, instead of the element itself, in order to have a handle for arr[i] that works for both value types and reference types, and thus can be passed to the constrained callvirt instruction.</para>
          <para>In general it would be unsafe to skip the run-time check if the array held elements of a reference type. To be safe, it is necessary to ensure that no modifications to the array are made through this pointer. The verifier rules ensure this. The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the readonly opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 1D </para>
              </term>
              <description>
                <para>refanytype </para>
              </description>
              <description>
                <para>Pushes the type token stored in a typed reference. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value type reference is pushed onto the stack.</para>
            </item>
            <item>
              <para>The typed reference is popped from the stack and its corresponding type token retrieved.</para>
            </item>
            <item>
              <para>The type token is pushed onto the stack.</para>
            </item>
          </list>
          <para>A typed reference contains a type token and an address to an object instance.</para>
          <para>The refanytype instruction retrieves the type token embedded in the typed reference. See the <see cref="F:System.Reflection.Emit.OpCodes.Mkrefany" /> instruction for information on creating typed references.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the refanytype opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the type token embedded in a typed reference.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>C2 &lt; T &gt; </para>
              </term>
              <description>
                <para>refanyval <paramref name="type" /> </para>
              </description>
              <description>
                <para>Pushes the address stored in a typed reference. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value type reference is pushed onto the stack.</para>
            </item>
            <item>
              <para>The typed reference is popped from the stack and the corresponding address retrieved.</para>
            </item>
            <item>
              <para>The address is pushed onto the stack.</para>
            </item>
          </list>
          <para>A typed reference contains a type token and an address to an object instance.</para>
          <para>The refanyval instruction retrieves the address embedded in the a typed reference. The type embedded in the typed reference supplied on the stack must match the type specified by <paramref name="type" /> (a metadata token, either a typedef or a typeref). See the <see cref="F:System.Reflection.Emit.OpCodes.Mkrefany" /> instruction for related content.</para>
          <para>
            <see cref="T:System.InvalidCastException" /> is thrown if <paramref name="type" /> is not identical to the type stored in the type reference (in this case, <paramref name="type" /> is the class supplied to the <see cref="F:System.Reflection.Emit.OpCodes.Mkrefany" /> instruction that constructed said typed reference).</para>
          <para>
            <see cref="T:System.TypeLoadException" /> is thrown if <paramref name="type" /> cannot be found.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the refanyval opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the address (type &amp;) embedded in a typed reference.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>5D </para>
              </term>
              <description>
                <para>rem </para>
              </description>
              <description>
                <para>Pushes the remainder of dividing <paramref name="value1" /> by <paramref name="value2" /> onto the stack. </para>
              </description>
            </item>
          </list>
          <block subset="none" type="note">
            <para>ReplaceThisText</para>
          </block>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack and the remainder of <paramref name="value1" />div<paramref name="value2" /> computed.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>
            <paramref name="result" /> = <paramref name="value1" />rem<paramref name="value2" /> satisfies the following conditions: </para>
          <para>
            <paramref name="result" /> = <paramref name="value1" /> - <paramref name="value2" /> (<paramref name="value1" />div<paramref name="value2" />), and: </para>
          <para>0 = | <paramref name="result" /> | &lt; | <paramref name="value2" /> |, sign(<paramref name="result" />) = sign(<paramref name="value1" />), where div is the division instruction that truncates towards zero.</para>
          <para>If <paramref name="value2" /> is zero or <paramref name="value1" /> is infinity the result is NaN. If <paramref name="value2" /> is infinity, the result is <paramref name="value1" /> (negated for -infinity).</para>
          <para>Integral operations throw <see cref="T:System.DivideByZeroException" /> if <paramref name="value2" /> is zero.</para>
          <para>Note that on the Intel-based platforms an <see cref="T:System.OverflowException" /> is thrown when computing (minint rem -1).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the rem opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Divides two values and pushes the remainder onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>5E </para>
              </term>
              <description>
                <para>rem.un </para>
              </description>
              <description>
                <para>Pushes the remainder of dividing unsigned <paramref name="value1" /> by unsigned <paramref name="value2" /> onto the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack and the remainder of <paramref name="value1" />div<paramref name="value2" /> computed.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>
            <paramref name="result" /> = <paramref name="value1" />rem.un<paramref name="value2" /> satisfies the following conditions: </para>
          <para>
            <paramref name="result" /> = <paramref name="value1" /> - <paramref name="value2" /> x(<paramref name="value1" />div.un<paramref name="value2" />), and: </para>
          <para>0 = <paramref name="result" /> &lt; <paramref name="value2" />, where div.un is the unsigned division instruction.</para>
          <para>The rem.un instruction computes <paramref name="result" /> and pushes it on the stack. Rem.un treats its arguments as unsigned integers, while <see cref="F:System.Reflection.Emit.OpCodes.Rem" /> treats them as signed integers.</para>
          <para>Rem.un is unspecified for floating-point numbers.</para>
          <para>Integral operations throw <see cref="T:System.DivideByZeroException" /> if <paramref name="value2" /> is zero.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the rem.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Divides two unsigned values and pushes the remainder onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>2A </para>
              </term>
              <description>
                <para>ret </para>
              </description>
              <description>
                <para>Returns from method, possibly returning a value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The return value is popped from the callee evaluation stack.</para>
            </item>
            <item>
              <para>The return value obtained in step 1 is pushed onto the caller evaluation stack.</para>
            </item>
          </list>
          <para>If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</para>
          <para>The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method. The evaluation stack for the current method must be empty except for the value to be returned.</para>
          <para>The ret instruction cannot be used to transfer control out of a try, filter, catch, or finally block. From within a try or catch, use the <see cref="F:System.Reflection.Emit.OpCodes.Leave" /> instruction with a destination of a ret instruction that is outside all enclosing exception blocks. Because the filter and finally blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a filter or finally.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the ret opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 1A </para>
              </term>
              <description>
                <para>rethrow </para>
              </description>
              <description>
                <para>Rethrows the current exception </para>
              </description>
            </item>
          </list>
          <para>No stack transition behavior is defined for this instruction.</para>
          <para>The <paramref name="rethrow" /> instruction is only permitted within the body of a catch handler. It throws the same exception that was caught by this handler.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the rethrow opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Rethrows the current exception.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>62 </para>
              </term>
              <description>
                <para>shl </para>
              </description>
              <description>
                <para>Shifts an integer to the left (shifting in zeros). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The amount of bits to be shifted is pushed onto the stack.</para>
            </item>
            <item>
              <para>The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The shl instruction shifts the value (type int32, int64 or native int) left by the specified number of bits. The number of bits is a value of type int32 or native int. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</para>
          <para>Shl inserts a zero bit in the lowest position on each shift.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the shl opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>63 </para>
              </term>
              <description>
                <para>shr </para>
              </description>
              <description>
                <para>Shifts an integer to the right (shifting in sign). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The amount of bits to be shifted is pushed onto the stack.</para>
            </item>
            <item>
              <para>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The shr.un instruction shifts the value (type int32, int64 or native int) right by the specified number of bits. The number of bits is a value of type int32 or native int. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</para>
          <para>Shr replicates the high order bit on each shift, preserving the sign of the original value in the <paramref name="result" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the shr opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>64 </para>
              </term>
              <description>
                <para>shr.un </para>
              </description>
              <description>
                <para>Shifts an integer to the right (shifting in zeroes). </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The amount of bits to be shifted is pushed onto the stack.</para>
            </item>
            <item>
              <para>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>The shr.un instruction shifts the value (type int32, int64 or native int) right by the specified number of bits. The number of bits is a value of type int32, int64 or native int. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</para>
          <para>Shr.un inserts a zero bit in the highest position on each shift.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the shr.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 1C &lt; T &gt; </para>
              </term>
              <description>
                <para>sizeof <paramref name="valType" /> </para>
              </description>
              <description>
                <para>Push the size, in bytes, of a value type as an unsigned int32. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The size (in bytes) of the supplied value type (<paramref name="valType" />) is pushed onto the stack.</para>
            </item>
          </list>
          <para>
            <paramref name="valType" /> must be a metadata token (a typeref or typedef) that specifies a value type, reference type, or generic type parameter.</para>
          <para>For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value. A generic type parameter can be used only in the body of the type or method that defines it. When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type. </para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the sizeof opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 0B &lt; unsigned int16 &gt; </para>
              </term>
              <description>
                <para>starg <paramref name="num" /> </para>
              </description>
              <description>
                <para>Pops the top value from the stack and stores it in argument slot <paramref name="num" />. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value currently on top of the stack is popped and placed in argument slot <paramref name="num" />.</para>
            </item>
          </list>
          <para>The starg instruction pops a value from the stack and places it in argument slot <paramref name="num" />. The type of the value must match the type of the argument, as specified in the current method's signature.</para>
          <para>For procedures that take a variable argument list, the starg instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</para>
          <para>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument. Floating-point values are rounded from their native size (type F) to the size associated with the argument.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the starg opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, short) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Stores the value on top of the evaluation stack in the argument slot at a specified index.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>10 &lt; unsigned int8 &gt; </para>
              </term>
              <description>
                <para>starg.s <paramref name="num" /> </para>
              </description>
              <description>
                <para>Pops the top value from the stack and stores it in argument slot <paramref name="num" />, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>The value currently on top of the stack is popped and placed in argument slot <paramref name="num" />.</para>
            </item>
          </list>
          <para>The starg.s instruction pops a value from the stack and places it in argument slot <paramref name="num" />. The type of the value must match the type of the argument, as specified in the current method's signature.</para>
          <para>The starg.s instruction provides an efficient encoding for use with the first 256 arguments.</para>
          <para>For procedures that take a variable argument list, the starg.s instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</para>
          <para>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument. Floating-point values are rounded from their native size (type F) to the size associated with the argument.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the starg.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, byte) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>A4 &lt;T&gt;</para>
              </term>
              <description>
                <para>stelem <paramref name="typeTok" /></para>
              </description>
              <description>
                <para>Replaces the array element at the supplied index with a value of type <paramref name="typeTok" /> on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to an array, <paramref name="array" />, is pushed onto the stack.</para>
            </item>
            <item>
              <para>An index value, <paramref name="index" />, to an element in <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value of the type specified in the instruction is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</para>
            </item>
          </list>
          <para>The stelem instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array <paramref name="array" /> with the value. The value has the type specified by the token <paramref name="typeTok" /> in the instruction.</para>
          <para>Arrays are objects, and hence represented by a value of type O. The index is type native int.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stelem opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>9B </para>
              </term>
              <description>
                <para>stelem.i </para>
              </description>
              <description>
                <para>Replaces an array element at the supplied index with the native int value on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to an array, <paramref name="array" />, is pushed onto the stack.</para>
            </item>
            <item>
              <para>A valid index to an element in <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</para>
            </item>
          </list>
          <para>The stelem.i instruction replaces the value of the element <paramref name="index" /> in the one-dimensional array <paramref name="array" /> with the native int value pushed onto the stack.</para>
          <para>Arrays are objects and hence represented by a value of type O. The index is type native int.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stelem.i opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the array element at a given index with the native int value on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>9C </para>
              </term>
              <description>
                <para>stelem.i1 </para>
              </description>
              <description>
                <para>Replaces an array element at the supplied index with the int8 value on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to an array, <paramref name="array" />, is pushed onto the stack.</para>
            </item>
            <item>
              <para>A valid index to an element in <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</para>
            </item>
          </list>
          <para>The stelem.i1 instruction replaces the value of the element <paramref name="index" /> in the one-dimensional array <paramref name="array" /> with the int8 value pushed onto the stack.</para>
          <para>Arrays are objects and hence represented by a value of type O. The index is type native int.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stelem.i1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the array element at a given index with the int8 value on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>9D </para>
              </term>
              <description>
                <para>stelem.i2 </para>
              </description>
              <description>
                <para>Replaces an array element at the supplied index with the int16 value on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to an array, <paramref name="array" />, is pushed onto the stack.</para>
            </item>
            <item>
              <para>A valid index to an element in <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</para>
            </item>
          </list>
          <para>The stelem.i2 instruction replaces the value of the element <paramref name="index" /> in the one-dimensional array <paramref name="array" /> with the int16 value pushed onto the stack.</para>
          <para>Arrays are objects and hence represented by a value of type O. The index is type native int.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stelem.i2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the array element at a given index with the int16 value on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>9E </para>
              </term>
              <description>
                <para>stelem.i4 </para>
              </description>
              <description>
                <para>Replaces an array element at the supplied index with the int32 value on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to an array, <paramref name="array" />, is pushed onto the stack.</para>
            </item>
            <item>
              <para>A valid index to an element in <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</para>
            </item>
          </list>
          <para>The stelem.i4 instruction replaces the value of the element <paramref name="index" /> in the one-dimensional array <paramref name="array" /> with the int32 value pushed onto the stack.</para>
          <para>Arrays are objects and hence represented by a value of type O. The index is type native int.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stelem.i4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the array element at a given index with the int32 value on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>9F </para>
              </term>
              <description>
                <para>stelem.i8 </para>
              </description>
              <description>
                <para>Replaces an array element at the supplied index with the int64 value on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to an array, <paramref name="array" />, is pushed onto the stack.</para>
            </item>
            <item>
              <para>A valid index to an element in <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</para>
            </item>
          </list>
          <para>The stelem.i8 instruction replaces the value of the element <paramref name="index" /> in the one-dimensional array <paramref name="array" /> with the int64 value pushed onto the stack.</para>
          <para>Arrays are objects and hence represented by a value of type O. The index is type native int.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stelem.i8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the array element at a given index with the int64 value on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>A0 </para>
              </term>
              <description>
                <para>stelem.r4 </para>
              </description>
              <description>
                <para>Replaces an array element at the supplied index with the float32 value on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to an array, <paramref name="array" />, is pushed onto the stack.</para>
            </item>
            <item>
              <para>A valid index to an element in <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</para>
            </item>
          </list>
          <para>The stelem.r4 instruction replaces the value of the element <paramref name="index" /> in the one-dimensional array <paramref name="array" /> with the float32 value pushed onto the stack.</para>
          <para>Arrays are objects and hence represented by a value of type O. The index is type native int.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stelem.r4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the array element at a given index with the float32 value on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>A1 </para>
              </term>
              <description>
                <para>stelem.r8 </para>
              </description>
              <description>
                <para>Replaces an array element at the supplied index with the float64 value on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to an array, <paramref name="array" />, is pushed onto the stack.</para>
            </item>
            <item>
              <para>A valid index to an element in <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</para>
            </item>
          </list>
          <para>The stelem.r8 instruction replaces the value of the element <paramref name="index" /> in the one-dimensional array <paramref name="array" /> with the float64 value pushed onto the stack.</para>
          <para>Arrays are objects and hence represented by a value of type O. The index is type native int.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stelem.r8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the array element at a given index with the float64 value on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>A2 </para>
              </term>
              <description>
                <para>stelem.ref </para>
              </description>
              <description>
                <para>Replaces an array element at the supplied index with the ref value (type O) on the stack. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference to an array, <paramref name="array" />, is pushed onto the stack.</para>
            </item>
            <item>
              <para>A valid index to an element in <paramref name="array" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</para>
            </item>
          </list>
          <para>The stelem.ref instruction replaces the value of the element at the supplied index in the one-dimensional array <paramref name="array" /> with the ref (type O) value pushed onto the stack.</para>
          <para>Arrays are objects and hence represented by a value of type O. The index is type native int.</para>
          <para>Note that stelem.ref implicitly casts the supplied value to the element type of <paramref name="array" /> before assigning the value to the array element. This cast can fail, even for verified code. Thus the stelem.ref instruction can throw <see cref="T:System.InvalidCastException" />. For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <see cref="T:System.Array" /> class provides a <see cref="M:System.Array.SetValue(System.Object,System.Int32)" /> method.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="array" /> is a null reference.</para>
          <para>
            <see cref="T:System.IndexOutOfRangeException" /> is thrown if <paramref name="index" /> is negative, or larger than the bound of <paramref name="array" />.</para>
          <para>
            <see cref="T:System.ArrayTypeMismatchException" /> is thrown if <paramref name="array" /> does not hold elements of the required type.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stelem.ref opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the array element at a given index with the object ref value (type O) on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>7D &lt; T &gt; </para>
              </term>
              <description>
                <para>stfld <paramref name="field" /> </para>
              </description>
              <description>
                <para>Replaces the value of <paramref name="field" /> of the object with a new value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference or pointer is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value and the object reference/pointer are popped from the stack; the value of <paramref name="field" /> in the object is replaced with the supplied value.</para>
            </item>
          </list>
          <para>The stfld instruction replaces the value of a field of an object (type O) or via a pointer (type native int, &amp;, or *) with a given value. <paramref name="Field" /> is a metadata token that refers to a field member reference. The stfld instruction can have a prefix of either or both of <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> and <see cref="F:System.Reflection.Emit.OpCodes.Volatile" />.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if the object reference or pointer is a null reference and the field isn't static.</para>
          <para>
            <see cref="T:System.MissingFieldException" /> is thrown if <paramref name="field" /> is not found in the metadata. This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stfld opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, FieldInfo) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the value stored in the field of an object reference or pointer with a new value.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>DF </para>
              </term>
              <description>
                <para>stind.i </para>
              </description>
              <description>
                <para>Stores a native int value at a given address. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value and the address are popped from the stack; the value is stored at the address.</para>
            </item>
          </list>
          <para>The stind.i instruction stores a native int value at the supplied address (type native int, *, or &amp;).</para>
          <para>Type safe operation requires that the stind.i instruction be used in a manner consistent with the type of the pointer. The operation of the stind.i instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="addr" /> is not naturally aligned for the argument type implied by the instruction suffix.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stind.i opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Stores a value of type native int at a supplied address.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>52 </para>
              </term>
              <description>
                <para>stind.i1 </para>
              </description>
              <description>
                <para>Stores an int8 value at a given address. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value and the address are popped from the stack; the value is stored at the address.</para>
            </item>
          </list>
          <para>The stind.i1 instruction stores an int8 value at the supplied address (type native int, *, or &amp;).</para>
          <para>Type safe operation requires that the stind.i1 instruction be used in a manner consistent with the type of the pointer. The operation of the stind.i1 instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="addr" /> is not naturally aligned for the argument type implied by the instruction suffix.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stind.i1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Stores a value of type int8 at a supplied address.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>53 </para>
              </term>
              <description>
                <para>stind.i2 </para>
              </description>
              <description>
                <para>Stores an int16 value at a given address. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value and the address are popped from the stack; the value is stored at the address.</para>
            </item>
          </list>
          <para>The stind.i2 instruction stores an int16 value at the supplied address (type native int, *, or &amp;).</para>
          <para>Type safe operation requires that the stind.2i instruction be used in a manner consistent with the type of the pointer. The operation of the stind.i2 instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="addr" /> is not naturally aligned for the argument type implied by the instruction suffix.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stind.i2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Stores a value of type int16 at a supplied address.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>54 </para>
              </term>
              <description>
                <para>stind.i4 </para>
              </description>
              <description>
                <para>Stores an int32 value at a given address. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value and the address are popped from the stack; the value is stored at the address.</para>
            </item>
          </list>
          <para>The stind.i4 instruction stores an int32 value at the supplied address (type native int, *, or &amp;).</para>
          <para>Type safe operation requires that the stind.i4 instruction be used in a manner consistent with the type of the pointer. The operation of the stind.i4 instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="addr" /> is not naturally aligned for the argument type implied by the instruction suffix.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stind.i4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Stores a value of type int32 at a supplied address.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>55 </para>
              </term>
              <description>
                <para>stind.i8 </para>
              </description>
              <description>
                <para>Stores an int64 value at a given address. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value and the address are popped from the stack; the value is stored at the address.</para>
            </item>
          </list>
          <para>The stind.i8 instruction stores an int64 value at the supplied address (type native int, *, or &amp;).</para>
          <para>Type safe operation requires that the stind.i8 instruction be used in a manner consistent with the type of the pointer. The operation of the stind.i instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="addr" /> is not naturally aligned for the argument type implied by the instruction suffix.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stind.i8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Stores a value of type int64 at a supplied address.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>56 </para>
              </term>
              <description>
                <para>stind.r4 </para>
              </description>
              <description>
                <para>Stores a float32 value at a given address. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value and the address are popped from the stack; the value is stored at the address.</para>
            </item>
          </list>
          <para>The stind.r4 instruction stores a float32 value at the supplied address (type native int, *, or &amp;).</para>
          <para>Type safe operation requires that the stind.r4 instruction be used in a manner consistent with the type of the pointer. The operation of the stind.r4 instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="addr" /> is not naturally aligned for the argument type implied by the instruction suffix.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stind.r4 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Stores a value of type float32 at a supplied address.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>57 </para>
              </term>
              <description>
                <para>stind.r8 </para>
              </description>
              <description>
                <para>Stores a float64 value at a given address. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value and the address are popped from the stack; the value is stored at the address.</para>
            </item>
          </list>
          <para>The stind.r8 instruction stores a float64 value at the supplied address (type native int, *, or &amp;).</para>
          <para>Type safe operation requires that the stind.r8 instruction be used in a manner consistent with the type of the pointer. The operation of the stind.r8 instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="addr" /> is not naturally aligned for the argument type implied by the instruction suffix.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stind.r8 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Stores a value of type float64 at a supplied address.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>51 </para>
              </term>
              <description>
                <para>stind.ref </para>
              </description>
              <description>
                <para>Stores an object reference (type O) value at a given address. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value and the address are popped from the stack; the value is stored at the address.</para>
            </item>
          </list>
          <para>The stind.ref instruction stores an object reference value at the supplied address (type native int, *, or &amp;).</para>
          <para>Type safe operation requires that the stind.ref instruction be used in a manner consistent with the type of the pointer. The operation of the stind.ref instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="addr" /> is not naturally aligned for the argument type implied by the instruction suffix.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stind.ref opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Stores a object reference value at a supplied address.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 0E &lt; unsigned int16 &gt; </para>
              </term>
              <description>
                <para>stloc <paramref name="index" /> </para>
              </description>
              <description>
                <para>Pops a value from the stack and stores it in local variable <paramref name="index" />. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is popped off of the stack and placed in local variable <paramref name="index" />.</para>
            </item>
          </list>
          <para>The stloc instruction pops the top value off the evaluation stack and moves it into local variable number <paramref name="index" />, where local variables are numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's local signature.</para>
          <para>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type F) to the size associated with the argument.</para>
          <para>Correct Microsoft Intermediate Language (MSIL) instructions require that <paramref name="index" /> be a valid local index. For the stloc instruction, <paramref name="index" /> must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid). The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method. If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overloads can use the stloc opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, LocalBuilder) </para>
            </item>
            <item>
              <para>ILGenerator.Emit(OpCode, short) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>0A </para>
              </term>
              <description>
                <para>stloc.0 </para>
              </description>
              <description>
                <para>Pops a value from the stack into local variable 0. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is popped off of the stack and placed in the local variable indexed by 0.</para>
            </item>
          </list>
          <para>The stloc.0 instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0. The type of the value must match the type of the local variable as specified in the current method's local signature.</para>
          <para>stloc.0 is an especially efficient encoding for storing values in local variable 0.</para>
          <para>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type F) to the size associated with the argument.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stloc.0 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>0B </para>
              </term>
              <description>
                <para>stloc.1 </para>
              </description>
              <description>
                <para>Pops a value from the stack into local variable 1. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is popped off of the stack and placed in the local variable indexed by 1.</para>
            </item>
          </list>
          <para>The stloc.1 instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1. The type of the value must match the type of the local variable as specified in the current method's local signature.</para>
          <para>stloc.1 is an especially efficient encoding for storing values in local variable 1.</para>
          <para>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type F) to the size associated with the argument.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stloc.1 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>0C </para>
              </term>
              <description>
                <para>stloc.2 </para>
              </description>
              <description>
                <para>Pops a value from the stack into local variable 2 </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is popped off of the stack and placed in the local variable indexed by 2.</para>
            </item>
          </list>
          <para>The stloc.2 instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2. The type of the value must match the type of the local variable as specified in the current method's local signature.</para>
          <para>stloc.2 is an especially efficient encoding for storing values in local variable 2.</para>
          <para>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type F) to the size associated with the argument.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stloc.2 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>0D </para>
              </term>
              <description>
                <para>stloc.3 </para>
              </description>
              <description>
                <para>Pops a value from the stack into local variable 3 </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is popped off of the stack and placed in the local variable indexed by 3.</para>
            </item>
          </list>
          <para>The stloc.3 instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3. The type of the value must match the type of the local variable as specified in the current method's local signature.</para>
          <para>stloc.3 is an especially efficient encoding for storing values in local variable 3.</para>
          <para>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type F) to the size associated with the argument.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stloc.3 opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>13 &lt; unsigned int8 &gt; </para>
              </term>
              <description>
                <para>stloc.s <paramref name="index" /> </para>
              </description>
              <description>
                <para>Pops a value from the stack and stores it in local variable <paramref name="index" />, short form. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is popped off of the stack and placed in local variable <paramref name="index" />.</para>
            </item>
          </list>
          <para>The stloc.s instruction pops the top value off the evaluation stack and moves it into local variable number <paramref name="index" />, where local variables are numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's local signature.</para>
          <para>The stloc.s instruction provides an efficient encoding for local variables 0 through 255.</para>
          <para>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type F) to the size associated with the argument.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overloads can use the stloc.s opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, LocalBuilder) </para>
            </item>
            <item>
              <para>ILGenerator.Emit(OpCode, byte) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>81 &lt; T &gt; </para>
              </term>
              <description>
                <para>stobj <paramref name="class" /> </para>
              </description>
              <description>
                <para>Stores a value of type <paramref name="class" /> from the stack into memory. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value type object of type <paramref name="class" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>The object and the address are popped from the stack; the value type object is stored at the address.</para>
            </item>
          </list>
          <para>The stobj instruction copies the value type object into the address specified by the address (a pointer of type native int, *, or &amp;). The number of bytes copied depends on the size of the class represented by <paramref name="class" />, a metadata token representing a value type.</para>
          <para>The operation of the stobj instruction can be altered by an immediately preceding <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> or <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> prefix instruction.</para>
          <para>
            <see cref="T:System.TypeLoadException" /> is thrown if class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stobj opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies a value of a specified type from the evaluation stack into a supplied memory address.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>80 &lt; T &gt; </para>
              </term>
              <description>
                <para>stsfld <paramref name="field" /> </para>
              </description>
              <description>
                <para>Replaces the value in <paramref name="field" /> with a supplied value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>A value is popped from the stack and stored in <paramref name="field" />.</para>
            </item>
          </list>
          <para>The stsfld instruction replaces the value of a static field with a value from the stack. <paramref name="field" /> is a metadata token that must refer to a static field member.</para>
          <para>The stsfld instruction may be prefixed by <see cref="F:System.Reflection.Emit.OpCodes.Volatile" />.</para>
          <para>
            <see cref="T:System.MissingFieldException" /> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the stsfld opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, FieldInfo) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the value of a static field with a value from the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>59 </para>
              </term>
              <description>
                <para>sub </para>
              </description>
              <description>
                <para>Subtracts one value from another, returning a new numeric value. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value2" /> is subtracted from <paramref name="value1" />.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>Overflow is not detected for integer operations (for proper overflow handling, see <see cref="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />).</para>
          <para>Integer subtraction wraps, rather than saturates. For example: assuming 8-bit integers, where <paramref name="value1" /> is set to 0 and <paramref name="value2" /> is set to 1, the "wrapped" result will be 255.</para>
          <para>Floating-point overflow returns +inf (PositiveInfinity) or -inf (NegativeInfinity).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the sub opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Subtracts one value from another and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>DA </para>
              </term>
              <description>
                <para>sub.ovf </para>
              </description>
              <description>
                <para>Subtracts one integer value from another with an overflow check. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value2" /> is subtracted from <paramref name="value1" /> with a check for overflow.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>This operation is performed on signed integers; for floating-point values, use <see cref="F:System.Reflection.Emit.OpCodes.Sub" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the sub.ovf opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>DB </para>
              </term>
              <description>
                <para>sub.ovf.un </para>
              </description>
              <description>
                <para>Subtracts one unsigned integer value from another with an overflow check. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack; <paramref name="value2" /> is subtracted from <paramref name="value1" /> with a check for overflow.</para>
            </item>
            <item>
              <para>The result is pushed onto the stack.</para>
            </item>
          </list>
          <para>
            <see cref="T:System.OverflowException" /> is thrown if the result can not be represented in the result type.</para>
          <para>This operation is performed on signed integers; for floating-point values, use <see cref="F:System.Reflection.Emit.OpCodes.Sub" />.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the sub.ovf.un opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>45 &lt; unsigned int32 &gt; &lt; int32 &gt;... &lt; int32 &gt; </para>
              </term>
              <description>
                <para>switch (<paramref name="N" />, <paramref name="t1" />, <paramref name="t2" />... <paramref name="tN" />) </para>
              </description>
              <description>
                <para>Jumps to one of <paramref name="N" /> values. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>A value is pushed onto the stack.</para>
            </item>
            <item>
              <para>The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than <paramref name="N" />.</para>
            </item>
          </list>
          <para>The switch instruction implements a jump table. The format of the instruction is an unsigned int32 representing the number of targets <paramref name="N" />, followed by <paramref name="N" /> int32 values specifying jump targets. These targets are represented as offsets (positive or negative) from the beginning of the instruction following this switch instruction.</para>
          <para>The switch instruction pops a value off the stack and compares it, as an unsigned integer, to <paramref name="N" />. If value is less than <paramref name="N" />, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on). If the value is greater than or equal to <paramref name="N" />, execution continues at the next instruction (fall through).</para>
          <para>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</para>
          <para>Control transfers into and out of try, catch, filter, and finally blocks cannot be performed by this instruction. (Such transfers are severely restricted and must use the leave instruction instead).</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the switch opcode. The <paramref name="Label[]" /> argument is an array of Labels representing 32-bit offsets.</para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label[]) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Implements a jump table.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 14 </para>
              </term>
              <description>
                <para>tail. </para>
              </description>
              <description>
                <para>Subsequent call terminates current methods </para>
              </description>
            </item>
          </list>
          <para>There is no stack transition behavior defined for this instruction.</para>
          <para>The tail prefix instruction must immediately precede a <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Calli" />, or <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" /> instruction. It indicates that the current method's stack frame should be removed before the call instruction is executed. It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</para>
          <para>The stack must be empty except for the arguments being transferred by the following call. The instruction following the call instruction must be a ret. Thus the only valid code sequence is tail. call (or calli or callvirt). Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the call instruction, but they may branch to the subsequent <see cref="F:System.Reflection.Emit.OpCodes.Ret" />.</para>
          <para>The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security. The .NET Framework security checks can therefore cause the tail to be ignored, leaving a standard <see cref="F:System.Reflection.Emit.OpCodes.Call" /> instruction. Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the tail prefix is ignored when used to exit a method that is marked synchronized.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the tail opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</para>
          <para>TakesSingleByteArgument returns true if the <see cref="T:System.Reflection.Emit.OpCode" /> instance takes a single byte argument in the following cases: </para>
          <list type="bullet">
            <item>
              <para>The opcode performs a branch instruction to a byte-sized address (for example, <see cref="F:System.Reflection.Emit.OpCodes.Br_S" /> and <see cref="F:System.Reflection.Emit.OpCodes.Bgt_S" />).</para>
            </item>
            <item>
              <para>The opcode pushes a byte value onto the stack (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />).</para>
            </item>
            <item>
              <para>The opcode references a variable or argument via the byte-sized "short form" (for example, <see cref="F:System.Reflection.Emit.OpCodes.Ldloc_S" /> and <see cref="F:System.Reflection.Emit.OpCodes.Stloc_S" />).</para>
            </item>
          </list>
          <para>Otherwise, it returns false.</para>
          <para>The example below demonstrates the use of TakesSingleByteArgument by reflecting on to the OpCodes class and testing to see whether each OpCode field takes a single-byte argument.</para>
          <para>code reference: System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns true or false if the supplied opcode takes a single byte argument.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>True or false.</para>
        </returns>
        <param name="inst">
          <attribution license="cc4" from="Microsoft" modified="false" />An instance of an Opcode object. </param>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>7A </para>
              </term>
              <description>
                <para>throw </para>
              </description>
              <description>
                <para>Throws an exception. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference (to an exception) is pushed onto the stack.</para>
            </item>
            <item>
              <para>The object reference is popped from the stack and the exception thrown.</para>
            </item>
          </list>
          <para>The throw instruction throws the exception object (type O) currently on the stack.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if the object reference is a null reference.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the throw opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Throws the exception object currently on the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 12 &lt; unsigned int8 &gt; </para>
              </term>
              <description>
                <para>unaligned. <paramref name="alignment" /> </para>
              </description>
              <description>
                <para>Indicates that the subsequent pointer instruction may be unaligned. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
          </list>
          <para>Unaligned specifies that the address (an unmanaged pointer, native int) on the stack might not be aligned to the natural size of the immediately following ldind, stind, ldfld, stfld, ldobj, stobj, initblk, or cpblk instruction. That is, for a <see cref="F:System.Reflection.Emit.OpCodes.Ldind_I4" /> instruction the alignment of the address may not be to a 4-byte boundary. For initblk and cpblk the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs). Code generators that do not restrict their output to a 32-bit word size must use unaligned if the alignment is not known at compile time to be 8-byte.</para>
          <para>The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively. Note that transient pointers (type *) are always aligned.</para>
          <para>While the alignment for a cpblk instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</para>
          <para>The unaligned and volatile prefixes can be combined in either order. They must immediately precede a ldind, stind, ldfld, stfld, ldobj, stobj, initblk, or cpblk instruction. Only the <see cref="F:System.Reflection.Emit.OpCodes.Volatile" /> prefix is allowed for the <see cref="F:System.Reflection.Emit.OpCodes.Ldsfld" /> and <see cref="F:System.Reflection.Emit.OpCodes.Stsfld" /> instructions.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overloads can use the unaligned opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Label) </para>
            </item>
            <item>
              <para>ILGenerator.Emit(Opcode, Byte) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following ldind, stind, ldfld, stfld, ldobj, stobj, initblk, or cpblk instruction.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>79 &lt; T &gt; </para>
              </term>
              <description>
                <para>unbox <paramref name="valType" /> </para>
              </description>
              <description>
                <para>Extracts the value type data from <paramref name="obj" />, its boxed representation. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference is pushed onto the stack.</para>
            </item>
            <item>
              <para>The object reference is popped from the stack and unboxed to a value type pointer.</para>
            </item>
            <item>
              <para>The value type pointer is pushed onto the stack.</para>
            </item>
          </list>
          <para>A value type has two separate representations within the Common Language Infrastructure (CLI): </para>
          <list type="bullet">
            <item>
              <para>A 'raw' form used when a value type is embedded within another object.</para>
            </item>
            <item>
              <para>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</para>
            </item>
          </list>
          <para>The unbox instruction converts the object reference (type O), the boxed representation of a value type, to a value type pointer (a managed pointer, type &amp;), its unboxed form. The supplied value type (<paramref name="valType" />) is a metadata token indicating the type of value type contained within the boxed object.</para>
          <para>Unlike <see cref="F:System.Reflection.Emit.OpCodes.Box" />, which is required to make a copy of a value type for use in the object, unbox is not required to copy the value type from the object. Typically it simply computes the address of the value type that is already present inside of the boxed object.</para>
          <para>
            <see cref="T:System.InvalidCastException" /> is thrown if the object is not boxed as <paramref name="valType" />.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if the object reference is a null reference.</para>
          <para>
            <see cref="T:System.TypeLoadException" /> is thrown if the value type <paramref name="valType" /> cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the unbox opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the boxed representation of a value type to its unboxed form.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>A5 &lt;T&gt; </para>
              </term>
              <description>
                <para>unbox.any <paramref name="typeTok" /> </para>
              </description>
              <description>
                <para>Extract the data from <paramref name="obj" />, its boxed representation. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An object reference <paramref name="obj" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>The object reference is popped from the stack and unboxed to the type specified in the instruction.</para>
            </item>
            <item>
              <para>The resulting object reference or value type is pushed onto the stack.</para>
            </item>
          </list>
          <para>When applied to the boxed form of a value type, the unbox.any instruction extracts the value contained within <paramref name="obj" /> (of type O), and is therefore equivalent to unbox followed by ldobj.</para>
          <para>When applied to a reference type, the unbox.any instruction has the same effect as castclass <paramref name="typeTok" />.</para>
          <para>If the operand <paramref name="typeTok" /> is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</para>
          <para>
            <see cref="T:System.InvalidCastException" /> is thrown if <paramref name="obj" /> is not a boxed type.</para>
          <para>
            <see cref="T:System.NullReferenceException" /> is thrown if <paramref name="obj" /> is a null reference.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the unbox.any opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode, Type) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the boxed representation of a type specified in the instruction to its unboxed form. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>FE 13 </para>
              </term>
              <description>
                <para>volatile. </para>
              </description>
              <description>
                <para>Indicates that the subsequent pointer reference is volatile. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>An address is pushed onto the stack.</para>
            </item>
          </list>
          <para>volatile. specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed. Marking an access as volatile affects only that single access; other accesses to the same location must be marked separately. Access to volatile locations need not be performed atomically.</para>
          <para>The <see cref="F:System.Reflection.Emit.OpCodes.Unaligned" /> and volatile prefixes can be combined in either order. They must immediately precede a ldind, stind, ldfld, stfld, ldobj, stobj, initblk, or cpblk instruction. Only the volatile prefix is allowed for the <see cref="F:System.Reflection.Emit.OpCodes.Ldsfld" /> and <see cref="F:System.Reflection.Emit.OpCodes.Stsfld" /> instructions.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the volatile opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Format </para>
                </term>
                <description>
                  <para>Assembly Format </para>
                </description>
                <description>
                  <para>Description </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>61 </para>
              </term>
              <description>
                <para>xor </para>
              </description>
              <description>
                <para>Computes the bitwise XOR of two integer values and returns an integer. </para>
              </description>
            </item>
          </list>
          <para>The stack transitional behavior, in sequential order, is: </para>
          <list type="ordered">
            <item>
              <para>
                <paramref name="value1" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> is pushed onto the stack.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack and their bitwise XOR computed.</para>
            </item>
            <item>
              <para>
                <paramref name="value2" /> and <paramref name="value1" /> are popped from the stack and their bitwise XOR computed.</para>
            </item>
          </list>
          <para>The xor instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</para>
          <para>Xor is an integer-specific operation.</para>
          <para>The following <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> method overload can use the xor opcode: </para>
          <list type="bullet">
            <item>
              <para>ILGenerator.Emit(OpCode) </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</para>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>