<?xml version="1.0" encoding="utf-8"?>
<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission" FullNameSP="System_Security_CodeAccessPermission" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public abstract serializable CodeAccessPermission extends System.Object implements System.Security.IPermission" />
  <TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission. If a permission object is null, it is handled the same as a permission object with the state <see cref="F:System.Security.Permissions.PermissionState.None" />.</para>
      <para>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</para>
      <para>Inheritors of the <see cref="T:System.Security.CodeAccessPermission" /> class must be granted full trust to function correctly as permissions extending the security infrastructure. To determine that the inheritors are fully trusted, <see cref="T:System.Security.CodeAccessPermission" /> issues an <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /> for <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> = true and <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" /> = true.</para>
      <para>For more information on inheritance demands, see <format type="text/html"><a href="28B9ADBB-8F08-4F10-B856-DBF59EB932D9">Inheritance Demands</a></format>.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Defines the underlying structure of all code access permissions.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="family specialname instance void .ctor()" />
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor is called to initialize state in the type whenever an instance of the derived class is created. Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Security.CodeAccessPermission" /> class. </para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual void Assert()" />
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <exception cref="T:System.Security.SecurityException">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" qualify="true" />. </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Requires permission to call <see cref="M:System.Security.CodeAccessPermission.Assert" />. See <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack. Calling <see cref="M:System.Security.CodeAccessPermission.Assert" /> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method. Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission. An assertion is effective only if the code that calls <see cref="M:System.Security.CodeAccessPermission.Assert" /> passes the security check for the permission that it is asserting.</para>
          <para>The call to <see cref="M:System.Security.CodeAccessPermission.Assert" /> is effective until the calling code returns to its caller. Only one <see cref="M:System.Security.CodeAccessPermission.Assert" /> can be active on a frame. An attempt to call <see cref="M:System.Security.CodeAccessPermission.Assert" /> when an active <see cref="M:System.Security.CodeAccessPermission.Assert" /> exists on the frame results in a <see cref="T:System.Security.SecurityException" />. Call <see cref="M:System.Security.CodeAccessPermission.RevertAssert" /> or <see cref="M:System.Security.CodeAccessPermission.RevertAll" /> to remove an active <see cref="M:System.Security.CodeAccessPermission.Assert" />.</para>
          <para>
            <see cref="M:System.Security.CodeAccessPermission.Assert" /> is ignored for a permission not granted because a demand for that permission will not succeed. However, if code lower on the call stack calls <see cref="M:System.Security.CodeAccessPermission.Demand" /> for that permission, a <see cref="T:System.Security.SecurityException" /> is thrown when the stack walk reaches the code that tried to call <see cref="M:System.Security.CodeAccessPermission.Assert" />. This happens because the code that called <see cref="M:System.Security.CodeAccessPermission.Assert" /> has not been granted the permission, even though it tried to <see cref="M:System.Security.CodeAccessPermission.Assert" /> it.</para>
          <block subset="none" type="note">
            <para>Because calling <see cref="M:System.Security.CodeAccessPermission.Assert" /> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately. Therefore, it should be used with great caution.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource. Using <see cref="M:System.Security.CodeAccessPermission.Assert" /> can create security issues.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Security.IPermission Copy()" />
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A copy of a permission object represents the same access to resources as the original permission object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When implemented by a derived class, creates and returns an identical copy of the current permission object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A copy of the current permission object.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual void Demand()" />
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <exception cref="T:System.Security.SecurityException">
          <para> A caller does not have the permission specified by the current instance.</para>
          <para>-or-</para>
          <para> A caller has called <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the resource protected by the current instance. </para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is typically used by secure libraries to ensure that callers have permission to access a resource. For example, a file class in a secure class library calls <see cref="M:System.Security.CodeAccessPermission.Demand" /> for the necessary <see cref="T:System.Security.Permissions.FileIOPermission" /> before performing a file operation requested by the caller.</para>
          <para>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack. <see cref="M:System.Security.CodeAccessPermission.Demand" /> succeeds only if no <see cref="T:System.Security.SecurityException" /> is raised.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Forces a <see cref="T:System.Security.SecurityException" /> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual void Deny()" />
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>The <see cref="M:System.Security.CodeAccessPermission.Deny" /> method should be used only to protect resources from accidental access by fully trusted code. It should not be used to protect resources from intentional misuse by untrusted code. For example, if method A issues a <see cref="M:System.Security.CodeAccessPermission.Deny" /> for a permission and then calls method B, method B can overtly override the <see cref="M:System.Security.CodeAccessPermission.Deny" /> by issuing an <see cref="M:System.Security.CodeAccessPermission.Assert" />. The called method is always higher in the stack. Therefore, if method B tries to access a protected resource, the security system begins checking for permissions with it because method B is the immediate caller, and then walks down the stack to confirm that there is no <see cref="M:System.Security.CodeAccessPermission.Deny" /> or <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> lower in the stack. Method B, which is trying to access the resource, can stop the stack walk immediately by using the <see cref="M:System.Security.CodeAccessPermission.Assert" /> method. In that case, the <see cref="M:System.Security.CodeAccessPermission.Deny" /> placed on the stack by method A (the calling method) is never discovered.</para>
          </block>
          <para>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack. </para>
          <para>
            <see cref="M:System.Security.CodeAccessPermission.Deny" /> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <see cref="M:System.Security.CodeAccessPermission.Deny" /> from being used to access the resource protected by the denied permission. If a method calls <see cref="M:System.Security.CodeAccessPermission.Deny" /> on a permission, and if a <see cref="M:System.Security.CodeAccessPermission.Demand" /> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <see cref="M:System.Security.CodeAccessPermission.Deny" />.</para>
          <para>The call to <see cref="M:System.Security.CodeAccessPermission.Deny" /> is effective until the calling code returns to its caller. Only one <see cref="M:System.Security.CodeAccessPermission.Deny" /> can be active on a frame. An attempt to call <see cref="M:System.Security.CodeAccessPermission.Deny" /> when an active <see cref="M:System.Security.CodeAccessPermission.Deny" /> exists on the frame results in a <see cref="T:System.Security.SecurityException" />. Call <see cref="M:System.Security.CodeAccessPermission.RevertDeny" /> or <see cref="M:System.Security.CodeAccessPermission.RevertAll" /> to remove an active <see cref="M:System.Security.CodeAccessPermission.Deny" />. <see cref="M:System.Security.CodeAccessPermission.Deny" /> is ignored for a permission not granted because a demand for that permission will not succeed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For more information, see <see cref="M:System.Object.Equals(System.Object)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />; otherwise, false.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Security.CodeAccessPermission" /> object to compare with the current <see cref="T:System.Security.CodeAccessPermission" />. </param>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract void FromXml(class System.Security.SecurityElement elem)" />
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="elem" /> does not contain the XML encoding for a instance of the same type as the current instance.</para>
          <para>-or-</para>
          <para>The version number of <paramref name="elem" /> is not valid.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Custom code that extends security objects needs to implement the <see cref="M:System.Security.CodeAccessPermission.ToXml" /> and <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /> methods to make the objects security-encodable.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</para>
        </summary>
        <param name="elem">
          <attribution license="cc4" from="Microsoft" modified="false" />The XML encoding to use to reconstruct the security object. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <see cref="T:System.Security.CodeAccessPermission" /> objects.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a hash code for the <see cref="T:System.Security.CodeAccessPermission" /> object that is suitable for use in hashing algorithms and data structures such as a hash table.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A hash code for the current <see cref="T:System.Security.CodeAccessPermission" /> object.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Security.IPermission Intersect(class System.Security.IPermission target)" />
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not <see langword="null" /> and is not a <see cref="T:System.Security.CodeAccessPermission" /> object.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The intersection of two permissions is a permission that describes the set of operations they both describe in common. Only a demand that passes both original permissions will pass the intersection.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new permission that represents the intersection of the current permission and the specified permission. This new permission is null if the intersection is empty.</para>
        </returns>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />A permission to intersect with the current permission. It must be of the same type as the current permission. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract bool IsSubsetOf(class System.Security.IPermission target)" />
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not <see langword="null" /> and is not of type <see cref="T:System.Security.CodeAccessPermission" /> .</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission. For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:\. If this method returns true, the current permission represents no more access to the protected resource than does the specified permission.</para>
          <para>The following statements are required to be true for all overrides of the <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" /> method. X, Y, and Z represent custom code access permission objects that are not null references, U represents an unrestricted code access permission, and N represents an empty permission with a <see cref="T:System.Security.Permissions.PermissionState" /> of <see cref="F:System.Security.Permissions.PermissionState.None" />.</para>
          <list type="bullet">
            <item>
              <para>X.IsSubsetOf(X) returns true.</para>
            </item>
            <item>
              <para>X.IsSubsetOf(Y) returns the same value as Y.IsSubsetOf(X) if and only if X and Y represent the same set of permissions.</para>
            </item>
            <item>
              <para>If X.IsSubsetOf(Y) and Y.IsSubsetOf(Z) both return true, X.IsSubsetOf(Z) returns true.</para>
            </item>
            <item>
              <para>X.IsSubsetOf(U) returns true.</para>
            </item>
            <item>
              <para>X.IsSubsetOf(N) returns false.</para>
            </item>
            <item>
              <para>N.IsSubsetOf(X) returns true.</para>
            </item>
          </list>
          <para>If X and Y represent custom code access permission objects that are null references, X.IsSubsetOf(Y) returns true. If Z is also null, the compound set operation X.Union(Y).IsSubsetOf(Z) also returns true because the union of two null permissions is a null permission.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current permission is a subset of the specified permission; otherwise, false.</para>
        </returns>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />A permission that is to be tested for the subset relationship. This permission must be of the same type as the current permission. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>The <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> method should be used only to protect resources from accidental access by fully trusted code. It should not be used to protect resources from intentional misuse by untrusted code. For example, if method A issues a <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for a permission and then calls method B, method B can overtly override the <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> by issuing an <see cref="M:System.Security.CodeAccessPermission.Assert" />. The called method is always higher in the stack. Therefore, if method B tries to access a protected resource, the security system begins checking for permissions with it because method B is the immediate caller, and then walks down the stack to confirm that there is no <see cref="M:System.Security.CodeAccessPermission.Deny" /> or <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> lower in the stack. Method B, which is trying to access the resource, can stop the stack walk immediately by using the <see cref="M:System.Security.CodeAccessPermission.Assert" /> method. In that case, the <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> placed on the stack by method A (the calling method) is never discovered.</para>
          </block>
          <para>
            <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> is similar to <see cref="M:System.Security.CodeAccessPermission.Deny" />, in that both cause stack walks to fail when they would otherwise succeed. The difference is that <see cref="M:System.Security.CodeAccessPermission.Deny" /> specifies permissions that will cause the stack walk to fail, but <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> specifies the only permissions that do not cause the stack walk to fail.</para>
          <para>Call this method to ensure that your code can be used to access only the specified resources. The call to <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> is effective until the calling code returns to its caller. Only one <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> can be active on a frame. An attempt to call <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> when an active <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> exists on the frame results in a <see cref="T:System.Security.SecurityException" />. Call <see cref="M:System.Security.CodeAccessPermission.RevertPermitOnly" /> or <see cref="M:System.Security.CodeAccessPermission.RevertAll" /> to remove an active <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />.</para>
          <para>
            <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> is ignored for a permission not granted because a demand for that permission will not succeed. However, if code lower on the call stack later calls <see cref="M:System.Security.CodeAccessPermission.Demand" /> for that permission, a <see cref="T:System.Security.SecurityException" /> is thrown when the stack walk reaches the code that tried to call <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />. This is because the code that called <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> has not been granted the permission, even though it called <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for that permission. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If there are no overrides (<see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />, or <see cref="M:System.Security.CodeAccessPermission.PermitOnly" />) for the current frame, an <see cref="T:System.ExecutionEngineException" /> is thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Causes all previous overrides for the current frame to be removed and no longer in effect.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If there is no <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame, an <see cref="T:System.ExecutionEngineException" /> is thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Causes any previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame to be removed and no longer in effect.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If there is no <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame, an <see cref="T:System.ExecutionEngineException" /> is thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Causes any previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame to be removed and no longer in effect.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If there is no <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame, an <see cref="T:System.ExecutionEngineException" /> is thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Causes any previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame to be removed and no longer in effect.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual string ToString()" />
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is useful in debugging when you need to display the permission as a string.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates and returns a string representation of the current permission object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string representation of the current permission object.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Security.SecurityElement ToXml()" />
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Custom code that extends security objects needs to implement the <see cref="M:System.Security.CodeAccessPermission.ToXml" /> and <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" /> methods to make the objects security-encodable.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, creates an XML encoding of the security object and its current state.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An XML encoding of the security object, including any state information.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Security.IPermission Union(class System.Security.IPermission other)" />
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="other" /> is not of type <see cref="T:System.Security.CodeAccessPermission" /> .</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="other" /> is not <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The result of a call to <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" /> is a permission that represents all the operations represented by both the current permission and the specified permission. Any demand that passes either permission passes their union.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new permission that represents the union of the current permission and the specified permission.</para>
        </returns>
        <param name="other">
          <attribution license="cc4" from="Microsoft" modified="false" />A permission to combine with the current permission. It must be of the same type as the current permission. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>