<?xml version="1.0" encoding="utf-8"?>
<Type Name="WaitHandle" FullName="System.Threading.WaitHandle" FullNameSP="System_Threading_WaitHandle" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public abstract WaitHandle extends System.MarshalByRefObject implements System.IDisposable" />
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>This class is typically used as a base class for synchronization objects. Classes derived from WaitHandle define a signaling mechanism to indicate taking or releasing access to a shared resource, but use the inherited WaitHandle methods to block while waiting for access to shared resources.</para>
      <para>Use the static methods of this class to block a thread until one or more synchronization objects receive a signal. </para>
      <para>
        <see cref="T:System.Threading.WaitHandle" /> implements the <see cref="M:System.IDisposable.Dispose" /> pattern. See <format type="text/html"><a href="31a6c13b-d6a2-492b-9a9f-e5238c983bcb">Implementing Finalize and Dispose to Clean Up Unmanaged Resources</a></format>. When you derive from <see cref="T:System.Threading.WaitHandle" />, use the <see cref="P:System.Threading.WaitHandle.SafeWaitHandle" /> property to store your native handle operating system handle. You do not need to override the protected <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method unless you use additional unmanaged resources. </para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Encapsulates operating systemâ€“specific objects that wait for exclusive access to shared resources.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor()" />
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Close()" />
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is the public version of the <see cref="M:System.IDisposable.Dispose" /> method implemented to support the <see cref="T:System.IDisposable" /> interface.</para>
          <para>This method releases any unmanaged resources held by the current instance. This method can, but is not required to, suppress finalization during garbage collection by calling the <see cref="M:System.GC.SuppressFinalize(System.Object)" /> method.</para>
          <para>Override this method to release resources allocated in derived classes.</para>
          <para>Use this method to release all resources held by an instance of WaitHandle. Once this method is called, references to the current instance cause undefined behavior.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is equivalent to the <see cref="M:System.Threading.WaitHandle.Close" /> method, but it can be called by using the <see cref="T:System.IDisposable" /> interface.</para>
          <para>Call Dispose when you are finished using the <see cref="T:System.Threading.WaitHandle" />. The Dispose method leaves the <see cref="T:System.Threading.WaitHandle" /> in an unusable state. After calling Dispose, you must release all references to the <see cref="T:System.Threading.WaitHandle" /> so the garbage collector can reclaim the memory that the <see cref="T:System.Threading.WaitHandle" /> was occupying.</para>
          <para>For more information, see <format type="text/html"><a href="A17B0066-71C2-4BA4-9822-8E19332FC213">Cleaning Up Unmanaged Resources</a></format> and <format type="text/html"><a href="eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9">Implementing a Dispose Method</a></format>.</para>
          <block subset="none" type="note">
            <para>Always call Dispose before you release your last reference to the <see cref="T:System.Threading.WaitHandle" />. Otherwise, the resources it is using will not be freed until the garbage collector calls the <see cref="T:System.Threading.WaitHandle" /> object's Finalize method.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Dispose(bool explicitDisposing)" />
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is called by the WaitHandle.Dispose() method and the Finalize method. Dispose() invokes this protected method with the <paramref name="explicitDisposing" /> parameter set to true. Finalize invokes Dispose with <paramref name="explicitDisposing" /> set to false.</para>
          <para>When the <paramref name="explicitDisposing" /> parameter is true, this method releases all resources held by any managed objects that this WaitHandle references. This method invokes the Dispose() method of each referenced object.</para>
          <para>Dispose can be called multiple times by other objects. When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to Dispose or Close.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</para>
        </summary>
        <param name="explicitDisposing">
          <attribution license="cc4" from="Microsoft" modified="false" />true to release both managed and unmanaged resources; false to release only unmanaged resources. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Finalize()" />
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>This member has been removed from the dnprdnext and subsequent versions. This topic applies only to the versions listed in "Version Information" later in this topic.</para>
          </block>
          <para>Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled. For more information, see <see cref="M:System.GC.SuppressFinalize(System.Object)" /> and <see cref="M:System.Object.Finalize" />. This method overrides <see cref="M:System.Object.Finalize" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the resources held by the current instance.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("In the profiles &gt; 2.x, use SafeHandle instead of Handle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Assigning a new value to the <see cref="P:System.Threading.WaitHandle.Handle" /> property does not close the previous handle. This can result in a leaked handle. </para>
          <para>Do not use this property in the .NET Framework version 2.0 or later; use the <see cref="P:System.Threading.WaitHandle.SafeWaitHandle" /> property instead. Setting this property to a valid handle also sets the <see cref="P:System.Threading.WaitHandle.SafeWaitHandle" /> property, but setting it to <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> can result in a leaked handle. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the native operating system handle.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Used internally to initialize the <see cref="P:System.Threading.WaitHandle.Handle" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Represents an invalid native operating system handle. This field is read-only.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When you assign a new value to the <see cref="P:System.Threading.WaitHandle.SafeWaitHandle" /> property, the previous handle will be closed when the previous <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> object is collected. Do not manually close the handle, because this results in an <see cref="T:System.ObjectDisposedException" /> when the <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> attempts to close the handle.</para>
          <para>
            <see cref="T:System.Threading.WaitHandle" /> implements the <see cref="M:System.IDisposable.Dispose" /> pattern. See <format type="text/html"><a href="31a6c13b-d6a2-492b-9a9f-e5238c983bcb">Implementing Finalize and Dispose to Clean Up Unmanaged Resources</a></format>. When you derive from <see cref="T:System.Threading.WaitHandle" />, use the <see cref="P:System.Threading.WaitHandle.SafeWaitHandle" /> property to store your native handle operating system handle. You do not need to override the protected <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method unless you use additional unmanaged resources. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the native operating system handle.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This operation is not guaranteed to be atomic. After the current thread signals <paramref name="toSignal" /> but before it waits on <paramref name="toWaitOn" />, a thread that is running on another processor might signal <paramref name="toWaitOn" /> or wait on it.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</para>
        </returns>
        <param name="toSignal">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This operation is not guaranteed to be atomic. After the current thread signals <paramref name="toSignal" /> but before it waits on <paramref name="toWaitOn" />, a thread that is running on another processor might signal <paramref name="toWaitOn" /> or wait on it.</para>
          <para>If <paramref name="millisecondsTimeout" /> is zero, the method does not block. It tests the state of the <paramref name="toWaitOn" /> and returns immediately. </para>
          <format type="text/html">
            <h2>Notes on Exiting the Context</h2>
          </format>
          <para>The <paramref name="exitContext" /> parameter has no effect unless the <see cref="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" /> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <see cref="T:System.ContextBoundObject" />. Even if you are currently executing a method on a class that does not derive from <see cref="T:System.ContextBoundObject" />, like <see cref="T:System.String" />, you can be in a nondefault context if a <see cref="T:System.ContextBoundObject" /> is on your stack in the current application domain.</para>
          <para>When your code is executing in a nondefault context, specifying true for <paramref name="exitContext" /> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <see cref="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" /> method. The thread returns to the original nondefault context after the call to the <see cref="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" /> method completes.</para>
          <para>This can be useful when the context-bound class has <see cref="T:System.Runtime.Remoting.Contexts.SynchronizationAttribute" />. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <see cref="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" /> method and specifies true for <paramref name="exitContext" />, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <see cref="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" /> method returns, the thread that made the call must wait to reenter the synchronization domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if both the signal and the wait completed successfully, or false if the signal completed but the wait timed out.</para>
        </returns>
        <param name="toSignal">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />An integer that represents the interval to wait. If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</param>
        <param name="exitContext">
          <attribution license="cc4" from="Microsoft" modified="false" />true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This operation is not guaranteed to be atomic. After the current thread signals <paramref name="toSignal" /> but before it waits on <paramref name="toWaitOn" />, a thread that is running on another processor might signal <paramref name="toWaitOn" /> or wait on it.</para>
          <para>The maximum value for <paramref name="timeout" /> is <see cref="F:System.Int32.MaxValue" />.</para>
          <para>If <paramref name="timeout" /> is zero, the method does not block. It tests the state of the <paramref name="toWaitOn" /> and returns immediately. </para>
          <format type="text/html">
            <h2>Notes on Exiting the Context</h2>
          </format>
          <para>The <paramref name="exitContext" /> parameter has no effect unless the <see cref="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" /> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <see cref="T:System.ContextBoundObject" />. Even if you are currently executing a method on a class that does not derive from <see cref="T:System.ContextBoundObject" />, like <see cref="T:System.String" />, you can be in a nondefault context if a <see cref="T:System.ContextBoundObject" /> is on your stack in the current application domain.</para>
          <para>When your code is executing in a nondefault context, specifying true for <paramref name="exitContext" /> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <see cref="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" /> method. The thread returns to the original nondefault context after the call to the <see cref="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" /> method completes.</para>
          <para>This can be useful when the context-bound class has <see cref="T:System.Runtime.Remoting.Contexts.SynchronizationAttribute" />. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <see cref="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" /> method and specifies true for <paramref name="exitContext" />, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <see cref="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" /> method returns, the thread that made the call must wait to reenter the synchronization domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if both the signal and the wait completed successfully, or false if the signal completed but the wait timed out.</para>
        </returns>
        <param name="toSignal">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> that represents the interval to wait. If the value is -1, the wait is infinite.</param>
        <param name="exitContext">
          <attribution license="cc4" from="Microsoft" modified="false" />true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Calling Dispose allows the resources used by the <see cref="T:System.Threading.WaitHandle" /> to be reallocated for other purposes. For more information about Dispose, see <format type="text/html"><a href="a17b0066-71c2-4ba4-9822-8e19332fc213">Cleaning Up Unmanaged Resources</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</para>
        </summary>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static bool WaitAll(class System.Threading.WaitHandle[] waitHandles)" />
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles " />is <see langword="null" /> or one or more elements in the <paramref name="waitHandles " /> array is <see langword="null" />.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles " />contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles " />is greater than the system permits.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Threading.AbandonedMutexException" /> is new in the .NET Framework version 2.0. In previous versions, the <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method returns true when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </para>
          <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method returns when all the handles are signaled. On some implementations, if more than 64 handles are passed, a <see cref="T:System.NotSupportedException" /> is thrown. If the array contains duplicates, the call fails with a <see cref="T:System.DuplicateWaitObjectException" />.</para>
          <block subset="none" type="note">
            <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method is not supported on threads that have <see cref="T:System.STAThreadAttribute" />.</para>
          </block>
          <para>Calling this method overload is equivalent to calling the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method overload and specifying -1 (or <see cref="F:System.Threading.Timeout.Infinite" />) for <paramref name="millisecondsTimeout" /> and true for <paramref name="exitContext" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for all the elements in the specified array to receive a signal.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</para>
        </returns>
        <param name="waitHandles">
          <attribution license="cc4" from="Microsoft" modified="false" />A WaitHandle array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="millisecondsTimeout" /> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </para>
          <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <see cref="T:System.NotSupportedException" /> is thrown. If there are duplicates in the array, the call fails with a <see cref="T:System.DuplicateWaitObjectException" />.</para>
          <block subset="none" type="note">
            <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method is not supported on threads that have <see cref="T:System.STAThreadAttribute" />.</para>
          </block>
          <para>Calling this method overload is the same as calling the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> overload and specifying false for <paramref name="exitContext" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true when every element in <paramref name="waitHandles" /> has received a signal; otherwise, false.</para>
        </returns>
        <param name="waitHandles">
          <attribution license="cc4" from="Microsoft" modified="false" />A WaitHandle array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates). </param>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="timeout" /> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </para>
          <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <see cref="T:System.NotSupportedException" /> is thrown. If the array contains duplicates, the call will fail.</para>
          <block subset="none" type="note">
            <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method is not supported on threads that have <see cref="T:System.STAThreadAttribute" />.</para>
          </block>
          <para>The maximum value for <paramref name="timeout" /> is <see cref="F:System.Int32.MaxValue" />.</para>
          <para>Calling this method overload is the same as calling the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> overload and specifying false for <paramref name="exitContext" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true when every element in <paramref name="waitHandles" /> has received a signal; otherwise, false.</para>
        </returns>
        <param name="waitHandles">
          <attribution license="cc4" from="Microsoft" modified="false" />A WaitHandle array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object. </param>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="millisecondsTimeout" /> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </para>
          <para>
            <see cref="T:System.Threading.AbandonedMutexException" /> is new in the .NET Framework version 2.0. In previous versions, the <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method returns true when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </para>
          <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <see cref="T:System.NotSupportedException" /> is thrown. If there are duplicates in the array, the call fails with a <see cref="T:System.DuplicateWaitObjectException" />.</para>
          <block subset="none" type="note">
            <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method is not supported on threads that have <see cref="T:System.STAThreadAttribute" />.</para>
          </block>
          <format type="text/html">
            <h2>Notes on Exiting the Context</h2>
          </format>
          <para>The <paramref name="exitContext" /> parameter has no effect unless the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <see cref="T:System.ContextBoundObject" />. Even if you are currently executing a method on a class that is not derived from <see cref="T:System.ContextBoundObject" />, like <see cref="T:System.String" />, you can be in a nondefault context if a <see cref="T:System.ContextBoundObject" /> is on your stack in the current application domain.</para>
          <para>When your code is executing in a nondefault context, specifying true for <paramref name="exitContext" /> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method. The thread returns to the original nondefault context after the call to the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method completes.</para>
          <para>This can be useful when the context-bound class has the <see cref="T:System.Runtime.Remoting.Contexts.SynchronizationAttribute" /> attribute. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method and specifies true for <paramref name="exitContext" />, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method returns, the thread that made the call must wait to reenter the synchronization domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true when every element in <paramref name="waitHandles" /> has received a signal; otherwise, false.</para>
        </returns>
        <param name="waitHandles">
          <attribution license="cc4" from="Microsoft" modified="false" />A WaitHandle array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates). </param>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely. </param>
        <param name="exitContext">
          <attribution license="cc4" from="Microsoft" modified="false" />true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="timeout" /> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </para>
          <para>
            <see cref="T:System.Threading.AbandonedMutexException" /> is new in the .NET Framework version 2.0. In previous versions, the <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method returns true when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </para>
          <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <see cref="T:System.NotSupportedException" /> is thrown. If the array contains duplicates, the call will fail.</para>
          <block subset="none" type="note">
            <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> method is not supported on threads that have <see cref="T:System.STAThreadAttribute" />.</para>
          </block>
          <para>The maximum value for <paramref name="timeout" /> is <see cref="F:System.Int32.MaxValue" />.</para>
          <format type="text/html">
            <h2>Notes on Exiting the Context</h2>
          </format>
          <para>The <paramref name="exitContext" /> parameter has no effect unless the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <see cref="T:System.ContextBoundObject" />. Even if you are currently executing a method on a class that is not derived from <see cref="T:System.ContextBoundObject" />, like <see cref="T:System.String" />, you can be in a nondefault context if a <see cref="T:System.ContextBoundObject" /> is on your stack in the current application domain.</para>
          <para>When your code is executing in a nondefault context, specifying true for <paramref name="exitContext" /> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> method. It returns to the original nondefault context after the call to the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> method completes.</para>
          <para>This can be useful when the context-bound class has <see cref="T:System.Runtime.Remoting.Contexts.SynchronizationAttribute" />. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> method and specifies true for <paramref name="exitContext" />, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <see cref="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> method returns, the thread that made the call must wait to reenter the synchronization domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true when every element in <paramref name="waitHandles" /> has received a signal; otherwise false.</para>
        </returns>
        <param name="waitHandles">
          <attribution license="cc4" from="Microsoft" modified="false" />A WaitHandle array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object. </param>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely. </param>
        <param name="exitContext">
          <attribution license="cc4" from="Microsoft" modified="false" />true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 WaitAny(class System.Threading.WaitHandle[] waitHandles)" />
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="waitHandles " />is <see langword="null" /> or one or more elements in the <paramref name="waitHandles " /> array is <see langword="null" />.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <paramref name="waitHandles " />contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles " />is greater than the system permits.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Threading.AbandonedMutexException" /> is new in the .NET Framework version 2.0. In previous versions, the <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method returns true if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </para>
          <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method throws an <see cref="T:System.Threading.AbandonedMutexException" /> only when the wait completes because of an abandoned mutex. If <paramref name="waitHandles" /> contains a released mutex with a lower index number than the abandoned mutex, the <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method completes normally and the exception is not thrown.</para>
          <block subset="none" type="note">
            <para>In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <see cref="T:System.Threading.Mutex" />, and that Mutex is at index 0 (zero) in a WaitAny array on another thread, the index returned by WaitAny is 128 instead of 0.</para>
          </block>
          <para>This method returns when any handle is signaled. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <see cref="T:System.NotSupportedException" /> is thrown.</para>
          <para>Calling this method overload is equivalent to calling the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method overload and specifying -1 (or <see cref="F:System.Threading.Timeout.Infinite" />) for <paramref name="millisecondsTimeout" /> and true for <paramref name="exitContext" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for any of the elements in the specified array to receive a signal.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The array index of the object that satisfied the wait.</para>
        </returns>
        <param name="waitHandles">
          <attribution license="cc4" from="Microsoft" modified="false" />A WaitHandle array containing the objects for which the current instance will wait. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="millisecondsTimeout" /> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </para>
          <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method throws an <see cref="T:System.Threading.AbandonedMutexException" /> only when the wait completes because of an abandoned mutex. If <paramref name="waitHandles" /> contains a released mutex with a lower index number than the abandoned mutex, the <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method completes normally and the exception is not thrown.</para>
          <para>This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <see cref="T:System.NotSupportedException" /> is thrown.</para>
          <para>Calling this method overload is the same as calling the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> overload and specifying false for <paramref name="exitContext" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</para>
        </returns>
        <param name="waitHandles">
          <attribution license="cc4" from="Microsoft" modified="false" />A WaitHandle array containing the objects for which the current instance will wait. </param>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="timeout" /> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </para>
          <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method throws an <see cref="T:System.Threading.AbandonedMutexException" /> only when the wait completes because of an abandoned mutex. If <paramref name="waitHandles" /> contains a released mutex with a lower index number than the abandoned mutex, the <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method completes normally and the exception is not thrown.</para>
          <para>This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <see cref="T:System.NotSupportedException" /> is thrown.</para>
          <para>The maximum value for <paramref name="timeout" /> is <see cref="F:System.Int32.MaxValue" />.</para>
          <para>Calling this method overload is the same as calling the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> overload and specifying false for <paramref name="exitContext" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</para>
        </returns>
        <param name="waitHandles">
          <attribution license="cc4" from="Microsoft" modified="false" />A WaitHandle array containing the objects for which the current instance will wait. </param>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="millisecondsTimeout" /> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </para>
          <para>
            <see cref="T:System.Threading.AbandonedMutexException" /> is new in the .NET Framework version 2.0. In previous versions, the <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method returns true if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </para>
          <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method throws an <see cref="T:System.Threading.AbandonedMutexException" /> only when the wait completes because of an abandoned mutex. If <paramref name="waitHandles" /> contains a released mutex with a lower index number than the abandoned mutex, the <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method completes normally and the exception is not thrown.</para>
          <block subset="none" type="note">
            <para>In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <see cref="T:System.Threading.Mutex" />, and that Mutex is at index 0 (zero) in a WaitAny array on another thread, the index returned by WaitAny is 128 instead of 0.</para>
          </block>
          <para>This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <see cref="T:System.NotSupportedException" /> is thrown.</para>
          <format type="text/html">
            <h2>Notes on Exiting the Context</h2>
          </format>
          <para>The <paramref name="exitContext" /> parameter has no effect unless the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <see cref="T:System.ContextBoundObject" />. Even if you are currently executing a method on a class that does not derive from <see cref="T:System.ContextBoundObject" />, like <see cref="T:System.String" />, you can be in a nondefault context if a <see cref="T:System.ContextBoundObject" /> is on your stack in the current application domain.</para>
          <para>When your code is executing in a nondefault context, specifying true for <paramref name="exitContext" /> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method. The thread returns to the original nondefault context after the call to the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method completes.</para>
          <para>This can be useful when the context-bound class has <see cref="T:System.Runtime.Remoting.Contexts.SynchronizationAttribute" />. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method and specifies true for <paramref name="exitContext" />, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> method returns, the thread that made the call must wait to reenter the synchronization domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</para>
        </returns>
        <param name="waitHandles">
          <attribution license="cc4" from="Microsoft" modified="false" />A WaitHandle array containing the objects for which the current instance will wait. </param>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely. </param>
        <param name="exitContext">
          <attribution license="cc4" from="Microsoft" modified="false" />true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="timeout" /> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </para>
          <para>
            <see cref="T:System.Threading.AbandonedMutexException" /> is new in the .NET Framework version 2.0. In previous versions, the <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method returns true if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.</para>
          <para>The <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method throws an <see cref="T:System.Threading.AbandonedMutexException" /> only when the wait completes because of an abandoned mutex. If <paramref name="waitHandles" /> contains a released mutex with a lower index number than the abandoned mutex, the <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> method completes normally and the exception is not thrown.</para>
          <block subset="none" type="note">
            <para>In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <see cref="T:System.Threading.Mutex" />, and that Mutex is at index 0 (zero) in a WaitAny array on another thread, the index returned by WaitAny is 128 instead of 0.</para>
          </block>
          <para>This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <see cref="T:System.NotSupportedException" /> is thrown.</para>
          <para>The maximum value for <paramref name="timeout" /> is <see cref="F:System.Int32.MaxValue" />.</para>
          <format type="text/html">
            <h2>Notes on Exiting the Context</h2>
          </format>
          <para>The <paramref name="exitContext" /> parameter has no effect unless the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <see cref="T:System.ContextBoundObject" />. Even if you are currently executing a method on a class that does not derive from <see cref="T:System.ContextBoundObject" />, like <see cref="T:System.String" />, you can be in a nondefault context if a <see cref="T:System.ContextBoundObject" /> is on your stack in the current application domain.</para>
          <para>When your code is executing in a nondefault context, specifying true for <paramref name="exitContext" /> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> method. The thread returns to the original nondefault context after the call to the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> method completes.</para>
          <para>This can be useful when the context-bound class has <see cref="T:System.Runtime.Remoting.Contexts.SynchronizationAttribute" />. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> method and specifies true for <paramref name="exitContext" />, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" /> method returns, the thread that made the call must wait to reenter the synchronization domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</para>
        </returns>
        <param name="waitHandles">
          <attribution license="cc4" from="Microsoft" modified="false" />A WaitHandle array containing the objects for which the current instance will wait. </param>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely. </param>
        <param name="exitContext">
          <attribution license="cc4" from="Microsoft" modified="false" />true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool WaitOne()" />
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Threading.AbandonedMutexException" /> is new in the .NET Framework version 2.0. In previous versions, the <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> method returns true when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </para>
          <para>The caller of this method blocks indefinitely until the current instance receives a signal. Use this method to block until a <see cref="T:System.Threading.WaitHandle" /> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <see cref="T:System.IAsyncResult" /> interface.</para>
          <para>Calling this method overload is equivalent to calling the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method overload and specifying -1 or <see cref="F:System.Threading.Timeout.Infinite" /> for the first parameter and false for the second parameter.</para>
          <para>Override this method to customize the behavior of derived classes.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current instance receives a signal. If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="millisecondsTimeout" /> is zero, the method does not block. It tests the state of the wait handle and returns immediately. </para>
          <para>The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <see cref="T:System.Threading.WaitHandle" /> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <see cref="T:System.IAsyncResult" /> interface.</para>
          <para>Override this method to customize the behavior of derived classes.</para>
          <para>Calling this method overload is the same as calling the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> overload and specifying false for <paramref name="exitContext" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current instance receives a signal; otherwise, false.</para>
        </returns>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="timeout" /> is zero, the method does not block. It tests the state of the wait handle and returns immediately. </para>
          <para>The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <see cref="T:System.Threading.WaitHandle" /> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <see cref="T:System.IAsyncResult" /> interface.</para>
          <para>Override this method to customize the behavior of derived classes.</para>
          <para>The maximum value for <paramref name="timeout" /> is <see cref="F:System.Int32.MaxValue" />.</para>
          <para>Calling this method overload is the same as calling the <see cref="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" /> overload and specifying false for <paramref name="exitContext" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current instance receives a signal; otherwise, false.</para>
        </returns>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="millisecondsTimeout" /> is zero, the method does not block. It tests the state of the wait handle and returns immediately. </para>
          <para>
            <see cref="T:System.Threading.AbandonedMutexException" /> is new in the .NET Framework version 2.0. In previous versions, the <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> method returns true when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </para>
          <para>The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <see cref="T:System.Threading.WaitHandle" /> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <see cref="T:System.IAsyncResult" /> interface.</para>
          <para>Override this method to customize the behavior of derived classes.</para>
          <format type="text/html">
            <h2>Notes on Exiting the Context</h2>
          </format>
          <para>The <paramref name="exitContext" /> parameter has no effect unless the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <see cref="T:System.ContextBoundObject" />. Even if you are currently executing a method on a class that does not derive from <see cref="T:System.ContextBoundObject" />, like <see cref="T:System.String" />, you can be in a nondefault context if a <see cref="T:System.ContextBoundObject" /> is on your stack in the current application domain.</para>
          <para>When your code is executing in a nondefault context, specifying true for <paramref name="exitContext" /> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method. The thread returns to the original nondefault context after the call to the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method completes.</para>
          <para>This can be useful when the context-bound class has <see cref="T:System.Runtime.Remoting.Contexts.SynchronizationAttribute" />. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method and specifies true for <paramref name="exitContext" />, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> method returns, the thread that made the call must wait to reenter the synchronization domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current instance receives a signal; otherwise, false.</para>
        </returns>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely. </param>
        <param name="exitContext">
          <attribution license="cc4" from="Microsoft" modified="false" />true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="timeout" /> is zero, the method does not block. It tests the state of the wait handle and returns immediately. </para>
          <para>
            <see cref="T:System.Threading.AbandonedMutexException" /> is new in the .NET Framework version 2.0. In previous versions, the <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> method returns true when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </para>
          <para>The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <see cref="T:System.Threading.WaitHandle" /> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <see cref="T:System.IAsyncResult" /> interface.</para>
          <para>Override this method to customize the behavior of derived classes.</para>
          <para>The maximum value for <paramref name="timeout" /> is <see cref="F:System.Int32.MaxValue" />.</para>
          <format type="text/html">
            <h2>Notes on Exiting the Context</h2>
          </format>
          <para>The <paramref name="exitContext" /> parameter has no effect unless the <see cref="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" /> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <see cref="T:System.ContextBoundObject" />. Even if you are currently executing a method on a class that does not derive from <see cref="T:System.ContextBoundObject" />, like <see cref="T:System.String" />, you can be in a nondefault context if a <see cref="T:System.ContextBoundObject" /> is on your stack in the current application domain.</para>
          <para>When your code is executing in a nondefault context, specifying true for <paramref name="exitContext" /> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <see cref="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" /> method. The thread returns to the original nondefault context after the call to the <see cref="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" /> method completes.</para>
          <para>This can be useful when the context-bound class has <see cref="T:System.Runtime.Remoting.Contexts.SynchronizationAttribute" />. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <see cref="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" /> method and specifies true for <paramref name="exitContext" />, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <see cref="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" /> method returns, the thread that made the call must wait to reenter the synchronization domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current instance receives a signal; otherwise, false.</para>
        </returns>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely. </param>
        <param name="exitContext">
          <attribution license="cc4" from="Microsoft" modified="false" />true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This field is one of the possible return values of WaitAny.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled. This field is constant.</para>
        </summary>
      </Docs>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>