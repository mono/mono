<?xml version="1.0" encoding="utf-8"?>
<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <TypeSignature Maintainer="auto" Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the &lt;link location="node:gtk-sharp/programming/threads"&gt;Gtk# Thread Programming&lt;/link&gt; for details.</ThreadSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur. Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information. The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system. Examples of operations that use thread pool threads include the following: </para>
      <list type="bullet">
        <item>
          <para>When you create a <see cref="T:System.Threading.Tasks.Task" /> or <see cref="T:System.Threading.Tasks.Task`1" /> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</para>
        </item>
        <item>
          <para>Asynchronous timers use the thread pool. Thread pool threads execute callbacks from the <see cref="T:System.Threading.Timer" /> class and raise events from the <see cref="T:System.Timers.Timer" /> class.</para>
        </item>
        <item>
          <para>When you use registered wait handles, a system thread monitors the status of the wait handles. When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</para>
        </item>
      </list>
      <block subset="none" type="note">
        <para>The threads in the managed thread pool are background threads. That is, their <see cref="P:System.Threading.Thread.IsBackground" /> properties are true. This means that a <see cref="T:System.Threading.ThreadPool" /> thread will not keep an application running after all foreground threads have exited.</para>
      </block>
      <block subset="none" type="note">
        <para>When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute. Therefore, when a method examines thread local storage or fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute, the values it finds might be left over from an earlier use of the thread pool thread. </para>
      </block>
      <para>You can also queue work items that are not related to a wait operation to the thread pool. To request that a work item be handled by a thread in the thread pool, call the <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" /> method. This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool. There is no way to cancel a work item after it has been queued.</para>
      <para>Timer-queue timers and registered wait operations also use the thread pool. Their callback functions are queued to the thread pool.</para>
      <para>There is one thread pool per process. Beginning with the net_v40_long, the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space. A process can call the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method to determine the number of threads. The number of threads in the thread pool can be changed by using the <see cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" /> method. Each thread uses the default stack size and runs at the default priority. </para>
      <block subset="none" type="note">
        <para>Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the <unmanagedCodeEntityReference>CorSetMaxThreads</unmanagedCodeEntityReference> function, defined in the mscoree.h file.</para>
      </block>
      <para>The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the net_v40_short, the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention. </para>
      <block subset="none" type="note">
        <para>When demand is low, the actual number of thread pool threads can fall below the minimum values.</para>
      </block>
      <para>You can use the <see cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" /> method to obtain these minimum values. </para>
      <block subset="none" type="note">
        <para>You can use the <see cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" /> method to increase the minimum number of threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own algorithm for allocating threads. </para>
      </block>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method is obsolete, use BindHandle(SafeHandle) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the handle is bound; otherwise, false.</para>
        </returns>
        <param name="osHandle">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.IntPtr" /> that holds the handle. The handle must have been opened for overlapped I/O on the unmanaged side. </param>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="osHandle" /> parameter should be a <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />, which derives from the abstract <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the handle is bound; otherwise, false.</para>
        </returns>
        <param name="osHandle">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Runtime.InteropServices.SafeHandle" />  that holds the operating system handle. The handle must have been opened for overlapped I/O on the unmanaged side.</param>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">To be added: an object of type 'int&amp;'</param>
        <param name="completionPortThreads">To be added: an object of type 'int&amp;'</param>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">To be added: an object of type 'int&amp;'</param>
        <param name="completionPortThreads">To be added: an object of type 'int&amp;'</param>
        <summary>To be added</summary>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">To be added.</param>
        <param name="completionPortThreads">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" /> overload that accepts an object containing the necessary data.</para>
          <block subset="none" type="note">
            <para>Visual Basic users can omit the <see cref="T:System.Threading.WaitCallback" /> constructor, and simply use the AddressOf operator when passing the callback method to <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />. Visual Basic automatically calls the correct delegate constructor.</para>
          </block>
          <format type="text/html">
            <h2>Version Information</h2>
          </format>
          <para>In the .NET Framework version 2.0, the <see cref="P:System.Threading.Thread.CurrentPrincipal" /> property value is propagated to worker threads queued using the <see cref="Overload:System.Threading.ThreadPool.QueueUserWorkItem" /> method. In earlier versions, the principal information is not propagated.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Queues a method for execution. The method executes when a thread pool thread becomes available.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</para>
        </returns>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed. </param>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the callback method requires complex data, you can define a class to contain the data.</para>
          <block subset="none" type="note">
            <para>Visual Basic users can omit the <see cref="T:System.Threading.WaitCallback" /> constructor, and simply use the AddressOf operator when passing the callback method to <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />. Visual Basic automatically calls the correct delegate constructor.</para>
          </block>
          <format type="text/html">
            <h2>Version Information</h2>
          </format>
          <para>In the .NET Framework version 2.0, the <see cref="P:System.Threading.Thread.CurrentPrincipal" /> property value is propagated to worker threads queued using the <see cref="Overload:System.Threading.ThreadPool.QueueUserWorkItem" /> method. In earlier versions, the principal information is not propagated.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Queues a method for execution, and specifies an object containing data to be used by the method. The method executes when a thread pool thread becomes available.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</para>
        </returns>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />An object containing data to be used by the method. </param>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When you are finished using the <see cref="T:System.Threading.RegisteredWaitHandle" /> that is returned by this method, call its <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method to release references to the wait handle. We recommend that you always call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method, even if you specify true for <paramref name="executeOnlyOnce" />. Garbage collection works more efficiently if you call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method instead of depending on the registered wait handle's finalizer.</para>
          <para>The <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" /> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </para>
          <list type="bullet">
            <item>
              <para>The specified object is in the signaled state.</para>
            </item>
            <item>
              <para>The time-out interval elapses.</para>
            </item>
          </list>
          <para>The <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" /> method checks the current state of the specified object's <see cref="T:System.Threading.WaitHandle" />. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the <paramref name="timeOutInterval" /> parameter is not 0 (zero) and the <paramref name="executeOnlyOnce" /> parameter is false, the timer is reset every time the event is signaled or the time-out interval elapses.</para>
          <block subset="none" type="note">
            <para>Using a <see cref="T:System.Threading.Mutex" /> for <paramref name="waitObject" /> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default WT_EXECUTEDEFAULT flag, so each callback is dispatched on a separate thread pool thread. Instead of a <see cref="T:System.Threading.Mutex" />, use a <see cref="T:System.Threading.Semaphore" /> with a maximum count of 1.</para>
          </block>
          <para>To cancel the wait operation, call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method.</para>
          <para>The wait thread uses the Win32 <unmanagedCodeEntityReference>WaitForMultipleObjects</unmanagedCodeEntityReference> function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />, you must duplicate the handle using the Win32 <unmanagedCodeEntityReference>DuplicateHandle</unmanagedCodeEntityReference> function. Note that you should not pulse an event object passed to <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />, because the wait thread might not detect that the event is signaled before it is reset.</para>
          <para>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</para>
          <format type="text/html">
            <h2>Version Information</h2>
          </format>
          <para>Starting with the .NET Framework version 2.0, the <see cref="P:System.Threading.Thread.CurrentPrincipal" /> property value is propagated to worker threads queued using the <see cref="Overload:System.Threading.ThreadPool.RegisterWaitForSingleObject" /> method. In earlier versions, the principal information is not propagated.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</para>
        </returns>
        <param name="waitObject">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to register. Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that is passed to the delegate. </param>
        <param name="millisecondsTimeOutInterval">
          <attribution license="cc4" from="Microsoft" modified="false" />The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses. </param>
        <param name="executeOnlyOnce">
          <attribution license="cc4" from="Microsoft" modified="false" />true to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </param>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When you are finished using the <see cref="T:System.Threading.RegisteredWaitHandle" /> that is returned by this method, call its <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method to release references to the wait handle. We recommend that you always call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method, even if you specify true for <paramref name="executeOnlyOnce" />. Garbage collection works more efficiently if you call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method instead of depending on the registered wait handle's finalizer.</para>
          <para>The <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" /> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </para>
          <list type="bullet">
            <item>
              <para>The specified object is in the signaled state.</para>
            </item>
            <item>
              <para>The time-out interval elapses.</para>
            </item>
          </list>
          <para>The <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" /> method checks the current state of the specified object's <see cref="T:System.Threading.WaitHandle" />. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the <paramref name="timeOutInterval" /> parameter is not 0 (zero) and the <paramref name="executeOnlyOnce" /> parameter is false, the timer is reset every time the event is signaled or the time-out interval elapses.</para>
          <block subset="none" type="note">
            <para>Using a <see cref="T:System.Threading.Mutex" /> for <paramref name="waitObject" /> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default WT_EXECUTEDEFAULT flag, so each callback is dispatched on a separate thread pool thread. Instead of a <see cref="T:System.Threading.Mutex" />, use a <see cref="T:System.Threading.Semaphore" /> with a maximum count of 1.</para>
          </block>
          <para>To cancel the wait operation, call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method.</para>
          <para>The wait thread uses the Win32 <unmanagedCodeEntityReference>WaitForMultipleObjects</unmanagedCodeEntityReference> function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />, you must duplicate the handle using the Win32 <unmanagedCodeEntityReference>DuplicateHandle</unmanagedCodeEntityReference> function. Note that you should not pulse an event object passed to <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />, because the wait thread might not detect that the event is signaled before it is reset.</para>
          <para>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</para>
          <format type="text/html">
            <h2>Version Information</h2>
          </format>
          <para>Starting with the .NET Framework version 2.0, the <see cref="P:System.Threading.Thread.CurrentPrincipal" /> property value is propagated to worker threads queued using the <see cref="Overload:System.Threading.ThreadPool.RegisterWaitForSingleObject" /> method. In earlier versions, the principal information is not propagated.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</para>
        </returns>
        <param name="waitObject">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to register. Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />The object passed to the delegate. </param>
        <param name="millisecondsTimeOutInterval">
          <attribution license="cc4" from="Microsoft" modified="false" />The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses. </param>
        <param name="executeOnlyOnce">
          <attribution license="cc4" from="Microsoft" modified="false" />true to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </param>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When you are finished using the <see cref="T:System.Threading.RegisteredWaitHandle" /> that is returned by this method, call its <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method to release references to the wait handle. We recommend that you always call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method, even if you specify true for <paramref name="executeOnlyOnce" />. Garbage collection works more efficiently if you call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method instead of depending on the registered wait handle's finalizer.</para>
          <para>The <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" /> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </para>
          <list type="bullet">
            <item>
              <para>The specified object is in the signaled state.</para>
            </item>
            <item>
              <para>The time-out interval elapses.</para>
            </item>
          </list>
          <para>The <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" /> method checks the current state of the specified object's <see cref="T:System.Threading.WaitHandle" />. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the <paramref name="timeOutInterval" /> parameter is not 0 (zero) and the <paramref name="executeOnlyOnce" /> parameter is false, the timer is reset every time the event is signaled or the time-out interval elapses.</para>
          <block subset="none" type="note">
            <para>Using a <see cref="T:System.Threading.Mutex" /> for <paramref name="waitObject" /> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default WT_EXECUTEDEFAULT flag, so each callback is dispatched on a separate thread pool thread. Instead of a <see cref="T:System.Threading.Mutex" />, use a <see cref="T:System.Threading.Semaphore" /> with a maximum count of 1.</para>
          </block>
          <para>To cancel the wait operation, call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method.</para>
          <para>The wait thread uses the Win32 <unmanagedCodeEntityReference>WaitForMultipleObjects</unmanagedCodeEntityReference> function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />, you must duplicate the handle using the Win32 <unmanagedCodeEntityReference>DuplicateHandle</unmanagedCodeEntityReference> function. Note that you should not pulse an event object passed to <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />, because the wait thread might not detect that the event is signaled before it is reset.</para>
          <para>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</para>
          <format type="text/html">
            <h2>Version Information</h2>
          </format>
          <para>Starting with the .NET Framework version 2.0, the <see cref="P:System.Threading.Thread.CurrentPrincipal" /> property value is propagated to worker threads queued using the <see cref="Overload:System.Threading.ThreadPool.RegisterWaitForSingleObject" /> method. In earlier versions, the principal information is not propagated.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</para>
        </returns>
        <param name="waitObject">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to register. Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />The object passed to the delegate. </param>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The time-out represented by a <see cref="T:System.TimeSpan" />. If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately. If <paramref name="timeout" /> is -1, the function's time-out interval never elapses. </param>
        <param name="executeOnlyOnce">
          <attribution license="cc4" from="Microsoft" modified="false" />true to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </param>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When you are finished using the <see cref="T:System.Threading.RegisteredWaitHandle" /> that is returned by this method, call its <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method to release references to the wait handle. We recommend that you always call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method, even if you specify true for <paramref name="executeOnlyOnce" />. Garbage collection works more efficiently if you call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method instead of depending on the registered wait handle's finalizer.</para>
          <para>The <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" /> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs: </para>
          <list type="bullet">
            <item>
              <para>The specified object is in the signaled state.</para>
            </item>
            <item>
              <para>The time-out interval elapses.</para>
            </item>
          </list>
          <para>The <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />method checks the current state of the specified object's <see cref="T:System.Threading.WaitHandle" />. If the object's state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If the <paramref name="timeOutInterval" /> parameter is not 0 (zero) and the <paramref name="executeOnlyOnce" /> parameter is false, the timer is reset every time the event is signaled or the time-out interval elapses.</para>
          <block subset="none" type="note">
            <para>Using a <see cref="T:System.Threading.Mutex" /> for <paramref name="waitObject" /> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default WT_EXECUTEDEFAULT flag, so each callback is dispatched on a separate thread pool thread. Instead of a <see cref="T:System.Threading.Mutex" />, use a <see cref="T:System.Threading.Semaphore" /> with a maximum count of 1.</para>
          </block>
          <para>To cancel the wait operation, call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method.</para>
          <para>The wait thread uses the Win32 <unmanagedCodeEntityReference>WaitForMultipleObjects</unmanagedCodeEntityReference> function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />, you must duplicate the handle using the Win32 <unmanagedCodeEntityReference>DuplicateHandle</unmanagedCodeEntityReference> function. Note that you should not pulse an event object passed to <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />, because the wait thread might not detect that the event is signaled before it is reset.</para>
          <para>Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.</para>
          <format type="text/html">
            <h2>Version Information</h2>
          </format>
          <para>Starting with the .NET Framework version 2.0, the <see cref="P:System.Threading.Thread.CurrentPrincipal" /> property value is propagated to worker threads queued using the <see cref="Overload:System.Threading.ThreadPool.RegisterWaitForSingleObject" /> method. In earlier versions, the principal information is not propagated.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</para>
        </returns>
        <param name="waitObject">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to register. Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />The object passed to the delegate. </param>
        <param name="millisecondsTimeOutInterval">
          <attribution license="cc4" from="Microsoft" modified="false" />The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses. </param>
        <param name="executeOnlyOnce">
          <attribution license="cc4" from="Microsoft" modified="false" />true to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </param>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You cannot set the number of worker threads or the number of I/O completion threads to a number smaller than the number of processors in the computer.</para>
          <para>If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</para>
          <para>Use caution when changing the maximum number of threads in the thread pool. While your code might benefit, the changes might have an adverse effect on code libraries you use.</para>
          <para>Setting the thread pool size too large can cause performance problems. If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the change is successful; otherwise, false.</para>
        </returns>
        <param name="workerThreads">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of worker threads in the thread pool. </param>
        <param name="completionPortThreads">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of asynchronous I/O threads in the thread pool. </param>
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the net_v40_short, the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention. </para>
          <para>When demand is low, the actual number of thread pool threads can fall below the minimum values.</para>
          <para>If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />), <see cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" /> returns false and does not change either of the minimum values.</para>
          <block subset="none" type="note">
            <para>You can use the <see cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" /> method to increase the minimum number of threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases, the thread pool will perform better with its own algorithm for allocating threads. Reducing the minimum to less than the number of processors can also hurt performance. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the change is successful; otherwise, false.</para>
        </returns>
        <param name="workerThreads">
          <attribution license="cc4" from="Microsoft" modified="false" />The minimum number of worker threads that the thread pool creates on demand. </param>
        <param name="completionPortThreads">
          <attribution license="cc4" from="Microsoft" modified="false" />The minimum number of asynchronous I/O threads that the thread pool creates on demand. </param>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For information about using native Win32 overlapped I/O, see the <see cref="T:System.Threading.Overlapped" /> class, the <see cref="T:System.Threading.NativeOverlapped" /> structure, and the <unmanagedCodeEntityReference>OVERLAPPED</unmanagedCodeEntityReference> structure in the Win32 Platform SDK.</para>
          <block subset="none" type="note">
            <para>Using the <see cref="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" /> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using <see cref="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />, the stack of the thread pool thread does not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Queues an overlapped I/O operation for execution.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the operation was successfully queued to an I/O completion port; otherwise, false.</para>
        </returns>
        <param name="overlapped">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</param>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike the <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" /> method, <see cref="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" /> does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.</para>
          <block subset="none" type="note">
            <para>Using <see cref="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" /> could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using <see cref="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</para>
        </returns>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that is passed to the delegate when serviced from the thread pool. </param>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike the <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" /> method, <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" /> does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.</para>
          <block subset="none" type="note">
            <para>Using <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" /> could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.</para>
          </block>
          <para>Using a <see cref="T:System.Threading.Mutex" /> for <paramref name="waitObject" /> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default WT_EXECUTEDEFAULT flag, so each callback is dispatched on a separate thread pool thread.</para>
          <para>When you are finished using the <see cref="T:System.Threading.RegisteredWaitHandle" /> that is returned by this method, call its <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method to release references to the wait handle. We recommend that you always call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method, even if you specify true for <paramref name="executeOnlyOnce" />. Garbage collection works more efficiently if you call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method instead of depending on the registered wait handle's finalizer.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</para>
        </returns>
        <param name="waitObject">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to register. Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate to call when the <paramref name="waitObject" /> parameter is signaled. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that is passed to the delegate. </param>
        <param name="millisecondsTimeOutInterval">
          <attribution license="cc4" from="Microsoft" modified="false" />The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses. </param>
        <param name="executeOnlyOnce">
          <attribution license="cc4" from="Microsoft" modified="false" />true to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </param>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike the <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" /> method, <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" /> does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.</para>
          <block subset="none" type="note">
            <para>Using <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" /> could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.</para>
          </block>
          <para>Using a <see cref="T:System.Threading.Mutex" /> for <paramref name="waitObject" /> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default WT_EXECUTEDEFAULT flag, so each callback is dispatched on a separate thread pool thread.</para>
          <para>When you are finished using the <see cref="T:System.Threading.RegisteredWaitHandle" /> that is returned by this method, call its <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method to release references to the wait handle. We recommend that you always call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method, even if you specify true for <paramref name="executeOnlyOnce" />. Garbage collection works more efficiently if you call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method instead of depending on the registered wait handle's finalizer.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</para>
        </returns>
        <param name="waitObject">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to register. Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate to call when the <paramref name="waitObject" /> parameter is signaled. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that is passed to the delegate. </param>
        <param name="millisecondsTimeOutInterval">
          <attribution license="cc4" from="Microsoft" modified="false" />The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses. </param>
        <param name="executeOnlyOnce">
          <attribution license="cc4" from="Microsoft" modified="false" />true to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </param>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike the <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" /> method, <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" /> does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.</para>
          <block subset="none" type="note">
            <para>Using <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" /> could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.</para>
          </block>
          <para>Using a <see cref="T:System.Threading.Mutex" /> for <paramref name="waitObject" /> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default WT_EXECUTEDEFAULT flag, so each callback is dispatched on a separate thread pool thread.</para>
          <para>When you are finished using the <see cref="T:System.Threading.RegisteredWaitHandle" /> that is returned by this method, call its <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method to release references to the wait handle. We recommend that you always call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method, even if you specify true for <paramref name="executeOnlyOnce" />. Garbage collection works more efficiently if you call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method instead of depending on the registered wait handle's finalizer.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</para>
        </returns>
        <param name="waitObject">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to register. Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate to call when the <paramref name="waitObject" /> parameter is signaled. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that is passed to the delegate. </param>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The time-out represented by a <see cref="T:System.TimeSpan" />. If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately. If <paramref name="timeout" /> is -1, the function's time-out interval never elapses. </param>
        <param name="executeOnlyOnce">
          <attribution license="cc4" from="Microsoft" modified="false" />true to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </param>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike the <see cref="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" /> method, <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" /> does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.</para>
          <block subset="none" type="note">
            <para>Using <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" /> could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using <see cref="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.</para>
          </block>
          <para>Using a <see cref="T:System.Threading.Mutex" /> for <paramref name="waitObject" /> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default WT_EXECUTEDEFAULT flag, so each callback is dispatched on a separate thread pool thread.</para>
          <para>When you are finished using the <see cref="T:System.Threading.RegisteredWaitHandle" /> that is returned by this method, call its <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method to release references to the wait handle. We recommend that you always call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method, even if you specify true for <paramref name="executeOnlyOnce" />. Garbage collection works more efficiently if you call the <see cref="M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)" /> method instead of depending on the registered wait handle's finalizer.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</para>
        </returns>
        <param name="waitObject">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Threading.WaitHandle" /> to register. Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate to call when the <paramref name="waitObject" /> parameter is signaled. </param>
        <param name="state">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that is passed to the delegate. </param>
        <param name="millisecondsTimeOutInterval">
          <attribution license="cc4" from="Microsoft" modified="false" />The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses. </param>
        <param name="executeOnlyOnce">
          <attribution license="cc4" from="Microsoft" modified="false" />true to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; false to indicate that the timer is reset every time the wait operation completes until the wait is unregistered. </param>
      </Docs>
    </Member>
  </Members>
</Type>