<Type Name="Interlocked" FullName="System.Threading.Interlocked" FullNameSP="System_Threading_Interlocked" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public sealed Interlocked extends System.Object" />
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <para> The <see cref="T:System.Threading.Interlocked" /> class provides atomic operations for variables that are shared by
   multiple threads.</para>
    </summary>
    <remarks>
      <para> The <see cref="T:System.Threading.Interlocked" /> methods protect against errors that can
   occur when the scheduler switches contexts while a
   thread is updating a variable that can be accessed by other threads. The
   members of this class do not throw exceptions.</para>
      <block subset="none" type="note">
        <para>The <see cref="M:System.Threading.Interlocked.Increment(System.Int32@)" /> method
   and its counterpart, <see cref="M:System.Threading.Interlocked.Decrement(System.Int32@)" />,
   
   increment or decrement a variable and store
   the resulting value, as an atomic operation.</para>
        <para>The <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" /> method atomically exchanges the values of the
specified variables. The <see cref="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" /> method
provides an atomic
operation that compares two values and stores a third value in one of the
variables, based on the outcome of the comparison.</para>
      </block>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <param name="comparand">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 CompareExchange(class System.Int32&amp; location1, int32 value, int32 comparand)" />
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">A <see cref="T:System.Int32" /> reference whose value is updated with <paramref name="value" /> if the original value of <paramref name="location1" /> is equal to <paramref name="comparand" />. </param>
        <param name="value">A <see cref="T:System.Int32" /> whose value will replace the value of <paramref name="location1" /> if <paramref name="location1" /> and <paramref name="comparand " /> are equal. </param>
        <param name="comparand">A <see cref="T:System.Int32" /> to be compared to <paramref name="location1." /></param>
        <summary>
          <para>Compares two <see cref="T:System.Int32" /> values for equality and stores a
   specified value if they are equal.</para>
        </summary>
        <returns>
          <para> The original value of <paramref name="location1" />.
   </para>
        </returns>
        <remarks>
          <para> The compare and store operations are performed as
      an atomic operation.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <param name="comparand">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <param name="comparand">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static object CompareExchange(class System.Object&amp; location1, object value, object comparand)" />
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">A <see cref="T:System.Object" /> reference that is set to <paramref name="value" /> if the object to which it refers is equal to <paramref name="comparand" />. </param>
        <param name="value">The reference that will replace the value of <paramref name="location1" /> if <paramref name="location1" /> and <paramref name="comparand" /> are equal. </param>
        <param name="comparand">An object to be compared to that referred to by <paramref name="location1." /></param>
        <summary>
          <para> Compares two <see cref="T:System.Object" /> variables for equality and stores a specified object
   if they are equal.</para>
        </summary>
        <returns>
          <para> A <see cref="T:System.Object" /> containing the original value of <paramref name="location1" />.
   </para>
        </returns>
        <remarks>
          <para> The compare and store operations are performed as an
      atomic operation.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The address of <paramref name="location1" /> is <see langword="null" /> .</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static float32 CompareExchange(class System.Single&amp; location1, float32 value, float32 comparand)" />
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">A <see cref="T:System.Single" /> whose value is updated with <paramref name="value" /> if its original value is equal to <paramref name="comparand" />. </param>
        <param name="value">The <see cref="T:System.Single" /> value that will replace value of <paramref name="location1" /> if <paramref name="location1" /> and <paramref name="comparand " /> are equal. </param>
        <param name="comparand">A <see cref="T:System.Single" /> to be compared to <paramref name="location1." /></param>
        <summary>
          <para>Compares two <see cref="T:System.Single" /> values for equality and stores a
   specified value if they are equal.</para>
        </summary>
        <returns>
          <para> A <see cref="T:System.Single" /> containing the original value of <paramref name="location1" />.
   </para>
        </returns>
        <remarks>
          <para> The compare and store operations are performed as
      an atomic operation.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The address of <paramref name="location1" /> is <see langword="null" /> .</exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedNumerics</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <param name="comparand">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 Decrement(class System.Int32&amp; location)" />
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">A <see cref="T:System.Int32" /> containing the variable whose value is to be decremented. </param>
        <summary>
          <para> Decrements the specified variable and stores the result as an atomic operation.
      </para>
        </summary>
        <returns>
          <para> A <see cref="T:System.Int32" /> containing the
   decremented value.
   </para>
        </returns>
        <remarks>
          <para>This method handles an overflow condition by wrapping:
      if <paramref name="location" /> = <see cref="F:System.Int32.MinValue" /> , <paramref name="location" /> - 1 =
   <see cref="F:System.Int32.MaxValue" /> . No exception is
      thrown. </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int64 Decrement(class System.Int64&amp; location)" />
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">A <see cref="T:System.Int64" /> containing the variable whose value is to be decremented. </param>
        <summary>
          <para> Decrements the specified variable and stores the result as an atomic operation.
      </para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int64" />
containing the decremented value. </para>
        </returns>
        <remarks>
          <para>This method handles an overflow condition by wrapping: if <paramref name="location" /> = 
<see cref="F:System.Int64.MinValue" /> , 
<paramref name="location" /> - 1 = <see cref="F:System.Int64.MaxValue" /> . No exception is thrown. </para>
          <para>The 64-bit versions
   of <see cref="M:System.Threading.Interlocked.Increment(System.Int32@)" /> and <see cref="M:System.Threading.Interlocked.Decrement(System.Int32@)" /> are truly atomic only on systems where
   a <see cref="T:System.IntPtr" /> is
   64-bits long. On other systems, these methods are atomic with respect to
   each other, but not with respect to other means of accessing the data.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 Exchange(class System.Int32&amp; location1, int32 value)" />
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">A <see cref="T:System.Int32" /> variable to set to the supplied value as an atomic operation. </param>
        <param name="value">The <see cref="T:System.Int32" /> value to which <paramref name="location1" /> is set. </param>
        <summary>
          <para> Sets a <see cref="T:System.Int32" /> variable to a specified value as an atomic
   operation and returns the original value.
   </para>
        </summary>
        <returns>
          <para> A <see cref="T:System.Int32" /> containing the value of <paramref name="location1" />
before the exchange.</para>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static object Exchange(class System.Object&amp; location1, object value)" />
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">The variable to set. </param>
        <param name="value">The reference to which <paramref name="location1" /> is set. </param>
        <summary>
          <para> Sets a <see cref="T:System.Object" /> reference to refer to a specified object as an
   atomic operation and returns a reference to the original object.
   </para>
        </summary>
        <returns>
          <para> The original value of <paramref name="location1" /> .
   </para>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The address of <paramref name="location1" /> is <see langword="null" /> .</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static float32 Exchange(class System.Single&amp; location1, float32 value)" />
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">A <see cref="T:System.Single" /> variable to set to the supplied value as an atomic operation. </param>
        <param name="value">The <see cref="T:System.Single" /> value to which <paramref name="location1" /> is set. </param>
        <summary>
          <para> Sets a <see cref="T:System.Single" /> variable to a specified value as an atomic
   operation and returns the original value.
   </para>
        </summary>
        <returns>
          <para> A <see cref="T:System.Single" /> containing the value of <paramref name="location1" />
before the exchange.</para>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedNumerics</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="T&amp;" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="location1">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 Increment(class System.Int32&amp; location)" />
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">A <see cref="T:System.Int32" /> containing the variable whose value is to be incremented.</param>
        <summary>
          <para> Increments the specified variable and stores the result as an atomic operation.
      </para>
        </summary>
        <returns>
          <para> A <see cref="T:System.Int32" /> containing the incremented value.
   </para>
        </returns>
        <remarks>
          <para>This method handles an overflow condition by wrapping: if <paramref name="location" /> = 
<see cref="F:System.Int32.MaxValue" /> , 
<paramref name="location" /> + 1 = <see cref="F:System.Int32.MinValue" /> . No exception is thrown. </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int64 Increment(class System.Int64&amp; location)" />
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">A <see cref="T:System.Int64" /> containing the variable whose value is to be incremented. </param>
        <summary>
          <para> Increments the specified variable and stores the result as an atomic operation.
      </para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int64" />
containing the incremented value. </para>
        </returns>
        <remarks>
          <para>This method handles an overflow condition by wrapping: if <paramref name="location" /> = 
<see cref="F:System.Int64.MaxValue" /> , 
<paramref name="location" /> + 1 = <see cref="F:System.Int64.MinValue" /> . No exception is thrown. </para>
          <para> The 64-bit versions of <see cref="M:System.Threading.Interlocked.Increment(System.Int32@)" />
and <see cref="M:System.Threading.Interlocked.Decrement(System.Int32@)" /> are truly atomic only on systems where a <see cref="T:System.IntPtr" /> is 64-bits
long. On other systems, these methods are atomic with respect to each
other, but not with respect to other means of accessing the data.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>
