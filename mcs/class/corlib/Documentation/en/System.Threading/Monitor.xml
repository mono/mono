<?xml version="1.0" encoding="utf-8"?>
<Type Name="Monitor" FullName="System.Threading.Monitor" FullNameSP="System_Threading_Monitor" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public sealed Monitor extends System.Object" />
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The Monitor class controls access to objects by granting a lock for an object to a single thread. Object locks provide the ability to restrict access to a block of code, commonly called a critical section. While a thread owns the lock for an object, no other thread can acquire that lock. You can also use Monitor to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</para>
      <block subset="none" type="note">
        <para>Use <see cref="T:System.Threading.Monitor" /> to lock objects (that is, reference types), not value types. For details, see the overloads of the <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> method and the conceptual topic <format type="text/html"><a href="33FE4AEF-B44B-42FD-9E72-C908E39E75DB">[&lt;topic://cpconMonitor&gt;]</a></format>.</para>
      </block>
      <para>Monitor has the following features: </para>
      <list type="bullet">
        <item>
          <para>It is associated with an object on demand.</para>
        </item>
        <item>
          <para>It is unbound, which means it can be called directly from any context.</para>
        </item>
        <item>
          <para>An instance of the Monitor class cannot be created.</para>
        </item>
      </list>
      <para>The following information is maintained for each synchronized object: </para>
      <list type="bullet">
        <item>
          <para>A reference to the thread that currently holds the lock.</para>
        </item>
        <item>
          <para>A reference to a ready queue, which contains the threads that are ready to obtain the lock.</para>
        </item>
        <item>
          <para>A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</para>
        </item>
      </list>
      <para>The following table describes the actions that can be taken by threads that access synchronized objects: </para>
      <list type="table">
        <listheader>
          <item>
            <term>
              <para>Action </para>
            </term>
            <description>
              <para>Description </para>
            </description>
          </item>
        </listheader>
        <item>
          <term>
            <para>
              <see cref="M:System.Threading.Monitor.Enter(System.Object)" />, <see cref="M:System.Threading.Monitor.TryEnter(System.Object)" /> </para>
          </term>
          <description>
            <para>Acquires a lock for an object. This action also marks the beginning of a critical section. No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object. </para>
          </description>
        </item>
        <item>
          <term>
            <para>
              <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" /> </para>
          </term>
          <description>
            <para>Releases the lock on an object in order to permit other threads to lock and access the object. The calling thread waits while another thread accesses the object. Pulse signals are used to notify waiting threads about changes to an object's state. </para>
          </description>
        </item>
        <item>
          <term>
            <para>
              <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> (signal), <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> </para>
          </term>
          <description>
            <para>Sends a signal to one or more waiting threads. The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock. The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object. Once the thread has the lock, it can check the new state of the object to see if the required state has been reached. </para>
          </description>
        </item>
        <item>
          <term>
            <para>
              <see cref="M:System.Threading.Monitor.Exit(System.Object)" /> </para>
          </term>
          <description>
            <para>Releases the lock on an object. This action also marks the end of a critical section protected by the locked object. </para>
          </description>
        </item>
      </list>
      <para>Use the Enter and Exit methods to mark the beginning and end of a critical section. If the critical section is a set of contiguous instructions, then the lock acquired by the Enter method guarantees that only a single thread can execute the enclosed code with the locked object. In this case, it is recommended you place those instructions in a try block and place the Exit instruction in a finally block. This facility is typically used to synchronize access to a static or instance method of a class. The functionality provided by the Enter and Exit methods is identical to that provided by the C# lock statement (SyncLock in Visual Basic), except that lock and SyncLock wrap the <see cref="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" /> method overload and the <see cref="M:System.Threading.Monitor.Exit(System.Object)" /> method in a try…finally block (Try…Finally in Visual Basic) to ensure that the monitor is released. </para>
      <para>Beginning with the net_v40_long, there are two sets of overloads for the <see cref="Overload:System.Threading.Monitor.Enter" /> and <see cref="Overload:System.Threading.Monitor.TryEnter" /> methods. One set of overloads has a ref (ByRef in Visual Basic) <see cref="T:System.Boolean" /> parameter that is atomically set to true if the lock is acquired, even if an exception is thrown when acquiring the lock. Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state. </para>
      <para>If a critical section spans an entire method, the locking facility described above can be achieved by placing the <see cref="T:System.Runtime.CompilerServices.MethodImplAttribute" /> on the method, and specifying the <see cref="F:System.Runtime.CompilerServices.MethodImplOptions.Synchronized" /> value in the constructor of MethodImplAttribute. Using this attribute, the Enter and Exit statements are not needed. Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the Monitor class or the C# lock statement instead of the attribute.</para>
      <para>While it is possible for the Enter and Exit statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</para>
      <para>When selecting an object on which to synchronize, you should lock only on private or internal objects. Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides a mechanism that synchronizes access to objects.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName="Enter">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Enter(object obj)" />
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj " />is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use Enter to acquire the <see cref="T:System.Threading.Monitor" /> on the object passed as the parameter. If another thread has executed an Enter on the object but has not yet executed the corresponding <see cref="M:System.Threading.Monitor.Exit(System.Object)" />, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke Enter more than once without it blocking; however, an equal number of Exit calls must be invoked before other threads waiting on the object will unblock.</para>
          <para>Use <see cref="T:System.Threading.Monitor" /> to lock objects (that is, reference types), not value types. When you pass a value type variable to Enter, it is boxed as an object. If you pass the same variable to Enter again, it is boxed as a separate object, and the thread does not block. In this case, the code that Monitor is supposedly protecting is not protected. Furthermore, when you pass the variable to Exit, still another separate object is created. Because the object passed to Exit is different from the object passed to Enter, Monitor throws <see cref="T:System.Threading.SynchronizationLockException" />. For more information, see the conceptual topic <format type="text/html"><a href="33FE4AEF-B44B-42FD-9E72-C908E39E75DB">[&lt;topic://cpconMonitor&gt;]</a></format>.</para>
          <para>
            <see cref="M:System.Threading.Thread.Interrupt" /> can interrupt threads that are waiting to enter a Monitor on an object. A <see cref="T:System.Threading.ThreadInterruptedException" /> will be thrown.</para>
          <para>Use a C# try…finally block (Try…Finally in Visual Basic) to ensure that you release the monitor, or use the C# lock statement (SyncLock statement in Visual Basic), which wraps the <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> and <see cref="M:System.Threading.Monitor.Exit(System.Object)" /> methods in a try…finally block.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Acquires an exclusive lock on the specified object.</para>
        </summary>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to acquire the monitor lock. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool lockTaken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="lockTaken">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Exit(object obj)" />
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj " />is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <para>The current thread does not own the lock for the specified object.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The calling thread must own the lock on the <paramref name="obj" /> parameter. If the calling thread owns the lock on the specified object, and has made an equal number of Exit and <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> calls for the object, then the lock is released. If the calling thread has not invoked Exit as many times as Enter, the lock is not released.</para>
          <para>If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock. If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls Exit. To move one or more waiting threads into the ready queue, call <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> before invoking Exit.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases an exclusive lock on the specified object.</para>
        </summary>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to release the lock. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method works only for locks that are acquired by using the methods of the <see cref="T:System.Threading.Monitor" /> class, or by using the C# lock statement or the Visual Basic SyncLock statement, which are implemented with <see cref="T:System.Threading.Monitor" />. </para>
          <para>Use this method with diagnostic tools, such as the <see cref="M:System.Diagnostics.Debug.Assert(System.Boolean)" /> method and the <see cref="T:System.Diagnostics.Contracts.Contract" /> class, to debug locking issues that involve the <see cref="T:System.Threading.Monitor" /> class. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the current thread holds the lock on the specified object. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current thread holds the lock on <paramref name="obj" />; otherwise, false.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to test. </param>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Pulse(object obj)" />
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj " />is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">The calling thread does not own the lock for the specified object.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Only the current owner of the lock can signal a waiting object using Pulse.</para>
          <para>The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock. Upon receiving the pulse, the waiting thread is moved to the ready queue. When the thread that invoked Pulse releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</para>
          <block subset="none" type="note">
            <para>The <see cref="T:System.Threading.Monitor" /> class does not maintain state indicating that the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> method has been called. Thus, if you call <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> when no threads are waiting, the next thread that calls <see cref="Overload:System.Threading.Monitor.Wait" /> blocks as if <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> had never been called. If two threads are using <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> and <see cref="Overload:System.Threading.Monitor.Wait" /> to interact, this could result in a deadlock. Contrast this with the behavior of the <see cref="T:System.Threading.AutoResetEvent" /> class: If you signal an <see cref="T:System.Threading.AutoResetEvent" /> by calling its <see cref="M:System.Threading.EventWaitHandle.Set" /> method, and there are no threads waiting, the <see cref="T:System.Threading.AutoResetEvent" /> remains in a signaled state until a thread calls <see cref="Overload:System.Threading.WaitHandle.WaitOne" />, <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, or <see cref="Overload:System.Threading.WaitHandle.WaitAll" />. The <see cref="T:System.Threading.AutoResetEvent" /> releases that thread and returns to the unsignaled state.</para>
          </block>
          <para>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </para>
          <para>The Pulse, <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, and <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" /> methods must be invoked from within a synchronized block of code. </para>
          <para>To signal multiple threads, use the <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Notifies a thread in the waiting queue of a change in the locked object's state.</para>
        </summary>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object a thread is waiting for. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void PulseAll(object obj)" />
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj " />is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">The calling thread does not own the lock for the specified object.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object. After the signal is sent, the waiting threads are moved to the ready queue. When the thread that invoked PulseAll releases the lock, the next thread in the ready queue acquires the lock.</para>
          <para>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </para>
          <para>The <see cref="M:System.Threading.Monitor.Pulse(System.Object)" />, PulseAll, and <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" /> methods must be invoked from within a synchronized block of code. </para>
          <para>The remarks for the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> method explain what happens if <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> is called when no threads are waiting.</para>
          <para>To signal a single thread, use the Pulse method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Notifies all waiting threads of a change in the object's state.</para>
        </summary>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that sends the pulse. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static bool TryEnter(object obj)" />
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj " />is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If successful, this method acquires an exclusive lock on the <paramref name="obj" /> parameter. This method returns immediately, whether or not the lock is available.</para>
          <para>This method is similar to <see cref="M:System.Threading.Monitor.Enter(System.Object)" />, but it will never block. If the thread cannot enter without blocking, the method returns false, and the thread does not enter the critical section.</para>
          <block subset="none" type="note">
            <para>Use <see cref="T:System.Threading.Monitor" /> to lock objects (that is, reference types), not value types. For details, see <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> and the conceptual topic <format type="text/html"><a href="33FE4AEF-B44B-42FD-9E72-C908E39E75DB">[&lt;topic://cpconMonitor&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Attempts to acquire an exclusive lock on the specified object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current thread acquires the lock; otherwise, false.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to acquire the lock. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool lockTaken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="lockTaken">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static bool TryEnter(object obj, int32 millisecondsTimeout)" />
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout " />is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" /> . </exception>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of milliseconds to wait for the lock. </param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the <paramref name="millisecondsTimeout" /> parameter equals <see cref="F:System.Threading.Timeout.Infinite" />, this method is equivalent to <see cref="M:System.Threading.Monitor.Enter(System.Object)" />. If <paramref name="millisecondsTimeout" /> equals 0, this method is equivalent to <see cref="M:System.Threading.Monitor.TryEnter(System.Object)" />.</para>
          <block subset="none" type="note">
            <para>Use <see cref="T:System.Threading.Monitor" /> to lock objects (that is, reference types), not value types. For details, see <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> and the conceptual topic <format type="text/html"><a href="33FE4AEF-B44B-42FD-9E72-C908E39E75DB">[&lt;topic://cpconMonitor&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current thread acquires the lock; otherwise, false.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to acquire the lock. </param>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of milliseconds to wait for the lock. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static bool TryEnter(object obj, valuetype System.TimeSpan timeout)" />
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj " />is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout " />in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> , or is greater than <see cref="F:System.Int32.MaxValue" /> .</exception>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock. A value of –1 millisecond specifies an infinite wait.</param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the value of the <paramref name="timeout" /> parameter converted to milliseconds equals –1, this method is equivalent to <see cref="M:System.Threading.Monitor.Enter(System.Object)" />. If the value of <paramref name="timeout" /> equals 0, this method is equivalent to <see cref="M:System.Threading.Monitor.TryEnter(System.Object)" />.</para>
          <block subset="none" type="note">
            <para>Use <see cref="T:System.Threading.Monitor" /> to lock objects (that is, reference types), not value types. For details, see <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> and the conceptual topic <format type="text/html"><a href="33FE4AEF-B44B-42FD-9E72-C908E39E75DB">[&lt;topic://cpconMonitor&gt;]</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current thread acquires the lock; otherwise, false.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to acquire the lock. </param>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock. A value of –1 millisecond specifies an infinite wait.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool lockTaken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="millisecondsTimeout">To be added.</param>
        <param name="lockTaken">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool lockTaken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="timeout">To be added.</param>
        <param name="lockTaken">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static bool Wait(object obj)" />
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj " />is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">The calling thread does not own the lock for the specified object.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</para>
          <para>When a thread calls Wait, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. All threads that call Wait remain in the waiting queue until they receive a signal from <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, sent by the owner of the lock. If Pulse is sent, only the thread at the head of the waiting queue is affected. If PulseAll is sent, all threads that are waiting for the object are affected. When the signal is received, one or more threads leave the waiting queue and enter the ready queue. A thread in the ready queue is permitted to reacquire the lock.</para>
          <para>This method returns when the calling thread reacquires the lock on the object. Note that this method blocks indefinitely if the holder of the lock does not call Pulse or PulseAll.</para>
          <para>The caller executes Wait once, regardless of the number of times <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked Enter on the object and invokes Exit as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls Enter as many times as necessary to restore the saved Enter count for the caller. Calling Wait releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</para>
          <para>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state. </para>
          <para>The <see cref="M:System.Threading.Monitor.Pulse(System.Object)" />, <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, and Wait methods must be invoked from within a synchronized block of code.</para>
          <para>The remarks for the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> method explain what happens if <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> is called when no threads are waiting.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the lock on an object and blocks the current thread until it reacquires the lock.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to wait. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static bool Wait(object obj, int32 millisecondsTimeout)" />
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj " />is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">The calling thread does not own the lock for the specified object.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout " /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" /> .</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method does not return until it reacquires an exclusive lock on the <paramref name="obj" /> parameter.</para>
          <para>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</para>
          <para>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" /> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" /> method again.</para>
          <para>When a thread calls Wait, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, or it is the next in the queue and a thread that holds the lock invokes <see cref="M:System.Threading.Monitor.Pulse(System.Object)" />. However, if <paramref name="millisecondsTimeout" /> elapses before another thread invokes this object's <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> method, the original thread is moved to the ready queue in order to regain the lock. </para>
          <block subset="none" type="note">
            <para>If <see cref="F:System.Threading.Timeout.Infinite" /> is specified for the <paramref name="millisecondsTimeout" /> parameter, this method blocks indefinitely unless the holder of the lock calls <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />. If <paramref name="millisecondsTimeout" /> equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock.</para>
          </block>
          <para>The caller executes Wait once, regardless of the number of times <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> on the object and invokes <see cref="M:System.Threading.Monitor.Exit(System.Object)" /> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> as many times as necessary to restore the saved <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> count for the caller. Calling Wait releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</para>
          <block subset="none" type="note">
            <para>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</para>
          </block>
          <para>The <see cref="M:System.Threading.Monitor.Pulse(System.Object)" />, <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, and Wait methods must be invoked from within a synchronized block of code.</para>
          <para>The remarks for the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> method explain what happens if <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> is called when no threads are waiting.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the lock was reacquired before the specified time elapsed; false if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to wait. </param>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of milliseconds to wait before the thread enters the ready queue. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static bool Wait(object obj, valuetype System.TimeSpan timeout)" />
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj " />is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">The calling thread does not own the lock for the specified object.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="timeout " />is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> , or is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method does not return until it reacquires an exclusive lock on the <paramref name="obj" /> parameter.</para>
          <para>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</para>
          <para>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" /> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" /> method again.</para>
          <para>When a thread calls Wait, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, or it is the next in the queue and a thread that holds the lock invokes <see cref="M:System.Threading.Monitor.Pulse(System.Object)" />. However, if <paramref name="timeout" /> elapses before another thread invokes this object's <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> method, the original thread is moved to the ready queue in order to regain the lock. </para>
          <block subset="none" type="note">
            <para>If a <see cref="T:System.TimeSpan" /> representing –1 millisecond is specified for the <paramref name="timeout" /> parameter, this method blocks indefinitely unless the holder of the lock calls <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />. If <paramref name="timeout" /> is 0 milliseconds, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock.</para>
          </block>
          <para>The caller executes Wait once, regardless of the number of times <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> on the object and invokes <see cref="M:System.Threading.Monitor.Exit(System.Object)" /> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> as many times as necessary to restore the saved <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> count for the caller. Calling Wait releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</para>
          <block subset="none" type="note">
            <para>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</para>
          </block>
          <para>The <see cref="M:System.Threading.Monitor.Pulse(System.Object)" />, <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, and Wait methods must be invoked from within a synchronized block of code.</para>
          <para>The remarks for the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> method explain what happens if <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> is called when no threads are waiting.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the lock was reacquired before the specified time elapsed; false if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to wait. </param>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method does not return until it reacquires an exclusive lock on the <paramref name="obj" /> parameter.</para>
          <para>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</para>
          <para>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" /> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" /> method again.</para>
          <para>When a thread calls Wait, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, or it is the next in the queue and a thread that holds the lock invokes <see cref="M:System.Threading.Monitor.Pulse(System.Object)" />. However, if <paramref name="millisecondsTimeout" /> elapses before another thread invokes this object's <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> method, the original thread is moved to the ready queue in order to regain the lock. </para>
          <block subset="none" type="note">
            <para>If <see cref="F:System.Threading.Timeout.Infinite" /> is specified for the <paramref name="millisecondsTimeout" /> parameter, this method blocks indefinitely unless the holder of the lock calls <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />. If <paramref name="millisecondsTimeout" /> equals 0, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock.</para>
          </block>
          <para>The caller executes Wait once, regardless of the number of times <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> on the object and invokes <see cref="M:System.Threading.Monitor.Exit(System.Object)" /> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> as many times as necessary to restore the saved <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> count for the caller. Calling Wait releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</para>
          <block subset="none" type="note">
            <para>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</para>
          </block>
          <para>The <see cref="M:System.Threading.Monitor.Pulse(System.Object)" />, <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, and Wait methods must be invoked from within a synchronized block of code.</para>
          <para>The remarks for the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> method explain what happens if <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> is called when no threads are waiting.</para>
          <format type="text/html">
            <h2>Notes on Exiting the Context</h2>
          </format>
          <para>The <paramref name="exitContext" /> parameter has no effect unless the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" /> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <see cref="T:System.ContextBoundObject" />. Even if you are currently executing a method on a class that is not derived from <see cref="T:System.ContextBoundObject" />, like <see cref="T:System.String" />, you can be in a nondefault context if a <see cref="T:System.ContextBoundObject" /> is on your stack in the current application domain.</para>
          <para>When your code is executing in a nondefault context, specifying true for <paramref name="exitContext" /> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" /> method. It returns to the original nondefault context after the call to the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" /> method completes.</para>
          <para>This can be useful when the context-bound class has the <see cref="T:System.Runtime.Remoting.Contexts.SynchronizationAttribute" /> attribute applied. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" /> method and specifies true for <paramref name="exitContext" />, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" /> method returns, the thread that made the call must wait to reenter the synchronization domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the lock was reacquired before the specified time elapsed; false if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to wait. </param>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of milliseconds to wait before the thread enters the ready queue. </param>
        <param name="exitContext">
          <attribution license="cc4" from="Microsoft" modified="false" />true to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method does not return until it reacquires an exclusive lock on the <paramref name="obj" /> parameter.</para>
          <para>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</para>
          <para>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" /> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" /> method again.</para>
          <para>When a thread calls Wait, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked Wait remains in the waiting queue until either a thread that holds the lock invokes <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, or it is the next in the queue and a thread that holds the lock invokes <see cref="M:System.Threading.Monitor.Pulse(System.Object)" />. However, if <paramref name="timeout" /> milliseconds elapse before another thread invokes this object's <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" /> method, the original thread is moved to the ready queue in order to regain the lock. </para>
          <block subset="none" type="note">
            <para>If a <see cref="T:System.TimeSpan" /> representing -1 millisecond is specified for the <paramref name="timeout" /> parameter, this method blocks indefinitely unless the holder of the lock calls <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> or <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />. If <paramref name="timeout" /> is 0 milliseconds, the thread that calls Wait releases the lock and then immediately enters the ready queue in order to regain the lock.</para>
          </block>
          <para>The caller executes Wait once, regardless of the number of times <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> has been invoked for the specified object. Conceptually, the Wait method stores the number of times the caller invoked <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> on the object and invokes <see cref="M:System.Threading.Monitor.Exit(System.Object)" /> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> as many times as necessary to restore the saved <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> count for the caller. Calling Wait releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</para>
          <block subset="none" type="note">
            <para>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</para>
          </block>
          <para>The <see cref="M:System.Threading.Monitor.Pulse(System.Object)" />, <see cref="M:System.Threading.Monitor.PulseAll(System.Object)" />, and Wait methods must be invoked from within a synchronized block of code.</para>
          <para>The remarks for the <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> method explain what happens if <see cref="M:System.Threading.Monitor.Pulse(System.Object)" /> is called when no threads are waiting.</para>
          <format type="text/html">
            <h2>Notes on Exiting the Context</h2>
          </format>
          <para>The <paramref name="exitContext" /> parameter has no effect unless the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" /> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <see cref="T:System.ContextBoundObject" />. Even if you are currently executing a method on a class that is not derived from <see cref="T:System.ContextBoundObject" />, like <see cref="T:System.String" />, you can be in a nondefault context if a <see cref="T:System.ContextBoundObject" /> is on your stack in the current application domain.</para>
          <para>When your code is executing in a nondefault context, specifying true for <paramref name="exitContext" /> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" /> method. It returns to the original nondefault context after the call to the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" /> method completes.</para>
          <para>This can be useful when the context-bound class has the <see cref="T:System.Runtime.Remoting.Contexts.SynchronizationAttribute" /> attribute applied. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" /> method and specifies true for <paramref name="exitContext" />, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <see cref="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" /> method returns, the thread that made the call must wait to reenter the synchronization domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the lock was reacquired before the specified time elapsed; false if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to wait. </param>
        <param name="timeout">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue. </param>
        <param name="exitContext">
          <attribution license="cc4" from="Microsoft" modified="false" />true to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, false. </param>
      </Docs>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>