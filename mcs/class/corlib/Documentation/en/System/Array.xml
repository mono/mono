<?xml version="1.0" encoding="utf-8"?>
<Type Name="Array" FullName="System.Array" FullNameSP="System_Array" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public abstract serializable Array extends System.Object implements System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList" />
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The <see cref="T:System.Array" /> class is the base class for language implementations that support arrays. However, only the system and compilers can derive explicitly from the <see cref="T:System.Array" /> class. Users should employ the array constructs provided by the language.</para>
      <para>An element is a value in an <see cref="T:System.Array" />. The length of an <see cref="T:System.Array" /> is the total number of elements it can contain. The rank of an <see cref="T:System.Array" /> is the number of dimensions in the <see cref="T:System.Array" />. The lower bound of a dimension of an <see cref="T:System.Array" /> is the starting index of that dimension of the <see cref="T:System.Array" />; a multidimensional <see cref="T:System.Array" /> can have different bounds for each dimension. An array can have a maximum of 32 dimensions. </para>
      <para>By default, the maximum size of an <see cref="T:System.Array" /> is 2 gigabytes (GB). In a 64-bit environment, you can avoid the size restriction by setting the enabled attribute of the <format type="text/html"><a href="5c7ea24a-39ac-4e5f-83b7-b9f9a1b556ab">gcAllowVeryLargeObjects</a></format> configuration element to true in the run-time environment. However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</para>
      <block subset="none" type="note">
        <para>Starting with the .NET Framework 2.0, the <see cref="T:System.Array" /> class implements the <see cref="T:System.Collections.Generic.IList`1" />, <see cref="T:System.Collections.Generic.ICollection`1" />, and <see cref="T:System.Collections.Generic.IEnumerable`1" /> generic interfaces. The implementations are provided to arrays at run time, and therefore are not visible to the documentation build tools. As a result, the generic interfaces do not appear in the declaration syntax for the <see cref="T:System.Array" /> class, and there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations). The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <see cref="T:System.NotSupportedException" />. </para>
      </block>
      <para>
        <see cref="T:System.Type" /> objects provide information about array type declarations. <see cref="T:System.Array" /> objects with the same array type share the same <see cref="T:System.Type" /> object.</para>
      <para>
        <see cref="P:System.Type.IsArray" /> and <see cref="M:System.Type.GetElementType" /> might not return the expected results with <see cref="T:System.Array" /> because if an array is cast to the type <see cref="T:System.Array" />, the result is an object, not an array. That is, typeof(System.Array).IsArray returns false, and typeof(System.Array).GetElementType returns null.</para>
      <para>Unlike most classes, <see cref="T:System.Array" /> provides the <see cref="Overload:System.Array.CreateInstance" /> method, instead of public constructors, to allow for late bound access.</para>
      <para>The <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</para>
      <para>Some methods, such as <see cref="M:System.Array.CreateInstance(System.Type,System.Int32)" />, <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />, <see cref="M:System.Array.CopyTo(System.Array,System.Int32)" />, <see cref="Overload:System.Array.GetValue" />, and <see cref="Overload:System.Array.SetValue" />, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays. <see cref="P:System.Array.LongLength" /> and <see cref="M:System.Array.GetLongLength(System.Int32)" /> return 64-bit integers indicating the length of the array.</para>
      <para>The <see cref="T:System.Array" /> is not guaranteed to be sorted.  You must sort the <see cref="T:System.Array" /> prior to performing operations (such as <see cref="Overload:System.Array.BinarySearch" />) that require the <see cref="T:System.Array" /> to be sorted.</para>
      <para>Using an <see cref="T:System.Array" /> object of pointers in native code is not supported and will throw a <see cref="T:System.NotSupportedException" /> for several methods.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to wrap in a read-only <see cref="T:System.Collections.Generic.IList&lt;T&gt;" /> wrapper.</param>
        <summary>
          <para>Returns a read-only <see cref="T: System.Collections.Generic.IList&lt;T&gt;" /> wrapper around the specified array.</para>
        </summary>
        <returns>
          <para>A read-only <see cref="T:System.Collections.Generic.IList&lt;T&gt;" />  wrapper around the specified array.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">To prevent any modifications to the array, expose the array only through this wrapper.</block>
          </para>
          <para>The returned <see langword="IList&lt;T&gt;" /> has the same enumeration order as the array it wraps.</para>
          <para>A collection that is read-only is simply a collection with a wrapper that prevents modifying the underlying array; therefore, if changes are made to the underlying array, the read-only collection reflects those changes.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 BinarySearch(class System.Array array, object value)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>Both <paramref name="value" /> and at least one element of <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface. </para>
          <para>-or-</para>
          <para>
            <paramref name="value" /> is not assignment-compatible with at least one element of <paramref name="array" />. </para>
          <para>-or-</para>
          <para>
            <paramref name="array" />.UpperBound == <see cref="F:System.Int32.MaxValue" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="array" /> has more than one dimension.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>Both <paramref name="value" /> and at least one element of <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface. </para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method does not support searching arrays that contain negative indexes. <paramref name="array" /> must be sorted before calling this method.</para>
          <para>If the <see cref="T:System.Array" /> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, Not in Visual Basic) to the negative result  to produce an index. If this index is one greater than the upper bound of the array, there are no elements larger than <paramref name="value" /> in the array. Otherwise, it is the index of the first element that is larger than <paramref name="value" />. </para>
          <para>Either <paramref name="value" /> or every element of <paramref name="array" /> must implement the <see cref="T:System.IComparable" /> interface, which is used for comparisons. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by the <see cref="T:System.IComparable" /> implementation; otherwise, the result might be incorrect.</para>
          <block subset="none" type="note">
            <para>If <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, the elements of <paramref name="array" /> are not tested for <see cref="T:System.IComparable" /> before the search begins. An exception is thrown if the search encounters an element that does not implement <see cref="T:System.IComparable" />.</para>
          </block>
          <para>Duplicate elements are allowed. If the <see cref="T:System.Array" /> contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, and not necessarily the first one.</para>
          <para>null can always be compared with any other reference type; therefore, comparisons with null do not generate an exception. </para>
          <block subset="none" type="note">
            <para>   For every element tested, <paramref name="value" /> is passed to the appropriate <see cref="T:System.IComparable" /> implementation, even if <paramref name="value" /> is null. That is, the <see cref="T:System.IComparable" /> implementation determines how a given element compares to null.</para>
          </block>
          <para>This method is an O(log <paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, a negative number which is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than any of the elements in <paramref name="array" />, a negative number which is the bitwise complement of (the index of the last element plus 1).</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The sorted one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to search for.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and both <paramref name="value" /> and at least one element of <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</para>
          <para>-or-</para>
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is not assignment-compatible with at least one element of <paramref name="array" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="array" />.UpperBound == <see cref="F:System.Int32.MaxValue" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and both <paramref name="value" /> and at least one element of <paramref name="array" /> do not implement the <see cref="T:System.IComparable" />  interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method does not support searching arrays that contain negative indexes. <paramref name="array" /> must be sorted before calling this method.</para>
          <para>If the <see cref="T:System.Array" /> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, Not in Visual Basic) to the negative result  to produce an index. If this index is one greater than the upper bound of the array, there are no elements larger than <paramref name="value" /> in the array. Otherwise, it is the index of the first element that is larger than <paramref name="value" />. </para>
          <para>The comparer customizes how the elements are compared. For example, you can use a <see cref="T:System.Collections.CaseInsensitiveComparer" /> as the comparer to perform case-insensitive string searches.</para>
          <para>If <paramref name="comparer" /> is not null, the elements of <paramref name="array" /> are compared to the specified value using the specified <see cref="T:System.Collections.IComparer" /> implementation. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by <paramref name="comparer" />; otherwise, the result might be incorrect.</para>
          <para>If <paramref name="comparer" /> is null, the comparison is done using the <see cref="T:System.IComparable" /> implementation provided by the element itself or by the specified value. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by the <see cref="T:System.IComparable" /> implementation; otherwise, the result might be incorrect.</para>
          <block subset="none" type="note">
            <para>If <paramref name="comparer" /> is null and <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, the elements of <paramref name="array" /> are not tested for <see cref="T:System.IComparable" /> before the search begins. An exception is thrown if the search encounters an element that does not implement <see cref="T:System.IComparable" />.</para>
          </block>
          <para>Duplicate elements are allowed. If the <see cref="T:System.Array" /> contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, and not necessarily the first one.</para>
          <para>null can always be compared with any other reference type; therefore, comparisons with null do not generate an exception. </para>
          <block subset="none" type="note">
            <para>For every element tested, <paramref name="value" /> is passed to the appropriate <see cref="T:System.IComparable" /> implementation, even if <paramref name="value" /> is null. That is, the <see cref="T:System.IComparable" /> implementation determines how a given element compares to null.</para>
          </block>
          <para>This method is an O(log <paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.IComparer" /> interface.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, a negative number which is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than any of the elements in <paramref name="array" />, a negative number which is the bitwise complement of (the index of the last element plus 1).</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The sorted one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to search for.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 BinarySearch(class System.Array array, int32 index, int32 length, object value)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> .</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="array" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" /> (i.e. <paramref name="index" /> + <paramref name="length" /> &gt; <paramref name="array" />.GetLowerBound(0) + <paramref name="array" />.Length).</para>
          <para> -or-</para>
          <para>
            <paramref name="array" />.UpperBound == <see cref="F:System.Int32.MaxValue" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>Either <paramref name="value" /> or at least one element of <paramref name="array" /> does not implement the <see cref="T:System.IComparable" /> interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method does not support searching arrays that contain negative indexes. <paramref name="array" /> must be sorted before calling this method.</para>
          <para>If the <see cref="T:System.Array" /> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, Not in Visual Basic) to the negative result  to produce an index. If this index is one greater than the upper bound of the array, there are no elements larger than <paramref name="value" /> in the array. Otherwise, it is the index of the first element that is larger than <paramref name="value" />. </para>
          <para>Either <paramref name="value" /> or every element of <paramref name="array" /> must implement the <see cref="T:System.IComparable" /> interface, which is used for comparisons. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by the <see cref="T:System.IComparable" /> implementation; otherwise, the result might be incorrect.</para>
          <block subset="none" type="note">
            <para>If <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, the elements of <paramref name="array" /> are not tested for <see cref="T:System.IComparable" /> before the search begins. An exception is thrown if the search encounters an element that does not implement <see cref="T:System.IComparable" />.</para>
          </block>
          <para>Duplicate elements are allowed. If the <see cref="T:System.Array" /> contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, and not necessarily the first one.</para>
          <para>null can always be compared with any other reference type; therefore, comparisons with null do not generate an exception. </para>
          <block subset="none" type="note">
            <para>   For every element tested, <paramref name="value" /> is passed to the appropriate <see cref="T:System.IComparable" /> implementation, even if <paramref name="value" /> is null. That is, the <see cref="T:System.IComparable" /> implementation determines how a given element compares to null.</para>
          </block>
          <para>This method is an O(log <paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified value.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, a negative number which is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than any of the elements in <paramref name="array" />, a negative number which is the bitwise complement of (the index of the last element plus 1).</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The sorted one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the range to search.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The length of the range to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to search for.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than <paramref name="array" /><see langword=".GetLowerBound(0)" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> + <paramref name="length" /> is greater than <paramref name="array" /><see langword=".GetLowerBound(0)" /> + <paramref name="array" /><see langword=".Length" />.</para>
          <para> -or- </para>
          <para>
            <paramref name="array" />.UpperBound == <see cref="F:System.Int32.MaxValue" />.</para>
        </exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.BinarySearch(System.Array,System.Object)" /> method.</para>
          <code lang="C#">using System;
class BinarySearchExample {
  public static void Main() {    
    int[] intAry = { 0, 2, 4, 6, 8 };
    Console.WriteLine( "The indices and elements of the array are: ");
    for ( int i = 0; i &lt; intAry.Length; i++ )
      Console.Write("[{0}]: {1, -5}", i, intAry[i]);
    Console.WriteLine();
    SearchFor( intAry, 3 );
    SearchFor( intAry, 6 );
    SearchFor( intAry, 9 );
  }
  public static void SearchFor( Array ar, Object value ) {
    int i = Array.BinarySearch( ar, 0, ar.Length, value, null );
    Console.WriteLine();
    if ( i &gt; 0 ) {
      Console.Write( "The object searched for, {0}, was found ", value );
      Console.WriteLine( "at index {1}.", value, i );
    }
    else if ( ~i == ar.Length ) {
      Console.Write( "The object searched for, {0}, was ", value );
      Console.Write( "not found,\nand no object in the array had " );
      Console.WriteLine( "greater value. " );
    }
    else {
      Console.Write( "The object searched for, {0}, was ", value );
      Console.Write( "not found.\nThe next larger object is at " );
      Console.WriteLine( "index {0}.", ~i );
    }
  }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The indices and elements of the array are:</para>
            <para> [0]:0 [1]:2 [2]:4 [3]:6 [4]:8</para>
            <para>The object searched for, 3, was not found.</para>
            <para>The next larger object is at index 2.</para>
            <para>The object searched for, 6, was found at index 3.</para>
            <para>The object searched for, 9, was not found,</para>
            <para>and no object in the array had greater value.</para>
          </c>
        </example>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and both <paramref name="value" /> and at least one element of <paramref name="array" /> do not implement the <see cref="T:System.IComparable" />  interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method does not support searching arrays that contain negative indexes. <paramref name="array" /> must be sorted before calling this method.</para>
          <para>If the <see cref="T:System.Array" /> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, Not in Visual Basic) to the negative result  to produce an index. If this index is one greater than the upper bound of the array, there are no elements larger than <paramref name="value" /> in the array. Otherwise, it is the index of the first element that is larger than <paramref name="value" />. </para>
          <para>The comparer customizes how the elements are compared. For example, you can use a <see cref="T:System.Collections.CaseInsensitiveComparer" /> as the comparer to perform case-insensitive string searches.</para>
          <para>If <paramref name="comparer" /> is not null, the elements of <paramref name="array" /> are compared to the specified value using the specified <see cref="T:System.Collections.IComparer" /> implementation. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by <paramref name="comparer" />; otherwise, the result might be incorrect.</para>
          <para>If <paramref name="comparer" /> is null, the comparison is done using the <see cref="T:System.IComparable" /> implementation provided by the element itself or by the specified value. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by the <see cref="T:System.IComparable" /> implementation; otherwise, the result might be incorrect.</para>
          <block subset="none" type="note">
            <para>If <paramref name="comparer" /> is null and <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, the elements of <paramref name="array" /> are not tested for <see cref="T:System.IComparable" /> before the search begins. An exception is thrown if the search encounters an element that does not implement <see cref="T:System.IComparable" />.</para>
          </block>
          <para>Duplicate elements are allowed. If the <see cref="T:System.Array" /> contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, and not necessarily the first one.</para>
          <para>null can always be compared with any other reference type; therefore, comparisons with null do not generate an exception when using <see cref="T:System.IComparable" />. </para>
          <block subset="none" type="note">
            <para>For every element tested, <paramref name="value" /> is passed to the appropriate <see cref="T:System.IComparable" /> implementation, even if <paramref name="value" /> is null. That is, the <see cref="T:System.IComparable" /> implementation determines how a given element compares to null.</para>
          </block>
          <para>This method is an O(log <paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.IComparer" /> interface.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, a negative number which is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than any of the elements in <paramref name="array" />, a negative number which is the bitwise complement of (the index of the last element plus 1).</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The sorted one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the range to search.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The length of the range to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to search for.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The one-dimensional array to search.</param>
        <param name="value">The object for which to search.</param>
        <summary>
          <para>Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified object.</para>
        </summary>
        <returns>
          <para>One of the following values based on the result of the search operation:</para>
          <list type="table">
            <listheader>
              <term>Return Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>A non-negative index of <paramref name="value" /> in the array.</term>
              <description>
                <paramref name="value" /> was found.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of the index of the first element that is larger than   <paramref name="value" />.</term>
              <description>
                <paramref name="value" /> was not found and the value of at least one element of array was greater than <paramref name="value" />.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of one more than the index of the final element.</term>
              <description>
                <paramref name="value" /> was not found, and  <paramref name="value" /> was greater than the value of all array elements.</description>
            </item>
          </list>
        </returns>
        <remarks>
          <para>Either <paramref name="value" /> or every element of <paramref name="array" />  must implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" />  interface, which is used for comparisons. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation; otherwise, the  behavior is unspecified</para>
          <para>Duplicate elements are allowed. If the array contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, but not necessarily the first one.</para>
          <para>
            <block subset="none" type="note">
              <see langword="null" /> can always be compared with any other reference type; therefore, comparisons with <see langword="null" /> do not generate an exception.</block>
          </para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> .</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>Neither <paramref name="value" /> nor the elements of the array implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interfaces.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> .</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and neither <paramref name="value" /> nor the elements of the array implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method does not support searching arrays that contain negative indexes. <paramref name="array" /> must be sorted before calling this method.</para>
          <para>If the <see cref="T:System.Array" /> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, Not in Visual Basic) to the negative result to produce an index. If this index is equal to the size of the array, there are no elements larger than <paramref name="value" /> in the array. Otherwise, it is the index of the first element that is larger than <paramref name="value" />. </para>
          <para>The comparer customizes how the elements are compared. For example, you can use a <see cref="T:System.Collections.CaseInsensitiveComparer" /> as the comparer to perform case-insensitive string searches.</para>
          <para>If <paramref name="comparer" /> is not null, the elements of <paramref name="array" /> are compared to the specified value using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by <paramref name="comparer" />; otherwise, the result might be incorrect.</para>
          <para>If <paramref name="comparer" /> is null, the comparison is done using the <see cref="T:System.IComparable`1" /> generic interface implementation provided by <paramref name="T" />. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by the <see cref="T:System.IComparable`1" /> implementation; otherwise, the result might be incorrect.</para>
          <block subset="none" type="note">
            <para>If <paramref name="comparer" /> is null and <paramref name="value" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface, the elements of <paramref name="array" /> are not tested for <see cref="T:System.IComparable`1" /> before the search begins. An exception is thrown if the search encounters an element that does not implement <see cref="T:System.IComparable`1" />.</para>
          </block>
          <para>Duplicate elements are allowed. If the <see cref="T:System.Array" /> contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, and not necessarily the first one.</para>
          <para>null can always be compared with any other reference type; therefore, comparisons with null do not generate an exception. </para>
          <block subset="none" type="note">
            <para>For every element tested, <paramref name="value" /> is passed to the appropriate <see cref="T:System.IComparable`1" /> implementation, even if <paramref name="value" /> is null. That is, the <see cref="T:System.IComparable`1" /> implementation determines how a given element compares to null.</para>
          </block>
          <para>This method is an O(log <paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, a negative number which is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than any of the elements in <paramref name="array" />, a negative number which is the bitwise complement of (the index of the last element plus 1).</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.  </param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to search for.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The one-dimensional array to search.</param>
        <param name="index">To be added.</param>
        <param name="length">The length of the range to search.</param>
        <param name="value">The object for which to search.</param>
        <summary>
          <para>Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified value.</para>
        </summary>
        <returns>
          <para>One of the following values based on the result of the search operation:</para>
          <list type="table">
            <listheader>
              <term>Return Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>A non-negative index of <paramref name="value" /> in the array.</term>
              <description>
                <paramref name="value" /> was found.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of the index of the first element that is larger than   <paramref name="value" />.</term>
              <description>
                <paramref name="value" /> was not found and the value of at least one element of array was greater than <paramref name="value" />.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of one more than the index of the final element.</term>
              <description>
                <paramref name="value" /> was not found, and  <paramref name="value" /> was greater than the value of all array elements.</description>
            </item>
          </list>
        </returns>
        <remarks>
          <para>Either <paramref name="value" /> or every element of <paramref name="array" />  must implement the <see cref="T:System.IComparable" />  interface, which is used for comparisons. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation; otherwise, the behavior is unspecified</para>
          <para>Duplicate elements are allowed. If the array contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, but not necessarily the first one.</para>
          <para>
            <block subset="none" type="note">
              <see langword="null" /> can always be compared with any other reference type; therefore, comparisons with <see langword="null" /> do not generate an exception.</block>
          </para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> + <paramref name="length" /> is greater than <paramref name="array" /><see langword=".Length" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> .</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>Neither <paramref name="value" /> nor the elements of the array implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in array.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> .</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and neither <paramref name="value" /> nor the elements of the array implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method does not support searching arrays that contain negative indexes. <paramref name="array" /> must be sorted before calling this method.</para>
          <para>If the array does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, Not in Visual Basic) to the negative result  to produce an index. If this index is equal to the size of the array, there are no elements larger than <paramref name="value" /> in the array. Otherwise, it is the index of the first element that is larger than <paramref name="value" />. </para>
          <para>The comparer customizes how the elements are compared. For example, you can use a <see cref="T:System.Collections.CaseInsensitiveComparer" /> as the comparer to perform case-insensitive string searches.</para>
          <para>If <paramref name="comparer" /> is not null, the elements of <paramref name="array" /> are compared to the specified value using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by <paramref name="comparer" />; otherwise, the result might be incorrect.</para>
          <para>If <paramref name="comparer" /> is null, the comparison is done using the <see cref="T:System.IComparable`1" /> generic interface implementation provided for type <paramref name="T" />. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by the <see cref="T:System.IComparable`1" /> implementation; otherwise, the result might be incorrect.</para>
          <para>Duplicate elements are allowed. If the <see cref="T:System.Array" /> contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, and not necessarily the first one.</para>
          <para>null can always be compared with any other reference type; therefore, comparisons with null do not generate an exception when using <see cref="T:System.IComparable`1" />. </para>
          <block subset="none" type="note">
            <para>For every element tested, <paramref name="value" /> is passed to the appropriate <see cref="T:System.IComparable`1" /> implementation, even if <paramref name="value" /> is null. That is, the <see cref="T:System.IComparable`1" /> implementation determines how a given element compares to null.</para>
          </block>
          <para>This method is an O(log <paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found. If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, a negative number which is the bitwise complement of the index of the first element that is larger than <paramref name="value" />. If <paramref name="value" /> is not found and <paramref name="value" /> is greater than any of the elements in <paramref name="array" />, a negative number which is the bitwise complement of (the index of the last element plus 1).</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search. </param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the range to search.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The length of the range to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to search for.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Clear(class System.Array array, int32 index, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="array" />.GetLowerBound(0).</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" /> (i.e. <paramref name="index" /> + <paramref name="length" /> &gt; <paramref name="array" />.GetLowerBound(0) + <paramref name="array" />.Length ).</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method resets each element in an array to the element type's default value. It sets elements of reference types (including <see cref="T:System.String" /> elements) to null, and sets elements of value types to the default values shown in the following table. </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Type</para>
                </term>
                <description>
                  <para>Value</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>
                  <see cref="T:System.Boolean" />
                </para>
              </term>
              <description>
                <para>false</para>
              </description>
            </item>
            <item>
              <term>
                <para>All integral and floating point numeric types </para>
              </term>
              <description>
                <para>0 (zero)</para>
              </description>
            </item>
            <item>
              <term>
                <para>
                  <see cref="T:System.DateTime" />
                </para>
              </term>
              <description>
                <para>
                  <see cref="F:System.DateTime.MinValue" />
                </para>
              </description>
            </item>
            <item>
              <term>
                <para>Other value types </para>
              </term>
              <description>
                <para>Default value of the type's fields </para>
              </description>
            </item>
          </list>
          <para>The range of cleared elements wrap from row to row in a multi-dimensional array.</para>
          <para>This method only clears the values of the elements; it does not delete the elements themselves. An array has a fixed size; therefore, elements cannot be added or removed.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets a range of elements in an array to the default value of each element type.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The array whose elements need to be cleared.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the range of elements to clear.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements to clear.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual object Clone()" />
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.Clone" /> method.</para>
          <code lang="C#">using System;
public class ArrayCloneExample {
  public static void Main() {
    int[] intAryOrig = { 3, 4, 5 };
    //must explicitly convert clones object into an array
    int[] intAryClone = (int[]) intAryOrig.Clone();
    Console.Write( "The elements of the first  array are: " );
    foreach( int i in intAryOrig )
      Console.Write( "{0,3}", i );
    Console.WriteLine();
    Console.Write( "The elements of the cloned array are: " );
    foreach( int i in intAryClone )
      Console.Write( "{0,3}", i );
    Console.WriteLine();
    //Clear the values of the original array.
    Array.Clear( intAryOrig, 0, 3 );
    Console.WriteLine( "After clearing the first array," );
    Console.Write( "The elements of the first  array are: " );
    foreach( int i in intAryOrig )
      Console.Write( "{0,3}", i );
    Console.WriteLine();
    Console.Write( "The elements of the cloned array are: " );
    foreach( int i in intAryClone )
      Console.Write( "{0,3}", i );
  }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The elements of the first array are: 3 4 5</para>
            <para>The elements of the cloned array are: 3 4 5</para>
            <para>After clearing the first array,</para>
            <para>The elements of the first array are: 0 0 0</para>
            <para>The elements of the cloned array are: 3 4 5</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A shallow copy of an <see cref="T:System.Array" /> copies only the elements of the <see cref="T:System.Array" />, whether they are reference types or value types, but it does not copy the objects that the references refer to. The references in the new <see cref="T:System.Array" /> point to the same objects that the references in the original <see cref="T:System.Array" /> point to.</para>
          <para>In contrast, a deep copy of an <see cref="T:System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</para>
          <para>The clone is of the same <see cref="T:System.Type" /> as the original <see cref="T:System.Array" />.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <see cref="P:System.Array.Length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a shallow copy of the <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A shallow copy of the <see cref="T:System.Array" />.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="sourceArray" /> and <paramref name="destinationArray" /> parameters must have the same number of dimensions.  The <paramref name="sourceArray" /> type must be the same as or derived from the <paramref name="destinationArray" /> type; otherwise, an <see cref="T:System.ArrayTypeMismatchException" /> is thrown.  Unlike <see cref="Overload:System.Array.Copy" />, <see cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" /> verifies the compatibility of the array types before performing any operation.</para>
          <para>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end. For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column). To start copying from the second element of the third row (or column), <paramref name="sourceIndex" /> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</para>
          <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> overlap, this method behaves as if the original values of <paramref name="sourceArray" /> were preserved in a temporary location before <paramref name="destinationArray" /> is overwritten.</para>
          <para>[C++]</para>
          <para>This method is equivalent to the standard C/C++ function memmove, not memcpy.</para>
          <para>The arrays can be reference-type arrays or value-type arrays.  If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are both reference-type arrays or are both arrays of type <see cref="T:System.Object" />, a shallow copy is performed. A shallow copy of an <see cref="T:System.Array" /> is a new <see cref="T:System.Array" /> containing references to the same elements as the original <see cref="T:System.Array" />. The elements themselves or anything referenced by the elements are not copied. In contrast, a deep copy of an <see cref="T:System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</para>
          <para>If this method throws an exception while copying, the <paramref name="destinationArray" /> remains unchanged; therefore, <see cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" /> can be used within a constrained execution region (<see cref="T:System.Runtime.ConstrainedExecution.Cer" />).</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.  Guarantees that all changes are undone if the copy does not succeed completely.</para>
        </summary>
        <param name="sourceArray">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="sourceIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the index in the <paramref name="sourceArray" /> at which copying begins.</param>
        <param name="destinationArray">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="destinationIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the index in the <paramref name="destinationArray" /> at which storing begins.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the number of elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> or <paramref name="converter" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Converter`2" /> is a delegate to a method that converts an object to the target type.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Converter`2" />, and the converted elements are saved in the new array.</para>
          <para>The source <paramref name="array" /> remains unchanged.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts an array of one type to an array of another type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of the target type containing the converted elements from the source array.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to convert to a target type.</param>
        <param name="converter">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Converter`2" /> that converts each element from one type to another type.</param>
        <typeparam name="TInput">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the source array.</typeparam>
        <typeparam name="TOutput">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the target array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="sourceArray" /> or <paramref name="destinationArray" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</para>
        </exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <para>The elements in both arrays are built-in types, and converting from the type of the elements of <paramref name="sourceArray" /> into the type of the elements in <paramref name="destinationArray" /> requires a narrowing conversion.</para>
          <para> -or-</para>
          <para>Both arrays are built-in types, and one array is a value-type array and the other an array of interface type not implemented by that value-type.</para>
          <para> -or-</para>
          <para>Both arrays are user-defined value types and are not of the same type.</para>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <para> At least one of the elements in <paramref name="sourceArray" /> is not assignment-compatible with the type of <paramref name="destinationArray" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="length" /> &gt; <paramref name="sourceArray" />.Length.</para>
          <para>-or-</para>
          <para>
            <paramref name="length " /> &gt; <paramref name="destinationArray" />.Length.</para>
        </exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> method.</para>
          <code lang="C#">using System;
public class ArrayCopyExample {
   public static void Main() {
      int[] intAryOrig = new int[3];
      double[] dAryCopy = new double[3];
      for ( int i = 0; i &lt; intAryOrig.Length; i++ )
         intAryOrig[i] = i+3;
      //copy the first 2 elements of the source into the destination
      Array.Copy( intAryOrig, dAryCopy, 2);
      Console.Write( "The elements of the first array are: " );
      for ( int i = 0; i &lt; intAryOrig.Length; i++ ) 
         Console.Write( "{0,3}", intAryOrig[i] );
      Console.WriteLine();
      Console.Write( "The elements of the copied array are: " );
      for ( int i = 0; i &lt; dAryCopy.Length; i++ ) 
         Console.Write( "{0,3}", dAryCopy[i] );
   }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The elements of the first array are: 3 4 5</para>
            <para>The elements of the copied array are: 3 4 0</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="sourceArray" /> and <paramref name="destinationArray" /> parameters must have the same number of dimensions. In addition, <paramref name="destinationArray" /> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data. </para>
          <para>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end. For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</para>
          <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> overlap, this method behaves as if the original values of <paramref name="sourceArray" /> were preserved in a temporary location before <paramref name="destinationArray" /> is overwritten.</para>
          <para>[C++]</para>
          <para>This method is equivalent to the standard C/C++ function memmove, not memcpy.</para>
          <para>The arrays can be reference-type arrays or value-type arrays. Type downcasting is performed, as required.</para>
          <list type="bullet">
            <item>
              <para>When copying from a reference-type array to a value-type array, each element is unboxed and then copied. When copying from a value-type array to a reference-type array, each element is boxed and then copied.</para>
            </item>
            <item>
              <para>When copying from a reference-type or value-type array to an <see cref="T:System.Object" /> array, an <see cref="T:System.Object" /> is created to hold each value or reference and then copied. When copying from an <see cref="T:System.Object" /> array to a reference-type or value-type array and the assignment is not possible, an <see cref="T:System.InvalidCastException" /> is thrown.</para>
            </item>
            <item>
              <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are both reference-type arrays or are both arrays of type <see cref="T:System.Object" />, a shallow copy is performed. A shallow copy of an <see cref="T:System.Array" /> is a new <see cref="T:System.Array" /> containing references to the same elements as the original <see cref="T:System.Array" />. The elements themselves or anything referenced by the elements are not copied. In contrast, a deep copy of an <see cref="T:System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</para>
            </item>
          </list>
          <para>An <see cref="T:System.ArrayTypeMismatchException" /> is thrown if the arrays are of incompatible types. Type compatibility is defined as follows: </para>
          <list type="bullet">
            <item>
              <para>A type is compatible with itself.</para>
            </item>
            <item>
              <para>A value type is compatible with <see cref="T:System.Object" /> and with an interface type implemented by that value type. A value type is considered connected to an interface only if it implements that interface directly. Disconnected types are not compatible.</para>
            </item>
            <item>
              <para>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion. A widening conversion never loses information, whereas a narrowing conversion can lose information. For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion. For more information about conversions, see <see cref="T:System.Convert" />.</para>
            </item>
            <item>
              <para>A nonintrinsic (user-defined) value type is compatible only with itself.</para>
            </item>
            <item>
              <para>Enumerations have an implicit conversion to <see cref="T:System.Enum" /> and to their underlying type.</para>
            </item>
          </list>
          <para>If every element in <paramref name="sourceArray" /> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <paramref name="destinationArray" />, an <see cref="T:System.InvalidCastException" /> is thrown.</para>
          <para>If this method throws an exception while copying, the state of <paramref name="destinationArray" /> is undefined.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element. The length is specified as a 32-bit integer.</para>
        </summary>
        <param name="sourceArray">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="destinationArray">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the number of elements to copy.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="sourceArray" /> and <paramref name="destinationArray" /> parameters must have the same number of dimensions. In addition, <paramref name="destinationArray" /> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</para>
          <para>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end. For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</para>
          <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> overlap, this method behaves as if the original values of <paramref name="sourceArray" /> were preserved in a temporary location before <paramref name="destinationArray" /> is overwritten.</para>
          <para>[C++]</para>
          <para>This method is equivalent to the standard C/C++ function memmove, not memcpy.</para>
          <para>The arrays can be reference-type arrays or value-type arrays. Type downcasting is performed, as required.</para>
          <list type="bullet">
            <item>
              <para>When copying from a reference-type array to a value-type array, each element is unboxed and then copied. When copying from a value-type array to a reference-type array, each element is boxed and then copied.</para>
            </item>
            <item>
              <para>When copying from a reference-type or value-type array to an <see cref="T:System.Object" /> array, an <see cref="T:System.Object" /> is created to hold each value or reference and then copied. When copying from an <see cref="T:System.Object" /> array to a reference-type or value-type array and the assignment is not possible, an <see cref="T:System.InvalidCastException" /> is thrown.</para>
            </item>
            <item>
              <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are both reference-type arrays or are both arrays of type <see cref="T:System.Object" />, a shallow copy is performed. A shallow copy of an <see cref="T:System.Array" /> is a new <see cref="T:System.Array" /> containing references to the same elements as the original <see cref="T:System.Array" />. The elements themselves or anything referenced by the elements are not copied. In contrast, a deep copy of an <see cref="T:System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</para>
            </item>
          </list>
          <para>An <see cref="T:System.ArrayTypeMismatchException" /> is thrown if the arrays are of incompatible types. Type compatibility is defined as follows: </para>
          <list type="bullet">
            <item>
              <para>A type is compatible with itself.</para>
            </item>
            <item>
              <para>A value type is compatible with <see cref="T:System.Object" /> and with an interface type implemented by that value type. A value type is considered connected to an interface only if it implements that interface directly. Disconnected types are not compatible.</para>
            </item>
            <item>
              <para>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion. A widening conversion never loses information, whereas a narrowing conversion can lose information. For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion. For more information about conversions, see <see cref="T:System.Convert" />.</para>
            </item>
            <item>
              <para>A nonintrinsic (user-defined) value type is compatible only with itself.</para>
            </item>
            <item>
              <para>Enumerations have an implicit conversion to <see cref="T:System.Enum" /> and to their underlying type.</para>
            </item>
          </list>
          <para>If every element in <paramref name="sourceArray" /> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <paramref name="destinationArray" />, an <see cref="T:System.InvalidCastException" /> is thrown.</para>
          <para>If this method throws an exception while copying, the state of <paramref name="destinationArray" /> is undefined.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element. The length is specified as a 64-bit integer.</para>
        </summary>
        <param name="sourceArray">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="destinationArray">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the number of elements to copy. The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="sourceArray" /> or <paramref name="destinationArray" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</para>
        </exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <para>The elements in both arrays are built-in types, and converting from the type of the elements of <paramref name="sourceArray" /> into the type of the elements in <paramref name="destinationArray" /> requires a narrowing conversion.</para>
          <para>-or-</para>
          <para>Both arrays are built-in types, and one array is a value-type array and the other an array of interface type not implemented by that value-type.</para>
          <para>-or-</para>
          <para>Both arrays are user-defined value types and are not of the same type.</para>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <para>At least one element in <paramref name="sourceArray" /> is assignment-incompatible with the type of <paramref name="destinationArray" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="sourceIndex" /> &lt; <paramref name="sourceArray" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="destinationIndex" /> &lt; <paramref name="destinationArray" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>(<paramref name="sourceIndex" /> + <paramref name="length" /> ) &gt; (<paramref name="sourceArray" />.GetLowerBound(0) + <paramref name="sourceArray" />.Length).</para>
          <para>(<paramref name="destinationIndex" /> + <paramref name="length" /> ) &gt; ( <paramref name="destinationArray" />.GetLowerBound(0) + <paramref name="destinationArray" />.Length).</para>
        </exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> method.</para>
          <code lang="C#">using System;
class ArrayCopyExample {
   public static void Main() {
      int[] intAry = { 0, 10, 20, 30, 40, 50 };
      Console.Write( "The elements of the array are: " );
      foreach ( int i in intAry )
         Console.Write( "{0,3}", i );
      Console.WriteLine();
      Array.Copy( intAry, 2, intAry, 0, 4 );
      Console.WriteLine( "After copying elements 2 through 5 into elements 0 through 4" );
      Console.Write( "The elements of the array are: " );
      foreach ( int i in intAry )
         Console.Write( "{0,3}", i );
      Console.WriteLine();     
   }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The elements of the array are: 0 10 20 30 40 50</para>
            <para>After copying elements 2 through 5 into elements 0 through 4</para>
            <para>The elements of the array are: 20 30 40 50 40 50</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="sourceArray" /> and <paramref name="destinationArray" /> parameters must have the same number of dimensions. In addition, <paramref name="destinationArray" /> must already have been dimensioned and must have a sufficient number of elements starting from the <paramref name="destinationIndex" /> position to accommodate the copied data. </para>
          <para>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end. For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column). To start copying from the second element of the third row (or column), <paramref name="sourceIndex" /> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</para>
          <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> overlap, this method behaves as if the original values of <paramref name="sourceArray" /> were preserved in a temporary location before <paramref name="destinationArray" /> is overwritten.</para>
          <para>[C++]</para>
          <para>This method is equivalent to the standard C/C++ function memmove, not memcpy.</para>
          <para>The arrays can be reference-type arrays or value-type arrays. Type downcasting is performed, as required.</para>
          <list type="bullet">
            <item>
              <para>When copying from a reference-type array to a value-type array, each element is unboxed and then copied. When copying from a value-type array to a reference-type array, each element is boxed and then copied.</para>
            </item>
            <item>
              <para>When copying from a reference-type or value-type array to an <see cref="T:System.Object" /> array, an <see cref="T:System.Object" /> is created to hold each value or reference and then copied. When copying from an <see cref="T:System.Object" /> array to a reference-type or value-type array and the assignment is not possible, an <see cref="T:System.InvalidCastException" /> is thrown.</para>
            </item>
            <item>
              <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are both reference-type arrays or are both arrays of type <see cref="T:System.Object" />, a shallow copy is performed. A shallow copy of an <see cref="T:System.Array" /> is a new <see cref="T:System.Array" /> containing references to the same elements as the original <see cref="T:System.Array" />. The elements themselves or anything referenced by the elements are not copied. In contrast, a deep copy of an <see cref="T:System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</para>
            </item>
          </list>
          <para>An <see cref="T:System.ArrayTypeMismatchException" /> is thrown if the arrays are of incompatible types. Type compatibility is defined as follows: </para>
          <list type="bullet">
            <item>
              <para>A type is compatible with itself.</para>
            </item>
            <item>
              <para>A value type is compatible with <see cref="T:System.Object" /> and with an interface type implemented by that value type. A value type is considered connected to an interface only if it implements that interface directly. Disconnected types are not compatible.</para>
            </item>
            <item>
              <para>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion. A widening conversion never loses information, whereas a narrowing conversion can lose information. For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion. For more information about conversions, see <see cref="T:System.Convert" />.</para>
            </item>
            <item>
              <para>A nonintrinsic (user-defined) value type is compatible only with itself.</para>
            </item>
            <item>
              <para>Enumerations have an implicit conversion to <see cref="T:System.Enum" /> and to their underlying type.</para>
            </item>
          </list>
          <para>If every element in <paramref name="sourceArray" /> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <paramref name="destinationArray" />, an <see cref="T:System.InvalidCastException" /> is thrown.</para>
          <para>If this method throws an exception while copying, the state of <paramref name="destinationArray" /> is undefined.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index. The length and the indexes are specified as 32-bit integers.</para>
        </summary>
        <param name="sourceArray">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="sourceIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the index in the <paramref name="sourceArray" /> at which copying begins.</param>
        <param name="destinationArray">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="destinationIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the index in the <paramref name="destinationArray" /> at which storing begins.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the number of elements to copy.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="sourceArray" /> and <paramref name="destinationArray" /> parameters must have the same number of dimensions. In addition, <paramref name="destinationArray" /> must already have been dimensioned and must have a sufficient number of elements starting from the <paramref name="destinationIndex" /> position to accommodate the copied data. </para>
          <para>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end. For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column). To start copying from the second element of the third row (or column), <paramref name="sourceIndex" /> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</para>
          <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> overlap, this method behaves as if the original values of <paramref name="sourceArray" /> were preserved in a temporary location before <paramref name="destinationArray" /> is overwritten.</para>
          <para>[C++]</para>
          <para>This method is equivalent to the standard C/C++ function memmove, not memcpy.</para>
          <para>The arrays can be reference-type arrays or value-type arrays. Type downcasting is performed, as required.</para>
          <list type="bullet">
            <item>
              <para>When copying from a reference-type array to a value-type array, each element is unboxed and then copied. When copying from a value-type array to a reference-type array, each element is boxed and then copied.</para>
            </item>
            <item>
              <para>When copying from a reference-type or value-type array to an <see cref="T:System.Object" /> array, an <see cref="T:System.Object" /> is created to hold each value or reference and then copied. When copying from an <see cref="T:System.Object" /> array to a reference-type or value-type array and the assignment is not possible, an <see cref="T:System.InvalidCastException" /> is thrown.</para>
            </item>
            <item>
              <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are both reference-type arrays or are both arrays of type <see cref="T:System.Object" />, a shallow copy is performed. A shallow copy of an <see cref="T:System.Array" /> is a new <see cref="T:System.Array" /> containing references to the same elements as the original <see cref="T:System.Array" />. The elements themselves or anything referenced by the elements are not copied. In contrast, a deep copy of an <see cref="T:System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</para>
            </item>
          </list>
          <para>An <see cref="T:System.ArrayTypeMismatchException" /> is thrown if the arrays are of incompatible types. Type compatibility is defined as follows: </para>
          <list type="bullet">
            <item>
              <para>A type is compatible with itself.</para>
            </item>
            <item>
              <para>A value type is compatible with <see cref="T:System.Object" /> and with an interface type implemented by that value type. A value type is considered connected to an interface only if it implements that interface directly. Disconnected types are not compatible.</para>
            </item>
            <item>
              <para>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion. A widening conversion never loses information, whereas a narrowing conversion can lose information. For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion. For more information about conversions, see <see cref="T:System.Convert" />.</para>
            </item>
            <item>
              <para>A nonintrinsic (user-defined) value type is compatible only with itself.</para>
            </item>
            <item>
              <para>Enumerations have an implicit conversion to <see cref="T:System.Enum" /> and to their underlying type.</para>
            </item>
          </list>
          <para>If every element in <paramref name="sourceArray" /> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <paramref name="destinationArray" />, an <see cref="T:System.InvalidCastException" /> is thrown.</para>
          <para>If this method throws an exception while copying, the state of <paramref name="destinationArray" /> is undefined.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index. The length and the indexes are specified as 64-bit integers.</para>
        </summary>
        <param name="sourceArray">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="sourceIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the index in the <paramref name="sourceArray" /> at which copying begins.</param>
        <param name="destinationArray">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="destinationIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the index in the <paramref name="destinationArray" /> at which storing begins.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the number of elements to copy. The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void CopyTo(class System.Array array, int32 index)" />
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <para>The current instance has more than one dimension.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> &lt; <paramref name="array" /><see langword=".GetLowerBound(0)" />.</exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="array" /> has more than one dimension.</para>
          <para> -or-</para>
          <para>( <paramref name="index" /> + Length of the current instance) &gt; (<paramref name="array" /><see langword=".GetLowerBound(0)" /> + <paramref name="array" /><see langword=".Length" />).</para>
          <para> -or-</para>
          <para>The number of elements in the current instance is greater than the available space from <paramref name="index" /> to the end of <paramref name="array" />.</para>
        </exception>
        <exception cref="T:System.ArrayTypeMismatchException">The element type of the current instance is not assignment-compatible with the element type of <paramref name="array" />.</exception>
        <example>
          <para> The following example shows how to copy the elements of one <see cref="T:System.Array" /> into another.</para>
          <code lang="C#">using System;

public class ArrayCopyToExample
{
   public static void Main()
   {
      Array aryOne = Array.CreateInstance(typeof(Object), 3);
      aryOne.SetValue("one", 0);
      aryOne.SetValue("two", 1);
      aryOne.SetValue("three", 2);

      Array aryTwo = Array.CreateInstance(typeof(Object), 5);
      for (int i=0; i &lt; aryTwo.Length; i++)
         aryTwo.SetValue(i, i);

      Console.WriteLine("The contents of the first array are:");
      foreach (object o in aryOne)
         Console.Write("{0} ", o);
      Console.WriteLine();
      Console.WriteLine("The original contents of the second array are:");
      foreach (object o in aryTwo)
         Console.Write("{0} ", o);
      Console.WriteLine();
      
      aryOne.CopyTo(aryTwo, 1);

      Console.WriteLine("The new contents of the second array are:");
      foreach( object o in aryTwo)
         Console.Write("{0} ", o);
   }
}
</code>
          <para>The output is</para>
          <para>
            <c>The contents of the first array are:</c>
          </para>
          <para>
            <c> one two three</c>
          </para>
          <para>
            <c>The original contents of the second array are:</c>
          </para>
          <para>
            <c>0 1 2 3 4</c>
          </para>
          <para>
            <c> The new contents of the second array are:</c>
          </para>
          <para>
            <c>0 one two three 4</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method copies all the elements of the current array instance to the <paramref name="array" /> destination array, starting at index <paramref name="index" />. The <paramref name="array" /> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements. Otherwise, the method throws an exception. </para>
          <para>This method supports the <see cref="T:System.Collections.ICollection" /> interface. If implementing <see cref="T:System.Collections.ICollection" /> is not explicitly required, use <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> to avoid an extra indirection.</para>
          <para>If this method throws an exception while copying, the state of <paramref name="array" /> is undefined.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <see cref="P:System.Array.Length" />. It performs a shallow copy only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 32-bit integer.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional array that is the destination of the elements copied from the current array.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the index in <paramref name="array" /> at which copying begins.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method copies all the elements of the current array instance to the <paramref name="array" /> destination array, starting at index <paramref name="index" />. The <paramref name="array" /> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements. Otherwise, the method throws an exception. </para>
          <para>This method supports the <see cref="T:System.Collections.ICollection" /> interface. If implementing <see cref="T:System.Collections.ICollection" /> is not explicitly required, use <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" /> to avoid an extra indirection.</para>
          <para>If this method throws an exception while copying, the state of <paramref name="array" /> is undefined.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <see cref="P:System.Array.Length" />. It performs a shallow copy only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 64-bit integer.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional array that is the destination of the elements copied from the current array.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the index in <paramref name="array" /> at which copying begins.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Array CreateInstance(class System.Type elementType, int32 length)" />
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> &lt; 0.</exception>
        <example>
          <para> The following example shows how to create and
      initialize a one-dimensional <see cref="T:System.Array" />.</para>
          <code lang="C#">using System;

public class ArrayCreateInstanceExample
{

   public static void Main()
   {

      Array intAry = Array.CreateInstance(typeof(int),5);
      for (int i=intAry.GetLowerBound(0);i&lt;=intAry.GetUpperBound(0);i++)
         intAry.SetValue(i*3,i);
      Console.Write("The values of the array are:");
      foreach (int i in intAry)
         Console.Write("{0} ",i);
   
   }

}
   </code>
          <para>The output is</para>
          <para>
            <c>The values of the array are: 0 3 6 9 12</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike most classes, <see cref="T:System.Array" /> provides the <see cref="Overload:System.Array.CreateInstance" /> method, instead of public constructors, to allow for late bound access.</para>
          <para>Reference-type elements are initialized to null. Value-type elements are initialized to zero.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and length, with zero-based indexing.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length, using zero-based indexing.</para>
        </returns>
        <param name="elementType">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The size of the <see cref="T:System.Array" /> to create.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Array CreateInstance(class System.Type elementType, class System.Int32[] lengths)" />
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="elementType" /> or <paramref name="lengths" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="lengths" />.Length = 0.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in <paramref name="lengths" /> is less than zero.</exception>
        <example>
          <para> The following example shows how to create and initialize a
      multidimensional <see cref="T:System.Array" />.</para>
          <code lang="C#">
using System;

public class CreateMultiDimArrayExample
{
   public static void Main()
   {
      int i, j, k;
      int[] indexAry = {2, 4, 5};
      Array ary = Array.CreateInstance( typeof(int), indexAry );
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++ )
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++ )
         {
            for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               ary.SetValue( (100*i + 10*j + k), i, j, k );
            }
         }
      }
      Console.WriteLine("The elements of the array are:");
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++)
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++)
         {
             for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               Console.Write("{0, 3} ", ary.GetValue(i, j, k));
            }
            Console.WriteLine();
         }
         Console.WriteLine();
      }
   }
}
   </code>
          <para>The output is</para>
          <code>The elements of the array are:
  0   1   2   3   4
 10  11  12  13  14
 20  21  22  23  24
 30  31  32  33  34

100 101 102 103 104
110 111 112 113 114
120 121 122 123 124
130 131 132 133 134 
</code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike most classes, <see cref="T:System.Array" /> provides the <see cref="Overload:System.Array.CreateInstance" /> method, instead of public constructors, to allow for late bound access.</para>
          <para>The number of elements in the <paramref name="lengths" /> array must equal the number of dimensions in the new <see cref="T:System.Array" />. Each element of the <paramref name="lengths" /> array must specify the length of the corresponding dimension in the new <see cref="T:System.Array" />.</para>
          <para>Reference-type elements are initialized to null. Value-type elements are initialized to zero.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the product of all values in <paramref name="lengths" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing. The dimension lengths are specified in an array of 32-bit integers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</para>
        </returns>
        <param name="elementType">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="lengths">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of 32-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike most classes, <see cref="T:System.Array" /> provides the <see cref="Overload:System.Array.CreateInstance" /> method, instead of public constructors, to allow for late bound access.</para>
          <para>The number of elements in the <paramref name="lengths" /> array must equal the number of dimensions in the new <see cref="T:System.Array" />. Each element of the <paramref name="lengths" /> array must specify the length of the corresponding dimension in the new <see cref="T:System.Array" />.</para>
          <para>Reference-type elements are initialized to null. Value-type elements are initialized to zero.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the product of all values in <paramref name="lengths" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing. The dimension lengths are specified in an array of 64-bit integers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</para>
        </returns>
        <param name="elementType">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="lengths">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of 64-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create. Each integer in the array must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2)" />
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="length1" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="length2" /> &lt; 0.</para>
        </exception>
        <example>
          <para> The following example shows how to create and
      initialize a two-dimensional <see cref="T:System.Array" />.</para>
          <code lang="C#">
using System;

public class Create2DArrayExample
{
   public static void Main()
   {
      int i, j;
      Array ary = Array.CreateInstance( typeof(int), 5, 3 );
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++ )
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++ )
         {
            ary.SetValue( (10*i + j), i, j );
         }
      }
      Console.WriteLine("The elements of the array are:");
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++)
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++)
         {
            Console.Write("{0, 2} ", ary.GetValue(i, j));
         }
         Console.WriteLine();
      }
   }
} 
  </code>
          <para>The output is</para>
          <code>The elements of the array are:
 0  1  2
10 11 12
20 21 22
30 31 32
40 41 42
 </code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike most classes, <see cref="T:System.Array" /> provides the <see cref="Overload:System.Array.CreateInstance" /> method, instead of public constructors, to allow for late bound access.</para>
          <para>Reference-type elements are initialized to null. Value-type elements are initialized to zero.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the product of <paramref name="length1" /> and <paramref name="length2" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</para>
        </returns>
        <param name="elementType">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="length1">
          <attribution license="cc4" from="Microsoft" modified="false" />The size of the first dimension of the <see cref="T:System.Array" /> to create.</param>
        <param name="length2">
          <attribution license="cc4" from="Microsoft" modified="false" />The size of the second dimension of the <see cref="T:System.Array" /> to create.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Array CreateInstance(class System.Type elementType, class System.Int32[] lengths, class System.Int32[] lowerBounds)" />
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="elementType" />, <paramref name="lengths" />, or <paramref name="lowerBounds" /> is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="lengths" />.Length = 0.</para>
          <para> -or-</para>
          <para>
            <paramref name="lengths" /> and <paramref name="lowerBounds" /> do not contain the same number of elements.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in <paramref name="lengths" /> is less than zero.</exception>
        <example>
          <para> The following example shows how to create and
      initialize a multidimensional <see cref="T:System.Array" />
      with specified low bounds.</para>
          <code lang="C#">
using System;

public class MultiDimNonZeroBoundExample
{
   public static void Main()
   {
      int i, j, k;
      int[] indexAry = {4, 2, 3};
      int[] lowboundAry = {3, 2, 1};
      Array ary = Array.CreateInstance( typeof(int), indexAry, lowboundAry );
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++ )
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++ )
         {
            for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               ary.SetValue( (100*i + 10*j + k), i, j, k );
            }
         }
      }
      Console.WriteLine("The elements of the array are:");
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++)
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++)
         {
             for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               Console.Write("{0, 3} ", ary.GetValue(i, j, k));
            }
            Console.WriteLine();
         }
         Console.WriteLine();
      }
   }
}
   </code>
          <para>The output is</para>
          <code>The elements of the array are:
321 322 323
331 332 333

421 422 423
431 432 433

521 522 523
531 532 533

621 622 623
631 632 633
</code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike most classes, <see cref="T:System.Array" /> provides the <see cref="Overload:System.Array.CreateInstance" /> method, instead of public constructors, to allow for late bound access.</para>
          <para>The <paramref name="lengths" /> and <paramref name="lowerBounds" /> arrays must have the same number of elements. The number of elements in the <paramref name="lengths" /> array must equal the number of dimensions in the new <see cref="T:System.Array" />.</para>
          <para>Each element of the <paramref name="lengths" /> array must specify the length of the corresponding dimension in the new <see cref="T:System.Array" />.</para>
          <para>Each element of the <paramref name="lowerBounds" /> array must specify the lower bound of the corresponding dimension in the new <see cref="T:System.Array" />. Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</para>
          <para>Reference-type elements are initialized to null. Value-type elements are initialized to zero.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the product of all values in <paramref name="lengths" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with the specified lower bounds.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length and lower bound for each dimension.</para>
        </returns>
        <param name="elementType">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="lengths">
          <attribution license="cc4" from="Microsoft" modified="false" />A one-dimensional array that contains the size of each dimension of the <see cref="T:System.Array" /> to create.</param>
        <param name="lowerBounds">
          <attribution license="cc4" from="Microsoft" modified="false" />A one-dimensional array that contains the lower bound (starting index) of each dimension of the <see cref="T:System.Array" /> to create.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3)" />
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="length1" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="length2" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="length3" /> &lt; 0.</para>
        </exception>
        <example>
          <para> The following example shows how to create and
      initialize a three-dimensional <see cref="T:System.Array" />.</para>
          <code lang="C#">
using System;

public class Create3DArrayExample
{
   public static void Main()
   {
      int i, j, k;
      Array ary = Array.CreateInstance( typeof(int), 2, 4, 3 );
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++ )
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++ )
         {
            for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               ary.SetValue( (100*i + 10*j + k), i, j, k );
            }
         }
      }
      Console.WriteLine("The elements of the array are:");
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++)
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++)
         {
             for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               Console.Write("{0, 3} ", ary.GetValue(i, j, k));
            }
            Console.WriteLine();
         }
         Console.WriteLine();
      }
   }
}
   </code>
          <para>The output is</para>
          <code>The elements of the array are:
  0   1   2
 10  11  12
 20  21  22
 30  31  32

100 101 102
110 111 112
120 121 122
130 131 132
 </code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unlike most classes, <see cref="T:System.Array" /> provides the <see cref="Overload:System.Array.CreateInstance" /> method, instead of public constructors, to allow for late bound access.</para>
          <para>Reference-type elements are initialized to null. Value-type elements are initialized to zero.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the product of <paramref name="length1" />, <paramref name="length2" />, and <paramref name="length3" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</para>
        </returns>
        <param name="elementType">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</param>
        <param name="length1">
          <attribution license="cc4" from="Microsoft" modified="false" />The size of the first dimension of the <see cref="T:System.Array" /> to create.</param>
        <param name="length2">
          <attribution license="cc4" from="Microsoft" modified="false" />The size of the second dimension of the <see cref="T:System.Array" /> to create.</param>
        <param name="length3">
          <attribution license="cc4" from="Microsoft" modified="false" />The size of the third dimension of the <see cref="T:System.Array" /> to create.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method that returns true if the object passed to it matches the conditions defined in the delegate.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />, and processing is stopped when a match is found.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="array" /> contains one or more elements that match the conditions defined by the specified predicate; otherwise, false.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method or a lambda expression that returns true if the object passed to it matches the conditions defined in the delegate or lambda expression.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />, starting with the first element and ending with the last element.  Processing is stopped when a match is found.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based array to search.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The predicate that defines the conditions of the element to search for.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method that returns true if the object passed to it matches the conditions defined in the delegate.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />, and the elements that match the conditions are saved in the returned array.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves all the elements that match the conditions defined by the specified predicate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.Array" /> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <see cref="T:System.Array" />.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Array" /> is searched forward starting at the first element and ending at the last element.</para>
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method that returns true if the object passed to it matches the conditions defined in the delegate.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than zero or greater than <paramref name="array" /><see langword=".Length" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Array" /> is searched forward starting at <paramref name="startIndex" /> and ending at the last element.</para>
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method that returns true if the object passed to it matches the conditions defined in the delegate.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the number of elements from <paramref name="startIndex" /> to the end of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the specified index to the last element.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based starting index of the search.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="startIndex" /> + <paramref name="count" /> is greater than <paramref name="array" /><see langword=".Length" />.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Array" /> is searched forward starting at <paramref name="startIndex" /> and ending at <paramref name="startIndex" /> plus <paramref name="count" /> minus 1, if <paramref name="count" /> is greater than 0.</para>
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method that returns true if the object passed to it matches the conditions defined in the delegate.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="count" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that starts at the specified index and contains the specified number of elements.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based starting index of the search.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the section to search.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method that returns true if the object passed to it matches the conditions defined in the delegate.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />, moving backward in the <see cref="T:System.Array" />, starting with the last element and ending with the first element.  Processing is stopped when a match is found.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Array" /> is searched backward starting at the last element and ending at the first element.</para>
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method that returns true if the object passed to it matches the conditions defined in the delegate.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than zero or greater than <paramref name="array" /><see langword=".Length" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Array" /> is searched backward starting at <paramref name="startIndex" /> and ending at the first element.</para>
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method that returns true if the object passed to it matches the conditions defined in the delegate.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the number of elements from the beginning of <paramref name="array" /> to <paramref name="startIndex" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based starting index of the backward search.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than zero or greater than <paramref name="array" /><see langword=".Length" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is greater than <paramref name="startIndex" /> + 1.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Array" /> is searched backward starting at <paramref name="startIndex" /> and ending at <paramref name="startIndex" /> minus <paramref name="count" /> plus 1, if <paramref name="count" /> is greater than 0.</para>
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method that returns true if the object passed to it matches the conditions defined in the delegate.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="count" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based starting index of the backward search.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the section to search.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="action" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Action`1" /> is a delegate to a method that performs an action on the object passed to it.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Action`1" />.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Performs the specified action on each element of the specified array.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> on whose elements the action is to be performed.</param>
        <param name="action">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Action`1" /> to perform on each element of <paramref name="array" />.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Collections.IEnumerator GetEnumerator()" />
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.GetEnumerator" /> method.</para>
          <code lang="C#">using System;
using System.Collections;
public class ArrayGetEnumerator {
   public static void Main() {
      string[,] strAry = {{"1","one"}, {"2", "two"}, {"3", "three"}};
      Console.Write( "The elements of the array are: " );
      IEnumerator sEnum = strAry.GetEnumerator();
      while ( sEnum.MoveNext() )
         Console.Write( " {0}", sEnum.Current );
   }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The elements of the array are: 1 one 2 two 3 three</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>[Visual Basic, C#]</para>
          <para>The foreach statement of the C# language (for each in C++, For Each in Visual Basic) hides the complexity of the enumerators. Therefore, using foreach is recommended, instead of directly manipulating the enumerator.</para>
          <para>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</para>
          <para>Initially, the enumerator is positioned before the first element in the collection. <see cref="M:System.Collections.IEnumerator.Reset" /> also brings the enumerator back to this position.  At this position, <see cref="P:System.Collections.IEnumerator.Current" /> is undefined. Therefore, you must call <see cref="M:System.Collections.IEnumerator.MoveNext" /> to advance the enumerator to the first element of the collection before reading the value of <see cref="P:System.Collections.IEnumerator.Current" />.</para>
          <para>
            <see cref="P:System.Collections.IEnumerator.Current" /> returns the same object until either <see cref="M:System.Collections.IEnumerator.MoveNext" /> or <see cref="M:System.Collections.IEnumerator.Reset" /> is called. <see cref="M:System.Collections.IEnumerator.MoveNext" /> sets <see cref="P:System.Collections.IEnumerator.Current" /> to the next element.</para>
          <para>If <see cref="M:System.Collections.IEnumerator.MoveNext" /> passes the end of the collection, the enumerator is positioned after the last element in the collection and <see cref="M:System.Collections.IEnumerator.MoveNext" /> returns false. When the enumerator is at this position, subsequent calls to <see cref="M:System.Collections.IEnumerator.MoveNext" /> also return false. If the last call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> returned false, <see cref="P:System.Collections.IEnumerator.Current" /> is undefined. To set <see cref="P:System.Collections.IEnumerator.Current" /> to the first element of the collection again, you can call <see cref="M:System.Collections.IEnumerator.Reset" /> followed by <see cref="M:System.Collections.IEnumerator.MoveNext" />.</para>
          <para>An enumerator remains valid as long as the collection remains unchanged. If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</para>
          <para>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.  To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.  To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="dimension" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An example of <see cref="M:System.Array.GetLength(System.Int32)" /> is GetLength(0), which returns the number of elements in the first dimension of the <see cref="T:System.Array" />.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a 32-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit integer that represents the number of elements in the specified dimension.</para>
        </returns>
        <param name="dimension">
          <attribution license="cc4" from="Microsoft" modified="false" />A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</param>
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An example of <see cref="M:System.Array.GetLongLength(System.Int32)" /> is GetLongLength(0), which returns the number of elements in the first dimension of the <see cref="T:System.Array" />.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a 64-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 64-bit integer that represents the number of elements in the specified dimension.</para>
        </returns>
        <param name="dimension">
          <attribution license="cc4" from="Microsoft" modified="false" />A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</param>
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension)" />
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="dimension" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="dimension" /> is equal to or greater than the <see cref="P:System.Array.Rank" /> property of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>GetLowerBound(0) returns the starting index of the first dimension of the array, and GetLowerBound(Rank - 1) returns the starting index of the last dimension of the array.</para>
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</para>
          <para>Note that, although most arrays in the .NET Framework are zero-based (that is, the <see cref="M:System.Array.GetLowerBound(System.Int32)" /> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based. Such arrays can be created with the <see cref="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" /> method, and can also be returned from unmanaged code. </para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the index of the first element of the specified dimension in the array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the first element of the specified dimension in the array.</para>
        </returns>
        <param name="dimension">
          <attribution license="cc4" from="Microsoft" modified="false" />A zero-based dimension of the array whose starting index needs to be determined.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension)" />
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="dimension" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="dimension" /> is equal to or greater than the <see cref="P:System.Array.Rank" /> property of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>GetUpperBound(0) returns the last index in the first dimension of the array, and GetUpperBound(Rank - 1) returns the last index of the last dimension of the array.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the index of the last element of the specified dimension in the array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty. </para>
        </returns>
        <param name="dimension">
          <attribution license="cc4" from="Microsoft" modified="false" />A zero-based dimension of the array whose upper bound needs to be determined.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object GetValue(int32 index)" />
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">The current instance has more than one dimension.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="index" /> is outside the range of valid indices for the current instance.</para>
        </exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.GetValue(System.Int32[])" /> method.</para>
          <code lang="C#">using System;
public class ArrayGetValueExample {
   public static void Main() {
      String[] strAry = { "one", "two", "three", "four", "five" };
      Console.Write( "The elements of the array are: " );
      for( int i = 0; i &lt; strAry.Length; i++ )
         Console.Write( " '{0}' ", strAry.GetValue( i ) );
   }
}
   </code>
          <para>The output is</para>
          <para>
            <c>The elements
      of the array are: 'one' 'two' 'three' 'four' 'five'</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether the value of <paramref name="index" /> is out of bounds.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />. The index is specified as a 32-bit integer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</para>
        </returns>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object GetValue(class System.Int32[] indices)" />
      <MemberSignature Language="C#" Value="public object GetValue (int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The number of dimensions in the current instance is not equal to the number of elements in <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>At least one element in <paramref name="indices" /> is outside the range of valid indices for the corresponding dimension of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of elements in <paramref name="indices" /> must equal the number of dimensions in the <see cref="T:System.Array" />. All elements in the <paramref name="indices" /> array must collectively specify the position of the desired element in the multidimensional <see cref="T:System.Array" />.</para>
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the indexes is out of bounds.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />. The indexes are specified as an array of 32-bit integers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value at the specified position in the multidimensional <see cref="T:System.Array" />.</para>
        </returns>
        <param name="indices">
          <attribution license="cc4" from="Microsoft" modified="false" />A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether the value of <paramref name="index" /> is out of bounds.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />. The index is specified as a 64-bit integer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</para>
        </returns>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</param>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of elements in <paramref name="indices" /> must equal the number of dimensions in the <see cref="T:System.Array" />. All elements in the <paramref name="indices" /> array must collectively specify the position of the desired element in the multidimensional <see cref="T:System.Array" />.</para>
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the indexes is out of bounds.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />. The indexes are specified as an array of 64-bit integers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value at the specified position in the multidimensional <see cref="T:System.Array" />.</para>
        </returns>
        <param name="indices">
          <attribution license="cc4" from="Microsoft" modified="false" />A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</param>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2)" />
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">The current instance does not have exactly two dimensions.</exception>
        <exception cref="T:System.IndexOutOfRangeException">At least one of <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current instance.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the indexes is out of bounds.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />. The indexes are specified as 32-bit integers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</para>
        </returns>
        <param name="index1">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index2">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the indexes is out of bounds.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />. The indexes are specified as 64-bit integers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</para>
        </returns>
        <param name="index1">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index2">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</param>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3)" />
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">The current instance does not have exactly three dimensions.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>At least one of<paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the indexes is out of bounds.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />. The indexes are specified as 32-bit integers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</para>
        </returns>
        <param name="index1">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index2">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index3">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the indexes is out of bounds.</para>
          <para>This method is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />. The indexes are specified as 64-bit integers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</para>
        </returns>
        <param name="index1">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index2">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</param>
        <param name="index3">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</param>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 IndexOf(class System.Array array, object value)" />
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Array.IndexOf(System.Array,System.Object)" /> 
method.</para>
          <code lang="C#">using System;
public class ArrayIndexOfExample {
   public static void Main() {
      int[] intAry = { 0, 1, 2, 0, 1 };
      Console.Write( "The values of the array are: " );
      foreach( int i in intAry )
         Console.Write( "{0,5}", i );
      Console.WriteLine();
      int j = Array.IndexOf( intAry, 1 );
      Console.WriteLine( "The first occurrence of 1 is at index {0}", j );
   }
}
</code>
          <para> The output is</para>
          <c>
            <para>The values of the array are: 0 1 2 0 1</para>
            <para>The first occurrence of 1 is at index 1</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The one-dimensional <see cref="T:System.Array" /> is searched forward starting at the first element and ending at the last element.</para>
          <para>The elements are compared to the specified value using the <see cref="M:System.Object.Equals(System.Object)" /> method. If the element type is a nonintrinsic (user-defined) type, the Equals implementation of that type is used.</para>
          <para>Since most arrays will have a lower bound of zero, this method would generally return –1 when <paramref name="value" /> is not found. In the rare case that the lower bound of the array is equal to <see cref="F:System.Int32.MinValue" /> and <paramref name="value" /> is not found, this method returns <see cref="F:System.Int32.MaxValue" />, which is System.Int32.MinValue - 1.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
          <para>In the .NET Framework version 2.0, this method uses the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <see cref="T:System.Array" /> to determine whether the <see cref="T:System.Object" /> specified by the <paramref name="value" /> parameter exists. In the earlier versions of the .NET Framework, this determination was made by using the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <paramref name="value" /> <see cref="T:System.Object" /> itself.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified object and returns the index of the first occurrence within the entire one-dimensional <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the first occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to locate in <paramref name="array" />.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 IndexOf(class System.Array array, object value, int32 startIndex)" />
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than <paramref name="array" /><see langword=".GetLowerBound(0)" /> or greater than <paramref name="array" /><see langword=".GetLowerBound(0)" /> + <paramref name="array" /><see langword=".Length" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The one-dimensional <see cref="T:System.Array" /> is searched forward starting at <paramref name="startIndex" /> and ending at the last element.</para>
          <para>The elements are compared to the specified value using the <see cref="M:System.Object.Equals(System.Object)" /> method. If the element type is a nonintrinsic (user-defined) type, the Equals implementation of that type is used.</para>
          <para>Since most arrays will have a lower bound of zero, this method would generally return –1 when <paramref name="value" /> is not found. In the rare case that the lower bound of the array is equal to <see cref="F:System.Int32.MinValue" /> and <paramref name="value" /> is not found, this method returns <see cref="F:System.Int32.MaxValue" />, which is System.Int32.MinValue - 1.</para>
          <para>Passing the <see cref="P:System.Array.Length" /> of the array as the <paramref name="startindex" /> will result in a return value of -1, while values greater than Length will raise an <see cref="T:System.ArgumentOutOfRangeException" />.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the number of elements from <paramref name="startIndex" /> to the end of <paramref name="array" />.</para>
          <para>In the .NET Framework version 2.0, this method uses the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <see cref="T:System.Array" /> to determine whether the <see cref="T:System.Object" /> specified by the <paramref name="value" /> parameter exists. In the earlier versions of the .NET Framework, this determination was made by using the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <paramref name="value" /> <see cref="T:System.Object" /> itself.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified object and returns the index of the first occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that extends from the specified index to the last element.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element, if found; otherwise, the lower bound of the array minus 1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to locate in <paramref name="array" />.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the search. 0 (zero) is valid in an empty array.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than <paramref name="array" /><see langword=".GetLowerBound(0)" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="startIndex" /> + <paramref name="count" /> is greater than <paramref name="array" /><see langword=".GetLowerBound(0)" /> + <paramref name="array" /><see langword=".Length" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The one-dimensional <see cref="T:System.Array" /> is searched forward starting at <paramref name="startIndex" /> and ending at <paramref name="startIndex" /> plus <paramref name="count" /> minus 1, if <paramref name="count" /> is greater than 0.</para>
          <para>The elements are compared to the specified value using the <see cref="M:System.Object.Equals(System.Object)" /> method. If the element type is a nonintrinsic (user-defined) type, the Equals implementation of that type is used.</para>
          <para>Since most arrays will have a lower bound of zero, this method would generally return –1 when <paramref name="value" /> is not found. In the rare case that the lower bound of the array is equal to <see cref="F:System.Int32.MinValue" /> and <paramref name="value" /> is not found, this method returns <see cref="F:System.Int32.MaxValue" />, which is System.Int32.MinValue - 1.</para>
          <para>Passing the <see cref="P:System.Array.Length" /> of the array as the <paramref name="startindex" /> will result in a return value of -1, while values greater than Length will raise an <see cref="T:System.ArgumentOutOfRangeException" />.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="count" />.</para>
          <para>In the .NET Framework version 2.0, this method uses the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <see cref="T:System.Array" /> to determine whether the <see cref="T:System.Object" /> specified by the <paramref name="value" /> parameter exists. In the earlier versions of the .NET Framework, this determination was made by using the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <paramref name="value" /> <see cref="T:System.Object" /> itself.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified object and returns the index of the first occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that starts at the specified index and contains the specified number of elements.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that starts at <paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />, if found; otherwise, the lower bound of the array minus 1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to locate in <paramref name="array" />.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the search. 0 (zero) is valid in an empty array.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the section to search.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <summary>
          <para>Searches the specified array, returning the index of the first occurrence of the specified value.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of <paramref name="value" /> in 
<paramref name="array" />, if found; otherwise, - 1.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched forward starting at the first element and ending at the last element.  Processing is stopped when the predicate returns <see langword="true" />. </para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <summary>
          <para>Searches the specified array, returning the index of the first occurrence in the specified array starting at the specified index and including the last element.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in 
<paramref name="array" /> that extends from  
<paramref name="startIndex" /> to the last element, if found; otherwise, -1. If <paramref name="startIndex" /> is equal to the length of the array, -1 is returned.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched forward starting at <paramref name="startIndex" /> and ending at the last element. Processing is stopped when the predicate returns <see langword="true" />. </para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than zero or greater than <paramref name="array" /><see langword=".Length" />.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <param name="count">The number of consecutive elements to search.</param>
        <summary>
          <para>Searches for the specified value and returns the index of the first occurrence within the range of elements in the array starting at the specified index and continuing for, at most, the specified number of elements.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in 
<paramref name="array" /> that starts at 
<paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />
, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched forward starting at <paramref name="startIndex" /> and ending at <paramref name="startIndex" /> + <paramref name="count" /> - 1. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="startIndex" /> + <paramref name="count" /> is greater than <see cref="P:System.Array.Length" />.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Initialize()" />
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is designed to help compilers support value-type arrays; most users do not need this method. It must not be used on reference-type arrays.</para>
          <para>If the <see cref="T:System.Array" /> is not a value-type <see cref="T:System.Array" /> or if the value type does not have a default constructor, the <see cref="T:System.Array" /> is not modified.</para>
          <para>The value-type <see cref="T:System.Array" /> can have any lower bound and any number of dimensions.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <see cref="P:System.Array.Length" />.</para>
          <block subset="none" type="note">
            <para>You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes every element of the value-type <see cref="T:System.Array" /> by calling the default constructor of the value type.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="ILASM" Value=".property bool IList.IsFixedSize { public hidebysig virtual abstract specialname bool get_IList.IsFixedSize() }" />
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Array" /> implements the <see cref="P:System.Array.IsFixedSize" /> property because it is required by the <see cref="T:System.Collections.IList" /> interface.</para>
          <para>An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</para>
          <para>Retrieving the value of this property is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Array" /> has a fixed size.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="ILASM" Value=".property bool IList.IsReadOnly { public hidebysig virtual abstract specialname bool get_IList.IsReadOnly() }" />
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Array" /> implements the <see cref="P:System.Array.IsReadOnly" /> property because it is required by the <see cref="T:System.Collections.IList" /> interface. An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</para>
          <para>If you require a read-only collection, use a <see cref="N:System.Collections" /> class that implements the <see cref="T:System.Collections.IList" /> interface.</para>
          <para>If you cast or convert an array to an <see cref="T:System.Collections.IList" /> interface object, the <see cref="P:System.Collections.IList.IsReadOnly" /> property returns false. However, if you cast or convert an array to a <see cref="T:System.Collections.Generic.IList`1" /> interface, the IsReadOnly property returns true.</para>
          <para>Retrieving the value of this property is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Array" /> is read-only.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="ILASM" Value=".property bool ICollection.IsSynchronized { public hidebysig virtual abstract specialname bool get_ICollection.IsSynchronized() }" />
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Array" /> implements the <see cref="P:System.Array.IsSynchronized" /> property because it is required by the <see cref="T:System.Collections.ICollection" /> interface.</para>
          <para>.NET Framework classes based on <see cref="T:System.Array" /> provide their own synchronized version of the collection using the <see cref="P:System.Array.SyncRoot" /> property.</para>
          <para>Classes that use arrays can also implement their own synchronization using the <see cref="P:System.Array.SyncRoot" /> property. The synchronizing code must perform operations on the SyncRoot of the collection, not directly on the collection. This ensures proper operation of collections that are derived from other objects. Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection. Note that some implementations of <see cref="P:System.Array.SyncRoot" /> might return the <see cref="T:System.Array" /> itself.</para>
          <para>Enumerating through a collection is intrinsically not a thread safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</para>
          <para>Retrieving the value of this property is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether access to the <see cref="T:System.Array" /> is synchronized (thread safe).</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 LastIndexOf(class System.Array array, object value)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> . </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Array.LastIndexOf(System.Array,System.Object)" /> method.</para>
          <code lang="C#">using System;

public class ArrayLastIndexOfExample {

   public static void Main() {
      int[] intAry = { 0, 1, 2, 0, 1 };
      Console.Write( "The values of the array are: ");
      foreach( int i in intAry )
         Console.Write( "{0,5}", i );
      Console.WriteLine();
      int j = Array.LastIndexOf( intAry, 1 );
      Console.WriteLine( "The last occurrence of 1 is at index {0}", j );
   }
}
</code>
          <para> The output is</para>
          <c>
            <para>The values of the array are: 0 1 2 0 1</para>
            <para>The last occurrence of 1 is at index 4</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The one-dimensional <see cref="T:System.Array" /> is searched backward starting at the last element and ending at the first element.</para>
          <para>The elements are compared to the specified value using the <see cref="M:System.Object.Equals(System.Object)" /> method. If the element type is a nonintrinsic (user-defined) type, the Equals implementation of that type is used.</para>
          <para>Since most arrays will have a lower bound of zero, this method would generally return –1 when <paramref name="value" /> is not found. In the rare case that the lower bound of the array is equal to <see cref="F:System.Int32.MinValue" /> and <paramref name="value" /> is not found, this method returns <see cref="F:System.Int32.MaxValue" />, which is System.Int32.MinValue - 1.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
          <para>In the .NET Framework version 2.0, this method uses the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <see cref="T:System.Array" /> to determine whether the <see cref="T:System.Object" /> specified by the <paramref name="value" /> parameter exists. In the earlier versions of the .NET Framework, this determination was made by using the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <paramref name="value" /> <see cref="T:System.Object" /> itself.</para>
          <para>
            <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <paramref name="item" /> parameter on the objects in the collection.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to locate in <paramref name="array" />.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 LastIndexOf(class System.Array array, object value, int32 startIndex)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is outside the range of valid indices for <paramref name="array" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The one-dimensional <see cref="T:System.Array" /> is searched backward starting at <paramref name="startIndex" /> and ending at the first element.</para>
          <para>The elements are compared to the specified value using the <see cref="M:System.Object.Equals(System.Object)" /> method. If the element type is a nonintrinsic (user-defined) type, the Equals implementation of that type is used.</para>
          <para>Since most arrays will have a lower bound of zero, this method would generally return –1 when <paramref name="value" /> is not found. In the rare case that the lower bound of the array is equal to <see cref="F:System.Int32.MinValue" /> and <paramref name="value" /> is not found, this method returns <see cref="F:System.Int32.MaxValue" />, which is System.Int32.MinValue - 1.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the number of elements from the beginning of <paramref name="array" /> to <paramref name="startIndex" />.</para>
          <para>In the .NET Framework version 2.0, this method uses the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <see cref="T:System.Array" /> to determine whether the <see cref="T:System.Object" /> specified by the <paramref name="value" /> parameter exists. In the earlier versions of the .NET Framework, this determination was made by using the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <paramref name="value" /> <see cref="T:System.Object" /> itself.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that extends from the first element to the specified index.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to locate in <paramref name="array" />.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the backward search.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is outside the range of valid indices for <paramref name="array" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is greater than <paramref name="startIndex" /> + 1.</para>
        </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The one-dimensional <see cref="T:System.Array" /> is searched backward starting at <paramref name="startIndex" /> and ending at <paramref name="startIndex" /> minus <paramref name="count" /> plus 1, if <paramref name="count" /> is greater than 0.</para>
          <para>The elements are compared to the specified value using the <see cref="M:System.Object.Equals(System.Object)" /> method. If the element type is a nonintrinsic (user-defined) type, the Equals implementation of that type is used.</para>
          <para>Since most arrays will have a lower bound of zero, this method would generally return –1 when <paramref name="value" /> is not found. In the rare case that the lower bound of the array is equal to <see cref="F:System.Int32.MinValue" /> and <paramref name="value" /> is not found, this method returns <see cref="F:System.Int32.MaxValue" />, which is System.Int32.MinValue - 1.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="count" />.</para>
          <para>In the .NET Framework version 2.0, this method uses the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <see cref="T:System.Array" /> to determine whether the <see cref="T:System.Object" /> specified by the <paramref name="value" /> parameter exists. In the earlier versions of the .NET Framework, this determination was made by using the <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.IComparable.CompareTo(System.Object)" /> methods of the <paramref name="value" /> <see cref="T:System.Object" /> itself.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to locate in <paramref name="array" />.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the backward search.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the section to search.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <summary>
          <para>Searches the specified array, returning the index of the last occurrence of the specified value.</para>
        </summary>
        <returns>
          <para>The zero-based index of the last occurrence of <paramref name="value" /> in 
<paramref name="array" />, if found; otherwise, - 1.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched backward starting at the last element and ending at the first element. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <summary>
          <para>Searches the specified array backwards, returning the index of the last occurrence of the specified array, starting at the specified index.</para>
        </summary>
        <returns>
          <para>The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in 
<paramref name="array" /> that extends from  
<paramref name="startIndex" /> to the first element, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched backward starting at <paramref name="startIndex" /> and ending at the first element. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is outside the range of valid indices for <paramref name="array" />.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <param name="count">The number of consecutive elements to search.</param>
        <summary>
          <para>Searches for the specified value and returns the index of the last occurrence within the range of elements in the array starting at the specified index and continuing backwards for, at most,  the specified number of elements.</para>
        </summary>
        <returns>
          <para>The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in 
<paramref name="array" /> that ends at 
<paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />
, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched backward starting at <paramref name="startIndex" /> and going for count elements. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is outside the range of valid indices for <paramref name="array" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is greater than <paramref name="startIndex" /> + 1.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="ILASM" Value=".property int32 Length { public hidebysig specialname instance int32 get_Length() }" />
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Int32" /> that contains the total number of elements in all the dimensions of
   the current instance.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieving the value of this property is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a 32-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="ILASM" value=".property int32 Length { public hidebysig specialname instance int32 get_LongLength() }" />
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Int64" /> value containing the length of the array.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieving the value of this property is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="ILASM" Value=".property int32 Rank { public hidebysig specialname instance int32 get_Rank() }" />
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Int32" /> that contains the rank (number of dimensions) of the current instance.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For example, the Visual Basic code </para>
          <code>Dim TDArray(0,0,0) As Integer</code>
          <para>and the C# code </para>
          <code>int[,,] TDArray = new int[1,1,1];</code>
          <para>create an array of three dimensions with a <see cref="P:System.Array.Rank" /> property whose value is 3.</para>
          <para>A jagged array (an array of arrays) is a one-dimensional array; the value of its <see cref="P:System.Array.Rank" /> property is 1.</para>
          <para>Retrieving the value of this property is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the rank (number of dimensions) of the <see cref="T:System.Array" />. For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on. </para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[] array, int32 newSize) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="newSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Reverse(class System.Array array)" />
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>After a call to this method, the element at myArray[i], where <paramref name="i" /> is any index in the array, moves to myArray[j], where <paramref name="j" /> equals (myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1.</para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
          <para>As the following example shows, the <see cref="M:System.Array.Reverse(System.Array)" /> method can be used to reverse a jagged array. It initializes a jagged array with one element for each month of the current year in the current culture's calendar. Each element contains an array with as many elements as that month has days. The example displays the contents of the array, calls the <see cref="M:System.Array.Reverse(System.Array)" /> method, and then displays the contents of the reversed array. </para>
          <para>code reference: System.Array.Reverse#1</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reverses the sequence of the elements in the entire one-dimensional <see cref="T:System.Array" />.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to reverse.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Reverse(class System.Array array, int32 index, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="array" />.GetLowerBound(0).</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" /> (i.e. <paramref name="index" /> + <paramref name="length" /> &gt; <paramref name="array" />.GetLowerBound(0) + <paramref name="array" />.Length).</exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Array.Reverse(System.Array)" /> method.</para>
          <code lang="C#">using System;
public class ArrayReverseExample {
   public static void Main() {
      string[] strAry = { "one", "two", "three" };
      Console.Write( "The elements of the array are:");
      foreach( string str in strAry )
         Console.Write( " {0}", str );
      Array.Reverse( strAry );
      Console.WriteLine();
      Console.WriteLine( "After reversing the array," );
      Console.Write( "the elements of the array are:");
      foreach( string str in strAry )
         Console.Write( " {0}", str );
   }
}
</code>
          <para>The output is</para>
          <c>
            <para>The elements of the array are: one two three</para>
            <para>After reversing the array,</para>
            <para>the elements of the array are: three two one</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>After a call to this method, the element at myArray[i], where <paramref name="i" /> is any index in the array, moves to myArray[j], where <paramref name="j" /> equals (myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1.</para>
          <para>The <see cref="M:System.Array.Reverse(System.Array)" /> method can be used to reverse a jagged array. </para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reverses the sequence of the elements in a range of elements in the one-dimensional <see cref="T:System.Array" />.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to reverse.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the section to reverse.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the section to reverse.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetValue(object value, int32 index)" />
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>The current instance has more than one dimension.</para>
        </exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="index" /> is outside the range of valid indices for the current instance.</para>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <para>
            <paramref name="value" /> is not assignment-compatible with the element type of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether the value of <paramref name="index" /> is out of bounds.</para>
          <para>For more information about conversions, see <see cref="T:System.Convert" />.</para>
          <para>This method is an O(1) operation.</para>
          <block subset="none" type="note">
            <para>If <see cref="Overload:System.Array.SetValue" /> is used to assign null to an element of an array of value types, all fields of the element are initialized to zero. The value of the element is not a null reference, and cannot be found by searching for a null reference.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />. The index is specified as a 32-bit integer.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The new value for the specified element.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetValue(object value, class System.Int32[] indices)" />
      <MemberSignature Language="C#" Value="public void SetValue (object value, int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <para>The number of dimensions in the current instance is not equal to the number of elements in <paramref name="indices" />. </para>
        </exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>At least one element in <paramref name="indices" /> is outside the range of valid indices for the corresponding dimension of the current instance.</para>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <para>
            <paramref name="value" /> is not assignment-compatible with the element type of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of elements in <paramref name="indices" /> must equal the number of dimensions in the <see cref="T:System.Array" />. All elements in the <paramref name="indices" /> array must collectively specify the position of the desired element in the multidimensional <see cref="T:System.Array" />.</para>
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the values in the <paramref name="indices" /> array is out of bounds.</para>
          <para>For more information about conversions, see <see cref="T:System.Convert" />.</para>
          <para>This method is an O(1) operation.</para>
          <block subset="none" type="note">
            <para>If <see cref="Overload:System.Array.SetValue" /> is used to assign null to an element of an array of value types, all fields of the element are initialized to zero. The value of the element is not a null reference, and cannot be found by searching for a null reference.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />. The indexes are specified as an array of 32-bit integers.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The new value for the specified element.</param>
        <param name="indices">
          <attribution license="cc4" from="Microsoft" modified="false" />A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether the value of <paramref name="index" /> is out of bounds.</para>
          <para>For more information about conversions, see <see cref="T:System.Convert" />.</para>
          <para>This method is an O(1) operation.</para>
          <block subset="none" type="note">
            <para>If <see cref="Overload:System.Array.SetValue" /> is used to assign null to an element of an array of value types, all fields of the element are initialized to zero. The value of the element is not a null reference, and cannot be found by searching for a null reference.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />. The index is specified as a 64-bit integer.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The new value for the specified element.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</param>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of elements in <paramref name="indices" /> must equal the number of dimensions in the <see cref="T:System.Array" />. All elements in the <paramref name="indices" /> array must collectively specify the position of the desired element in the multidimensional <see cref="T:System.Array" />.</para>
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the values in the <paramref name="indices" /> array is out of bounds.</para>
          <para>For more information about conversions, see <see cref="T:System.Convert" />.</para>
          <para>This method is an O(1) operation.</para>
          <block subset="none" type="note">
            <para>If <see cref="Overload:System.Array.SetValue" /> is used to assign null to an element of an array of value types, all fields of the element are initialized to zero. The value of the element is not a null reference, and cannot be found by searching for a null reference.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />. The indexes are specified as an array of 64-bit integers.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The new value for the specified element.</param>
        <param name="indices">
          <attribution license="cc4" from="Microsoft" modified="false" />A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</param>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2)" />
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>The current instance does not have exactly two dimensions.</para>
        </exception>
        <exception cref="T:System.IndexOutOfRangeException">At least one of <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indices for the corresponding dimension of the current instance.</exception>
        <exception cref="T:System.InvalidCastException">
          <para>
            <paramref name="value" /> is not assignment-compatible with the element type of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the indexes is out of bounds.</para>
          <para>For more information about conversions, see <see cref="T:System.Convert" />.</para>
          <para>This method is an O(1) operation.</para>
          <block subset="none" type="note">
            <para>If <see cref="Overload:System.Array.SetValue" /> is used to assign null to an element of an array of value types, all fields of the element are initialized to zero. The value of the element is not a null reference, and cannot be found by searching for a null reference.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />. The indexes are specified as 32-bit integers.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The new value for the specified element.</param>
        <param name="index1">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index2">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the indexes is out of bounds.</para>
          <para>For more information about conversions, see <see cref="T:System.Convert" />.</para>
          <para>This method is an O(1) operation.</para>
          <block subset="none" type="note">
            <para>If <see cref="Overload:System.Array.SetValue" /> is used to assign null to an element of an array of value types, all fields of the element are initialized to zero. The value of the element is not a null reference, and cannot be found by searching for a null reference.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />. The indexes are specified as 64-bit integers.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The new value for the specified element.</param>
        <param name="index1">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index2">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</param>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3)" />
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>The current instance does not have exactly three dimensions.</para>
        </exception>
        <exception cref="T:System.IndexOutOfRangeException">At least one of <paramref name="index1" />, <paramref name="index2" />, or <paramref name="index3" /> is outside the range of valid indices for the corresponding dimension of the current instance.</exception>
        <exception cref="T:System.InvalidCastException">
          <para>
            <paramref name="value" /> is not assignment-compatible with the element type of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the indexes is out of bounds.</para>
          <para>For more information about conversions, see <see cref="T:System.Convert" />.</para>
          <para>This method is an O(1) operation.</para>
          <block subset="none" type="note">
            <para>If <see cref="Overload:System.Array.SetValue" /> is used to assign null to an element of an array of value types, all fields of the element are initialized to zero. The value of the element is not a null reference, and cannot be found by searching for a null reference.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />. The indexes are specified as 32-bit integers.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The new value for the specified element.</param>
        <param name="index1">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index2">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index3">
          <attribution license="cc4" from="Microsoft" modified="false" />A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods can determine whether any of the indexes is out of bounds.</para>
          <para>For more information about conversions, see <see cref="T:System.Convert" />.</para>
          <para>This method is an O(1) operation.</para>
          <block subset="none" type="note">
            <para>If <see cref="Overload:System.Array.SetValue" /> is used to assign null to an element of an array of value types, all fields of the element are initialized to zero. The value of the element is not a null reference, and cannot be found by searching for a null reference.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />. The indexes are specified as 64-bit integers.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The new value for the specified element.</param>
        <param name="index1">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index2">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</param>
        <param name="index3">
          <attribution license="cc4" from="Microsoft" modified="false" />A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</param>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array array)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <exception cref="T:System.ArgumentException">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.Sort(System.Array)" /> method.</para>
          <code lang="C#">using System;
public class ArraySortExample {
   public static void Main() {
      string[] strAry = { "All's", "well", "that", "ends", "well" };
      Console.Write( "The original string array is: " );
      foreach ( String str in strAry )
         Console.Write( str + " " );
      Console.WriteLine();
      Array.Sort( strAry );
      Console.Write( "The sorted string array is: " );
      foreach ( string str in strAry )
         Console.Write( str + " " );
   }
}
</code>
          <para>The output is</para>
          <c>
            <para>The original string array is: All's well that ends well</para>
            <para>The sorted string array is: All's ends that well well</para>
          </c>
        </example>
        <exception cref="T:System.InvalidOperationException">One or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Each element of <paramref name="array" /> must implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows: </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal. </para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts the elements in an entire one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to sort.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array keys, class System.Array items)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="keys" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="items" /> is not a null reference and has more than one dimension.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.GetLowerBound(0) does not equal <paramref name="items" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.Length &gt; <paramref name="items" />.Length.</para>
        </exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.Sort(System.Array)" /> method.</para>
          <code lang="C#">using System;
public class ArraySortExample {
   public static void Main() {
      string[] strAry = { "All's", "well", "that", "ends", "well" };
      int[] intAry = { 3, 4, 0, 1, 2 };
      Console.Write( "The original string array is: " );
      foreach ( string str in strAry )
         Console.Write( str + " " );
      Console.WriteLine();
      Console.Write( "The key array is: " );
      foreach ( int i in intAry )
         Console.Write( i + " " );
      Console.WriteLine();
      Array.Sort( intAry, strAry );
      Console.Write( "The sorted string array is: " );
      foreach ( string str in strAry )
         Console.Write( str + " " );
   }
}
</code>
          <para>The output is</para>
          <c>
            <para>The original string array is: All's well that ends well</para>
            <para>The key array is: 3 4 0 1 2</para>
            <para>The sorted string array is: that ends well All's well</para>
          </c>
        </example>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="keys" /> that are used in a comparison  do not implement the <see cref="T:System.IComparable" /> interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Each key in the <paramref name="keys" /> <see cref="T:System.Array" /> has a corresponding item in the <paramref name="items" /> <see cref="T:System.Array" />. When a key is repositioned during the sorting, the corresponding item in the <paramref name="items" /> <see cref="T:System.Array" /> is similarly repositioned. Therefore, the <paramref name="items" /> <see cref="T:System.Array" /> is sorted according to the arrangement of the corresponding keys in the <paramref name="keys" /> <see cref="T:System.Array" />.</para>
          <para>Each key in the <paramref name="keys" /> <see cref="T:System.Array" /> must implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other key.</para>
          <para>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <see cref="T:System.ArgumentException" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="keys" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</para>
        </summary>
        <param name="keys">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /> <see cref="T:System.Array" />.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array array, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />. </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> is a null reference, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is a null reference, and one or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="comparer" /> is null, each element of <paramref name="array" /> must implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where  N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts the elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to sort.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="keys" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="items" /> is not a null reference and has more than one dimension.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.GetLowerBound(0) does not equal <paramref name="items" />.GetLowerBound(0). </para>
          <para>-or-</para>
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.Length &gt; <paramref name="items" />.Length.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is a <see langword="null" />, and one or more elements in <paramref name="keys" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface. </para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Each key in the <paramref name="keys" /> <see cref="T:System.Array" /> has a corresponding item in the <paramref name="items" /> <see cref="T:System.Array" />. When a key is repositioned during the sorting, the corresponding item in the <paramref name="items" /> <see cref="T:System.Array" /> is similarly repositioned. Therefore, the <paramref name="items" /> <see cref="T:System.Array" /> is sorted according to the arrangement of the corresponding keys in the <paramref name="keys" /> <see cref="T:System.Array" />.</para>
          <para>If <paramref name="comparer" /> is null, each key in the <paramref name="keys" /> <see cref="T:System.Array" /> must implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other key.</para>
          <para>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <see cref="T:System.ArgumentException" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where  N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="keys" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</para>
        </summary>
        <param name="keys">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /> <see cref="T:System.Array" />.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array array, int32 index, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />. </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="array" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Each element within the specified range of elements in <paramref name="array" /> must implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where  N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to sort.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the range to sort.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the range to sort.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array keys, class System.Array items, int32 index, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="keys" /> has more than one dimension.</para>
          <para> -or-</para>
          <para>
            <paramref name="items" /> is not a null reference and has more than one dimension.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="keys" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.GetLowerBound(0) does not equal <paramref name="items" />.GetLowerBound(0). </para>
          <para>-or- </para>
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="keys" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="items" />. </para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="keys" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Each key in the <paramref name="keys" /> <see cref="T:System.Array" /> has a corresponding item in the <paramref name="items" /> <see cref="T:System.Array" />. When a key is repositioned during the sorting, the corresponding item in the <paramref name="items" /> <see cref="T:System.Array" /> is similarly repositioned. Therefore, the <paramref name="items" /> <see cref="T:System.Array" /> is sorted according to the arrangement of the corresponding keys in the <paramref name="keys" /> <see cref="T:System.Array" />.</para>
          <para>Each key within the specified range of elements in the <paramref name="keys" /> <see cref="T:System.Array" /> must implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other key.</para>
          <para>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <see cref="T:System.ArgumentException" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</para>
        </summary>
        <param name="keys">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /> <see cref="T:System.Array" />.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the range to sort.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the range to sort.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />. </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="array" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface. </para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="comparer" /> is null, each element within the specified range of elements in <paramref name="array" /> must implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where  N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> to sort.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the range to sort.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the range to sort.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="keys" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="items" /> is not a null reference and has more than one dimension.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="keys" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.GetLowerBound(0) does not equal <paramref name="items" />.GetLowerBound(0). </para>
          <para>-or- </para>
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="key" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="items" />. </para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="keys" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface. </para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Each key in the <paramref name="keys" /> <see cref="T:System.Array" /> has a corresponding item in the <paramref name="items" /> <see cref="T:System.Array" />. When a key is repositioned during the sorting, the corresponding item in the <paramref name="items" /> <see cref="T:System.Array" /> is similarly repositioned. Therefore, the <paramref name="items" /> <see cref="T:System.Array" /> is sorted according to the arrangement of the corresponding keys in the <paramref name="keys" /> <see cref="T:System.Array" />.</para>
          <para>If <paramref name="comparer" /> is null, each key within the specified range of elements in the <paramref name="keys" /> <see cref="T:System.Array" /> must implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other key.</para>
          <para>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <see cref="T:System.ArgumentException" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</para>
        </summary>
        <param name="keys">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /> <see cref="T:System.Array" />.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the range to sort.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the range to sort.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">
          <para>The array to sort.</para>
        </param>
        <summary>
          <para>Sorts the elements in an entire array using the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation of each element of that array.</para>
        </summary>
        <remarks>
          <para>Each element of <paramref name="array" /> is required to implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="array" /> that are used in a comparison are the null reference or do not implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="comparer" /> is null, each element of <paramref name="array" /> must implement the <see cref="T:System.IComparable`1" /> generic interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where  N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-base <see cref="T:System.Array" /> to sort</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or null to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="comparison" /> is <see langword="null" />.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where  N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Comparison`1" />.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</param>
        <param name="comparison">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Comparison`1" /> to use when comparing elements.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">
          <para>The array to sort.</para>
        </param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <summary>
          <para>Sorts an array using the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation of each element of that array.</para>
        </summary>
        <remarks>
          <para>Each element within the specified range of elements in <paramref name="array" /> must implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />. </para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />. </para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="comparer" /> is null, each element within the specified range of elements in <paramref name="array" /> must implement the <see cref="T:System.IComparable`1" /> generic interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where  N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the range to sort.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the range to sort.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or null to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <param name="keys">
          <para>The array that contains the keys to sort.</para>
        </param>
        <param name="items">
          <para>The array that contains the items that correspond to each of the keys in <paramref name="keys" />.</para>
          <para>-or-</para>
          <para>
            <see langword="null" /> to sort only the <paramref name="keys" /> array.</para>
        </param>
        <summary>
          <para>Sorts a pair of arrays based on the keys in the first array using the <see cref="T:System.IComparable" />  implementation of each key.</para>
        </summary>
        <remarks>
          <para>If <paramref name="items" /> is non-null, each key in <paramref name="keys" /> is required to have
   a corresponding item in <paramref name="items" />. When a key is repositioned during the sorting,
   the corresponding item in <paramref name="items" /> is similarly repositioned. Therefore, <paramref name="items" /> is sorted according to the arrangement of
   the corresponding keys in <paramref name="keys" />. </para>
          <para>Each key in <paramref name="keys" /> must implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other key.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not <see langword="null" />, and  the length of <paramref name="keys" /> does not equal the length of <paramref name="items" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="keys" /> that are used in a comparison  are the null reference or do not implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not <see langword="null" />, and  the length of <paramref name="keys" /> does not match the length of <paramref name="items" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="keys" /> that are used in a comparison  do not implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Each key in the <paramref name="keys" /> <see cref="T:System.Array" /> has a corresponding item in the <paramref name="items" /> <see cref="T:System.Array" />. When a key is repositioned during the sorting, the corresponding item in the <paramref name="items" /> <see cref="T:System.Array" /> is similarly repositioned. Therefore, the <paramref name="items" /> <see cref="T:System.Array" /> is sorted according to the arrangement of the corresponding keys in the <paramref name="keys" /> <see cref="T:System.Array" />.</para>
          <para>If <paramref name="comparer" /> is null, each key in the <paramref name="keys" /> <see cref="T:System.Array" /> must implement the <see cref="T:System.IComparable`1" /> generic interface to be capable of comparisons with every other key.</para>
          <para>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <see cref="T:System.ArgumentException" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where  N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</para>
        </summary>
        <param name="keys">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort. </param>
        <param name="items">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <paramref name="keys" />, or null to sort only <paramref name="keys" />.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or null to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</param>
        <typeparam name="TKey">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the key array.</typeparam>
        <typeparam name="TValue">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the items array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <param name="keys">
          <para>The array that contains the keys to sort.</para>
        </param>
        <param name="items">
          <para>The array that contains the items that correspond to each of the keys in <paramref name="keys" />.</para>
          <para>-or-</para>
          <para>
            <see langword="null" /> to sort only the <paramref name="keys" /> array.</para>
        </param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <summary>
          <para>Sorts a range of elements in a pair of arrays based on the keys in the first array, using the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" />  implementation of each key.</para>
        </summary>
        <remarks>
          <para>If <paramref name="items" /> is non-null, each key in <paramref name="keys" /> is required to have
   a corresponding item in <paramref name="items" />. When a key is repositioned during the sorting,
   the corresponding item in <paramref name="items" /> is similarly repositioned. Therefore, <paramref name="items" /> is sorted according to the arrangement of
   the corresponding keys in <paramref name="keys" />. </para>
          <para>If the sort is not successfully completed, the results are unspecified.</para>
          <para>Each key within the specified range of elements in <paramref name="keys" /> must implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other key.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="keys" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="items" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="keys" /> that are used in a comparison are the null reference or do not implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="keys" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="items" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="keys" /> that are used in a comparison do not implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Each key in the <paramref name="keys" /> <see cref="T:System.Array" /> has a corresponding item in the <paramref name="items" /> <see cref="T:System.Array" />. When a key is repositioned during the sorting, the corresponding item in the <paramref name="items" /> <see cref="T:System.Array" /> is similarly repositioned. Therefore, the <paramref name="items" /> <see cref="T:System.Array" /> is sorted according to the arrangement of the corresponding keys in the <paramref name="keys" /> <see cref="T:System.Array" />.</para>
          <para>If <paramref name="comparer" /> is null, each key within the specified range of elements in the <paramref name="keys" /> <see cref="T:System.Array" /> must implement the <see cref="T:System.IComparable`1" /> generic interface to be capable of comparisons with every other key.</para>
          <para>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <see cref="T:System.ArgumentException" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This method uses the introspective sort (introsort) algorithm as follows:  </para>
          <list type="bullet">
            <item>
              <para>If the partition size is fewer than 16 elements, it uses an <see cref="http://en.wikipedia.org/wiki/Insertion_sort">insertion sort</see> algorithm. </para>
            </item>
            <item>
              <para>If the number of partitions exceeds 2 * Log<superscript>N</superscript>, where  N is the range of the input array, it uses a <see cref="http://en.wikipedia.org/wiki/Heapsort">Heapsort</see> algorithm.</para>
            </item>
            <item>
              <para>Otherwise, it uses a <see cref="http://en.wikipedia.org/wiki/Quicksort">Quicksort</see> algorithm. </para>
            </item>
          </list>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
          <para>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<paramref name="n" /> log <paramref name="n" />) operation, where <paramref name="n" /> is <paramref name="length" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</para>
        </summary>
        <param name="keys">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort. </param>
        <param name="items">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <paramref name="keys" />, or null to sort only <paramref name="keys" />.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the range to sort.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements in the range to sort.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or null to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</param>
        <typeparam name="TKey">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the key array.</typeparam>
        <typeparam name="TValue">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the items array.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="ILASM" Value=".property object ICollection.SyncRoot { public hidebysig virtual abstract specialname object get_ICollection.SyncRoot() }" />
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property implements the <see cref="T:System.Collections.ICollection" /> interface.</para>
          <para>.NET Framework classes based on <see cref="T:System.Array" /> provide their own synchronized version of the collection using the <see cref="P:System.Array.SyncRoot" /> property.</para>
          <para>Classes that use arrays can also implement their own synchronization using the <see cref="P:System.Array.SyncRoot" /> property. The synchronizing code must perform operations on the SyncRoot of the collection, not directly on the collection. This ensures proper operation of collections that are derived from other objects. Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection. Note that some implementations of <see cref="P:System.Array.SyncRoot" /> might return the <see cref="T:System.Array" /> itself.</para>
          <para>Enumerating through a collection is intrinsically not a thread safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</para>
          <para>Retrieving the value of this property is an O(1) operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an object that can be used to synchronize access to the <see cref="T:System.Array" />.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <format type="text/html"><a href="">T:System.Collections.ICollection</a></format> interface.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of elements contained in the <see cref="T:System.Array" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <see cref="T:System.Collections.IList" /> interface.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Adds an item to <see cref="T:System.Collections.IList" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The position into which the new element was inserted, or -1 to indicate that the item was not inserted into the collection.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to be added to the <see cref="T:System.Collections.IList" />.</param>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <see cref="T:System.Collections.IList" /> interface.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes all items from the <see cref="T:System.Collections.IList" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <see cref="T:System.Collections.IList" /> interface.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether an element is in the <see cref="T:System.Collections.IList" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="value" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to locate in the current list. The element to locate can be null for reference types.</param>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <see cref="T:System.Collections.IList" /> interface.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index of value if found in the list; otherwise, -1.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to locate in the current list.</param>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <see cref="T:System.Collections.IList" /> interface.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.</para>
        </summary>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index at which <paramref name="value" /> should be inserted.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to insert.</param>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.Item" />.]</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <see cref="T:System.Collections.IList" /> interface.</para>
          <para />
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to remove from the <see cref="T:System.Collections.IList" />.</param>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <see cref="T:System.Collections.IList" /> interface.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes the <see cref="T:System.Collections.IList" /> item at the specified index.</para>
        </summary>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the element to remove.</param>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <see cref="T:System.Collections.IStructuralComparable" /> interface.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An integer that indicates the relationship of the current collection object to other, as shown in the following table.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Return value</para>
                </term>
                <description>
                  <para>Description</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>-1</para>
              </term>
              <description>
                <para>The current instance precedes <paramref name="other" />.</para>
              </description>
            </item>
            <item>
              <term>
                <para>0</para>
              </term>
              <description>
                <para>The current instance and <paramref name="other" /> are equal.</para>
              </description>
            </item>
            <item>
              <term>
                <para>1</para>
              </term>
              <description>
                <para>The current instance follows <paramref name="other" />.</para>
              </description>
            </item>
          </list>
        </returns>
        <param name="other">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to compare with the current instance.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that compares the current object and <paramref name="other" />.</param>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <see cref="T:System.Collections.IStructuralEquatable" /> interface.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether an object is equal to the current instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the two objects are equal; otherwise, false.</para>
        </returns>
        <param name="other">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to compare with the current instance.</param>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that determines whether the current instance and <paramref name="other" /> are equal. </param>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.Array" /> instance is cast to an <see cref="T:System.Collections.IStructuralEquatable" /> interface.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a hash code for the current instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The hash code for the current instance.</para>
        </returns>
        <param name="comparer">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that computes the hash code of the current object.</param>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Predicate`1" /> is a delegate to a method that returns true if the object passed to it matches the conditions defined in the delegate.  The elements of <paramref name="array" /> are individually passed to the <see cref="T:System.Predicate`1" />, and processing is stopped when the delegate returns false for any element. </para>
          <para>This method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is the <see cref="P:System.Array.Length" /> of <paramref name="array" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether every element in the array matches the conditions defined by the specified predicate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if every element in <paramref name="array" /> matches the conditions defined by the specified predicate; otherwise, false. If there are no elements in the array, the return value is true.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional, zero-based <see cref="T:System.Array" /> to check against the conditions.</param>
        <param name="match">
          <attribution license="cc4" from="Microsoft" modified="false" />The predicate that defines the conditions to check against the elements.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the elements of the array.</typeparam>
      </Docs>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>