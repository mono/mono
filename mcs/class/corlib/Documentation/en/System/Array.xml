<Type Name="Array" FullName="System.Array" FullNameSP="System_Array" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public abstract serializable Array extends System.Object implements System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList" />
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <para> Serves as the base class for arrays. Provides methods for creating,
      copying, manipulating, searching, and sorting arrays.</para>
    </summary>
    <remarks>
      <para>This class is intended to be used as a base class by
      language implementations that support arrays. Only the system can derive from
      this type: derived classes of <see cref="T:System.Array" /> are not to be created by the developer.</para>
      <block subset="none" type="note">
        <para>An array is a collection of
         identically typed data <paramref name="elements" /> that are accessed and referenced by
         sets of integral <paramref name="indices" />. </para>
        <para>The <paramref name="rank" /> of an array is the number
      of dimensions in the array. Each dimension has its own set of indices. An array
      with a rank greater than one can have a different lower
      bound and a different number of elements for each dimension. Multidimensional
      arrays (i.e. arrays with a rank greater than one) are processed in row-major
      order. </para>
        <para>The <paramref name="lower bound" /> of a dimension
   is the starting index of that dimension. </para>
        <para>The <paramref name="length" /> of an array is the total number of elements contained in all of its
dimensions. </para>
        <para>A <paramref name="vector" /> is a
one-dimensional array with a <paramref name="lower bound" /> of '0'. </para>
        <para>If the implementer creates a derived class of <see cref="T:System.Array" />, expected <see cref="T:System.Array" /> behavior
cannot be guaranteed. For information on array-like objects with increased
functionality, see the <see cref="T:System.Collections.IList" /> and <see cref="T:System.Collections.Generic.IList&lt;T&gt;" /> interfaces. For more information regarding the use of arrays versus the use
of collections, see Partition V of the CLI Specification. </para>
      </block>
      <para>Every specific <see cref="T:System.Array" /> type has three instance methods defined on it.
   While some programming languages allow direct access to these methods, they are
   primarily intended to be called by the output of compilers based on language
   syntax that deals with arrays. </para>
      <list type="bullet">
        <item>
          <term>
            <para>
              <c>Get</c>: Takes as many <see cref="T:System.Int32" /> arguments as the array
   has dimensions and returns the value stored at the given index. It throws a
<see cref="T:System.IndexOutOfRangeException" /> 
exception for invalid indices. </para>
          </term>
        </item>
        <item>
          <term>
            <para>
              <c>Set</c>: Takes as many <see cref="T:System.Int32" /> arguments as the array
   has dimensions, plus one additional argument (the last argument) which has the
   same type as an array element. It stores the final value in the specified
   index of the array. It throws a <see cref="T:System.IndexOutOfRangeException" />
   exception for invalid indices. </para>
          </term>
        </item>
        <item>
          <term>
            <para>
              <c>Address</c>: Takes as many <see cref="T:System.Int32" /> arguments as the
   array has dimensions and returns the address of the element at the given index.
   It throws a <see cref="T:System.IndexOutOfRangeException" />
   exception for invalid indices. </para>
          </term>
        </item>
      </list>
      <para>In addition, every specific <see cref="T:System.Array" /> type has a constructor on it that takes as many non-negative 
<see cref="T:System.Int32" /> 
arguments as the array has dimensions. The arguments specify the
number of elements in each dimension, and a lower bound of 0. Thus, a
two-dimensional array of <see cref="T:System.Int32" /> objects would have a constructor that could be called with
<c>(2, 4)</c> as its arguments to create an array of eight zeros with the first dimension indexed
with 0 and 1 and the second dimension indexed with 0, 1, 2, and 3. </para>
      <para>For all specific array types except vectors (i.e. those
   permitted to have non-zero lower bounds and those with more than one dimension)
   there is an additional constructor. It takes twice as many arguments as the
   array has dimensions. The arguments are considered in pairs, with the first of
   the pair specifying the lower bound for that dimension and the second specifying
   the total number of elements in that dimension. Thus, a two-dimensional array
   of <see cref="T:System.Int32" />
   
   objects would also have a constructor that could be called with <c>(-1, 2, 1, 3)</c> as its arguments,
specifying an array of 6 zeros, with the first dimension indexed by -1 and 0,
and the second dimension indexed by 1, 2, and 3. </para>
      <para>Enumeration over an array occurs in ascending row-major order, starting from the first element. (For example, a 2x3 array is traversed in the order [0,0], [0,1], [0,2], [1,0], [1,1], and [1,2].)</para>
      <para>Parallel implementation of methods taking a <see cref="T:System.Predicate" /> argument are not permitted.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to wrap in a read-only <see cref="T:System.Collections.Generic.IList&lt;T&gt;" /> wrapper.</param>
        <summary>
          <para>Returns a read-only <see cref="T: System.Collections.Generic.IList&lt;T&gt;" /> wrapper around the specified array.</para>
        </summary>
        <returns>
          <para>A read-only <see cref="T:System.Collections.Generic.IList&lt;T&gt;" />  wrapper around the specified array.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">To prevent any modifications to the array, expose the array only through this wrapper.</block>
          </para>
          <para>The returned <see langword="IList&lt;T&gt;" /> has the same enumeration order as the array it wraps.</para>
          <para>A collection that is read-only is simply a collection with a wrapper that prevents modifying the underlying array; therefore, if changes are made to the underlying array, the read-only collection reflects those changes.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 BinarySearch(class System.Array array, object value)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">A <see cref="T:System.Array" /> to search for an object.</param>
        <param name="value">A <see cref="T:System.Object" /> for which to search. </param>
        <summary>
          <para>Searches the specified one-dimensional <see cref="T:System.Array" /> for the specified object.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> with one of the following values based on the result of the search
   operation.</para>
          <list type="table">
            <listheader>
              <term>Return Value</term>
              <description> Description</description>
            </listheader>
            <item>
              <term> The index of <paramref name="value" /> in the
      array.</term>
              <description>
                <paramref name="value" /> was found.</description>
            </item>
            <item>
              <term> The bitwise complement of the index of the first element that is larger than
   <paramref name="value" />.</term>
              <description>
                <paramref name="value" /> was not found and the value of at least one element of
<paramref name="array" /> was greater than <paramref name="value" />.</description>
            </item>
            <item>
              <term> The bitwise complement of (<paramref name="array" />.GetLowerBound(0) +
<paramref name="array" />.Length).</term>
              <description>
                <paramref name="value" /> was not found, and <paramref name="value" /> was greater than the
value of all array elements.</description>
            </item>
          </list>
          <para>
            <block subset="none" type="note"> If <paramref name="value" />
is not found, the caller can take the bitwise complement of the return value to
determine the index where value would be found in <paramref name="array" /> if it is sorted
already.</block>
          </para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Array.BinarySearch(System.Array,System.Object)" /> is equivalent to <see cref="M:System.Array.BinarySearch(System.Array,System.Object)" />(<paramref name="array" />, <paramref name="array" />.GetLowerBound(0),
<paramref name="array" />.Length, <paramref name="value" />, 
<see langword="null" />).</para>
          <para>
            <paramref name="value" /> is compared to each element of
<paramref name="array" /> using the <see cref="T:System.IComparable" /> interface of the element being 
compared - or of <paramref name="value" /> if the element being compared does not implement the
interface - until an element with a value greater than or equal to
<paramref name="value" /> is found. If <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface 
and is compared to an element that does not implement the <see cref="T:System.IComparable" /> interface,
a <see cref="T:System.InvalidOperationException" /> exception is thrown. If <paramref name="array" />
is not already sorted, correct results are not guaranteed.</para>
          <para>
            <block subset="none" type="note"> A null reference
   can be compared with any type; therefore,
   comparisons with a null reference do not generate exceptions.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <para>Both <paramref name="value" /> and at least one element of <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface. </para>
          <para>-or-</para>
          <para>
            <paramref name="value" /> is not assignment-compatible with at least one element of <paramref name="array" />. </para>
          <para>-or-</para>
          <para>
            <paramref name="array" />.UpperBound == <see cref="F:System.Int32.MaxValue" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="array" /> has more than one dimension.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>Both <paramref name="value" /> and at least one element of <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface. </para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">A <see cref="T:System.Array" /> to search.</param>
        <param name="value">A <see cref="T:System.Object" /> for which to search. </param>
        <param name="comparer">
          <para>The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements. Specify a null reference to use the <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Searches the specified one-dimensional <see cref="T:System.Array" /> for the specified
   value, using the specified <see cref="T:System.Collections.IComparer" />
   implementation.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> with one of the following values based on the result of the search
   operation.</para>
          <list type="table">
            <listheader>
              <term>Return Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term> The index of <paramref name="value" /> in the
      array.</term>
              <description>
                <paramref name="value" /> was found.</description>
            </item>
            <item>
              <term> The bitwise complement of the index of the first element that is larger than
   <paramref name="value" />.</term>
              <description>
                <paramref name="value" /> was not found, and at least one array element was
   greater than <paramref name="value" />.</description>
            </item>
            <item>
              <term> The bitwise complement of (<paramref name="array" />.GetLowerBound(0) +
<paramref name="array" />.Length).</term>
              <description>
                <paramref name="value" /> was not found, and <paramref name="value" /> was greater than all
array elements.</description>
            </item>
          </list>
          <para>
            <block subset="none" type="note"> If <paramref name="value" />
is not found, the caller can take the bitwise complement of the return value to
determine the index where value would be found in <paramref name="array" /> if it is
already sorted.</block>
          </para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Array.BinarySearch(System.Array,System.Object)" /> is equivalent to <see cref="M:System.Array.BinarySearch(System.Array,System.Object)" />(<paramref name="array" />, <paramref name="array" />.GetLowerBound(0),
<paramref name="array" />.Length, <paramref name="value" />, <paramref name="comparer" />).</para>
          <para>
            <paramref name="value" /> is compared to each element of
<paramref name="array" /> using <paramref name="comparer" /> until an element with a value greater 
than or equal to <paramref name="value" /> is found. If <paramref name="comparer" /> is <see langword="null" />,
the <see cref="T:System.IComparable" /> interface of the element being compared - or of
<paramref name="value" /> if the element being compared does not implement the interface 
- is used. If <paramref name="value" /> does not implement
the <see cref="T:System.IComparable" />
interface and is compared to an element that does not implement
the <see cref="T:System.IComparable" />
interface, a <see cref="T:System.InvalidOperationException" /> exception is thrown. If <paramref name="array" /> is
not already sorted, correct results are not guaranteed.</para>
          <para>
            <block subset="none" type="note"> A null reference
   can be compared with any type; therefore, comparisons
   with a null reference do not generate exceptions.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and both <paramref name="value" /> and at least one element of <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</para>
          <para>-or-</para>
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is not assignment-compatible with at least one element of <paramref name="array" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="array" />.UpperBound == <see cref="F:System.Int32.MaxValue" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and both <paramref name="value" /> and at least one element of <paramref name="array" /> do not implement the <see cref="T:System.IComparable" />  interface.</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 BinarySearch(class System.Array array, int32 index, int32 length, object value)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">A <see cref="T:System.Array" /> to search.</param>
        <param name="index">A <see cref="T:System.Int32" /> that contains the index at which searching starts.</param>
        <param name="length">A <see cref="T:System.Int32" /> that contains the number of elements to search, beginning with <paramref name="index" /> .</param>
        <param name="value">A <see cref="T:System.Object" /> for which to search. </param>
        <summary>
          <para>Searches the specified section of the specified
      one-dimensional <see cref="T:System.Array" /> for the specified value.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> with one of the following values based on the result of the search
   operation.</para>
          <list type="table">
            <listheader>
              <term>Return Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term> The index of <paramref name="value" /> in the
      array.</term>
              <description>
                <paramref name="value" /> was found.</description>
            </item>
            <item>
              <term> The bitwise complement of the index of the first element that is larger than
   <paramref name="value" />.</term>
              <description>
                <paramref name="value" /> was not found, and at least one array element in the
   range of <paramref name="index" /> to <paramref name="index" /> + <paramref name="length" /> - 1 was greater
   than <paramref name="value" />.</description>
            </item>
            <item>
              <term> The bitwise complement of (<paramref name="index" /> + <paramref name="length" />).</term>
              <description>
                <paramref name="value" /> was not found, and <paramref name="value" /> was greater than all
array elements in the range of <paramref name="index" /> to <paramref name="index" /> +
<paramref name="length" />- 1.</description>
            </item>
          </list>
          <para>
            <block subset="none" type="note"> If <paramref name="value" />
is not found, the caller can take the bitwise complement of the return value to
determine the index of the array where <paramref name="value" /> would be found in the
range of <paramref name="index" /> to <paramref name="index" /> + <paramref name=" length" /> - 1 if <paramref name="array" />
is already sorted.</block>
          </para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Array.BinarySearch(System.Array,System.Object)" /> is equivalent to <see cref="M:System.Array.BinarySearch(System.Array,System.Object)" />(<paramref name="array" />, <paramref name="array" />.GetLowerBound(0),
<paramref name="array" />.Length, <paramref name="value" />, 
<see langword="null" />). </para>
          <para>
            <paramref name="value" /> is compared to each element of <paramref name="array" /> using
the <see cref="T:System.IComparable" /> interface of the element being compared - or of
<paramref name="value" /> if the element being compared does not implement the interface - 
until an element with a value greater than or equal to <paramref name="value" /> is found.
If <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface and is compared to an element
that does not implement the <see cref="T:System.IComparable" /> interface, a <see cref="T:System.InvalidOperationException" />
exception is thrown. If <paramref name="array" /> is not already sorted, correct results
are not guaranteed. </para>
          <para>
            <block subset="none" type="note"> A null reference can be compared with
   any type; therefore, comparisons with a null reference do not generate
   exceptions.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> .</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="array" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" /> (i.e. <paramref name="index" /> + <paramref name="length" /> &gt; <paramref name="array" />.GetLowerBound(0) + <paramref name="array" />.Length).</para>
          <para> -or-</para>
          <para>
            <paramref name="array" />.UpperBound == <see cref="F:System.Int32.MaxValue" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>Either <paramref name="value" /> or at least one element of <paramref name="array" /> does not implement the <see cref="T:System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">A <see cref="T:System.Array" /> to search.</param>
        <param name="index">A <see cref="T:System.Int32" /> that contains the index at which searching starts. </param>
        <param name="length">A <see cref="T:System.Int32" /> that contains the number of elements to search, beginning with <paramref name="index" /> . </param>
        <param name="value">A <see cref="T:System.Object" /> for which to search. </param>
        <param name="comparer">
          <para>The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements. Specify a null reference to use the <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Searches the specified section of the specified
      one-dimensional <see cref="T:System.Array" /> for the specified value, using the
      specified <see cref="T:System.Collections.IComparer" />
      implementation.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> with one of the following values based on the result of the search
   operation.</para>
          <list type="table">
            <listheader>
              <term>Return Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term> The index of <paramref name="value" /> in the
      array.</term>
              <description>
                <paramref name="value" /> was found.</description>
            </item>
            <item>
              <term> The bitwise complement of the index of the first element that is larger than
   <paramref name="value" />.</term>
              <description>
                <paramref name="value" /> was not found, and at least one array element in the
   range of <paramref name="index" /> to <paramref name="index" /> + <paramref name="length" /> - 1 was greater
   than <paramref name="value" />.</description>
            </item>
            <item>
              <term> The bitwise complement of (<paramref name="index" /> + <paramref name="length" />).</term>
              <description>
                <paramref name="value" /> was not found, and <paramref name="value" /> was greater than all
array elements in the range of <paramref name="index" /> to <paramref name="index" /> +
<paramref name="length" />- 1.</description>
            </item>
          </list>
          <para>
            <block subset="none" type="note"> If <paramref name="value" /> is
not found, the caller can take the bitwise complement of the return value to
determine the index of <paramref name="array" /> where <paramref name="value" /> would be found in the
range of <paramref name="index" /> to <paramref name="index" /> + <paramref name="length" /> - 1 if <paramref name="array" /> is
already sorted.</block>
          </para>
        </returns>
        <remarks>
          <para>
            <paramref name="value" /> is compared to each element of
<paramref name="array" /> using <paramref name="comparer" /> until an element with a value greater 
   than or equal to <paramref name="value" /> is found. If <paramref name="comparer" /> is <see langword="null" />,
   the <see cref="T:System.IComparable" /> interface of the element being compared - or of
<paramref name="value" /> if the element being compared does not implement the interface 
   -- is used. If <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface and is compared to an element
   that does not implement the <see cref="T:System.IComparable" /> interface, a <see cref="T:System.InvalidOperationException" />
   exception is thrown. If <paramref name="array" /> is not already
   sorted, correct results are not guaranteed.</para>
          <para>
            <block subset="none" type="note"> A null reference can
   be compared with any type; therefore, comparisons with a
   null reference do not generate exceptions.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than <paramref name="array" /><see langword=".GetLowerBound(0)" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> + <paramref name="length" /> is greater than <paramref name="array" /><see langword=".GetLowerBound(0)" /> + <paramref name="array" /><see langword=".Length" />.</para>
          <para> -or- </para>
          <para>
            <paramref name="array" />.UpperBound == <see cref="F:System.Int32.MaxValue" />.</para>
        </exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.BinarySearch(System.Array,System.Object)" /> method.</para>
          <code lang="C#">using System;
class BinarySearchExample {
  public static void Main() {    
    int[] intAry = { 0, 2, 4, 6, 8 };
    Console.WriteLine( "The indices and elements of the array are: ");
    for ( int i = 0; i &lt; intAry.Length; i++ )
      Console.Write("[{0}]: {1, -5}", i, intAry[i]);
    Console.WriteLine();
    SearchFor( intAry, 3 );
    SearchFor( intAry, 6 );
    SearchFor( intAry, 9 );
  }
  public static void SearchFor( Array ar, Object value ) {
    int i = Array.BinarySearch( ar, 0, ar.Length, value, null );
    Console.WriteLine();
    if ( i &gt; 0 ) {
      Console.Write( "The object searched for, {0}, was found ", value );
      Console.WriteLine( "at index {1}.", value, i );
    }
    else if ( ~i == ar.Length ) {
      Console.Write( "The object searched for, {0}, was ", value );
      Console.Write( "not found,\nand no object in the array had " );
      Console.WriteLine( "greater value. " );
    }
    else {
      Console.Write( "The object searched for, {0}, was ", value );
      Console.Write( "not found.\nThe next larger object is at " );
      Console.WriteLine( "index {0}.", ~i );
    }
  }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The indices and elements of the array are:</para>
            <para> [0]:0 [1]:2 [2]:4 [3]:6 [4]:8</para>
            <para>The object searched for, 3, was not found.</para>
            <para>The next larger object is at index 2.</para>
            <para>The object searched for, 6, was found at index 3.</para>
            <para>The object searched for, 9, was not found,</para>
            <para>and no object in the array had greater value.</para>
          </c>
        </example>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and both <paramref name="value" /> and at least one element of <paramref name="array" /> do not implement the <see cref="T:System.IComparable" />  interface.</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The one-dimensional array to search.</param>
        <param name="value">The object for which to search.</param>
        <summary>
          <para>Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified object.</para>
        </summary>
        <returns>
          <para>One of the following values based on the result of the search operation:</para>
          <list type="table">
            <listheader>
              <term>Return Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>A non-negative index of <paramref name="value" /> in the array.</term>
              <description>
                <paramref name="value" /> was found.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of the index of the first element that is larger than   <paramref name="value" />.</term>
              <description>
                <paramref name="value" /> was not found and the value of at least one element of array was greater than <paramref name="value" />.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of one more than the index of the final element.</term>
              <description>
                <paramref name="value" /> was not found, and  <paramref name="value" /> was greater than the value of all array elements.</description>
            </item>
          </list>
        </returns>
        <remarks>
          <para>Either <paramref name="value" /> or every element of <paramref name="array" />  must implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" />  interface, which is used for comparisons. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation; otherwise, the  behavior is unspecified</para>
          <para>Duplicate elements are allowed. If the array contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, but not necessarily the first one.</para>
          <para>
            <block subset="none" type="note">
              <see langword="null" /> can always be compared with any other reference type; therefore, comparisons with <see langword="null" /> do not generate an exception.</block>
          </para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> .</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>Neither <paramref name="value" /> nor the elements of the array implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interfaces.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The one-dimensional array to search.</param>
        <param name="value">The object for which to search.</param>
        <param name="comparer">
          <para>The implementation to use when comparing elements.</para>
          <para>-or-</para>
          <para>
            <see langword="null" /> to use the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.Generic.IComparer&lt;T&gt;" /> interface.</para>
        </summary>
        <returns>
          <para>One of the following values based on the result of the search operation:</para>
          <list type="table">
            <listheader>
              <term>Return Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>A non-negative index of <paramref name="value" /> in the array.</term>
              <description>
                <paramref name="value" /> was found.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of the index of the first element that is larger than   <paramref name="value" />.</term>
              <description>
                <paramref name="value" /> was not found and the value of at least one element of array was greater than <paramref name="value" />.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of one more than the index of the final element.</term>
              <description>
                <paramref name="value" /> was not found, and  <paramref name="value" /> was greater than the value of all array elements.</description>
            </item>
          </list>
        </returns>
        <remarks>
          <para>The comparer customizes how the elements are compared.</para>
          <para>The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by <paramref name="comparer" />; otherwise, the behavior is unspecified</para>
          <para>If <paramref name="comparer" /> is not <see langword="null" />, the elements of <paramref name="array" /> are compared to the specified value using the specified  <see cref="T:System.Collections.Generic.IComparer" /> implementation. </para>
          <para>If <paramref name="comparer" /> is <see langword="null" />, the default comparer is used.</para>
          <para>Duplicate elements are allowed. If the array contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, but not necessarily the first one.</para>
          <para>
            <block subset="none" type="note">
              <see langword="null" /> can always be compared with any other reference type; therefore, comparisons with <see langword="null" /> do not generate an exception.</block>
          </para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> .</exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and neither <paramref name="value" /> nor the elements of the array implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The one-dimensional array to search.</param>
        <param name="index">To be added.</param>
        <param name="length">The length of the range to search.</param>
        <param name="value">The object for which to search.</param>
        <summary>
          <para>Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified value.</para>
        </summary>
        <returns>
          <para>One of the following values based on the result of the search operation:</para>
          <list type="table">
            <listheader>
              <term>Return Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>A non-negative index of <paramref name="value" /> in the array.</term>
              <description>
                <paramref name="value" /> was found.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of the index of the first element that is larger than   <paramref name="value" />.</term>
              <description>
                <paramref name="value" /> was not found and the value of at least one element of array was greater than <paramref name="value" />.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of one more than the index of the final element.</term>
              <description>
                <paramref name="value" /> was not found, and  <paramref name="value" /> was greater than the value of all array elements.</description>
            </item>
          </list>
        </returns>
        <remarks>
          <para>Either <paramref name="value" /> or every element of <paramref name="array" />  must implement the <see cref="T:System.IComparable" />  interface, which is used for comparisons. The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation; otherwise, the behavior is unspecified</para>
          <para>Duplicate elements are allowed. If the array contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, but not necessarily the first one.</para>
          <para>
            <block subset="none" type="note">
              <see langword="null" /> can always be compared with any other reference type; therefore, comparisons with <see langword="null" /> do not generate an exception.</block>
          </para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> + <paramref name="length" /> is greater than <paramref name="array" /><see langword=".Length" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> .</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>Neither <paramref name="value" /> nor the elements of the array implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The one-dimensional array to search.</param>
        <param name="index">The starting index of the range to search.</param>
        <param name="length">The length of the range to search.</param>
        <param name="value">The object for which to search.</param>
        <param name="comparer">
          <para>The implementation to use when comparing elements.</para>
          <para>-or-</para>
          <para>
            <see langword="null" /> to use the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.Generic.IComparer&lt;T&gt;" /> interface.</para>
        </summary>
        <returns>
          <para>One of the following values based on the result of the search operation:</para>
          <list type="table">
            <listheader>
              <term>Return Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>A non-negative index of <paramref name="value" /> in the array.</term>
              <description>
                <paramref name="value" /> was found.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of the index of the first element that is larger than   <paramref name="value" />.</term>
              <description>
                <paramref name="value" /> was not found and the value of at least one element of array was greater than <paramref name="value" />.</description>
            </item>
            <item>
              <term>A negative value, which is the bitwise complement of one more than the index of the final element.</term>
              <description>
                <paramref name="value" /> was not found, and  <paramref name="value" /> was greater than the value of all array elements.</description>
            </item>
          </list>
        </returns>
        <remarks>
          <para>The comparer customizes how the elements are compared.</para>
          <para>The elements of <paramref name="array" /> must already be sorted in increasing value according to the sort order defined by <paramref name="comparer" />; otherwise, the behavior is unspecified.</para>
          <para>If <paramref name="comparer" /> is not <see langword="null" />, the elements of <paramref name="array" /> are compared to the specified value using the specified  <see cref="T:System.Collections.Generic.IComparer&lt;T&gt;" /> implementation. </para>
          <para>If <paramref name="comparer" /> is <see langword="null" />, the comparison is done using the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable " /> implementation provided by the element itself or by the specified value.</para>
          <para>Duplicate elements are allowed. If the array contains more than one element equal to <paramref name="value" />, the method returns the index of only one of the occurrences, but not necessarily the first one.</para>
          <para>
            <block subset="none" type="note">
              <see langword="null" /> can always be compared with any other reference type; therefore, comparisons with <see langword="null" /> do not generate an exception.</block>
          </para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in array.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> .</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and neither <paramref name="value" /> nor the elements of the array implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Clear(class System.Array array, int32 index, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The <see cref="T:System.Array" /> to clear.</param>
        <param name="index">A <see cref="T:System.Int32" /> that contains the index at which clearing starts.</param>
        <param name="length">A <see cref="T:System.Int32" /> that contains the number of elements to clear, beginning with <paramref name="index" />.</param>
        <summary>
          <para>Sets the specified range of elements in the
      specified <see cref="T:System.Array" /> to zero, false, or to a null reference, depending on the
      element type.</para>
        </summary>
        <remarks>
          <para>Reference-type elements will be set to
   <see langword="null" />. Value-type elements will be set to zero, 
      except for <see cref="T:System.Boolean" />
      elements, which will be set to
   <see langword="false" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="array" />.GetLowerBound(0).</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" /> (i.e. <paramref name="index" /> + <paramref name="length" /> &gt; <paramref name="array" />.GetLowerBound(0) + <paramref name="array" />.Length ).</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual object Clone()" />
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns a <see cref="T:System.Object" /> that is a copy of the current instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" /> that is a copy of
   the current instance.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note"> This method is implemented to support
      the <see cref="T:System.ICloneable" />
      interface.</block>
          </para>
          <para>
            <block subset="none" type="behaviors">Each of the
      elements of the current instance is copied to the clone. If the elements are
      reference types, the references are copied. If the elements are value-types, the
      values are copied. The clone is of the same type as the current
      instance.</block>
          </para>
          <para>
            <block subset="none" type="default">As described above.</block>
          </para>
          <para>
            <block subset="none" type="overrides">Override this method to return a
      clone of an array.</block>
          </para>
          <para>
            <block subset="none" type="usage">Use this method to obtain the clone of
      an array.</block>
          </para>
        </remarks>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.Clone" /> method.</para>
          <code lang="C#">using System;
public class ArrayCloneExample {
  public static void Main() {
    int[] intAryOrig = { 3, 4, 5 };
    //must explicitly convert clones object into an array
    int[] intAryClone = (int[]) intAryOrig.Clone();
    Console.Write( "The elements of the first  array are: " );
    foreach( int i in intAryOrig )
      Console.Write( "{0,3}", i );
    Console.WriteLine();
    Console.Write( "The elements of the cloned array are: " );
    foreach( int i in intAryClone )
      Console.Write( "{0,3}", i );
    Console.WriteLine();
    //Clear the values of the original array.
    Array.Clear( intAryOrig, 0, 3 );
    Console.WriteLine( "After clearing the first array," );
    Console.Write( "The elements of the first  array are: " );
    foreach( int i in intAryOrig )
      Console.Write( "{0,3}", i );
    Console.WriteLine();
    Console.Write( "The elements of the cloned array are: " );
    foreach( int i in intAryClone )
      Console.Write( "{0,3}", i );
  }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The elements of the first array are: 3 4 5</para>
            <para>The elements of the cloned array are: 3 4 5</para>
            <para>After clearing the first array,</para>
            <para>The elements of the first array are: 0 0 0</para>
            <para>The elements of the cloned array are: 3 4 5</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">To be added.</param>
        <param name="sourceIndex">To be added.</param>
        <param name="destinationArray">To be added.</param>
        <param name="destinationIndex">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">To be added.</typeparam>
        <typeparam name="TOutput">To be added.</typeparam>
        <param name="array">The one-dimensional array to convert.</param>
        <param name="converter">
          <para>A <see cref="T:System.Converter&lt;T,U&gt;" /> that converts each element from one type to another type.</para>
        </param>
        <summary>
          <para>Converts an array of one type to an array of another type.</para>
        </summary>
        <returns>
          <para>A new array of the target type containing the converted elements from <paramref name="array" />.</para>
        </returns>
        <remarks>
          <para>The <see cref="T:System.Converter&lt;T,U&gt;" /> is a delegate that converts an array element to the target type.  The elements of  <paramref name="array" /> are individually passed to this converter, and the converted elements are saved in the new array. The source array remains unchanged.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> or <paramref name="converter" /> is <see langword="null" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">A <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="destinationArray">A <see cref="T:System.Array" /> that receives the data.</param>
        <param name="length">A <see cref="T:System.Int32" /> designating the number of elements to copy, starting with the first element and proceeding in order.</param>
        <summary>
          <para> Copies the specified number of elements from the 
      specified source array to the specified destination array.</para>
        </summary>
        <remarks>
          <para>This version of <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> is equivalent to <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> (<paramref name="sourceArray" />, <paramref name="sourceArray" />.GetLowerBound(0), <paramref name="destinationArray" />,
<paramref name="destinationArray" />.GetLowerBound(0), <paramref name="length" />). </para>
          <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of different
types, <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> performs widening conversions on the elements of
<paramref name="sourceArray" /> as necessary before storing the information in 
<paramref name="destinationArray" />. Value types will be boxed when being converted to a 
<see cref="T:System.Object" />. If the necessary 
conversion is a narrowing conversion, a <see cref="T:System.ArrayTypeMismatchException" /> exception is thrown. <block subset="none" type="note">
For information regarding valid conversions performed by this method, see
<see cref="T:System.Convert" />.</block></para>
          <para>If an exception is thrown while copying, the state of
<paramref name="destinationArray" /> is undefined. </para>
          <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are the same
array, <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> copies the source elements safely to their
destination, as if the copy were done through an intermediate array. </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="sourceArray" /> or <paramref name="destinationArray" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</para>
        </exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <para>The elements in both arrays are built-in types, and converting from the type of the elements of <paramref name="sourceArray" /> into the type of the elements in <paramref name="destinationArray" /> requires a narrowing conversion.</para>
          <para> -or-</para>
          <para>Both arrays are built-in types, and one array is a value-type array and the other an array of interface type not implemented by that value-type.</para>
          <para> -or-</para>
          <para>Both arrays are user-defined value types and are not of the same type.</para>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <para> At least one of the elements in <paramref name="sourceArray" /> is not assignment-compatible with the type of <paramref name="destinationArray" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="length" /> &gt; <paramref name="sourceArray" />.Length.</para>
          <para>-or-</para>
          <para>
            <paramref name="length " /> &gt; <paramref name="destinationArray" />.Length.</para>
        </exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> method.</para>
          <code lang="C#">using System;
public class ArrayCopyExample {
   public static void Main() {
      int[] intAryOrig = new int[3];
      double[] dAryCopy = new double[3];
      for ( int i = 0; i &lt; intAryOrig.Length; i++ )
         intAryOrig[i] = i+3;
      //copy the first 2 elements of the source into the destination
      Array.Copy( intAryOrig, dAryCopy, 2);
      Console.Write( "The elements of the first array are: " );
      for ( int i = 0; i &lt; intAryOrig.Length; i++ ) 
         Console.Write( "{0,3}", intAryOrig[i] );
      Console.WriteLine();
      Console.Write( "The elements of the copied array are: " );
      for ( int i = 0; i &lt; dAryCopy.Length; i++ ) 
         Console.Write( "{0,3}", dAryCopy[i] );
   }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The elements of the first array are: 3 4 5</para>
            <para>The elements of the copied array are: 3 4 0</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">To be added.</param>
        <param name="destinationArray">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">The <see cref="T:System.Array" /> that contains the data to copy.</param>
        <param name="sourceIndex">A <see cref="T:System.Int32" /> that contains the index in <paramref name="sourceArray" /> from which copying begins.</param>
        <param name="destinationArray">The <see cref="T:System.Array" /> that receives the data.</param>
        <param name="destinationIndex">A <see cref="T:System.Int32" /> that contains the index in <paramref name="destinationArray" /> at which storing begins.</param>
        <param name="length">A <see cref="T:System.Int32" /> that contains the number of elements to copy.</param>
        <summary>
          <para> Copies the specified number of elements from a source 
      array starting at the specified source index to a destination array
      starting at the specified destination index.</para>
        </summary>
        <remarks>
          <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" />
are of different types, <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> performs widening conversions on the elements of
<paramref name="sourceArray" /> as necessary before storing the information in 
<paramref name="destinationArray" />. Value types will be boxed when being converted to a 
<see cref="T:System.Object" />. If the necessary 
conversion is a narrowing conversion, a <see cref="T:System.ArrayTypeMismatchException" /> exception is thrown. <block subset="none" type="note">
For information regarding valid conversions performed by this method, see
<see cref="T:System.Convert" /> .</block></para>
          <para>If an exception is thrown while copying, the state of
<paramref name="destinationArray" /> is undefined. </para>
          <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" />
are the same array, <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> copies the source elements safely to their
destination as if the copy were done through an intermediate array. </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="sourceArray" /> or <paramref name="destinationArray" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</para>
        </exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <para>The elements in both arrays are built-in types, and converting from the type of the elements of <paramref name="sourceArray" /> into the type of the elements in <paramref name="destinationArray" /> requires a narrowing conversion.</para>
          <para>-or-</para>
          <para>Both arrays are built-in types, and one array is a value-type array and the other an array of interface type not implemented by that value-type.</para>
          <para>-or-</para>
          <para>Both arrays are user-defined value types and are not of the same type.</para>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <para>At least one element in <paramref name="sourceArray" /> is assignment-incompatible with the type of <paramref name="destinationArray" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="sourceIndex" /> &lt; <paramref name="sourceArray" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="destinationIndex" /> &lt; <paramref name="destinationArray" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>(<paramref name="sourceIndex" /> + <paramref name="length" /> ) &gt; (<paramref name="sourceArray" />.GetLowerBound(0) + <paramref name="sourceArray" />.Length).</para>
          <para>(<paramref name="destinationIndex" /> + <paramref name="length" /> ) &gt; ( <paramref name="destinationArray" />.GetLowerBound(0) + <paramref name="destinationArray" />.Length).</para>
        </exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" /> method.</para>
          <code lang="C#">using System;
class ArrayCopyExample {
   public static void Main() {
      int[] intAry = { 0, 10, 20, 30, 40, 50 };
      Console.Write( "The elements of the array are: " );
      foreach ( int i in intAry )
         Console.Write( "{0,3}", i );
      Console.WriteLine();
      Array.Copy( intAry, 2, intAry, 0, 4 );
      Console.WriteLine( "After copying elements 2 through 5 into elements 0 through 4" );
      Console.Write( "The elements of the array are: " );
      foreach ( int i in intAry )
         Console.Write( "{0,3}", i );
      Console.WriteLine();     
   }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The elements of the array are: 0 10 20 30 40 50</para>
            <para>After copying elements 2 through 5 into elements 0 through 4</para>
            <para>The elements of the array are: 20 30 40 50 40 50</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">To be added.</param>
        <param name="sourceIndex">To be added.</param>
        <param name="destinationArray">To be added.</param>
        <param name="destinationIndex">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void CopyTo(class System.Array array, int32 index)" />
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from the current instance.</param>
        <param name="index">A <see cref="T:System.Int32" /> that contains the index in <paramref name="array" /> at which copying begins.</param>
        <summary>
          <para> Copies all the elements of the current zero-based instance to the specified one-dimensional array starting at the specified subscript in the destination array.</para>
        </summary>
        <remarks>
          <para>
            <paramref name="index" /> is the array index in the destination array at which copying begins.</para>
          <block subset="none" type="note">
            <para>This method is implemented to support the <see cref="T:System.Collections.ICollection" /> interface. If implementing <see cref="T:System.Collections.ICollection" /> is not explicitly required, use <see cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
   to avoid an extra indirection.</para>
            <para>If this method throws an exception while copying, the state of <paramref name="array" />
is undefined.</para>
          </block>
          <para>
            <block subset="none" type="behaviors">As described
   above.</block>
          </para>
          <para>
            <block subset="none" type="default">As described
   above.</block>
          </para>
          <para>
            <block subset="none" type="overrides">Override this
   method to copy elements of the current instance to a specified
   array.</block>
          </para>
          <para>
            <block subset="none" type="usage">Use this method to
   copy elements of the current instance to a specified array.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <para>The current instance has more than one dimension.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> &lt; <paramref name="array" /><see langword=".GetLowerBound(0)" />.</exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="array" /> has more than one dimension.</para>
          <para> -or-</para>
          <para>( <paramref name="index" /> + Length of the current instance) &gt; (<paramref name="array" /><see langword=".GetLowerBound(0)" /> + <paramref name="array" /><see langword=".Length" />).</para>
          <para> -or-</para>
          <para>The number of elements in the current instance is greater than the available space from <paramref name="index" /> to the end of <paramref name="array" />.</para>
        </exception>
        <exception cref="T:System.ArrayTypeMismatchException">The element type of the current instance is not assignment-compatible with the element type of <paramref name="array" />.</exception>
        <example>
          <para> The following example shows how to copy the elements of one <see cref="T:System.Array" /> into another.</para>
          <code lang="C#">using System;

public class ArrayCopyToExample
{
   public static void Main()
   {
      Array aryOne = Array.CreateInstance(typeof(Object), 3);
      aryOne.SetValue("one", 0);
      aryOne.SetValue("two", 1);
      aryOne.SetValue("three", 2);

      Array aryTwo = Array.CreateInstance(typeof(Object), 5);
      for (int i=0; i &lt; aryTwo.Length; i++)
         aryTwo.SetValue(i, i);

      Console.WriteLine("The contents of the first array are:");
      foreach (object o in aryOne)
         Console.Write("{0} ", o);
      Console.WriteLine();
      Console.WriteLine("The original contents of the second array are:");
      foreach (object o in aryTwo)
         Console.Write("{0} ", o);
      Console.WriteLine();
      
      aryOne.CopyTo(aryTwo, 1);

      Console.WriteLine("The new contents of the second array are:");
      foreach( object o in aryTwo)
         Console.Write("{0} ", o);
   }
}
</code>
          <para>The output is</para>
          <para>
            <c>The contents of the first array are:</c>
          </para>
          <para>
            <c> one two three</c>
          </para>
          <para>
            <c>The original contents of the second array are:</c>
          </para>
          <para>
            <c>0 1 2 3 4</c>
          </para>
          <para>
            <c> The new contents of the second array are:</c>
          </para>
          <para>
            <c>0 one two three 4</c>
          </para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Array CreateInstance(class System.Type elementType, int32 length)" />
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the elements contained in the new <see cref="T:System.Array" /> instance.</param>
        <param name="length">A <see cref="T:System.Int32" /> that contains the number of elements contained in the new <see cref="T:System.Array" /> instance.</param>
        <summary>
          <para>Constructs a zero-based, one-dimensional array with the specified number of elements of the specified type.</para>
        </summary>
        <returns>
          <para>A zero-based, one-dimensional <see cref="T:System.Array" /> object containing <paramref name="length" /> elements of type
<paramref name="elementType" />.</para>
        </returns>
        <remarks>
          <para>Reference-type elements will be set to <see langword="null" />. Value-type elements will be set to zero, 
   except for <see cref="T:System.Boolean" />
   elements, which will be set to
<see langword="false" />.</para>
          <para>
            <block subset="none" type="note">Unlike most classes, <see cref="T:System.Array" /> provides the <see cref="M:System.Array.CreateInstance(System.Type,System.Int32)" /> method, instead of public constructors, to allow
for late bound access.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> &lt; 0.</exception>
        <example>
          <para> The following example shows how to create and
      initialize a one-dimensional <see cref="T:System.Array" />.</para>
          <code lang="C#">using System;

public class ArrayCreateInstanceExample
{

   public static void Main()
   {

      Array intAry = Array.CreateInstance(typeof(int),5);
      for (int i=intAry.GetLowerBound(0);i&lt;=intAry.GetUpperBound(0);i++)
         intAry.SetValue(i*3,i);
      Console.Write("The values of the array are:");
      foreach (int i in intAry)
         Console.Write("{0} ",i);
   
   }

}
   </code>
          <para>The output is</para>
          <para>
            <c>The values of the array are: 0 3 6 9 12</c>
          </para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Array CreateInstance(class System.Type elementType, class System.Int32[] lengths)" />
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the elements contained in the new <see cref="T:System.Array" /> instance. </param>
        <param name="lengths">A one-dimensional array of <see cref="T:System.Int32" /> objects that contains the size of each dimension of the new <see cref="T:System.Array" /> instance.</param>
        <summary>
          <para>Creates a zero-based, multidimensional array of the
      specified <see cref="T:System.Type" /> and dimension lengths.</para>
        </summary>
        <returns>
          <para>A new zero-based, multidimensional <see cref="T:System.Array" /> instance of the
   specified <see cref="T:System.Type" /> with the specified length for
   each dimension. The <see cref="P:System.Array.Rank" /> of the new instance is equal to
<paramref name="lengths" />.Length.</para>
        </returns>
        <remarks>
          <para>The number of elements in <paramref name="lengths" /> is required to equal the number of
   dimensions in the new <see cref="T:System.Array" /> instance. Each element of <paramref name="lengths" /> specifies
   the length of the corresponding dimension in the new instance.</para>
          <para>Reference-type elements will be set to <see langword="null" />. Value-type elements will be set to zero, 
except for <see cref="T:System.Boolean" />
elements, which will be set to
<see langword="false" />.</para>
          <para>
            <block subset="none" type="note">Unlike most classes, <see cref="T:System.Array" /> provides the
<see cref="M:System.Array.CreateInstance(System.Type,System.Int32)" /> method, instead of public constructors, to allow
for late bound access.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="elementType" /> or <paramref name="lengths" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="lengths" />.Length = 0.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in <paramref name="lengths" /> is less than zero.</exception>
        <example>
          <para> The following example shows how to create and initialize a
      multidimensional <see cref="T:System.Array" />.</para>
          <code lang="C#">
using System;

public class CreateMultiDimArrayExample
{
   public static void Main()
   {
      int i, j, k;
      int[] indexAry = {2, 4, 5};
      Array ary = Array.CreateInstance( typeof(int), indexAry );
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++ )
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++ )
         {
            for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               ary.SetValue( (100*i + 10*j + k), i, j, k );
            }
         }
      }
      Console.WriteLine("The elements of the array are:");
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++)
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++)
         {
             for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               Console.Write("{0, 3} ", ary.GetValue(i, j, k));
            }
            Console.WriteLine();
         }
         Console.WriteLine();
      }
   }
}
   </code>
          <para>The output is</para>
          <code>The elements of the array are:
  0   1   2   3   4
 10  11  12  13  14
 20  21  22  23  24
 30  31  32  33  34

100 101 102 103 104
110 111 112 113 114
120 121 122 123 124
130 131 132 133 134 
</code>
        </example>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, long[] lengths);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2)" />
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the elements contained in the new <see cref="T:System.Array" /> instance. </param>
        <param name="length1">A <see cref="T:System.Int32" /> that contains the number of elements contained in the first dimension of the new <see cref="T:System.Array" /> instance. </param>
        <param name="length2">A <see cref="T:System.Int32" /> that contains the number of elements contained in the second dimension of the new <see cref="T:System.Array" /> instance. </param>
        <summary>
          <para>Creates a zero-based, two-dimensional array of the specified <see cref="T:System.Type" />
and dimension lengths.</para>
        </summary>
        <returns>
          <para>A new zero-indexed, two-dimensional <see cref="T:System.Array" /> instance of <paramref name="elementType" /> objects with the size
<paramref name="length1" /> for the first dimension and <paramref name="length2" /> 
for the second.</para>
        </returns>
        <remarks>
          <para>Reference-type elements will be set to <see langword="null" />. Value-type elements will be set to zero, 
   except for <see cref="T:System.Boolean" />
   elements, which will be set to
<see langword="false" />.</para>
          <para>
            <block subset="none" type="note">Unlike most classes, <see cref="T:System.Array" /> provides the
<see cref="M:System.Array.CreateInstance(System.Type,System.Int32)" /> method, instead of public constructors, to allow 
for late bound access.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="length1" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="length2" /> &lt; 0.</para>
        </exception>
        <example>
          <para> The following example shows how to create and
      initialize a two-dimensional <see cref="T:System.Array" />.</para>
          <code lang="C#">
using System;

public class Create2DArrayExample
{
   public static void Main()
   {
      int i, j;
      Array ary = Array.CreateInstance( typeof(int), 5, 3 );
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++ )
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++ )
         {
            ary.SetValue( (10*i + j), i, j );
         }
      }
      Console.WriteLine("The elements of the array are:");
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++)
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++)
         {
            Console.Write("{0, 2} ", ary.GetValue(i, j));
         }
         Console.WriteLine();
      }
   }
} 
  </code>
          <para>The output is</para>
          <code>The elements of the array are:
 0  1  2
10 11 12
20 21 22
30 31 32
40 41 42
 </code>
        </example>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Array CreateInstance(class System.Type elementType, class System.Int32[] lengths, class System.Int32[] lowerBounds)" />
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the elements contained in the new <see cref="T:System.Array" /> instance. </param>
        <param name="lengths">A one-dimensional array of <see cref="T:System.Int32" /> objects that contains the size of each dimension of the new <see cref="T:System.Array" /> instance.</param>
        <param name="lowerBounds">A one-dimensional array of <see cref="T:System.Int32" /> objects that contains the lower bound of each dimension of the new <see cref="T:System.Array" /> instance.</param>
        <summary>
          <para>Creates a multidimensional array whose element type is the specified <see cref="T:System.Type" />, and dimension lengths and lower bounds, as specified.</para>
        </summary>
        <returns>
          <para>A new multidimensional <see cref="T:System.Array" /> whose element type is the specified <see cref="T:System.Type" /> and with
   the specified length and lower bound for each dimension.</para>
        </returns>
        <remarks>
          <para>The <paramref name="lengths" /> and <paramref name="lowerBounds" />
are required to have the same number of elements. The number of elements in
<paramref name="lengths" />
equals the number of dimensions in the new <see cref="T:System.Array" /> instance</para>
          <para> Each element of <paramref name="lengths" />
specifies the length of the corresponding dimension in the new <see cref="T:System.Array" /> instance.</para>
          <para> Each element of <paramref name="lowerBounds" /> specifies the lower bound of the
corresponding dimension in the new <see cref="T:System.Array" /> instance.</para>
          <para> Reference-type elements will be set to <see langword="null" />. Value-type elements will be set to zero,
except for <see cref="T:System.Boolean" />
elements, which will be set to
<see langword="false" />.</para>
          <para>
            <block subset="none" type="note">Unlike most classes, <see cref="T:System.Array" /> provides the
<see cref="M:System.Array.CreateInstance(System.Type,System.Int32)" /> method, instead of public constructors, to allow
for late bound access.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="elementType" />, <paramref name="lengths" />, or <paramref name="lowerBounds" /> is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="lengths" />.Length = 0.</para>
          <para> -or-</para>
          <para>
            <paramref name="lengths" /> and <paramref name="lowerBounds" /> do not contain the same number of elements.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A value in <paramref name="lengths" /> is less than zero.</exception>
        <example>
          <para> The following example shows how to create and
      initialize a multidimensional <see cref="T:System.Array" />
      with specified low bounds.</para>
          <code lang="C#">
using System;

public class MultiDimNonZeroBoundExample
{
   public static void Main()
   {
      int i, j, k;
      int[] indexAry = {4, 2, 3};
      int[] lowboundAry = {3, 2, 1};
      Array ary = Array.CreateInstance( typeof(int), indexAry, lowboundAry );
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++ )
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++ )
         {
            for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               ary.SetValue( (100*i + 10*j + k), i, j, k );
            }
         }
      }
      Console.WriteLine("The elements of the array are:");
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++)
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++)
         {
             for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               Console.Write("{0, 3} ", ary.GetValue(i, j, k));
            }
            Console.WriteLine();
         }
         Console.WriteLine();
      }
   }
}
   </code>
          <para>The output is</para>
          <code>The elements of the array are:
321 322 323
331 332 333

421 422 423
431 432 433

521 522 523
531 532 533

621 622 623
631 632 633
</code>
        </example>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3)" />
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">The <see cref="T:System.Type" /> of the elements contained in the new <see cref="T:System.Array" /> instance. </param>
        <param name="length1">A <see cref="T:System.Int32" /> that contains the number of elements contained in the first dimension of the new <see cref="T:System.Array" /> instance. </param>
        <param name="length2">A <see cref="T:System.Int32" /> that contains the number of elements contained in the second dimension of the new <see cref="T:System.Array" /> instance. </param>
        <param name="length3">A <see cref="T:System.Int32" /> that contains the number of elements contained in the third dimension of the new <see cref="T:System.Array" /> instance. </param>
        <summary>
          <para>Creates a zero-based, three-dimensional array of the
      specified <see cref="T:System.Type" /> and dimension lengths.</para>
        </summary>
        <returns>
          <para>A new zero-based, three-dimensional <see cref="T:System.Array" /> instance of <paramref name="elementType" /> objects with the size
<paramref name="length1" /> for the first dimension, <paramref name="length2" /> for the second, and 
<paramref name="length3" /> for the third.</para>
        </returns>
        <remarks>
          <para>Reference-type elements will be set to <see langword="null" />. Value-type elements will be set to zero, 
   except for <see cref="T:System.Boolean" />
   elements, which will be set to
<see langword="false" />.</para>
          <para>
            <block subset="none" type="note">Unlike most classes, <see cref="T:System.Array" /> provides the
<see cref="M:System.Array.CreateInstance(System.Type,System.Int32)" /> method, instead of public constructors, to allow 
for late bound access.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="length1" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="length2" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="length3" /> &lt; 0.</para>
        </exception>
        <example>
          <para> The following example shows how to create and
      initialize a three-dimensional <see cref="T:System.Array" />.</para>
          <code lang="C#">
using System;

public class Create3DArrayExample
{
   public static void Main()
   {
      int i, j, k;
      Array ary = Array.CreateInstance( typeof(int), 2, 4, 3 );
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++ )
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++ )
         {
            for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               ary.SetValue( (100*i + 10*j + k), i, j, k );
            }
         }
      }
      Console.WriteLine("The elements of the array are:");
      for( i = ary.GetLowerBound(0); i &lt;= ary.GetUpperBound(0); i++)
      {
         for( j = ary.GetLowerBound(1); j &lt;= ary.GetUpperBound(1); j++)
         {
             for( k = ary.GetLowerBound(2); k &lt;= ary.GetUpperBound(2); k++ )
            {
               Console.Write("{0, 3} ", ary.GetValue(i, j, k));
            }
            Console.WriteLine();
         }
         Console.WriteLine();
      }
   }
}
   </code>
          <para>The output is</para>
          <code>The elements of the array are:
  0   1   2
 10  11  12
 20  21  22
 30  31  32

100 101 102
110 111 112
120 121 122
130 131 132
 </code>
        </example>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="match">
          <para>The predicate that defines the conditions of the elements to search for.</para>
        </param>
        <summary>
          <para>Determines whether the specified array contains any element that matches the conditions defined by the specified predicate.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" />, if the array contains one or more elements that match the conditions defined by the specified predicate; otherwise, <see langword="false" />.</para>
        </returns>
        <remarks>
          <para>The predicate returns <see langword="true" /> if the object passed to it matches the delegate. Each element of <paramref name="array" /> is passed to the predicate in turn, and processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="match">
          <para>The predicate that defines the conditions of the element to search for.</para>
        </param>
        <summary>
          <para>Searches for an element that matches the predicate, and returns the first occurrence within the entire array.</para>
        </summary>
        <returns>
          <para>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</para>
        </returns>
        <remarks>
          <para>The elements of <paramref name="array" /> are individually passed to the predicate, moving forward in the array, starting with the first element and ending with the last element. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="match">
          <para>The predicate that specifies the elements to search for.</para>
        </param>
        <summary>
          <para>Retrieves all the elements that match the conditions defined by the specified predicate.</para>
        </summary>
        <returns>
          <para>An array containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty array.</para>
        </returns>
        <remarks>
          <para>The elements of <paramref name="array" /> are individually passed to the predicate, and those elements for which the predicate returns <see langword="true" />, are saved in the returned array.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="match">
          <para>The predicate that specifies the elements to search for.</para>
        </param>
        <summary>
          <para>Searches for an element that matches the predicate, and returns the zero-based index of the first occurrence within the entire array.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements of <paramref name="array" /> are individually passed to the predicate. The array is searched forward starting at the first element and ending at the last element. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="startIndex">
          <para>The zero-based starting index of the search.</para>
        </param>
        <param name="match">
          <para>The predicate that specifies the elements to search for.</para>
        </param>
        <summary>
          <para>Searches for an element that matches the predicate, and returns the zero-based index of the first occurrence within the range of elements in the array that extends from the specified index to the last element.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements of <paramref name="array" /> are individually passed to the predicate. The array is searched forward starting at the specified index and ending at the last element.  Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than zero or greater than <paramref name="array" /><see langword=".Length" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="startIndex">
          <para>The zero-based starting index of the search</para>
        </param>
        <param name="count">
          <para>The number of consecutive elements to search.</para>
        </param>
        <param name="match">
          <para>The predicate that specifies the elements to search for.</para>
        </param>
        <summary>
          <para>Searches for an element that matches the predicate, and returns the zero-based index of the first occurrence within the range of elements in the array that starts at the specified index and contains the specified number of elements.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements of <paramref name="array" /> are individually passed to the predicate. The array is searched forward starting at the specified index and going for <paramref name="count" /> elements.  Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="startIndex" /> + <paramref name="count" /> is greater than <paramref name="array" /><see langword=".Length" />.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="match">
          <para>The predicate that specifies the elements to search for.</para>
        </param>
        <summary>
          <para>Searches for an element that matches the predicate, and returns the last occurrence within the entire array.</para>
        </summary>
        <returns>
          <para>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</para>
        </returns>
        <remarks>
          <para>The elements of <paramref name="array" /> are individually passed to the predicate, moving backward in the array, starting with the last element and ending with the first element. Processing is stopped when a match is found.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="match">
          <para>The predicate that specifies the elements to search for.</para>
        </param>
        <summary>
          <para>Searches for an element that matches the predicate, and returns the zero-based index of the last occurrence within the entire array.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements of <paramref name="array" /> are individually passed to the predicate. The array is searched backwards starting at the last element and ending at the first element.  Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="startIndex">
          <para>The zero-based starting index of the backward search.</para>
        </param>
        <param name="match">
          <para>The predicate that specifies the elements to search for.</para>
        </param>
        <summary>
          <para>Searches for an element that matches the predicate, and returns the zero-based index of the last occurrence within the range of elements in the array that extends from the specified index to the last element.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements of <paramref name="array" /> are individually passed to the predicate. The array is searched backward starting at the specified index and ending at the first element. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than zero or greater than <paramref name="array" /><see langword=".Length" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="startIndex">
          <para>The zero-based starting index of the backward search.</para>
        </param>
        <param name="count">
          <para>The number of consecutive elements to search.</para>
        </param>
        <param name="match">
          <para>The predicate that specifies the elements to search for.</para>
        </param>
        <summary>
          <para>Searches for an element that matches the predicate, and returns the zero-based index of the last occurrence within the range of elements in the array that ends at the specified index and contains the specified number of elements.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements of <paramref name="array" /> are individually passed to the predicate. The array is searched backward starting at the specified index and going for <paramref name="count" /> elements. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than zero or greater than <paramref name="array" /><see langword=".Length" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is greater than <paramref name="startIndex" /> + 1.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array on whose elements the action is to be performed.</param>
        <param name="action">
          <para>The action to perform on each element of <paramref name="array" />.</para>
        </param>
        <summary>
          <para>Performs the specified action on each element of the specified array.</para>
        </summary>
        <remarks>
          <para>The elements of <paramref name="array" /> are individually passed to the action. The elements of the current array are individually passed to the action delegate, sequentially, in index order, and on the same thread as that used to call <see langword="ForEach" />. Execution stops if the action throws an exception.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="action" /> is <see langword="null" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Collections.IEnumerator GetEnumerator()" />
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns a <see cref="T:System.Collections.IEnumerator" /> for the current instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Collections.IEnumerator" /> for the current instance.</para>
        </returns>
        <remarks>
          <para>A <see cref="T:System.Collections.IEnumerator" /> grants read-access to the elements of a
<see cref="T:System.Array" />.</para>
          <para>
            <block subset="none" type="note"> This method is
   implemented to support the <see cref="T:System.Collections.IEnumerator" /> interface. For more information regarding the use of an
   enumerator, see <see cref="T:System.Collections.IEnumerator" />.</block>
          </para>
          <block subset="none" type="behaviors">
            <para>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</para>
            <para> Initially, the enumerator is positioned before the
      first element of the current instance. <see cref="M:System.Collections.IEnumerator.Reset" /> returns the enumerator to this
      position. Therefore, after an enumerator is created or after a
   <see cref="M:System.Collections.IEnumerator.Reset" />, <see cref="M:System.Collections.IEnumerator.MoveNext" /> is required to be
      called to advance the enumerator to the first element of the collection before
      reading the value of <see cref="P:System.Collections.IEnumerator.Current" />.</para>
            <para>
              <see cref="P:System.Collections.IEnumerator.Current" /> returns the same object until either
<see cref="M:System.Collections.IEnumerator.MoveNext" /> or
<see cref="M:System.Collections.IEnumerator.Reset" /> is called. <see cref="M:System.Collections.IEnumerator.MoveNext" /> sets <see cref="P:System.Collections.IEnumerator.Current" />  to the next element.</para>
            <para>If <see cref="M:System.Collections.IEnumerator.MoveNext" />  passes the end of the collection, the enumerator is positioned after the last element in the collection and <see cref="M:System.Collections.IEnumerator.MoveNext" /> returns false. When the enumerator is at this position, subsequent calls to<see cref="M:System.Collections.IEnumerator.MoveNext" />  also return <see langword="false" />. If the last call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> returned <see langword="false" />, <see cref="P:System.Collections.IEnumerator.Current" /> is unspecified. To set <see cref="P:System.Collections.IEnumerator.Current" /> to the first element of the collection again, you can call <see cref="M:System.Collections.IEnumerator.Reset" /> followed by <see cref="M:System.Collections.IEnumerator.MoveNext" />.</para>
            <para>An enumerator remains valid as long as the collection remains unchanged. If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</para>
            <para>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.  To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.  To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</para>
          </block>
          <block subset="none" type="default">
            <para>Multidimensional arrays will be processed in Row-major form. </para>
            <para>
              <block subset="none" type="note"> For some
      multidimensional <see cref="T:System.Array" />
      objects, it can be desirable for an enumerator to process them in Column-major form.</block>
            </para>
          </block>
          <para>
            <block subset="none" type="overrides">Override this
   method to provide read-access to the current instance.</block>
          </para>
          <para>
            <block subset="none" type="usage">Use this method
   to iterate over the elements of the current instance.</block>
          </para>
        </remarks>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.GetEnumerator" /> method.</para>
          <code lang="C#">using System;
using System.Collections;
public class ArrayGetEnumerator {
   public static void Main() {
      string[,] strAry = {{"1","one"}, {"2", "two"}, {"3", "three"}};
      Console.Write( "The elements of the array are: " );
      IEnumerator sEnum = strAry.GetEnumerator();
      while ( sEnum.MoveNext() )
         Console.Write( " {0}", sEnum.Current );
   }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The elements of the array are: 1 one 2 two 3 three</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">The zero-based dimension of the array whose length is to be determined.</param>
        <summary>
          <para>Gets the number of elements in the specified dimension of the array.</para>
        </summary>
        <returns>
          <para>The number of elements in the specified dimension of the array.</para>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="dimension" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension)" />
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">A <see cref="T:System.Int32" /> that contains the zero-based dimension of the current instance whose lower bound is to be determined.</param>
        <summary>
          <para>Returns the lower bound of the specified dimension in
      the current instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> that contains the lower bound of the specified dimension in the
   current instance.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">For example,
   <see cref="M:System.Array.GetLowerBound(System.Int32)" /> (0) returns the lower bound of the first
      dimension of the current instance, and <see cref="M:System.Array.GetLowerBound(System.Int32)" />(<see cref="P:System.Array.Rank" /> - 1) returns the lower bound of the last dimension of
      the current instance.</block>
          </para>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="dimension" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="dimension" /> is equal to or greater than the <see cref="P:System.Array.Rank" /> property of the current instance.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension)" />
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">A <see cref="T:System.Int32" /> that contains the zero-based dimension of the current instance whose upper bound is to be determined.</param>
        <summary>
          <para>Returns the upper bound of the specified dimension in
      the current instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> that contains the upper bound of the specified dimension in the
   current instance.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">For example, <see cref="M:System.Array.GetUpperBound(System.Int32)" />
(0) returns the upper bound of the first dimension of the current
instance, and <see cref="M:System.Array.GetUpperBound(System.Int32)" />(<see cref="P:System.Array.Rank" /> - 1) returns the upper bound of the last dimension
of the current instance.</block>
          </para>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="dimension" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="dimension" /> is equal to or greater than the <see cref="P:System.Array.Rank" /> property of the current instance.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object GetValue(int32 index)" />
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A <see cref="T:System.Int32" /> that contains the position of the value to get from the current instance.</param>
        <summary>
          <para> Gets the value at the specified position in the current one-dimensional
      instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" /> that contains the value at the specified position in the current
   instance.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">Use the <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and
<see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods to determine 
   whether <paramref name="index" /> is out of bounds.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentException">The current instance has more than one dimension.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="index" /> is outside the range of valid indices for the current instance.</para>
        </exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.GetValue(System.Int32[])" /> method.</para>
          <code lang="C#">using System;
public class ArrayGetValueExample {
   public static void Main() {
      String[] strAry = { "one", "two", "three", "four", "five" };
      Console.Write( "The elements of the array are: " );
      for( int i = 0; i &lt; strAry.Length; i++ )
         Console.Write( " '{0}' ", strAry.GetValue( i ) );
   }
}
   </code>
          <para>The output is</para>
          <para>
            <c>The elements
      of the array are: 'one' 'two' 'three' 'four' 'five'</c>
          </para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object GetValue(class System.Int32[] indices)" />
      <MemberSignature Language="C#" Value="public object GetValue (int[] indices);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">A one-dimensional array of <see cref="T:System.Int32" /> objects that contains the indices that specify the position of the element in the current instance whose value to get.</param>
        <summary>
          <para>Gets the value at the specified position in the
      current multidimensional instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" /> that contains the value at the specified position in the
   current instance.</para>
        </returns>
        <remarks>
          <para>The number of elements in <paramref name="indices" /> is required to be equal to the number of
   dimensions in the current instance. All elements in <paramref name="indices" /> collectively specify the position of the
   desired element in the current instance.</para>
          <para>
            <block subset="none" type="note">Use the <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and
<see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods to determine whether any of the values in 
<paramref name="indices" /> are out of
bounds.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The number of dimensions in the current instance is not equal to the number of elements in <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>At least one element in <paramref name="indices" /> is outside the range of valid indices for the corresponding dimension of the current instance.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long[] indices);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2)" />
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">A <see cref="T:System.Int32" /> that contains the first-dimension index of the element in the current instance to get.</param>
        <param name="index2">A <see cref="T:System.Int32" /> that contains the second-dimension index of the element in the current instance to get.</param>
        <summary>
          <para>Gets the value at the specified position in the current 
      two-dimensional instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" /> that contains the value at the specified position in the current 
   instance.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">Use the <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and 
<see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods to determine
   whether any of the indices are out of bounds.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentException">The current instance does not have exactly two dimensions.</exception>
        <exception cref="T:System.IndexOutOfRangeException">At least one of <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current instance.</exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">To be added.</param>
        <param name="index2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3)" />
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">A <see cref="T:System.Int32" /> that contains the first-dimension index of the element in the current instance to get. </param>
        <param name="index2">A <see cref="T:System.Int32" /> that contains the second-dimension index of the element in the current instance to get. </param>
        <param name="index3">A <see cref="T:System.Int32" /> that contains the third-dimension index of the element in the current instance to get. </param>
        <summary>
          <para>Gets the value at the specified position in the 
      current three-dimensional instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" /> that contains the value at the specified position in the 
   current instance.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">Use the <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and 
<see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods to determine
   whether any of the indices are out of bounds.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentException">The current instance does not have exactly three dimensions.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>At least one of<paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current instance.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">To be added.</param>
        <param name="index2">To be added.</param>
        <param name="index3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 IndexOf(class System.Array array, object value)" />
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">A one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">A <see cref="T:System.Object" /> to locate in <paramref name="array" />.</param>
        <summary>
          <para>Searches the specified one-dimensional <see cref="T:System.Array" />, returning the
   index of the first occurrence of the specified <see cref="T:System.Object" />.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the index of the first occurrence of <paramref name="value" /> in
<paramref name="array" />, if found; otherwise, <paramref name="array" />.GetLowerBound(0) - 1. <block subset="none" type="note"> For a vector, if <paramref name="value" /> is not 
   found, the return value will be -1. This provides the caller with a standard code for a failed search.</block></para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Array.IndexOf(System.Array,System.Object)" /> is equivalent to <see cref="M:System.Array.IndexOf(System.Array,System.Object)" />(<paramref name="array" />, <paramref name="value" />, <paramref name="array" />.GetLowerBound(0),<paramref name="array" />.Length).</para>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Array.IndexOf(System.Array,System.Object)" /> 
method.</para>
          <code lang="C#">using System;
public class ArrayIndexOfExample {
   public static void Main() {
      int[] intAry = { 0, 1, 2, 0, 1 };
      Console.Write( "The values of the array are: " );
      foreach( int i in intAry )
         Console.Write( "{0,5}", i );
      Console.WriteLine();
      int j = Array.IndexOf( intAry, 1 );
      Console.WriteLine( "The first occurrence of 1 is at index {0}", j );
   }
}
</code>
          <para> The output is</para>
          <c>
            <para>The values of the array are: 0 1 2 0 1</para>
            <para>The first occurrence of 1 is at index 1</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 IndexOf(class System.Array array, object value, int32 startIndex)" />
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">A <see cref="T:System.Object" /> to locate in <paramref name="array" />.</param>
        <param name="startIndex">A <see cref="T:System.Int32" /> that contains the index at which searching starts.</param>
        <summary>
          <para>Searches the specified one-dimensional <see cref="T:System.Array" />, returning the index of the first
   occurrence of the specified <see cref="T:System.Object" /> between the specified index and the last element.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the index of the first occurrence of <paramref name="value" /> in
<paramref name="array" />, within the range <paramref name="startIndex" /> through the last element of 
<paramref name="array" />, if found; otherwise, 
<paramref name="array" />.GetLowerBound(0) - 1. 
<block subset="none" type="note"> For a vector, if <paramref name="value" /> is not 
   found, the return value will be -1. This provides the caller with a standard code for the failed search.</block></para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Array.IndexOf(System.Array,System.Object)" /> is equivalent to <see cref="M:System.Array.IndexOf(System.Array,System.Object)" /> (<paramref name="array" />, <paramref name="value" /> ,
<paramref name="startIndex" />, (<paramref name="array" />.Length - <paramref name="startIndex" />+<paramref name="array" />.GetLowerBound(0))).</para>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than <paramref name="array" /><see langword=".GetLowerBound(0)" /> or greater than <paramref name="array" /><see langword=".GetLowerBound(0)" /> + <paramref name="array" /><see langword=".Length" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">A <see cref="T:System.Object" /> to locate in <paramref name="array" />.</param>
        <param name="startIndex">A <see cref="T:System.Int32" /> that contains the index at which searching starts. </param>
        <param name="count">A <see cref="T:System.Int32" /> that contains the number of elements to search, beginning with <paramref name="startIndex" />.</param>
        <summary>
          <para>Searches the specified one-dimensional <see cref="T:System.Array" />, returning the index of the first
   occurrence of the specified <see cref="T:System.Object" /> in the specified range.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the index of the first occurrence of <paramref name="value" /> in
<paramref name="array" />, within the range <paramref name="startIndex" /> through <paramref name="startIndex" /> 
+ <paramref name="count" />- 1, if found; otherwise,
<paramref name="array" />.GetLowerBound(0) - 1.
<block subset="none" type="note"> For a vector, if <paramref name="value" /> is not 
found, the return value will be -1. This provides the caller with a standard code for the failed search.</block></para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than <paramref name="array" /><see langword=".GetLowerBound(0)" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="startIndex" /> + <paramref name="count" /> is greater than <paramref name="array" /><see langword=".GetLowerBound(0)" /> + <paramref name="array" /><see langword=".Length" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <summary>
          <para>Searches the specified array, returning the index of the first occurrence of the specified value.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of <paramref name="value" /> in 
<paramref name="array" />, if found; otherwise, - 1.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched forward starting at the first element and ending at the last element.  Processing is stopped when the predicate returns <see langword="true" />. </para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <summary>
          <para>Searches the specified array, returning the index of the first occurrence in the specified array starting at the specified index and including the last element.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in 
<paramref name="array" /> that extends from  
<paramref name="startIndex" /> to the last element, if found; otherwise, -1. If <paramref name="startIndex" /> is equal to the length of the array, -1 is returned.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched forward starting at <paramref name="startIndex" /> and ending at the last element. Processing is stopped when the predicate returns <see langword="true" />. </para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than zero or greater than <paramref name="array" /><see langword=".Length" />.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <param name="count">The number of consecutive elements to search.</param>
        <summary>
          <para>Searches for the specified value and returns the index of the first occurrence within the range of elements in the array starting at the specified index and continuing for, at most, the specified number of elements.</para>
        </summary>
        <returns>
          <para>The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in 
<paramref name="array" /> that starts at 
<paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />
, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched forward starting at <paramref name="startIndex" /> and ending at <paramref name="startIndex" /> + <paramref name="count" /> - 1. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="startIndex" /> + <paramref name="count" /> is greater than <see cref="P:System.Array.Length" />.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void Initialize()" />
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Initializes every element of the current instance of
      value-type objects by calling the
      default constructor of that value type.</para>
        </summary>
        <remarks>
          <para> This method cannot be used on reference-type arrays.</para>
          <para>If the current instance is not a value-type <see cref="T:System.Array" /> or if the value type does not have a default
   constructor, the current instance is not modified.</para>
          <para>The current instance can have any lower bound and any number of dimensions.</para>
          <para>
            <block subset="none" type="note">This method can be used only
   on value types that have constructors. </block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="ILASM" Value=".property bool IList.IsFixedSize { public hidebysig virtual abstract specialname bool get_IList.IsFixedSize() }" />
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.IsFixedSize" />.]</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="ILASM" Value=".property bool IList.IsReadOnly { public hidebysig virtual abstract specialname bool get_IList.IsReadOnly() }" />
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.IsReadOnly" />.]</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="ILASM" Value=".property bool ICollection.IsSynchronized { public hidebysig virtual abstract specialname bool get_ICollection.IsSynchronized() }" />
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implemented to support the <see cref="T:System.Collections.ICollection" /> interface. [Note: For more information, see <see cref="M:System.Collections.ICollection.IsSynchronized" />.]</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 LastIndexOf(class System.Array array, object value)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">A one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">A <see cref="T:System.Object" /> to locate in <paramref name="array" />.</param>
        <summary>
          <para> Searches the specified one-dimensional <see cref="T:System.Array" />, returning the index of the last
   occurrence of the specified <see cref="T:System.Object" />.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the index of the last occurrence in <paramref name="array" /> of
<paramref name="value" />, if found; otherwise, 
<paramref name="array" />.GetLowerBound(0) - 1. 
<block subset="none" type="note"> For a vector, if <paramref name="value" /> is not 
   found, the return value will be -1. This provides the caller with a standard code for the failed search.</block></para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Array.LastIndexOf(System.Array,System.Object)" /> is equivalent to <see cref="M:System.Array.LastIndexOf(System.Array,System.Object)" />(<paramref name="array" />, <paramref name="value" />, (<paramref name="array" />.GetLowerBound(0) + <paramref name="array" />.Length - 1), <paramref name="array" />.Length).</para>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" /> . </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Array.LastIndexOf(System.Array,System.Object)" /> method.</para>
          <code lang="C#">using System;

public class ArrayLastIndexOfExample {

   public static void Main() {
      int[] intAry = { 0, 1, 2, 0, 1 };
      Console.Write( "The values of the array are: ");
      foreach( int i in intAry )
         Console.Write( "{0,5}", i );
      Console.WriteLine();
      int j = Array.LastIndexOf( intAry, 1 );
      Console.WriteLine( "The last occurrence of 1 is at index {0}", j );
   }
}
</code>
          <para> The output is</para>
          <c>
            <para>The values of the array are: 0 1 2 0 1</para>
            <para>The last occurrence of 1 is at index 4</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 LastIndexOf(class System.Array array, object value, int32 startIndex)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">A <see cref="T:System.Object" /> to locate in <paramref name="array" />.</param>
        <param name="startIndex">A <see cref="T:System.Int32" /> that contains the index at which searching starts.</param>
        <summary>
          <para> Searches the specified one-dimensional <see cref="T:System.Array" />, returning the index of the last
   occurrence of the specified <see cref="T:System.Object" /> between the specified index and the first element.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the index of the last occurrence of <paramref name="value" /> in the range
<paramref name="startIndex" /> through the lower bound of <paramref name="array" />, if found; otherwise, 
<paramref name="array" />.GetLowerBound(0) - 1. <block subset="none" type="note"> For a vector, if <paramref name="value" /> is not found, the return value will
   be -1. This provides the caller with a standard code for the failed
   search.</block></para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Array.LastIndexOf(System.Array,System.Object)" /> is equivalent to <see cref="M:System.Array.LastIndexOf(System.Array,System.Object)" />( <paramref name="array" />, <paramref name="value" />, <paramref name="startIndex" />,<paramref name="startIndex" />+ 1 -<paramref name="array" />.GetLowerBound(0)).</para>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is outside the range of valid indices for <paramref name="array" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A one-dimensional <see cref="T:System.Array" /> to search.</param>
        <param name="value">A <see cref="T:System.Object" /> to locate in <paramref name="array" />.</param>
        <param name="startIndex">A <see cref="T:System.Int32" /> that contains the index at which searching starts. </param>
        <param name="count">A <see cref="T:System.Int32" /> that contains the number of elements to search, beginning with <paramref name="startIndex" /> . </param>
        <summary>
          <para> Searches the specified one-dimensional <see cref="T:System.Array" />, returning the index of the last
   occurrence of the specified <see cref="T:System.Object" /> in the specified range.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the index of the last occurrence of <paramref name="value" /> in 
<paramref name="array" />, within the range <paramref name="startIndex" /> through 
<paramref name="startIndex" /> - <paramref name="count" /> + 1, if found; otherwise, 
<paramref name="array" />.GetLowerBound(0) - 1. 
<block subset="none" type="note"> For a vector, if <paramref name="value" /> is not 
   found, the return value will be -1. This provides the caller with a standard code for the failed search.</block></para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is outside the range of valid indices for <paramref name="array" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> &lt; 0.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is greater than <paramref name="startIndex" /> + 1.</para>
        </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <summary>
          <para>Searches the specified array, returning the index of the last occurrence of the specified value.</para>
        </summary>
        <returns>
          <para>The zero-based index of the last occurrence of <paramref name="value" /> in 
<paramref name="array" />, if found; otherwise, - 1.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched backward starting at the last element and ending at the first element. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <summary>
          <para>Searches the specified array backwards, returning the index of the last occurrence of the specified array, starting at the specified index.</para>
        </summary>
        <returns>
          <para>The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in 
<paramref name="array" /> that extends from  
<paramref name="startIndex" /> to the first element, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched backward starting at <paramref name="startIndex" /> and ending at the first element. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is outside the range of valid indices for <paramref name="array" />.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to search.</param>
        <param name="value">The value to locate.</param>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <param name="count">The number of consecutive elements to search.</param>
        <summary>
          <para>Searches for the specified value and returns the index of the last occurrence within the range of elements in the array starting at the specified index and continuing backwards for, at most,  the specified number of elements.</para>
        </summary>
        <returns>
          <para>The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in 
<paramref name="array" /> that ends at 
<paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />
, if found; otherwise, -1.</para>
        </returns>
        <remarks>
          <para>The elements are compared using <see cref="M:System.Object.Equals(System.Object)" />. The array is searched backward starting at <paramref name="startIndex" /> and going for count elements. Processing is stopped when the predicate returns <see langword="true" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is outside the range of valid indices for <paramref name="array" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="count" /> is greater than <paramref name="startIndex" /> + 1.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="ILASM" Value=".property int32 Length { public hidebysig specialname instance int32 get_Length() }" />
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the total number of elements in all the dimensions
      of the current instance.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Int32" /> that contains the total number of elements in all the dimensions of
   the current instance.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="ILASM" value=".property int32 Length { public hidebysig specialname instance int32 get_LongLength() }" />
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the total number of elements in all the dimensions of the current instance.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Int64" /> value containing the length of the array.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="ILASM" Value=".property int32 Rank { public hidebysig specialname instance int32 get_Rank() }" />
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the rank (number of dimensions) of the current instance.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Int32" /> that contains the rank (number of dimensions) of the current instance.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="newSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Reverse(class System.Array array)" />
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to reverse.</param>
        <summary>
          <para>Reverses the sequence of the elements in the specified one-dimensional
   <see cref="T:System.Array" />.</para>
        </summary>
        <remarks>
          <para>This version of <see cref="M:System.Array.Reverse(System.Array)" /> is equivalent to <see cref="M:System.Array.Reverse(System.Array)" />(<paramref name="array" />, <paramref name="array" />.GetLowerBound(0),
<paramref name="array" />.Length).</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Reverse(class System.Array array, int32 index, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to reverse.</param>
        <param name="index">A <see cref="T:System.Int32" /> that contains the index at which reversing starts.</param>
        <param name="length">A <see cref="T:System.Int32" /> that contains the number of elements to reverse.</param>
        <summary>
          <para>Reverses the sequence of the elements in the specified 
      range of the specified one-dimensional <see cref="T:System.Array" />.</para>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> is multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="array" />.GetLowerBound(0).</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" /> (i.e. <paramref name="index" /> + <paramref name="length" /> &gt; <paramref name="array" />.GetLowerBound(0) + <paramref name="array" />.Length).</exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Array.Reverse(System.Array)" /> method.</para>
          <code lang="C#">using System;
public class ArrayReverseExample {
   public static void Main() {
      string[] strAry = { "one", "two", "three" };
      Console.Write( "The elements of the array are:");
      foreach( string str in strAry )
         Console.Write( " {0}", str );
      Array.Reverse( strAry );
      Console.WriteLine();
      Console.WriteLine( "After reversing the array," );
      Console.Write( "the elements of the array are:");
      foreach( string str in strAry )
         Console.Write( " {0}", str );
   }
}
</code>
          <para>The output is</para>
          <c>
            <para>The elements of the array are: one two three</para>
            <para>After reversing the array,</para>
            <para>the elements of the array are: three two one</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetValue(object value, int32 index)" />
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Object" /> that contains the new value for the specified element.</param>
        <param name="index">A <see cref="T:System.Int32" /> that contains the index of the element whose value is to be set.</param>
        <summary>
          <para> Sets the value of the element at the specified position
      in the current one-dimensional instance.</para>
        </summary>
        <remarks>
          <block subset="none" type="note">
            <para>Use the <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods to determine whether
   <paramref name="index" /> is out of bounds.</para>
            <para> For more
      information regarding valid conversions that will be performed by this method,
      see <see cref="T:System.Convert" />.</para>
          </block>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <para>The current instance has more than one dimension.</para>
        </exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="index" /> is outside the range of valid indices for the current instance.</para>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <para>
            <paramref name="value" /> is not assignment-compatible with the element type of the current instance.</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetValue(object value, class System.Int32[] indices)" />
      <MemberSignature Language="C#" Value="public void SetValue (object value, int[] indices);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Object" /> that contains the new value for the specified element. </param>
        <param name="indices">A one-dimensional array of <see cref="T:System.Int32" /> objects that contains the indices that specify the position of the element in the current instance to set. </param>
        <summary>
          <para>Sets the value of the element at the specified position in
      the current multidimensional instance.</para>
        </summary>
        <remarks>
          <para>The number of elements in <paramref name="indices" /> is required to be equal to the number of
   dimensions in the current instance. All elements in <paramref name="indices" /> collectively specify the position of the
   desired element in the current instance.</para>
          <block subset="none" type="note">
            <para>For more information regarding valid conversions that will be performed by
      this method, see <see cref="T:System.Convert" />.</para>
            <para>Use the <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods to determine whether any
   of the values in <paramref name="indices" /> is out of bounds.</para>
          </block>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <para>The number of dimensions in the current instance is not equal to the number of elements in <paramref name="indices" />. </para>
        </exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <para>At least one element in <paramref name="indices" /> is outside the range of valid indices for the corresponding dimension of the current instance.</para>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <para>
            <paramref name="value" /> is not assignment-compatible with the element type of the current instance.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long[] indices);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="indices">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2)" />
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Object" /> that contains the new value for the specified element.</param>
        <param name="index1">A <see cref="T:System.Int32" /> that contains the first-dimension index of the element in the current instance to set. </param>
        <param name="index2">A <see cref="T:System.Int32" /> that contains the second-dimension index of the element in the current instance to set. </param>
        <summary>
          <para> Sets the value of the element at the specified position
      in the current two-dimensional instance.</para>
        </summary>
        <remarks>
          <block subset="none" type="note">
            <para>For more information regarding valid conversions that will be performed by
         this method, see <see cref="T:System.Convert" />.</para>
            <para>Use the <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods to determine whether any of the indices
      are out of bounds.</para>
          </block>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <para>The current instance does not have exactly two dimensions.</para>
        </exception>
        <exception cref="T:System.IndexOutOfRangeException">At least one of <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indices for the corresponding dimension of the current instance.</exception>
        <exception cref="T:System.InvalidCastException">
          <para>
            <paramref name="value" /> is not assignment-compatible with the element type of the current instance.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="index1">To be added.</param>
        <param name="index2">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3)" />
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Object" /> that contains the new value for the specified element. </param>
        <param name="index1">A <see cref="T:System.Int32" /> that contains the first-dimension index of the element in the current instance to set. </param>
        <param name="index2">A <see cref="T:System.Int32" /> that contains the second-dimension index of the element in the current instance to set. </param>
        <param name="index3">A <see cref="T:System.Int32" /> that contains the third-dimension index of the element in the current instance to set. </param>
        <summary>
          <para> Sets the value of the element at the
      specified position in the current three-dimensional instance.</para>
        </summary>
        <remarks>
          <block subset="none" type="note">
            <para>For more information regarding valid conversions that will be performed by
         this method, see <see cref="T:System.Convert" />.</para>
            <para>Use the <see cref="M:System.Array.GetLowerBound(System.Int32)" /> and
   <see cref="M:System.Array.GetUpperBound(System.Int32)" /> methods to determine whether any of the indices
      are out of bounds.</para>
          </block>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <para>The current instance does not have exactly three dimensions.</para>
        </exception>
        <exception cref="T:System.IndexOutOfRangeException">At least one of <paramref name="index1" />, <paramref name="index2" />, or <paramref name="index3" /> is outside the range of valid indices for the corresponding dimension of the current instance.</exception>
        <exception cref="T:System.InvalidCastException">
          <para>
            <paramref name="value" /> is not assignment-compatible with the element type of the current instance.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>ExtendedArray</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="index1">To be added.</param>
        <param name="index2">To be added.</param>
        <param name="index3">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array array)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">A one-dimensional <see cref="T:System.Array" /> to sort.</param>
        <summary>
          <para>Sorts the elements of the specified one-dimensional <see cref="T:System.Array" />.</para>
        </summary>
        <remarks>
          <para>This version of <see cref="M:System.Array.Sort(System.Array)" /> is equivalent to <see cref="M:System.Array.Sort(System.Array)" />(<paramref name="array" />, <see langword="null" />, <paramref name="array" />.GetLowerBound(0),
<paramref name="array" />.Length, <see langword="null" />).</para>
          <para>Each element of <paramref name="array" /> is
required to implement
the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other
element in array.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension.</exception>
        <exception cref="T:System.ArgumentException">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.Sort(System.Array)" /> method.</para>
          <code lang="C#">using System;
public class ArraySortExample {
   public static void Main() {
      string[] strAry = { "All's", "well", "that", "ends", "well" };
      Console.Write( "The original string array is: " );
      foreach ( String str in strAry )
         Console.Write( str + " " );
      Console.WriteLine();
      Array.Sort( strAry );
      Console.Write( "The sorted string array is: " );
      foreach ( string str in strAry )
         Console.Write( str + " " );
   }
}
</code>
          <para>The output is</para>
          <c>
            <para>The original string array is: All's well that ends well</para>
            <para>The sorted string array is: All's ends that well well</para>
          </c>
        </example>
        <exception cref="T:System.InvalidOperationException">One or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array keys, class System.Array items)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">A one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">
          <para>A one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of element of <paramref name="keys" />. Specify a null reference to sort only <paramref name="keys" />.</para>
        </param>
        <summary>
          <para>Sorts the specified pair of one-dimensional <see cref="T:System.Array" /> objects (one
   containing a set of keys and the other containing corresponding items) based on
   the keys in the first specified <see cref="T:System.Array" />.</para>
        </summary>
        <remarks>
          <para> This version of <see cref="M:System.Array.Sort(System.Array)" /> is equivalent to <see cref="M:System.Array.Sort(System.Array)" />(<paramref name="keys" />, <paramref name="items" />, <paramref name="keys" />.GetLowerBound(0), <paramref name="keys" />.Length, <see langword="null" />).</para>
          <para> Each key in <paramref name="keys" /> is required to have
a corresponding item in <paramref name="items" />. The sort is performed according to the
order of <paramref name="keys" /> . After a key is repositioned during the sort,
the corresponding item in <paramref name="items" /> is similarly repositioned. Only
<paramref name="keys" />.Length elements of 
<paramref name="items" /> are sorted. Therefore, 
<paramref name="items" />
is sorted according to the arrangement of the corresponding keys in
<paramref name="keys" />. If
the sort is not successfully completed, the results are unspecified.</para>
          <para>Each element of <paramref name="keys" /> is
required to implement
the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other
element in <paramref name="keys" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="keys" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="items" /> is not a null reference and has more than one dimension.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.GetLowerBound(0) does not equal <paramref name="items" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.Length &gt; <paramref name="items" />.Length.</para>
        </exception>
        <example>
          <para>This example demonstrates the <see cref="M:System.Array.Sort(System.Array)" /> method.</para>
          <code lang="C#">using System;
public class ArraySortExample {
   public static void Main() {
      string[] strAry = { "All's", "well", "that", "ends", "well" };
      int[] intAry = { 3, 4, 0, 1, 2 };
      Console.Write( "The original string array is: " );
      foreach ( string str in strAry )
         Console.Write( str + " " );
      Console.WriteLine();
      Console.Write( "The key array is: " );
      foreach ( int i in intAry )
         Console.Write( i + " " );
      Console.WriteLine();
      Array.Sort( intAry, strAry );
      Console.Write( "The sorted string array is: " );
      foreach ( string str in strAry )
         Console.Write( str + " " );
   }
}
</code>
          <para>The output is</para>
          <c>
            <para>The original string array is: All's well that ends well</para>
            <para>The key array is: 3 4 0 1 2</para>
            <para>The sorted string array is: that ends well All's well</para>
          </c>
        </example>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="keys" /> that are used in a comparison  do not implement the <see cref="T:System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array array, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> to sort.</param>
        <param name="comparer">
          <para>The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements. Specify a null reference to use the <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Sorts the elements in the specified one-dimensional <see cref="T:System.Array" /> using the
   specified <see cref="T:System.Collections.IComparer" /> implementation.</para>
        </summary>
        <remarks>
          <para>This version of <see cref="M:System.Array.Sort(System.Array)" /> is equivalent to <see cref="M:System.Array.Sort(System.Array)" />(<paramref name="array" />, <see langword="null" />, <paramref name="array" />.GetLowerBound(0), <paramref name="array" />.Length,
<paramref name="comparer" />).</para>
          <para>If <paramref name="comparer" /> is a null reference, each element
of <paramref name="array" /> is required to implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons
with every other element in <paramref name="array" />. If the sort is not successfully
completed, the results are unspecified.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />. </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension. </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> is a null reference, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is a null reference, and one or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">A one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">
          <para>A one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each element in <paramref name="keys" />. Specify a null reference to sort only <paramref name="keys" />.</para>
        </param>
        <param name="comparer">
          <para>The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements. Specify a null reference to use the <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Sorts the specified pair of one-dimensional
   <see cref="T:System.Array" /> objects (one
      containing a set of keys and the other containing corresponding items) based on
      the keys in the first specified <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" /> implementation.</para>
        </summary>
        <remarks>
          <para>This version of <see cref="M:System.Array.Sort(System.Array)" /> is equivalent to <see cref="M:System.Array.Sort(System.Array)" />(<paramref name="keys" />, <paramref name="items" />, <paramref name="keys" />.GetLowerBound(0), <paramref name="keys" />.Length, <paramref name="comparer" />).</para>
          <para> Each key in <paramref name="keys" /> is required to have
a corresponding item in <paramref name="items" />. The sort is performed according to the order of
<paramref name="keys" /> . After a key is repositioned during the sort, the 
corresponding item in <paramref name="items" /> is similarly repositioned. Only
<paramref name="keys" />.Length elements of <paramref name="items" /> are sorted. Therefore, 
<paramref name="items" />
is sorted according to the arrangement of the corresponding keys in
<paramref name="keys" />. If
the sort is not successfully completed, the results are unspecified.</para>
          <para>If <paramref name="comparer" /> is a null reference, each element
of <paramref name="keys" /> is required to implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons
with every other element in <paramref name="keys" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="keys" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="items" /> is not a null reference and has more than one dimension.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.GetLowerBound(0) does not equal <paramref name="items" />.GetLowerBound(0). </para>
          <para>-or-</para>
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.Length &gt; <paramref name="items" />.Length.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is a <see langword="null" />, and one or more elements in <paramref name="keys" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface. </para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array array, int32 index, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A one-dimensional <see cref="T:System.Array" /> to sort.</param>
        <param name="index">A <see cref="T:System.Int32" /> that contains the index at which sorting starts.</param>
        <param name="length">A <see cref="T:System.Int32" /> that contains the number of elements to sort.</param>
        <summary>
          <para>Sorts the elements in the specified range of the
      specified one-dimensional <see cref="T:System.Array" />.</para>
        </summary>
        <remarks>
          <para>This version of <see cref="M:System.Array.Sort(System.Array)" /> is equivalent to <see cref="M:System.Array.Sort(System.Array)" />(<paramref name="array" />,
<see langword="null" /> , <paramref name="index" />, <paramref name="length" />, 
<see langword="null" />).</para>
          <para>Each element of <paramref name="array" /> is
required to implement
the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other
element in <paramref name="array" />. If the sort is not successfully completed, the
results are unspecified.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />. </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="array" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array keys, class System.Array items, int32 index, int32 length)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">A one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">A one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each element in <paramref name="keys" />. Specify a null reference to sort only <paramref name="keys" />.</param>
        <param name="index">A <see cref="T:System.Int32" /> that contains the index at which sort begins.</param>
        <param name="length">A <see cref="T:System.Int32" /> that contains the number of elements to sort.</param>
        <summary>
          <para>Sorts the specified ranges of the specified pair of
      one-dimensional <see cref="T:System.Array" />
      objects (one containing a set of keys and the other containing corresponding
      items) based on the keys in the first specified <see cref="T:System.Array" />.</para>
        </summary>
        <remarks>
          <para>This version of <see cref="M:System.Array.Sort(System.Array)" /> is equivalent to <see cref="M:System.Array.Sort(System.Array)" />(<paramref name="keys" />, <paramref name="items" />, <paramref name="index" />, <paramref name="length" />, <see langword="null" />).</para>
          <para> Each key in <paramref name="keys" /> is
required to have
a corresponding item in <paramref name="items" />. The sort is performed according to the
order of <paramref name="keys" /> . After a key is repositioned during the sort,
the corresponding item in <paramref name="items" /> is similarly
repositioned. Therefore, <paramref name="items" /> is sorted according to the arrangement of
the corresponding keys in <paramref name="keys" />. If the sort is not successfully
completed, the results are undefined.</para>
          <para>Each element of <paramref name="keys" /> is
required to implement the <see cref="T:System.IComparable" /> interface to
be capable of comparisons with every other element in <paramref name="keys" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="keys" /> has more than one dimension.</para>
          <para> -or-</para>
          <para>
            <paramref name="items" /> is not a null reference and has more than one dimension.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="keys" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.GetLowerBound(0) does not equal <paramref name="items" />.GetLowerBound(0). </para>
          <para>-or- </para>
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="keys" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="items" />. </para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="keys" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">A one-dimensional <see cref="T:System.Array" /> to sort.</param>
        <param name="index">A <see cref="T:System.Int32" /> that contains the index at which sorting starts.</param>
        <param name="length">A <see cref="T:System.Int32" /> that contains the number of elements to sort.</param>
        <param name="comparer">
          <para>The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements. Specify a null reference to use the <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Sorts the elements in the specified section of the
      specified one-dimensional <see cref="T:System.Array" />
      using the specified <see cref="T:System.Collections.IComparer" />
      implementation.</para>
        </summary>
        <remarks>
          <para>This version of <see cref="M:System.Array.Sort(System.Array)" /> is equivalent to <see cref="M:System.Array.Sort(System.Array)" />(<paramref name="array" />, <see langword="null" />, <paramref name="index" />, <paramref name="length" />, <paramref name="comparer" />).</para>
          <para>If <paramref name="comparer" /> is a null reference, each element
of <paramref name="array" /> is required to implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons
with every other element in <paramref name="array" />. If the sort is not successfully
completed, the results are unspecified.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />. </exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> has more than one dimension. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="array" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface. </para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">A one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</param>
        <param name="items">
          <para>A one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each element of <paramref name="keys" />. Specify a null reference to sort only <paramref name="keys" />.</para>
        </param>
        <param name="index">A <see cref="T:System.Int32" /> that contains the index at which sorting starts.</param>
        <param name="length">A <see cref="T:System.Int32" /> that contains the number of elements to sort.</param>
        <param name="comparer">
          <para>The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements. Specify a null reference to use the <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Sorts the specified range of the specified pair of one-dimensional <see cref="T:System.Array" /> objects (one
   containing a set of keys and the other containing corresponding items) based on
   the keys in the first specified <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />
   implementation.</para>
        </summary>
        <remarks>
          <para> Each key in <paramref name="keys" /> is required to have
   a corresponding item in <paramref name="items" />. The sort is performed according to the
   order of <paramref name="keys" />. After a key is repositioned during the sort,
   the corresponding item in <paramref name="items" /> is similarly repositioned. Only
<paramref name="keys" />.Length elements of <paramref name="items" /> will be sorted. Therefore, 
<paramref name="items" /> is sorted according to the arrangement of
   the corresponding keys in <paramref name="keys" />. If the sort is not successfully
   completed, the results are undefined.</para>
          <para>If <paramref name="comparer" /> is a null reference, each element
of <paramref name="keys" /> is required to implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons
with every other element in <paramref name="keys" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.RankException">
          <para>
            <paramref name="keys" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="items" /> is not a null reference and has more than one dimension.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> &lt; <paramref name="keys" />.GetLowerBound(0).</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> &lt; 0.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="keys" />.GetLowerBound(0) does not equal <paramref name="items" />.GetLowerBound(0). </para>
          <para>-or- </para>
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="key" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="items" /> is not a null reference, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="items" />. </para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="keys" /> that are used in a comparison do not implement the <see cref="T:System.IComparable" /> interface. </para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">
          <para>The array to sort.</para>
        </param>
        <summary>
          <para>Sorts the elements in an entire array using the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation of each element of that array.</para>
        </summary>
        <remarks>
          <para>Each element of <paramref name="array" /> is required to implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="array" /> that are used in a comparison are the null reference or do not implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">
          <para>The array to sort.</para>
        </param>
        <param name="comparer">
          <para>The <see cref="T:System.Collections.Generic.IComparer&lt;T&gt;" /> implementation to use when comparing elements.</para>
          <para>-or-</para>
          <para>
            <see langword="null" />  to use the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Sorts the elements in an array using the specified comparer.</para>
        </summary>
        <remarks>
          <para>If <paramref name="comparer" /> is null, each element of <paramref name="array" /> must implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">
          <para>The array to sort.</para>
        </param>
        <param name="comparison">
          <para>The <see cref="T:System.Comparison&lt;T&gt;" /> to use when comparing elements.</para>
        </param>
        <summary>
          <para>Sorts the elements in an array using the specified comparison.</para>
        </summary>
        <remarks>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="comparison" /> is <see langword="null" />.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">
          <para>The array to sort.</para>
        </param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <summary>
          <para>Sorts an array using the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> implementation of each element of that array.</para>
        </summary>
        <remarks>
          <para>Each element within the specified range of elements in <paramref name="array" /> must implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />. </para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable&lt;T&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">
          <para>The array to sort.</para>
        </param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <param name="comparer">
          <para>The <see cref="T:System.Collections.Generic.IComparer&lt;K&gt;" /> implementation to use when comparing elements.</para>
          <para>-or-</para>
          <para>
            <see langword="null" />  to use the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Sorts the elements in a range of elements in an array using the specified comparer.</para>
        </summary>
        <remarks>
          <para>If <paramref name="comparer" /> is null, each element within the specified range of elements in <paramref name="array" /> must implement the <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other element in <paramref name="array" />.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="array" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />. </para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> that are used in a comparison do not implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <param name="keys">
          <para>The array that contains the keys to sort.</para>
        </param>
        <param name="items">
          <para>The array that contains the items that correspond to each of the keys in <paramref name="keys" />.</para>
          <para>-or-</para>
          <para>
            <see langword="null" /> to sort only the <paramref name="keys" /> array.</para>
        </param>
        <summary>
          <para>Sorts a pair of arrays based on the keys in the first array using the <see cref="T:System.IComparable" />  implementation of each key.</para>
        </summary>
        <remarks>
          <para>If <paramref name="items" /> is non-null, each key in <paramref name="keys" /> is required to have
   a corresponding item in <paramref name="items" />. When a key is repositioned during the sorting,
   the corresponding item in <paramref name="items" /> is similarly repositioned. Therefore, <paramref name="items" /> is sorted according to the arrangement of
   the corresponding keys in <paramref name="keys" />. </para>
          <para>Each key in <paramref name="keys" /> must implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other key.</para>
          <para>If the sort is not successfully completed, the results are undefined.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not <see langword="null" />, and  the length of <paramref name="keys" /> does not equal the length of <paramref name="items" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="keys" /> that are used in a comparison  are the null reference or do not implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <param name="keys">
          <para>The array that contains the keys to sort.</para>
        </param>
        <param name="items">
          <para>The array that contains the items that correspond to each of the keys in <paramref name="keys" />.</para>
          <para>-or-</para>
          <para>
            <see langword="null" /> to sort only the <paramref name="keys" /> array.</para>
        </param>
        <param name="comparer">
          <para>The <see cref="T:System.Collections.Generic.IComparer&lt;K&gt;" /> implementation to use when comparing elements.</para>
          <para>-or-</para>
          <para>
            <see langword="null" />  to use the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Sorts a pair of arrays based on the keys in the first array, using the specified <see cref="T:System.Collections.Generic.IComparer" />.</para>
        </summary>
        <remarks>
          <para>This version of <see cref="M:System.Array.Sort" />  is equivalent to <see cref="M:System.Array.Sort&lt;K,V&gt;" /><see langword="(" /><paramref name="keys" /><see langword=", " /><paramref name="items" /><see langword=", " /><see langword="0, " /><paramref name="keys" /><see langword=".Length" /><see langword=", " /><paramref name="comparer" /><see langword=")" />.</para>
          <para>If <paramref name="items" /> is non-null, each key in <paramref name="keys" /> is required to have
   a corresponding item in <paramref name="items" />. The sort is performed according to the
   order of <paramref name="keys" />. After a key is repositioned during the sort,
   the corresponding item in <paramref name="items" /> is similarly repositioned. Only
<paramref name="keys" />.Length elements of <paramref name="items" /> will be sorted. Therefore, 
<paramref name="items" /> is sorted according to the arrangement of
   the corresponding keys in <paramref name="keys" />. If the sort is not successfully
   completed, the results are unspecified.</para>
          <para>If <paramref name="comparer" /> is a null reference, each element of <paramref name="keys" /> is required to implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons
with every other element in <paramref name="keys" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="items" /> is not <see langword="null" />, and  the length of <paramref name="keys" /> does not match the length of <paramref name="items" />.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="keys" /> that are used in a comparison  do not implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <param name="keys">
          <para>The array that contains the keys to sort.</para>
        </param>
        <param name="items">
          <para>The array that contains the items that correspond to each of the keys in <paramref name="keys" />.</para>
          <para>-or-</para>
          <para>
            <see langword="null" /> to sort only the <paramref name="keys" /> array.</para>
        </param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <summary>
          <para>Sorts a range of elements in a pair of arrays based on the keys in the first array, using the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" />  implementation of each key.</para>
        </summary>
        <remarks>
          <para>If <paramref name="items" /> is non-null, each key in <paramref name="keys" /> is required to have
   a corresponding item in <paramref name="items" />. When a key is repositioned during the sorting,
   the corresponding item in <paramref name="items" /> is similarly repositioned. Therefore, <paramref name="items" /> is sorted according to the arrangement of
   the corresponding keys in <paramref name="keys" />. </para>
          <para>If the sort is not successfully completed, the results are unspecified.</para>
          <para>Each key within the specified range of elements in <paramref name="keys" /> must implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons with every other key.</para>
          <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="keys" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="items" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>One or more elements in <paramref name="keys" /> that are used in a comparison are the null reference or do not implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <param name="keys">
          <para>The array that contains the keys to sort.</para>
        </param>
        <param name="items">
          <para>The array that contains the items that correspond to each of the keys in <paramref name="keys" />.</para>
          <para>-or-</para>
          <para>
            <see langword="null" /> to sort only the <paramref name="keys" /> array.</para>
        </param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <param name="comparer">
          <para>The <see cref="T:System.Collections.Generic.IComparer&lt;K&gt;" /> implementation to use when comparing elements.</para>
          <para>-or-</para>
          <para>
            <see langword="null" />  to use the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" /> implementation of each element.</para>
        </param>
        <summary>
          <para>Sorts a range of elements in a pair of arrays based on the keys in the first array using the specified <see cref="T:System.Collections.Generic.IComparer&lt;K&gt;" />.</para>
        </summary>
        <remarks>
          <para>If <paramref name="items" /> is non-null, each key in <paramref name="keys" /> is required to have
   a corresponding item in <paramref name="items" />. The sort is performed according to the
   order of <paramref name="keys" />. After a key is repositioned during the sort,
   the corresponding item in <paramref name="items" /> is similarly repositioned. Only
<paramref name="keys" />.Length elements of <paramref name="items" /> will be sorted. Therefore, 
<paramref name="items" /> is sorted according to the arrangement of
   the corresponding keys in <paramref name="keys" />. If the sort is not successfully
   completed, the results are undefined.</para>
          <para>If <paramref name="comparer" /> is a null reference, each element of <paramref name="keys" /> is required to implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T:System.IComparable" /> interface to be capable of comparisons
with every other element in <paramref name="keys" />.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="keys" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="items" />.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="keys" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="index" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="length" /> is less than zero.</para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>
            <paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="keys" /> that are used in a comparison do not implement the <see cref="T:System.IComparable&lt;K&gt;" /> or <see cref="T: System.IComparable" /> interface.</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="ILASM" Value=".property object ICollection.SyncRoot { public hidebysig virtual abstract specialname object get_ICollection.SyncRoot() }" />
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implemented to support the <see cref="T:System.Collections.ICollection" /> interface. [Note: For more information, see <see cref="M:System.Collections.ICollection.SyncRoot" />.]</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implemented to support the <see cref="T:System.Collections.ICollection" /> interface. [Note: For more information, see <see cref="M:System.Collections.ICollection.Count" />.]</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.Add" />.]</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.Clear" />.]</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.Contains" />.]</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.IndexOf" />.]</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.Insert" />.]</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.Item" />.]</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.Remove" />.]</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>Implemented to support the <see cref="T:System.Collections.IList" /> interface. [Note: For more information, see <see cref="M:System.Collections.IList.RemoveAt" />.]</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The array to check against the conditions.</param>
        <param name="match">
          <para>The predicate against which the elements are checked..</para>
        </param>
        <summary>
          <para>Determines whether every element in the array matches the predicate.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" />, if every element in <paramref name="array" /> matches the specified predicate; otherwise, <see langword="false" />.</para>
        </returns>
        <remarks>
          <para>The predicate returns <see langword="true" /> if the object passed to it matches the delegate.  The elements of <paramref name="array" /> are individually passed to the predicate, and processing is stopped when the delegate returns <see langword="false" /> for any element.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" />  or <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
</Type>
