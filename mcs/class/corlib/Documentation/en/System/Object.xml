<Type Name="Object" FullName="System.Object" FullNameSP="System_Object" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public serializable Object" />
  <TypeSignature Language="C#" Value="public class Object" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <para> Provides support for classes. This class is the root of the object hierarchy.</para>
    </summary>
    <remarks>
      <block subset="none" type="note">
        <para>Classes derived from <see cref="T:System.Object" /> can override the following methods of
 the <see cref="T:System.Object" /> class:</para>
        <list type="bullet">
          <item>
            <term>
              <see cref="M:System.Object.Equals(System.Object)" /> - Enables 
 comparisons between objects.</term>
          </item>
          <item>
            <term>
              <see cref="M:System.Object.Finalize" /> - 
 Performs clean up operations before an object is automatically reclaimed.</term>
          </item>
          <item>
            <term>
              <see cref="M:System.Object.GetHashCode" /> - Generates a number corresponding to the value 
 of the object (to support the use of a hashtable).</term>
          </item>
          <item>
            <term>
              <see cref="M:System.Object.ToString" /> - Manufactures a human-readable text string that
 describes an instance of the class.</term>
          </item>
        </list>
      </block>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor()" />
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>
          <para>Constructs a new instance of the <see cref="T:System.Object" /> class.</para>
        </summary>
        <remarks>
          <para>
            <block subset="none" type="usage">This constructor is 
      called by constructors in derived classes, but it can also be used to directly
      create an instance of the <see langword=" Object" />
      class. This might be useful, for example, if you need to obtain a reference to
      an object so that you can synchronize on it, as might be the case when using the
      C# <see langword="lock" /> statement.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool Equals(object obj)" />
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Object" /> to compare with the current instance.</param>
        <summary>
          <para>Determines whether the specified <see cref="T:System.Object" /> is equal to the
   current instance.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if <paramref name="obj" /> is equal to the
   current instance; otherwise, <see langword="false" />.</para>
        </returns>
        <remarks>
          <block subset="none" type="behaviors">
            <para>The statements listed below are required to be true for all
         implementations of the <see cref="M:System.Object.Equals(System.Object)" />
         method. In the list, x, y, and z represent non-null object references. </para>
            <list type="bullet">
              <item>
                <term>x.Equals(x) returns <see langword="true" />.</term>
              </item>
              <item>
                <term>x.Equals(y) returns the same value as y.Equals(x).</term>
              </item>
              <item>
                <term>If (x.Equals(y) &amp;&amp; y.Equals(z)) returns <see langword="true" />, then x.Equals(z) returns <see langword="true" />.</term>
              </item>
              <item>
                <term>Successive invocations of x.Equals(y) return the same 
value as long as the objects referenced by x and y are not modified.</term>
              </item>
              <item>
                <term>x.Equals(<see langword="null" />) returns <see langword="false" /> for non-null x.</term>
              </item>
            </list>
            <para>See <see cref="M:System.Object.GetHashCode" /> for additional required behaviors pertaining to the
<see cref="M:System.Object.Equals(System.Object)" /> 
method.</para>
            <para>
              <block subset="none" type="note">Implementations of <see cref="M:System.Object.Equals(System.Object)" /> should
not
throw exceptions.</block>
            </para>
          </block>
          <block subset="none" type="default">
            <para>The <see cref="M:System.Object.Equals(System.Object)" /> method
   tests for <paramref name="referential equality" /> , which means that
<see cref="M:System.Object.Equals(System.Object)" /> returns 
<see langword="true" /> if the specified instance of <see langword="Object" /> and 
   the current instance are the same instance; otherwise, it returns
<see langword="false" /> 
. </para>
            <block subset="none" type="note">
              <para>An implementation of the <see cref="M:System.Object.Equals(System.Object)" /> method is shown in the following C#
   code:</para>
              <c>
                <para>public virtual bool Equals(Object obj) {</para>
              </c>
              <c>
                <para>return this == obj;</para>
              </c>
              <c>
                <para>} </para>
              </c>
            </block>
          </block>
          <block subset="none" type="overrides">
            <para>For some kinds of objects, it is desirable to have <see cref="M:System.Object.Equals(System.Object)" /> test for <paramref name="value    equality" /> instead of
   referential equality. Such implementations of <see langword="Equals" /> return true if the two objects have the
   same "value", even if they are not the same instance. The definition of what
   constitutes an object's "value" is up to the implementer of the type, but it is
   typically some or all of the data stored in the instance variables of the
   object. For example, the value of a <see cref="T:System.String" /> is based on the characters of the
   string; the <see langword="Equals" />
   method of the <see cref="T:System.String" /> class returns
<see langword="true" /> for any two string instances that
   contain exactly the same characters in the same order. </para>
            <para>When the <see langword="Equals" />
method of a base class provides value equality, an override of
<see langword="Equals" /> in a class 
derived from that base class should invoke the inherited implementation of
<see langword="Equals" /> . </para>
            <para>All implementations of <see cref="M:System.Object.GetHashCode" /> are required to ensure that for any two object references <paramref name="x" /> and <paramref name="y" />, if <paramref name="x" /><see langword=".Equals(" /><paramref name="y" /><see langword=") == true" />, then <paramref name="x" /><see langword=".GetHashCode() == " /><paramref name="y" /><see langword=".GetHashCode()" />.</para>
            <para>If your programming language supports operator
   overloading, and if you choose to overload the equality operator for a given
   type, that type should override the <see langword="Equals" /> method. Such
   implementations of the <see langword="Equals" /> method should return the same
   results as the equality operator. Following this guideline will help ensure that
   class library code using <see langword="Equals" /> (such as <see cref="T:System.Collections.ArrayList" /> and <see cref="T:System.Collections.Hashtable" />
   
   ) behaves
   in a manner that is consistent with the way the equality operator is used by
   application code.</para>
            <para>If you are implementing a value type, you should follow these guidelines:</para>
            <list type="bullet">
              <item>
                <term>
      Consider overriding <see langword="Equals" /> to gain
      increased performance over that provided by the default implementation of
      <see langword="Equals" /> on <see cref="T:System.ValueType" />.</term>
              </item>
              <item>
                <term>
      If you override <see langword="Equals" />
      
      and the language supports operator overloading, you
      should overload the equality operator for your value type.</term>
              </item>
            </list>
            <para>For reference types, the guidelines are as follows:</para>
            <list type="bullet">
              <item>
                <term>
      Consider overriding <see langword="Equals" /> on a
      reference type if the semantics of the type are based on the fact that the
      type represents some value(s). For example, reference types such as Point and
      BigNumber should override <see langword="Equals" />.</term>
              </item>
              <item>
                <term>
      Most reference types should not overload the equality
      operator, even if they override <see langword="Equals" />
      
      . However, if you are implementing a reference type that
      is intended to have value semantics, such as a complex number type, you should
      override the equality operator.</term>
              </item>
            </list>
            <para>If you implement <see cref="T:System.IComparable" /> on a given type, you should override
<see langword="Equals" /> on that
type.</para>
          </block>
          <para>
            <block subset="none" type="usage">The <see cref="M:System.Object.Equals(System.Object)" /> method is called by methods in collections
classes that perform search operations, including the <see cref="M:System.Array.IndexOf(System.Array,System.Object)" /> method and
the <see cref="M:System.Collections.ArrayList.Contains(System.Object)" />
method.</block>
          </para>
        </remarks>
        <example>
          <para>
            <see langword="Example 1:" />
          </para>
          <para> The following example contains two calls to the default
   implementation of <see cref="M:System.Object.Equals(System.Object)" /> .</para>
          <code lang="C#">using System;
class MyClass {
   static void Main() {
      Object obj1 = new Object();
      Object obj2 = new Object();
      Console.WriteLine(obj1.Equals(obj2));
      obj1 = obj2; 
      Console.WriteLine(obj1.Equals(obj2)); 
   }
}
</code>
          <para>The output is</para>
          <c>
            <para>False</para>
            <para>True</para>
          </c>
          <para>
            <see langword="Example 2:" />
          </para>
          <para> The following example shows a <see langword="Point" /> class that overrides
the <see cref="M:System.Object.Equals(System.Object)" /> method to
provide value equality and a class <see langword="Point3D" />, which is derived
from <see langword="Point" />
. Because Point's override of
<see cref="M:System.Object.Equals(System.Object)" /> is the first 
in the inheritance chain to introduce value equality, the
<see langword="Equals" /> method of 
the base class (which is inherited from <see cref="T:System.Object" /> and checks for referential
equality) is not invoked. However, <see langword="Point3D.Equals" /> invokes
<see langword="Point.Equals" /> because <see langword="Point" /> implements
<see langword="Equals" /> 
in a manner that provides value equality.</para>
          <code lang="C#">using System;
public class Point: object {
 int x, y;
 public override bool Equals(Object obj) {
 //Check for null and compare run-time types.
 if (obj == null || GetType() != obj.GetType()) return false;
 Point p = (Point)obj;
 return (x == p.x) &amp;&amp; (y == p.y);
 }
 public override int GetHashCode() {
 return x ^ y;
 }
}

class Point3D: Point {
 int z;
 public override bool Equals(Object obj) {
 return base.Equals(obj) &amp;&amp; z == ((Point3D)obj).z;
 }
 public override int GetHashCode() {
 return base.GetHashCode() ^ z;
 }
}
</code>
          <para> The <see langword="Point.Equals" /> method checks that the <paramref name="obj" />
argument is non-null and that it references an instance of the same type as this
object. If either of those checks fail, the method returns false. The
<see cref="M:System.Object.Equals(System.Object)" /> method uses 
<see cref="M:System.Object.GetType" /> to determine whether 
the run-time types of the two objects are identical. (Note that
<see langword="typeof" /> is not used here because it returns the static type.) If 
instead the method had used a check of the form <c><paramref name="obj" /> is Point</c> , the check would
return true in cases where <paramref name="obj" /> is an instance of a subclass of
<see langword="Point" /> ,
even though <paramref name="obj" /> and the current instance are not of the same runtime
type. Having verified that both objects are of the same type, the method casts
<paramref name="obj" /> 
to type <see langword="Point" />
and returns the result of comparing the instance variables of the two objects.</para>
          <para> In <see langword="Point3D.Equals" /> , the inherited
<see langword="Equals" /> method is 
invoked before anything else is done; the inherited <see langword="Equals" /> method checks to see that <paramref name="obj " />is non-null, that <paramref name="obj" /> is an instance of the same class as this
object, and that the inherited instance variables match. Only when the inherited
<see langword="Equals" /> returns true does the method compare the 
instance variables introduced in the subclass. Specifically, the cast to
<see langword="Point3D" /> 
is not executed unless <paramref name="obj" />
has been determined to be of type <see langword="Point3D" /> or a subclass of
<see langword="Point3D" />
.</para>
          <para>
            <see langword="Example 3:" />
          </para>
          <para> In the previous example, operator == (the equality
   operator) is used to compare the individual instance variables. In some cases,
   it is appropriate to use the <see cref="M:System.Object.Equals(System.Object)" /> method to
   compare instance variables in an <see langword="Equals" />
   implementation, as shown in the following example:</para>
          <code lang="C#">using System;
class Rectangle {
 Point a, b;
 public override bool Equals(Object obj) {
 if (obj == null || GetType() != obj.GetType()) return false;
 Rectangle r = (Rectangle)obj;
 //Use Equals to compare instance variables
 return a.Equals(r.a) &amp;&amp; b.Equals(r.b);
 }
 public override int GetHashCode() {
 return a.GetHashCode() ^ b.GetHashCode();
 }
}
</code>
          <para>
            <see langword="Example 4:" />
          </para>
          <para>In some languages, such as C#, operator overloading is
   supported. When a type overloads operator ==, it should also override the
<see cref="M:System.Object.Equals(System.Object)" /> method to 
   provide the same functionality. This is typically accomplished by writing the
<see langword="Equals" /> 
method
in terms of the overloaded operator ==. For example:</para>
          <code lang="C#">using System;
public struct Complex {
 double re, im;
 public override bool Equals(Object obj) {
 return obj is Complex &amp;&amp; this == (Complex)obj;
 }
 public override int GetHashCode() {
 return re.GetHashCode() ^ im.GetHashCode();
 }
 public static bool operator ==(Complex x, Complex y) {
 return x.re == y.re &amp;&amp; x.im == y.im;
 }
 public static bool operator !=(Complex x, Complex y) {
 return !(x == y);
 }
}
</code>
          <para>Because Complex is a C# struct (a value type), it is
   known that there will be no subclasses of <see langword="Complex" />
   . Therefore, the
<see cref="M:System.Object.Equals(System.Object)" /> method need 
   not compare the GetType() results for each object, but can instead use the
<see langword="is" /> operator to check the type of the <paramref name="obj" /> 
parameter.</para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static bool Equals(object objA, object objB)" />
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">To be added.</param>
        <param name="objB">To be added.</param>
        <summary>
          <para>Determines whether two object references are equal.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if one or more of the following statements is
   true:</para>
          <list type="bullet">
            <item>
              <term>
                <paramref name="objA" /> and <paramref name="objB" /> refer to the same object,</term>
            </item>
            <item>
              <term>
                <paramref name="objA" /> and <paramref name="objB" /> are both null references,</term>
            </item>
            <item>
              <term>
                <paramref name="objA" /> is not 
   <see langword="null" /> and
   <paramref name="objA" />.Equals(<paramref name="objB" /> ) returns true;</term>
            </item>
          </list>
          <para>otherwise returns <see langword="false" />.</para>
        </returns>
        <remarks>
          <para>This static method checks for null references before it
      calls <paramref name="objA" />.Equals(<paramref name="objB" /> ) and
      returns false if either <paramref name="objA" /> or <paramref name="objB" /> is null. If the Equals(object
   <paramref name="obj" />) implementation throws an exception, this method throws an
      exception.</para>
        </remarks>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Object.Equals(System.Object)" /> method.</para>
          <code lang="C#">using System;

public class MyClass {
   public static void Main() {
   string s1 = "Tom";
   string s2 = "Carol";
   Console.WriteLine("Object.Equals(\"{0}\", \"{1}\") =&gt; {2}", 
      s1, s2, Object.Equals(s1, s2));

   s1 = "Tom";
   s2 = "Tom";
   Console.WriteLine("Object.Equals(\"{0}\", \"{1}\") =&gt; {2}", 
      s1, s2, Object.Equals(s1, s2));

   s1 = null;
   s2 = "Tom";
   Console.WriteLine("Object.Equals(null, \"{1}\") =&gt; {2}",
       s1, s2, Object.Equals(s1, s2));

   s1 = "Carol";
   s2 = null;
   Console.WriteLine("Object.Equals(\"{0}\", null) =&gt; {2}", 
       s1, s2, Object.Equals(s1, s2));

   s1 = null;
   s2 = null;
   Console.WriteLine("Object.Equals(null, null) =&gt; {2}", 
       s1, s2, Object.Equals(s1, s2));
   }
}
   </code>
          <para>The output is</para>
          <c>
            <para>Object.Equals("Tom", "Carol") =&gt; False</para>
            <para>Object.Equals("Tom", "Tom") =&gt; True</para>
            <para>Object.Equals(null, "Tom") =&gt; False</para>
            <para>Object.Equals("Carol", null) =&gt; False</para>
            <para>Object.Equals(null, null) =&gt; True</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Finalize()" />
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Allows a <see cref="T:System.Object" /> to perform cleanup operations before the memory
   allocated for the <see cref="T:System.Object" /> is automatically reclaimed.</para>
        </summary>
        <remarks>
          <block subset="none" type="behaviors">
            <para>During execution, <see cref="M:System.Object.Finalize" /> is automatically called after an object
      becomes inaccessible, unless the object has been exempted from finalization by a
      call to <see cref="M:System.GC.SuppressFinalize(System.Object)" />. During shutdown of an application domain, <see cref="M:System.Object.Finalize" /> is
      automatically called on objects that are not exempt from finalization, even
      those that are still accessible. <see cref="M:System.Object.Finalize" /> is automatically called only once on a
      given instance, unless the object is re-registered using a mechanism such as
   <see cref="M:System.GC.ReRegisterForFinalize(System.Object)" /> and <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has not been subsequently called.</para>
            <para>Conforming implementations of the CLI are required to make every
         effort to ensure that for every object that has not been exempted from
         finalization, the <see cref="M:System.Object.Finalize" /> method is called after the object becomes inaccessible.
         However, there might be some circumstances under which <see langword="Finalize" /> is not
         called. Conforming CLI implementations are required to explicitly specify the conditions
         under which <see langword="Finalize" /> is not guaranteed to be called. <block subset="none" type="note">For example, <see langword="Finalize" /> might not be guaranteed to be called in
         the event of equipment failure, power failure, or other catastrophic system failures.</block></para>
            <para>In addition to <see cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
   and <see cref="M:System.GC.SuppressFinalize(System.Object)" />, conforming implementations of the CLI are allowed to
   provide other mechanisms that affect the behavior of <see cref="M:System.Object.Finalize" /> . Any mechanisms provided are required to be specified by the CLI implementation.</para>
            <para>The order in which the <see langword="Finalize" /> methods
of two objects are run is unspecified, even if one object refers to the other.</para>
            <para>The thread on which <see langword="Finalize" /> is run is unspecified.</para>
            <para>Every implementation of <see cref="M:System.Object.Finalize" /> in a
derived type is required to call its base type's implementation of <see langword="Finalize" />
. This is the only case in which application code calls <see cref="M:System.Object.Finalize" /> .</para>
          </block>
          <block subset="none" type="default">
            <para>The <see cref="M:System.Object.Finalize" />
implementation does nothing.</para>
          </block>
          <block subset="none" type="overrides">
            <para>A type should implement <see langword="Finalize" /> when it uses unmanaged resources such as
   file handles or database connections that must be released when the managed
   object that uses them is reclaimed. Because <see langword="Finalize" /> methods
   can be invoked in any order (including from multiple threads), synchronization
   can be necessary if the <see langword="Finalize" /> method can interact with other
   objects, whether accessible or not. Furthermore, since the order in which
<see langword="Finalize" /> is called is unspecified, implementers of 
<see langword="Finalize" /> (or of destructors implemented through 
   overriding Finalize) must take care to correctly handle references to
   other objects, as their <see langword="Finalize" />
   
   
   method might already have been invoked. In
   general, referenced objects should not be considered valid during
   finalization.</para>
            <para>See the <see cref="T:System.IDisposable" /> interface for an alternate means of disposing of
resources.</para>
          </block>
          <para>
            <block subset="none" type="usage">For C# developers: Destructors are the C# mechanism for
   performing cleanup operations. Destructors provide appropriate safeguards, such
   as automatically calling the base type's destructor. In C# code, <see cref="M:System.Object.Finalize" /> cannot be
   called or overridden.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetHashCode()" />
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Generates a hash code for the current instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the hash code for the current instance.</para>
        </returns>
        <remarks>
          <para>
            <see cref="M:System.Object.GetHashCode" /> serves as a hash function for a specific
   type. <block subset="none" type="note"> A hash function is used to
   quickly generate a number (a hash code) corresponding to the value of an object.
   Hash functions are used with <see langword="hashtables" />. A good hash function
   algorithm rarely generates hash codes that collide. For more information about
   hash functions, see <paramref name="The Art of Computer Programming" />
   
   , Vol. 3, by Donald E. Knuth.</block></para>
          <block subset="none" type="behaviors">
            <para>All implementations of <see cref="M:System.Object.GetHashCode" /> are required to ensure that for any two object references x
   and y, if x.Equals(y) ==
   true, then x.GetHashCode() ==
   y.GetHashCode().</para>
            <para>Hash codes generated by <see cref="M:System.Object.GetHashCode" />
need not be unique.</para>
            <para>Implementations of <see cref="M:System.Object.GetHashCode" />
are not permitted to throw exceptions.</para>
          </block>
          <para>
            <block subset="none" type="default">The <see cref="M:System.Object.GetHashCode" /> implementation attempts to produce a
unique hash code for every object, but the hash codes generated by this method
are not guaranteed to be unique. Therefore, <see cref="M:System.Object.GetHashCode" /> can generate the same hash code for two different instances.</block>
          </para>
          <para>
            <block subset="none" type="overrides">It is recommended (but not required) that types
   overriding <see cref="M:System.Object.GetHashCode" /> also override <see cref="M:System.Object.Equals(System.Object)" /> . Hashtables cannot be relied on to work correctly if this recommendation is not followed.</block>
          </para>
          <para>
            <block subset="none" type="usage">Use this method to obtain
   the hash code of an object. Hash codes should not be persisted (i.e. in a database or file) as they are allowed to change from run to run.</block>
          </para>
        </remarks>
        <example>
          <para>
            <see langword="Example 1" />
          </para>
          <para>In some cases, <see cref="M:System.Object.GetHashCode" /> is implemented to simply return an integer value.
The following example illustrates an implementation of <see cref="M:System.Int32.GetHashCode" />
, which
returns an integer value:</para>
          <code lang="C#">using System;
public struct Int32 {
 int value;
 //other methods...

 public override int GetHashCode() {
 return value;
 }
}
</code>
          <para>
            <see langword="Example 2" />
          </para>
          <para>Frequently, a type has multiple data members that can participate in
   generating the hash code. One way to generate a hash code is to combine these
   fields using an xor (exclusive or) operation, as shown in the following
   example:</para>
          <code lang="C#">using System;
public struct Point {
 int x;
 int y; 
 //other methods
 
 public override int GetHashCode() {
 return x ^ y;
 }
}
</code>
          <para>
            <see langword="Example 3" />
          </para>
          <para>The following example illustrates another case where the type's fields are
   combined using xor (exclusive or) to generate the hash code. Notice that in this
   example, the fields represent user-defined types, each of which implements
<see cref="M:System.Object.GetHashCode" /> (and should implement <see cref="M:System.Object.Equals(System.Object)" /> as well):</para>
          <code lang="C#">using System;
public class SomeType {
 public override int GetHashCode() {
 return 0;
 }
}

public class AnotherType {
 public override int GetHashCode() {
 return 1;
 }
}

public class LastType {
 public override int GetHashCode() {
 return 2;
 }
}
public class MyClass {
 SomeType a = new SomeType();
 AnotherType b = new AnotherType();
 LastType c = new LastType();

 public override int GetHashCode () {
 return a.GetHashCode() ^ b.GetHashCode() ^ c.GetHashCode();
 }
}
</code>
          <para>Avoid implementing <see cref="M:System.Object.GetHashCode" /> in a manner that results in circular references. In
other words, if AClass.GetHashCode calls BClass.GetHashCode, it should not be
the case that BClass.GetHashCode calls AClass.GetHashCode. </para>
          <para>
            <see langword="Example 4" />
          </para>
          <para>In some cases, the data member of the class in which you are implementing
<see cref="M:System.Object.GetHashCode" /> is bigger than a <see cref="T:System.Int32" />. In such cases, you could combine the 
   high order bits of the value with the low order bits using an XOR operation, as
   shown in the following example:</para>
          <code lang="C#">using System;
public struct Int64 {
 long value;
 //other methods...

 public override int GetHashCode() {
 return ((int)value ^ (int)(value &gt;&gt; 32));
 }
}
</code>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Type GetType()" />
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the type of the current instance.</para>
        </summary>
        <returns>
          <para> The instance of <see cref="T:System.Type" /> that represents the run-time type (the exact type) of the current instance.</para>
        </returns>
        <remarks>
          <para>For two objects x and y that have identical run-time 
      types, <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />(x.GetType(),y.GetType()) returns
   <see langword="true" /> 
   .</para>
        </remarks>
        <example>
          <para>The following example demonstrates the fact that <see cref="M:System.Object.GetType" />
returns the run-time type of the current instance:</para>
          <code lang="C#">using System;
public class MyBaseClass: Object {
}
public class MyDerivedClass: MyBaseClass {
}
public class Test {
   public static void Main() {
   MyBaseClass myBase = new MyBaseClass();
   MyDerivedClass myDerived = new MyDerivedClass();

   object o = myDerived;
   MyBaseClass b = myDerived;

   Console.WriteLine("mybase: Type is {0}", myBase.GetType());
   Console.WriteLine("myDerived: Type is {0}", myDerived.GetType());
   Console.WriteLine("object o = myDerived: Type is {0}", o.GetType());
   Console.WriteLine("MyBaseClass b = myDerived: Type is {0}", b.GetType());
   }
}
</code>
          <para> The output is</para>
          <c>
            <para>mybase: Type is MyBaseClass</para>
            <para>myDerived: Type is MyDerivedClass</para>
            <para>object o = myDerived: Type is MyDerivedClass</para>
            <para>MyBaseClass b = myDerived: Type is MyDerivedClass </para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="ILASM" Value=".method family hidebysig instance object MemberwiseClone()" />
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Creates a shallow copy of the current instance.</para>
        </summary>
        <returns>
          <para>A shallow copy of the current instance. The run-time
      type (the exact type) of the returned object is the same as the run-time type of
      the object that was copied.</para>
        </returns>
        <remarks>
          <para>
            <see cref="M:System.Object.MemberwiseClone" /> creates a new instance of the same type
   as the current instance and then copies each of the object's non-static fields
   in a manner that depends on whether the field is a value type or a reference
   type. If the field is a value type, a bit-by-bit copy of all the field's bits is
   performed. If the field is a reference type, only the reference is copied. The algorithm for performing a shallow copy is as follows (in pseudo-code):</para>
          <c>
            <para>for each instance field f in this instance</para>
            <para> if (f is a value type)</para>
            <para> bitwise copy the field</para>
            <para> if (f is a reference type)</para>
            <para> copy the reference</para>
            <para>end for loop</para>
          </c>
          <para>
            <block subset="none" type="note">This mechanism is
   referred to as a shallow copy because it copies rather than clones the non-static fields.</block>
          </para>
          <para>Because <see cref="M:System.Object.MemberwiseClone" /> implements the above algorithm, for any object, a, the following statements are required to be true:</para>
          <list type="bullet">
            <item>
              <term>
      
      a.MemberwiseClone() is not identical to a.</term>
            </item>
            <item>
              <term>
      
      a.MemberwiseClone().GetType() is identical to a.GetType().</term>
            </item>
          </list>
          <para>
            <see cref="M:System.Object.MemberwiseClone" /> does not call any of the type's constructors.</para>
          <para>
            <block subset="none" type="note">If <see cref="M:System.Object.Equals(System.Object)" /> has been
overridden, a.MemberwiseClone().Equals(a) might return
<see langword=" false" /> .</block>
          </para>
          <block subset="none" type="usage">
            <para>For an alternate copying mechanism, see <see cref="T:System.ICloneable" /> .</para>
            <para>
              <see cref="M:System.Object.MemberwiseClone" /> is protected (rather than public) to
   ensure that from verifiable code it is only possible to clone objects of the
   same class as the one performing the operation (or one of its subclasses).
   Although cloning an object does not directly open security holes, it does allow
   an object to be created without running any of its constructors. Since these
   constructors might establish important invariants, objects created by cloning might
   not have these invariants established, and this can lead to incorrect program
   behavior. For example, a constructor might add the new object to a linked list
   of all objects of this class, and cloning the object would not add the new
   object to that list -- thus operations that relied on the list to locate all
   instances would fail to notice the cloned object. By making the method
   protected, only objects of the same class (or a subclass) can produce a clone
   and implementers of those classes are (presumably) aware of the appropriate
   invariants and can arrange for them to be true without necessarily calling a constructor.</para>
          </block>
        </remarks>
        <example>
          <para>The following example shows a class called
   <see langword="MyClass" /> as well as a representation of the instance of
   <see langword="MyClass" />
   returned by <see cref="M:System.Object.MemberwiseClone" />
   .</para>
          <code lang="C#">using System;
class MyBaseClass {
   public static string CompanyName = "My Company";
   public int age;
   public string name;
}

class MyDerivedClass: MyBaseClass {

   static void Main() {
   
   //Create an instance of MyDerivedClass
   //and assign values to its fields.
   MyDerivedClass m1 = new MyDerivedClass();
   m1.age = 42;
   m1.name = "Sam";

   //Do a shallow copy of m1
   //and assign it to m2.
   MyDerivedClass m2 = (MyDerivedClass) m1.MemberwiseClone();
   }
}
</code>
          <para>A graphical representation of m1 and m2 might look like this</para>
          <code>
+---------------+

|     42        |                           m1 

+---------------+

|     +---------|-----------------&gt; "Sam" 

+---------------+                    /|\ 

                                      | 

+---------------+                     | 

|     42        |                     |      m2 

+---------------+                     | 

|      +--------|---------------------| 

+---------------+
</code>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static bool ReferenceEquals(object objA, object objB)" />
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">To be added.</param>
        <param name="objB">To be added.</param>
        <summary>
          <para>Determines whether two object references are identical.</para>
        </summary>
        <returns>
          <para>
            <see langword="True" /> if <paramref name="a" /> and <paramref name="b" /> refer
   to the same object or are both null references; otherwise,
<see langword="false" />.</para>
        </returns>
        <remarks>
          <para>This static method provides a way to compare two objects 
      for reference equality. It does not call any user-defined code, including
      overrides of <see cref="M:System.Object.Equals(System.Object)" />
      .</para>
        </remarks>
        <example>
          <code lang="C#">using System;
class MyClass {
   static void Main() {
   object o = null;
   object p = null;
   object q = new Object();
   Console.WriteLine(Object.ReferenceEquals(o, p));
   p = q;
   Console.WriteLine(Object.ReferenceEquals(p, q));
   Console.WriteLine(Object.ReferenceEquals(o, p));
   }
}
   </code>
          <para>The output is</para>
          <c>
            <para>True</para>
            <para>True</para>
            <para>False</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual string ToString()" />
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Creates and returns a <see cref="T:System.String" /> representation of the current
   instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.String" /> representation of the current instance.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="behaviors">
              <see cref="M:System.Object.ToString" /> returns a string whose content is intended to be
      understood by humans. Where the object contains culture-sensitive data, the
      string representation returned by <see cref="M:System.Object.ToString" /> takes into account the current
      system culture. For example, for an instance of the <see cref="T:System.Double" /> class whose value
      is zero, the implementation of <see cref="M:System.Double.ToString" /> might return "0.00" or "0,00" depending on the
      current UI culture. <block subset="none" type="note"> Although there are no exact requirements
      for the format of the returned string, it should as much as possible
      reflect the value of the object as perceived by the user.</block></block>
          </para>
          <para>
            <block subset="none" type="default">
              <see cref="M:System.Object.ToString" /> is equivalent to calling <see cref="M:System.Object.GetType" /> to obtain
   the <see cref="T:System.Type" /> object
   for the current instance and then returning the result of calling the <see cref="M:System.Object.ToString" />
   implementation
   for that type. <block subset="none" type="note"> The value returned includes the full name of the type.</block></block>
          </para>
          <block subset="none" type="overrides">
            <para> It is recommended, but not required, that <see cref="M:System.Object.ToString" /> be
   overridden in a derived class to return values that are meaningful for that
   type. For example, the base data types, such as <see cref="T:System.Int32" />, implement <see cref="M:System.Object.ToString" /> so that
   it returns the string form of the value the object represents.</para>
            <para> Subclasses that require more control over the formatting
   of strings than <see cref="M:System.Object.ToString" /> provides should implement <see cref="T:System.IFormattable" />, whose
<see cref="M:System.Object.ToString" /> method 
   uses the culture of the current thread.</para>
          </block>
        </remarks>
        <example>
          <para>The following example outputs the textual description of
      the value of an object of type <see cref="T:System.Object" /> to the console.</para>
          <code lang="C#">using System;

class MyClass {
   static void Main() {
      object o = new object();
      Console.WriteLine (o.ToString());
   }
}
      </code>
          <para>The output is</para>
          <para>
            <c>System.Object</c>
          </para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>
