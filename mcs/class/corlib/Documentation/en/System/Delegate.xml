<Type Name="Delegate" FullName="System.Delegate" FullNameSP="System_Delegate" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public abstract serializable Delegate extends System.Object implements System.ICloneable" />
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <para> A class used to create types that invoke methods.</para>
    </summary>
    <remarks>
      <para>Delegate types derive from the <see cref="T:System.Delegate" /> class. The declaration of a delegate type
   establishes a contract that specifies the signature of one or more methods. <block subset="none" type="note"> For an example of a delegate type
   declaration, see the examples at the end of this topic.</block></para>
      <para>Delegate types are implicitly sealed: it is not permissible to derive a new
   type from a delegate type. <block subset="none" type="note"> The <see cref="T:System.Delegate" /> class is not
   considered a delegate type; it is a class used to derive delegate
   types.</block></para>
      <para>
        <block subset="none" type="note"> For information on subclassing the Delegate class,
   see Partition II of the CLI Specification.</block>
      </para>
      <para>A delegate is an instance of a delegate type. A non-null
   delegate references an <paramref name="invocation list" />, which is made up of one or more
   entries. Each entry consists of a pair of values: a non-null method, and a
   corresponding object, called the <paramref name="target" />. If the method is static, the
   corresponding target is <see langword=" null" />
   , otherwise the target is the instance
   on which the method is to be called.</para>
      <para>The signature of each method in the invocation list is required to exactly
   match the signature specified by the delegate's type.</para>
      <para>When a delegate is invoked, the methods in the corresponding invocation list
   are invoked in the order in which they appear in that list. A delegate attempts
   to invoke every method in its invocation list, with duplicate methods being
   invoked once for each occurrence in that list.</para>
      <para>Delegates are immutable; once created, the invocation list of a delegate does
   not change. Combining operations, such as <see cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" /> and
<see cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />, cannot alter existing delegates. Instead, such operations 
   result in the return of either a new delegate that contains the results
   of the operation, an existing delegate, or the null value. <block subset="none" type="note"> A combining operation returns the null value when the
   result of the operation is an empty invocation list. A combining operation
   returns an existing delegate when the requested operation has no effect (for
   example, if an attempt is made to remove a nonexistent entry).</block></para>
      <para> If an invoked method throws an exception, the
   method stops executing and the exception is passed back to the caller of the
   delegate. The delegate does not continue invoking methods from its invocation
   list. Catching the exception in the caller does not alter this behavior. It is
   possible that non-standard methods that implement combining operations allow the
   creation of delegates with different behavior. When this is the case, the
   non-standard methods are required to specify the behavior.</para>
      <para>When the signature of the methods invoked by a delegate includes a return value,
   the delegate returns the return value of the last element in the invocation
   list. When the signature includes a parameter that is passed by reference,
   the final value of the parameter is the result of every method in the invocation
   list executing sequentially and updating the parameter's value.
   <block subset="none" type="note"> For an example that
      demonstrates this behavior, see Example 2.</block></para>
    </remarks>
    <example>
      <para>
        <see langword="Example1: " />
      </para>
      <para>The following example creates two delegates. The first
   delegate invokes a static method, and the second invokes an instance method on a target object.</para>
      <code lang="C#">using System;
public delegate string DelegatedMethod(string s);
class MyClass {
 public static string StaticMethod(string s) {
 return ("Static method Arg=" + s);
 }
 public string InstanceMethod(string s) {
 return ("Instance method Arg=" + s);
 }
}
class TestClass {
 public static void Main() {
 MyClass myInstance = new MyClass();
 //Create delegates from delegate type DelegatedMethod.
 DelegatedMethod delStatic = new DelegatedMethod(MyClass.StaticMethod); 
 DelegatedMethod delInstance = new DelegatedMethod(myInstance.InstanceMethod);
 //Invoke the methods referenced by the delegates.
 Console.WriteLine (delStatic("Call 1"));
 Console.WriteLine (delInstance ("Call 2"));
 }
}
</code>
      <para> The output is</para>
      <c>
        <para>Static method Arg=Call 1</para>
        <para>Instance method Arg=Call 2</para>
      </c>
      <para>
        <see langword="Example2:" />
      </para>
      <para>The following example shows the return value and the
   final value of a parameter that is passed by reference to a delegate that invokes multiple methods.</para>
      <code lang="C#">using System;
class MyClass {
 public int Increment(ref int i) {
   Console.WriteLine("Incrementing {0}",i);
   return (i++);
 }
 public int Negate(ref int i) {
   Console.WriteLine("Negating {0}",i);
   i = i * -1;
   return i;
 }
}

public delegate int DelegatedMethod(ref int i);
class TestClass {
 public static void Main() {
   MyClass myInstance = new MyClass();
   DelegatedMethod delIncrementer = new DelegatedMethod(myInstance.Increment);
   DelegatedMethod delNegater = new DelegatedMethod(myInstance.Negate);
   DelegatedMethod d = (DelegatedMethod) Delegate.Combine(delIncrementer, delNegater);
   int i = 1;
   Console.WriteLine("Invoking delegate using ref value {0}",i);
   int retvalue = d(ref i); 
   Console.WriteLine("After Invoking delegate i = {0} return value is {1}",i, retvalue);
  }
}
</code>
      <para> The output is</para>
      <c>
        <para>Invoking delegate using ref value 1</para>
        <para>Incrementing 1</para>
        <para>Negating 2</para>
        <para>After Invoking delegate i = -2 return value is -2</para>
      </c>
    </example>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberType>Constructor</MemberType>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">To be added.</param>
        <param name="method">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberType>Constructor</MemberType>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">To be added.</param>
        <param name="method">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual object Clone()" />
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Creates a copy of the current instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" /> that is a copy of the current instance.</para>
        </returns>
        <remarks>
          <para>The <see cref="M:System.Delegate.Clone" /> method creates a new instance of the
   same type as the current instance and then copies the contents of each of the current instance's non-static fields.</para>
          <para>
            <block subset="none" type="note"> This method is
   implemented to support the <see cref="T:System.ICloneable" /> interface.</block>
          </para>
          <para>
            <block subset="none" type="behaviors">The returned object must have the exact same type and invocation list as the current instance.</block>
          </para>
          <para>
            <block subset="none" type="default">
   The default implementation of the <see cref="M:System.Delegate.Clone" /> method creates a new instance, which is the
   exact same type as the current instance, and then copies the contents of each of
   the current instance's non-static fields. If the field is a value type, a
   bit-by-bit copy of the field is performed. If the field is a reference type, the
   object referenced by the field is not copied; instead, the returned object
   contains a copy of the reference. This behavior is identical to <see cref="M:System.Object.MemberwiseClone" /> .
</block>
          </para>
          <para>
            <block subset="none" type="overrides">
   Subclasses of
<see cref="T:System.Delegate" /> should
   override <see cref="M:System.Delegate.Clone" /> to customize the way in which copies of the subclass are constructed.
</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate Combine(class System.Delegate[] delegates)" />
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate[] delegates);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">An array of delegates of the exact same type.</param>
        <summary>
          <para>Concatenates the invocation lists of the specified
      delegates.</para>
        </summary>
        <returns>
          <para>A new delegate, or <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" /> or has only
<see langword="null" /> 
elements.</para>
        </returns>
        <remarks>
          <para>The invocation list of the returned delegate is
      constructed by concatenating the invocation lists of the delegates in
      <paramref name="delegates" />, in increasing subscript order. For example, consider the
      following situation, in which the elements of delegates have the following
      invocation lists (where En represents an entry in an invocation list, and null
      represents an empty invocation list): [0] = E1, [1] = null, [2] = E2 + E3, and
      [3] = E4 + E5 + E6. When these elements are combined, the resulting delegate
      contains the invocation list E1 + E2 + E3 + E4 + E5 + E6. </para>
          <para>Null elements in <paramref name="delegates" /> are not included in the returned
   delegate. </para>
          <para>
            <block subset="none" type="note"> The invocation list of the returned
   delegate can contain duplicate methods.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <para>The non-<see langword="null" /> delegates in <paramref name="delegates" /> are not of the same type.</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate Combine(class System.Delegate a, class System.Delegate b)" />
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">The delegate whose invocation list will be first in the invocation list of the new delegate.</param>
        <param name="b">The delegate whose invocation list will be last in the invocation list of the new delegate.</param>
        <summary>
          <para>Concatenates the invocation lists of the specified
      delegates.</para>
        </summary>
        <returns>
          <para>A delegate, or <see langword="null" /> .</para>
          <para>The following table describes the value returned
   when <paramref name="a" /> or <paramref name="b" /> is
<see langword="null" />
.</para>
          <list type="table">
            <listheader>
              <term>a</term>
              <description>b</description>
              <description>Return Value</description>
            </listheader>
            <item>
              <term> null</term>
              <description>null</description>
              <description>null</description>
            </item>
            <item>
              <term> null</term>
              <description>non-null</description>
              <description>
                <paramref name="b" />
              </description>
            </item>
            <item>
              <term> non-null</term>
              <description>null</description>
              <description>
                <paramref name="a" />
              </description>
            </item>
          </list>
          <para>When <paramref name="a" /> and <paramref name="b" /> are non-null, this method
returns a new delegate with the concatenated invocation lists of <paramref name="a" /> and
<paramref name="b" /> .</para>
        </returns>
        <remarks>
          <para>Unless <paramref name="a" /> or <paramref name="b" /> is <see langword="null" /> , <paramref name="a" /> and
<paramref name="b" /> are required 
   to be the exact same type.</para>
          <para>Consider the following situation, in which D1, D2, D3, D4, and D5 are
   delegate instances of the same type, D1's invocation list has one entry, E1, and
   D2's invocation list has one entry, E2.</para>
          <para>Then, D3 = Combine(D1, D2) results in D3's having an invocation list of E1 +
   E2.</para>
          <para>Then, D4 = Combine(D2, D1) results in D4's having an invocation list of E2 +
   E1.</para>
          <para>Then, D5 = Combine(D3, D4) results in D5's having an invocation list of E1 +
   E2 + E2 + E1.</para>
          <block subset="none" type="note">
            <para> The invocation list of the returned
      delegate can contain duplicate methods.
      </para>
            <para>
              <see cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" /> is useful for creating event handlers that call multiple
   methods each time an event occurs.</para>
          </block>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" /> and not of the same type.</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of <see cref="T:System.Delegate" /> to return. This <see cref="T:System.Type" /> is required to derive from <see cref="T:System.Delegate" /> .</param>
        <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that reflects a static method.</param>
        <summary>
          <para> Returns a new delegate with the specified static
      method as its invocation list.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Delegate" /> of type <paramref name="type" /> that invokes <paramref name="method." /></para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">This method is used to dynamically
      create delegates that invoke static methods. To create a delegate that invokes
      instance methods, see <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />(<see cref="T:System.Type" />, <see cref="T:System.Object" />, <see cref="T:System.String" />).</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> or <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="type" /> does not derive from <see cref="T:System.Delegate" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="method" /> does not reflect a static method.</para>
        </exception>
        <exception cref="T:System.ExecutionEngineException">
          <para>The <see langword="Invoke" /> method of the <paramref name="type" /> delegate was not found.</para>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <para>The caller does not have the required permission.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to access type information. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <exception cref="T:System.InvalidProgramException">
          <para>The <see langword="Invoke" /> method of the <paramref name="type" /> delegate was not found.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="firstArgument">To be added.</param>
        <param name="method">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate CreateDelegate(class System.Type type, object target, string method)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of the delegate to return. This <see cref="T:System.Type" /> is required to derive from <see cref="T:System.Delegate" /> .</param>
        <param name="target">An instance of an object that implements <paramref name="method" /> .</param>
        <param name="method">A <see cref="T:System.String" /> containing the name of the instance method to be invoke on <paramref name="target" /> .</param>
        <summary>
          <para> Returns a new delegate with the specified target
      and instance method as its invocation list.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Delegate" /> of type
<paramref name="type" /> that invokes <paramref name="method" /> on <paramref name="target" />.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">This method is used to dynamically
      create delegates that invoke instance methods. To create a delegate that invokes
      static methods, see <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />(<see cref="T:System.Type" />, <see cref="T:System.Type" />, <see cref="T:System.String" />).</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="type, target, or method" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="type" /> does not derive from <see cref="T:System.Delegate" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="method" /> is not an instance method.</para>
          <para>-or-</para>
          <para>
            <paramref name="target" /> does not implement <paramref name="method" />.</para>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <para>The caller does not have the required permission.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to access type information. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="method">To be added.</param>
        <param name="throwOnBindFailure">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to return. This <see cref="T:System.Type" /> is required to derive from <see cref="T:System.Delegate" /> .</param>
        <param name="target">A <see cref="T:System.Type" /> representing the class that implements <paramref name="method" /> .</param>
        <param name="method">A <see cref="T:System.String" /> containing the name of the static method implemented by <paramref name="target" /> .</param>
        <summary>
          <para> Returns a new delegate with the specified
      static method as its invocation list.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Delegate" /> of type <paramref name="type" /> that invokes <paramref name="method." /></para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">This method is used to dynamically
      create delegates that invoke static methods. To create a delegate that invokes
      instance methods, see <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />(<see cref="T:System.Type" />, <see cref="T:System.Object" />, <see cref="T:System.String" />).</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="type, target, or method" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="type" /> does not derive from <see cref="T:System.Delegate" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="method" /> is not a static method.</para>
          <para> -or-</para>
          <para>
            <paramref name="target" /> does not implement <paramref name="method" /> .</para>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <para>The caller does not have the required permission.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to access type information. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="firstArgument">To be added.</param>
        <param name="method">To be added.</param>
        <param name="throwOnBindFailure">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="target">To be added.</param>
        <param name="method">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="target">To be added.</param>
        <param name="method">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="target">To be added.</param>
        <param name="method">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="throwOnBindFailure">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <param name="target">To be added.</param>
        <param name="method">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="throwOnBindFailure">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object DynamicInvoke(class System.Object[] args)" />
      <MemberSignature Language="C#" Value="public object DynamicInvoke (object[] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">
          <para>An array of <see cref="T:System.Object" /> instances that are to be passed to the methods in the invocation list of the current instance. Specify <see langword="null" /> if the methods invoked by the current instance do not take arguments.</para>
        </param>
        <summary>
          <para>Causes a delegate to invoke the methods in its invocation
      list using the specified arguments.</para>
        </summary>
        <returns>
          <para>The <see cref="T:System.Object" /> returned by the
   last method in the invocation list of the current instance.</para>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <para>The type of one or more elements in <paramref name="args" /> is invalid as a parameter to the methods implemented by the current instance.</para>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <para>The caller does not have the required permissions.</para>
          <para>-or-</para>
          <para>The number, order or type of parameters listed in <paramref name="args" /> is invalid.</para>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <para>A method in the invocation list of the current instance is an instance method and its target object is <see langword="null" />.</para>
          <para>-or-</para>
          <para>A method in the invocation list of the current instance was invoked on a target object or a class that does not implement it.</para>
        </exception>
        <exception cref="!:System.Reflection.TargetParamterCountException">
          <para> The number of elements in <paramref name="args" /> is not equal to the number of parameters required by the methods invoked by the current instance.</para>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A method in the invocation list of the current instance threw an exception.</exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool Equals(object obj)" />
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Object" /> to compare with the current instance.</param>
        <summary>
          <para>Determines whether the
      specified object is equal to the current instance.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if <paramref name="obj" /> is equal to the
   current instance, otherwise <see langword="false" />.</para>
        </returns>
        <remarks>
          <para>Two delegates are equal if they are not null and are of
      the exact same type, their invocation lists contain the same number of elements,
      and every element in the invocation list of the first delegate is equal to
      the element in the corresponding position in the invocation list of the second delegate.</para>
          <para> Two invocation list elements are equal if they invoke the same
      instance method on the same target instance, or they invoke the same static method.</para>
          <para>
            <block subset="none" type="note"> This method
      overrides <see cref="M:System.Object.Equals(System.Object)" />
      .</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetHashCode()" />
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Generates a hash code for the current instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the hash code for this instance.</para>
        </returns>
        <remarks>
          <para> The algorithm used to
      generate the hash code is unspecified.</para>
          <para>
            <block subset="none" type="note"> This method
      overrides <see cref="M:System.Object.GetHashCode" />
      
      .</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Delegate[] GetInvocationList()" />
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns the invocation list of the current delegate.</para>
        </summary>
        <returns>
          <para>An ordered set of <see cref="T:System.Delegate" /> instances whose invocation lists collectively match those of the current delegate.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="behaviors">
      The
      array contains a set of delegates, each having an invocation list of one
      entry. Invoking these delegates sequentially, in the order in which they appear in the
      array, produces the same results as invoking the current delegate.
   </block>
          </para>
          <para>
            <block subset="none" type="overrides">
      Override <see cref="M:System.Delegate.GetInvocationList" />
      when subclassing Delegate.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="ILASM" Value=".property class System.Reflection.MethodInfo Method { public hidebysig specialname instance class System.Reflection.MethodInfo get_Method() }" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets the last method in a delegate's invocation 
      list.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Reflection.MethodInfo" />
.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have the required permissions.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to access type information. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2)" />
      <MemberSignature Language="C#" Value="public static bool op_Equality (Delegate d1, Delegate d2);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>
          <para>Determines whether the specified delegates are equal.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if
<paramref name="d1" />.Equals(<paramref name="d2" />) returns <see langword="true" />; 
   otherwise, <see langword="false" />.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note"> See <see cref="M:System.Delegate.Equals(System.Object)" />.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2)" />
      <MemberSignature Language="C#" Value="public static bool op_Inequality (Delegate d1, Delegate d2);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>
          <para>Determines whether the specified Delegates are not equal.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if
<paramref name="d1" />.Equals(<paramref name="d2" />) returns 
<see langword="false" />; otherwise, <see langword="false" />.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note"> See <see cref="M:System.Delegate.Equals(System.Object)" />.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate Remove(class System.Delegate source, class System.Delegate value)" />
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <paramref name="value" />.</param>
        <param name="value">The delegate that supplies the invocation list to remove from <paramref name="source" />.</param>
        <summary>
          <para>Removes the invocation list of a <see cref="T:System.Delegate" /> from the
   invocation list of another delegate.</para>
        </summary>
        <returns>
          <para>Returns a new delegate, <paramref name="source" />, or <see langword="null" /> . </para>
          <para>If <paramref name="source" /> and <paramref name="value" /> are not <see langword="null" /> , are not equal, and the
invocation list of <paramref name="value" /> is contained in the invocation list of source,
returns a new delegate with the invocation list of <paramref name="value" /> removed from
the invocation list of <paramref name="source" />.</para>
          <para>If the invocation lists of <paramref name="source" /> and <paramref name="value" /> are equal,
returns <see langword="null" />
.</para>
          <para>If the invocation list of <paramref name="value" /> is not found in the invocation list
of <paramref name="source" />, returns <paramref name="source" />.</para>
          <para>The following table describes the value returned when <paramref name="source" /> or
<paramref name="value" /> is 
<see langword="null" /> .</para>
          <list type="table">
            <listheader>
              <term>
                <paramref name="source" />
              </term>
              <description>
                <paramref name="value" />
              </description>
              <description>Return value</description>
            </listheader>
            <item>
              <term> null</term>
              <description>null</description>
              <description>null</description>
            </item>
            <item>
              <term> null</term>
              <description>non-null</description>
              <description>null</description>
            </item>
            <item>
              <term> non-null</term>
              <description>null</description>
              <description>
                <paramref name="source" />
              </description>
            </item>
          </list>
        </returns>
        <remarks>
          <para>The invocation list of <paramref name="value" /> is required to be
   an exact match of a contiguous set of elements in the invocation list of
 <paramref name="source" />. If the invocation list of <paramref name="value" /> occurs more than once 
   in the invocation list of <paramref name="source" />, the last occurrence is removed.</para>
        </remarks>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" /> method.</para>
          <code lang="C#">using System;
class MyClass {
    public string InstanceMethod(string s) {
    return ("Instance String " + s);
    }
}
class MyClass2 {
    public string InstanceMethod2(string s) {
    return ("Instance String2 " + s);
    }
}
public delegate string DelegatedMethod(string s);

class TestClass {
    public static void WriteDelegate (string label, Delegate d) {
    Console.WriteLine("Invocation list targets for {0}:",label);
    foreach(Delegate x in d.GetInvocationList())
        Console.WriteLine("{0}",x.Target);
    }

    public static void Main() {
    MyClass myInstance = new MyClass();
    DelegatedMethod delInstance = new DelegatedMethod(myInstance.InstanceMethod);
    MyClass2 myInstance2 = new MyClass2();
    DelegatedMethod delInstance2 = new DelegatedMethod(myInstance2.InstanceMethod2);
    DelegatedMethod [] sourceArray = {delInstance, delInstance2, delInstance2, delInstance};
    DelegatedMethod [] remove1 = {delInstance};
    DelegatedMethod [] remove2 = {delInstance2, delInstance2};
    DelegatedMethod [] remove3 = {delInstance2, delInstance};
    DelegatedMethod [] remove4 = {delInstance, delInstance2};
    DelegatedMethod [] remove5 = {delInstance, delInstance};
    Delegate source = Delegate.Combine(sourceArray);
    // Display invocation list of source
    TestClass.WriteDelegate("source", source);
    //Test 1: value occurs in source twice.
    Delegate value1 = Delegate.Combine(remove1);
    Delegate result1 = Delegate.Remove(source, value1);
    TestClass.WriteDelegate("value1", value1);
    if (result1==null) {
        Console.WriteLine("removal test 1 result is null");
    } else {
        TestClass.WriteDelegate("result1", result1);
    }
    //Test 2: value matches the middle two elements of source.
    Delegate value2 = Delegate.Combine(remove2);
    Delegate result2 = Delegate.Remove(source, value2);
    TestClass.WriteDelegate("value2", value2);
    if (result2==null) {
        Console.WriteLine("removal test 2 result2 is null");
    } else {
        TestClass.WriteDelegate("result2", result2);
    }
    //Test 3: value matches the last two elements of source.
    Delegate value3 = Delegate.Combine(remove3);
    Delegate result3 = Delegate.Remove(source, value3);
    TestClass.WriteDelegate("value3", value3);
    if (result3==null) {
        Console.WriteLine("removal test 3 result3 is null");
    } else {
        TestClass.WriteDelegate("result3", result3);
    }
    //Test 4: value matches the first two elements of source.
    Delegate value4 = Delegate.Combine(remove4);
    Delegate result4 = Delegate.Remove(source, value4);
    TestClass.WriteDelegate("value4", value4);
    if (result4==null) {
        Console.WriteLine("removal test 4 result4 is null");
    } else {
        TestClass.WriteDelegate("result4", result4);
    }
    //Test 5: value does not occur in source.
    Delegate value5 = Delegate.Combine(remove5);
    Delegate result5 = Delegate.Remove(source, value5);
    TestClass.WriteDelegate("value5", value5);
    if (result5==null) {
        Console.WriteLine("removal test 5 result5 is null");
    } else {
        TestClass.WriteDelegate("result5", result5);
    }
    //Test 6: value exactly matches source.
    Delegate result6 = Delegate.Remove(source, source);
    TestClass.WriteDelegate("value=source", source);
    if (result6==null) {
        Console.WriteLine("removal test 6 result6 is null");
    } else {

        TestClass.WriteDelegate("result6", result6);
    }
}
}
</code>
          <para>The output is</para>
          <c>
            <para>Invocation list targets for source:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>MyClass2</para>
            <para>MyClass</para>
            <para>Invocation list targets for value1:</para>
            <para>MyClass</para>
            <para>Invocation list targets for result1:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>MyClass2</para>
            <para>Invocation list targets for value2:</para>
            <para>MyClass2</para>
            <para>MyClass2</para>
            <para>Invocation list targets for result2:</para>
            <para>MyClass</para>
            <para>MyClass</para>
            <para>Invocation list targets for value3:</para>
            <para>MyClass2</para>
            <para>MyClass</para>
            <para>Invocation list targets for result3:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>Invocation list targets for value4:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>Invocation list targets for result4:</para>
            <para>MyClass2</para>
            <para>MyClass</para>
            <para>Invocation list targets for value5:</para>
            <para>MyClass</para>
            <para>MyClass</para>
            <para>Invocation list targets for result5:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>MyClass2</para>
            <para>MyClass</para>
            <para>Invocation list targets for value=source:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>MyClass2</para>
            <para>MyClass</para>
            <para>removal test 6 result6 is null</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value)" />
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove all matching occurrences of the invocation list of <paramref name="value" />.</param>
        <param name="value">The delegate that supplies the invocation list to remove from <paramref name="source" />.</param>
        <summary>
          <para>Removes all matching occurrences of the invocation list of a <see cref="T:System.Delegate" /> from the     invocation list of another delegate.
    </para>
        </summary>
        <returns>
          <para>Returns a new delegate, <paramref name="source" />, or <see langword="null" />.</para>
          <para>If <paramref name="source" /> and <paramref name="value" /> are not <see langword="null" /> , are not equal, and the invocation list of <paramref name="value" /> is contained in the invocation list of source, returns a new delegate with all matching occurrences of the invocation list of <paramref name="value" /> removed from the invocation list of <paramref name="source" />.
    </para>
          <para>If the invocation lists of <paramref name="source" /> and <paramref name="value" /> are equal, or if <paramref name="source" /> contains only a succession of invocation lists equal to <paramref name="value" />, returns <see langword="null" />.</para>
          <para>If the invocation list of <paramref name="value" /> is not found in the invocation list of <paramref name="source" />, returns <paramref name="source" />.</para>
          <para>The following table describes the value returned when <paramref name="source" /> or <paramref name="value" /> is <see langword="null" /> .</para>
          <list type="table">
            <listheader>
              <term>
                <paramref name="source" />
              </term>
              <description>
                <paramref name="value" />
              </description>
              <description>Return value</description>
            </listheader>
            <item>
              <term> null</term>
              <description>null</description>
              <description>null</description>
            </item>
            <item>
              <term> null</term>
              <description>non-null</description>
              <description>null</description>
            </item>
            <item>
              <term> non-null</term>
              <description>null</description>
              <description>
                <paramref name="source" />
              </description>
            </item>
          </list>
        </returns>
        <remarks>
          <para>The invocation list of <paramref name="value" /> is required to be   an exact match of a contiguous set of elements in the invocation list of<paramref name="source" />. If the invocation list of <paramref name="value" /> occurs more than once    in the invocation list of <paramref name="source" />, all occurrences are removed.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="ILASM" Value=".property object Target { public hidebysig specialname instance object get_Target() }" />
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the last object upon which a delegate invokes an
      instance method.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Object" /> instance, or 
<see langword="null" /> if the delegate invokes only static methods.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the delegate invokes only static methods, this 
      property returns <see langword="null" />
      . If the delegate invokes one or more instance methods, this property returns the target of the last instance method/target pair in the invocation list.</para>
        </remarks>
        <example>
          <para>Example 1:</para>
          <para>The following example gets the <see cref="P:System.Delegate.Target" /> property values
   for two delegates. The first delegate invokes a static method, and the second
   invokes an instance method.</para>
          <code lang="C#">using System;
public delegate string DelegatedMethod(string s);
class MyClass {
  public static string StaticMethod(string s) {
    return ("Static method Arg=" + s);
  }
  public string InstanceMethod(string s) {
    return ("Instance method Arg=" + s);
  }
}
class TestClass {
  public static void Main() {
    MyClass myInstance = new MyClass();
     //Create  delegates from delegate type DelegatedMethod.
    DelegatedMethod delStatic = new DelegatedMethod(MyClass.StaticMethod);        
    DelegatedMethod delInstance = new DelegatedMethod(myInstance.InstanceMethod);
    object t = delStatic.Target; 
    Console.WriteLine ("Static target is {0}", t==null ? "null":t);    
    t = delInstance.Target;
    Console.WriteLine ("Instance target is {0}", t==null ? "null":t);
    }
}
</code>
          <para>The output is</para>
          <c>
            <para>Static target is null</para>
            <para>Instance target is MyClass</para>
          </c>
          <para>Example 2: </para>
          <para>The following example gets the <see cref="P:System.Delegate.Target" /> property value for three delegates
created using instance methods, static methods, and a combination of the two. </para>
          <code lang="C#">using System;
class MyClass {
  public static string StaticMethod(string s) {
    return ("Static String " + s);
  }
  public string InstanceMethod(string s) {
    return ("Instance String " + s);
  }
}
class MyClass2 {
  public static string StaticMethod2(string s) {
    return ("Static String2 " + s);
  }
  public string InstanceMethod2(string s) {
    return ("Instance String2 " + s);
  }
}
public delegate string DelegatedMethod(string s);

class TestClass {
    public static void Main() {
    DelegatedMethod delStatic = new DelegatedMethod(MyClass.StaticMethod);
    DelegatedMethod delStatic2 = new DelegatedMethod(MyClass2.StaticMethod2);
    
    MyClass myInstance = new MyClass();
    DelegatedMethod delInstance = new DelegatedMethod(myInstance.InstanceMethod);

    MyClass2 myInstance2 = new MyClass2();
    DelegatedMethod delInstance2 = new DelegatedMethod(myInstance2.InstanceMethod2);

    Delegate d = Delegate.Combine(delStatic, delInstance );
    Delegate e = Delegate.Combine(delInstance,delInstance2);
    Delegate f = Delegate.Combine(delStatic, delStatic2 );
    if (d!=null) {
        Console.WriteLine("Combined 1 static, 1 instance, same class:");
        Console.WriteLine("target...{0}", d.Target == null ? "null" : d.Target);
        foreach(Delegate x in d.GetInvocationList())
            Console.WriteLine("invoke element target: {0}",x.Target);

    }
    Console.WriteLine("");
    if (e!=null) {
        Console.WriteLine("Combined 2 instance methods, different classes:");
        Console.WriteLine("target...{0}", e.Target == null ? "null" : e.Target);
        foreach(Delegate x in e.GetInvocationList())
            Console.WriteLine("invoke element target: {0}",x.Target);
    }
    Console.WriteLine("");
    if (f!=null) {
        Console.WriteLine("Combined 2 static methods, different classes:");
        Console.WriteLine("target...{0}", f.Target == null ? "null" : f.Target);
        foreach(Delegate x in f.GetInvocationList())
            Console.WriteLine("invoke element target: {0}",x.Target);
    }

    }
}
</code>
          <para>The output is</para>
          <c>
            <para>Combined 1 static, 1 instance, same class:</para>
            <para>target...MyClass</para>
            <para>invoke element target:</para>
            <para>invoke element target: MyClass</para>
            <para>Combined 2 instance methods, different classes:</para>
            <para>target...MyClass2</para>
            <para>invoke element target: MyClass</para>
            <para>invoke element target: MyClass2</para>
            <para>Combined 2 static methods, different classes:</para>
            <para>target...null</para>
            <para>invoke element target:</para>
            <para>invoke element target:</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>
