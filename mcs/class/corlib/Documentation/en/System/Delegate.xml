<?xml version="1.0" encoding="utf-8"?>
<Type Name="Delegate" FullName="System.Delegate" FullNameSP="System_Delegate" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public abstract serializable Delegate extends System.Object implements System.ICloneable" />
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <example>
      <para>
        <see langword="Example1: " />
      </para>
      <para>The following example creates two delegates. The first
   delegate invokes a static method, and the second invokes an instance method on a target object.</para>
      <code lang="C#">using System;
public delegate string DelegatedMethod(string s);
class MyClass {
 public static string StaticMethod(string s) {
 return ("Static method Arg=" + s);
 }
 public string InstanceMethod(string s) {
 return ("Instance method Arg=" + s);
 }
}
class TestClass {
 public static void Main() {
 MyClass myInstance = new MyClass();
 //Create delegates from delegate type DelegatedMethod.
 DelegatedMethod delStatic = new DelegatedMethod(MyClass.StaticMethod); 
 DelegatedMethod delInstance = new DelegatedMethod(myInstance.InstanceMethod);
 //Invoke the methods referenced by the delegates.
 Console.WriteLine (delStatic("Call 1"));
 Console.WriteLine (delInstance ("Call 2"));
 }
}
</code>
      <para> The output is</para>
      <c>
        <para>Static method Arg=Call 1</para>
        <para>Instance method Arg=Call 2</para>
      </c>
      <para>
        <see langword="Example2:" />
      </para>
      <para>The following example shows the return value and the
   final value of a parameter that is passed by reference to a delegate that invokes multiple methods.</para>
      <code lang="C#">using System;
class MyClass {
 public int Increment(ref int i) {
   Console.WriteLine("Incrementing {0}",i);
   return (i++);
 }
 public int Negate(ref int i) {
   Console.WriteLine("Negating {0}",i);
   i = i * -1;
   return i;
 }
}

public delegate int DelegatedMethod(ref int i);
class TestClass {
 public static void Main() {
   MyClass myInstance = new MyClass();
   DelegatedMethod delIncrementer = new DelegatedMethod(myInstance.Increment);
   DelegatedMethod delNegater = new DelegatedMethod(myInstance.Negate);
   DelegatedMethod d = (DelegatedMethod) Delegate.Combine(delIncrementer, delNegater);
   int i = 1;
   Console.WriteLine("Invoking delegate using ref value {0}",i);
   int retvalue = d(ref i); 
   Console.WriteLine("After Invoking delegate i = {0} return value is {1}",i, retvalue);
  }
}
</code>
      <para> The output is</para>
      <c>
        <para>Invoking delegate using ref value 1</para>
        <para>Incrementing 1</para>
        <para>Negating 2</para>
        <para>After Invoking delegate i = -2 return value is -2</para>
      </c>
    </example>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The <see cref="T:System.Delegate" /> class is the base class for delegate types. However, only the system and compilers can derive explicitly from the <see cref="T:System.Delegate" /> class or from the <see cref="T:System.MulticastDelegate" /> class. It is also not permissible to derive a new type from a delegate type. The <see cref="T:System.Delegate" /> class is not considered a delegate type; it is a class used to derive delegate types.</para>
      <para>Most languages implement a delegate keyword, and compilers for those languages are able to derive from the <see cref="T:System.MulticastDelegate" /> class; therefore, users should use the delegate keyword provided by the language.</para>
      <block subset="none" type="note">
        <para>The common language runtime provides an Invoke method for each delegate type, with the same signature as the delegate. You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically. The Invoke method is useful in <format type="text/html"><a href="d1a58e7f-fb39-4d50-bf84-e3b8f9bf9775">reflection</a></format> when you want to find the signature of the delegate type.</para>
      </block>
      <para>The common language runtime provides each delegate type with BeginInvoke and EndInvoke methods, to enable asynchronous invocation of the delegate. For more information about these methods, see <format type="text/html"><a href="41972034-92ed-450a-9664-ab93fcc6f1fb">Calling Synchronous Methods Asynchronously</a></format>.</para>
      <para>The declaration of a delegate type establishes a contract that specifies the signature of one or more methods. A delegate is an instance of a delegate type that has references to: </para>
      <list type="bullet">
        <item>
          <para>An instance method of a type and a target object assignable to that type. </para>
        </item>
        <item>
          <para>An instance method of a type, with the hidden <paramref name="this" /> parameter exposed in the formal parameter list. The delegate is said to be an open instance delegate.</para>
        </item>
        <item>
          <para>A static method.</para>
        </item>
        <item>
          <para>A static method and a target object assignable to the first parameter of the method. The delegate is said to be closed over its first argument.</para>
        </item>
      </list>
      <para>For more information on delegate binding, see the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> method overload. </para>
      <block subset="none" type="note">
        <para>In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type. Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</para>
      </block>
      <para>When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method. When a delegate represents an open instance method, it stores a reference to the method's entry point. The delegate signature must include the hidden <paramref name="this" /> parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked. </para>
      <para>When a delegate represents a static method, the delegate stores a reference to the method's entry point. When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument. When the delegate is invoked, the first argument of the static method receives the target object.</para>
      <para>The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate. An invocation list can contain duplicate methods. During an invocation, methods are invoked in the order in which they appear in the invocation list. A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list. Delegates are immutable; once created, the invocation list of a delegate does not change.</para>
      <para>Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations. </para>
      <para>Combining operations, such as <see cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" /> and <see cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />, do not alter existing delegates. Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or null. A combining operation returns null when the result of the operation is a delegate that does not reference at least one method. A combining operation returns an unchanged delegate when the requested operation has no effect.</para>
      <block subset="none" type="note">
        <para>Managed languages use the <see cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" /> and <see cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" /> methods to implement delegate operations. Examples include the AddHandler and RemoveHandler statements in Visual Basic and the += and -= operators on delegate types in C#. </para>
      </block>
      <para>Starting with the net_v40_long, generic delegate types can have variant type parameters. Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type. This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in <format type="text/html"><a href="2678dc63-c7f9-4590-9ddc-0a4df684d42e">Covariance and Contravariance in Generics</a></format>.</para>
      <block subset="none" type="note">
        <para>Generic delegates that are assignment-compatible because of variance are not necessarily combinable. To be combinable, the types must match exactly. For example, suppose that a class named Derived is derived from a class named Base. A delegate of type Action&lt;Base&gt; (Action(Of Base) in Visual Basic) can be assigned to a variable of type Action&lt;Derived&gt;, but the two delegates cannot be combined because the types do not match exactly.</para>
      </block>
      <para>If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked. Catching the exception in the caller does not alter this behavior.</para>
      <para>When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list. When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</para>
      <para>The closest equivalent of a delegate in C or C++ is a function pointer. A delegate can represent a static method or an instance method. When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance. Unlike function pointers, delegates are object oriented and type safe.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor cannot be used in application code. To create a delegate by specifying the name of an instance method, use an overload of the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" /> method that specifies a method name and a target object. For example, the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" /> method overload creates a delegate for an instance method with a specified name.</para>
          <para>This constructor creates delegates for instance methods only. An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a delegate that invokes the specified instance method on the specified class instance.</para>
        </summary>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The class instance on which the delegate invokes <paramref name="method" />. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the instance method that the delegate represents. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor cannot be used in application code. To create a delegate by specifying the name of a static method, use an overload of the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" /> method that specifies a method name but does not specify a target object. For example, the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" /> method overload creates a static delegate for a method with a specified name.</para>
          <para>This constructor creates delegates for static methods only. An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a delegate that invokes the specified static method from the specified class.</para>
        </summary>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> representing the class that defines <paramref name="method" />. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the static method that the delegate represents. </param>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual object Clone()" />
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The clone has the same <see cref="T:System.Type" />, target, method, and invocation list as the original delegate.</para>
          <para>A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object. If the field is a value type, a bit-by-bit copy of the field is performed. If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object. In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a shallow copy of the delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A shallow copy of the delegate.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate Combine(class System.Delegate[] delegates)" />
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>The non-<see langword="null" /> delegates in <paramref name="delegates" /> are not of the same type.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the <paramref name="delegates" /> array contains entries that are null, those entries are ignored.</para>
          <para>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</para>
          <block subset="none" type="note">
            <para>Generic delegates that are assignment-compatible because of variance are not necessarily combinable. To be combinable, the types must match exactly. For example, suppose that a class named Derived is derived from a class named Base. A delegate of type Action&lt;Base&gt; (Action(Of Base) in Visual Basic) can be assigned to a variable of type Action&lt;Derived&gt;, as explained in <format type="text/html"><a href="2678dc63-c7f9-4590-9ddc-0a4df684d42e">Covariance and Contravariance in Generics</a></format>, but the two delegates cannot be combined because the types do not match exactly.</para>
          </block>
          <para>
            <see cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" /> is useful for creating event handlers that call multiple methods each time an event occurs.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the invocation lists of an array of delegates.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array. Returns null if <paramref name="delegates" /> is null, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is null.</para>
        </returns>
        <param name="delegates">
          <attribution license="cc4" from="Microsoft" modified="false" />The array of delegates to combine. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate Combine(class System.Delegate a, class System.Delegate b)" />
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" /> and not of the same type.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</para>
          <block subset="none" type="note">
            <para>Generic delegates that are assignment-compatible because of variance are not necessarily combinable. To be combinable, the types must match exactly. For example, suppose that a class named Derived is derived from a class named Base. A delegate of type Action&lt;Base&gt; (Action(Of Base) in Visual Basic) can be assigned to a variable of type Action&lt;Derived&gt;, as explained in <format type="text/html"><a href="2678dc63-c7f9-4590-9ddc-0a4df684d42e">Covariance and Contravariance in Generics</a></format>, but the two delegates cannot be combined because the types do not match exactly.</para>
          </block>
          <para>
            <see cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" /> is useful for creating event handlers that call multiple methods each time an event occurs.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the invocation lists of two delegates.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order. Returns <paramref name="a" /> if <paramref name="b" /> is null, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</para>
        </returns>
        <param name="a">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate whose invocation list comes first. </param>
        <param name="b">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate whose invocation list comes last. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method applies only if the current delegate is multicast (combinable).</para>
          <para>The current implementation simply throws a <see cref="T:System.MulticastNotSupportedException" />.</para>
          <para>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is null.</para>
        </returns>
        <param name="d">
          <attribution license="cc4" from="Microsoft" modified="false" />The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> or <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="type" /> does not derive from <see cref="T:System.Delegate" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="method" /> does not reflect a static method.</para>
        </exception>
        <exception cref="T:System.ExecutionEngineException">
          <para>The <see langword="Invoke" /> method of the <paramref name="type" /> delegate was not found.</para>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <para>The caller does not have the required permission.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to access type information. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <exception cref="T:System.InvalidProgramException">
          <para>The <see langword="Invoke" /> method of the <paramref name="type" /> delegate was not found.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only. In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods. For a detailed explanation, see the more general <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" /> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument. </para>
          <block subset="none" type="note">
            <para>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</para>
          </block>
          <para>This method overload is equivalent to calling the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" /> method overload and specifying true for <paramref name="throwOnBindFailure" />.</para>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public methods if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
          <format type="text/html">
            <h2>Compatible Parameter Types and Return Type</h2>
          </format>
          <para>In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly. This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</para>
          <para>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</para>
          <para>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</para>
          <para>For example, a delegate with a parameter of type <see cref="T:System.Collections.Hashtable" /> and a return type of <see cref="T:System.Object" /> can represent a method with a parameter of type <see cref="T:System.Object" /> and a return value of type <see cref="T:System.Collections.Hashtable" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a delegate of the specified type to represent the specified static method.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate of the specified type to represent the specified static method.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of delegate to create. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent. Only static methods are supported in the .NET Framework version 1.0 and 1.1.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Calling this method overload is equivalent to calling the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> method overload and specifying true for <paramref name="throwOnBindFailure" />. These two overloads provide the most flexible way to create delegates. You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</para>
          <block subset="none" type="note">
            <para>If you do not supply a first argument, use the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" /> method overload for better performance.</para>
          </block>
          <para>The delegate type and the method must have compatible return types. That is, the return type of <paramref name="method" /> must be assignable to the return type of <paramref name="type" />.</para>
          <para>If <paramref name="firstArgument" /> is supplied, it is passed to <paramref name="method" /> every time the delegate is invoked; <paramref name="firstArgument" /> is said to be bound to the delegate, and the delegate is said to be closed over its first argument. If <paramref name="method" /> is static (Shared in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <paramref name="method" /> is an instance method, then <paramref name="firstArgument" /> is passed to the hidden instance parameter (represented by this in C#, or by Me in Visual Basic).</para>
          <para>If <paramref name="firstArgument" /> is supplied, the first parameter of <paramref name="method" /> must be a reference type, and <paramref name="firstArgument" /> must be compatible with that type. </para>
          <block subset="none" type="note">
            <para>If <paramref name="method" /> is static (Shared in Visual Basic) and its first parameter is of type <see cref="T:System.Object" /> or <see cref="T:System.ValueType" />, then <paramref name="firstArgument" /> can be a value type. In this case <paramref name="firstArgument" /> is automatically boxed. Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call. </para>
          </block>
          <para>If <paramref name="firstArgument" /> is a null reference and <paramref name="method" /> is an instance method, the result depends on the signatures of the delegate type <paramref name="type" /> and of <paramref name="method" />:</para>
          <list type="bullet">
            <item>
              <para>If the signature of <paramref name="type" /> explicitly includes the hidden first parameter of <paramref name="method" />, the delegate is said to represent an open instance method. When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <paramref name="method" />.</para>
            </item>
            <item>
              <para>If the signatures of <paramref name="method" /> and <paramref name="type" /> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference. Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do. </para>
            </item>
          </list>
          <para>If <paramref name="firstArgument" /> is a null reference and <paramref name="method" /> is static, the result depends on the signatures of the delegate type <paramref name="type" /> and of <paramref name="method" />:</para>
          <list type="bullet">
            <item>
              <para>If the signature of <paramref name="method" /> and <paramref name="type" /> match (that is, all parameter types are compatible), the delegate is said to represent an open static method. This is the most common case for static methods. In this case, you can get slightly better performance by using the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" /> method overload.</para>
            </item>
            <item>
              <para>If the signature of <paramref name="type" /> begins with the second parameter of <paramref name="method" /> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference. When the delegate is invoked, a null reference is passed to the first parameter of <paramref name="method" />. </para>
            </item>
          </list>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public methods if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
          <format type="text/html">
            <h2>Compatible Parameter Types and Return Type</h2>
          </format>
          <para>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly. </para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</para>
          </block>
          <para>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</para>
          <para>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</para>
          <para>For example, a delegate with a parameter of type <see cref="T:System.Collections.Hashtable" /> and a return type of <see cref="T:System.Object" /> can represent a method with a parameter of type <see cref="T:System.Object" /> and a return value of type <see cref="T:System.Collections.Hashtable" />.</para>
          <format type="text/html">
            <h2>Determining the Methods a Delegate Can Represent</h2>
          </format>
          <para>Another useful way to think of the flexibility provided by this overload of <see cref="Overload:System.Delegate.CreateDelegate" /> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance). Consider a delegate type D with one argument of type C. The following describes the methods D can represent, ignoring the return type since it must match in all cases:</para>
          <list type="bullet">
            <item>
              <para>D can represent any instance method that has exactly one argument of type C, regardless of what type the instance method belongs to. When <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> is called, <paramref name="firstArgument" /> is an instance of the type <paramref name="method" /> belongs to, and the resulting delegate is said to be closed over that instance. (Trivially, D can also be closed over a null reference if <paramref name="firstArgument" /> is a null reference.)</para>
            </item>
            <item>
              <para>D can represent an instance method of C that has no arguments. When <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> is called, <paramref name="firstArgument" /> is a null reference. The resulting delegate represents an open instance method, and an instance of C must be supplied each time it is invoked. </para>
            </item>
            <item>
              <para>D can represent a static method that takes one argument of type C, and that method can belong to any type. When <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> is called, <paramref name="firstArgument" /> is a null reference. The resulting delegate represents an open static method, and an instance of C must be supplied each time it is invoked.</para>
            </item>
            <item>
              <para>D can represent a static method that belongs to type F and has two arguments, of type F and type C. When <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> is called, <paramref name="firstArgument" /> is an instance of F. The resulting delegate represents a static method that is closed over that instance of F. Note that in the case where F and C are the same type, the static method has two arguments of that type. (In this case, D is closed over a null reference if <paramref name="firstArgument" /> is a null reference.)</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate of the specified type that represents the specified static or instance method. </para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of delegate to create. </param>
        <param name="firstArgument">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to which the delegate is bound, or null to treat <paramref name="method" /> as static (Shared in Visual Basic). </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate CreateDelegate(class System.Type type, object target, string method)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="type, target, or method" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="type" /> does not derive from <see cref="T:System.Delegate" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="method" /> is not an instance method.</para>
          <para>-or-</para>
          <para>
            <paramref name="target" /> does not implement <paramref name="method" />.</para>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <para>The caller does not have the required permission.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to access type information. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method creates delegates for instance methods only. An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</para>
          <para>This method overload is equivalent to calling the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" /> method overload, specifying false for <paramref name="ignoreCase" /> and true for <paramref name="throwOnBindFailure" />.</para>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public methods if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of delegate to create. </param>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The class instance on which <paramref name="method" /> is invoked. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the instance method that the delegate is to represent. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overload can create open static method delegates and open instance method delegates — that is, delegates that expose the hidden first argument of instance methods. For a detailed explanation, see the more general <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods. </para>
          <block subset="none" type="note">
            <para>This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</para>
          </block>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public methods if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
          <format type="text/html">
            <h2>Compatible Parameter Types and Return Type</h2>
          </format>
          <para>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly. </para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 1.0 and 1.1, the types must match exactly.</para>
          </block>
          <para>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</para>
          <para>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</para>
          <para>For example, a delegate with a parameter of type <see cref="T:System.Collections.Hashtable" /> and a return type of <see cref="T:System.Object" /> can represent a method with a parameter of type <see cref="T:System.Object" /> and a return value of type <see cref="T:System.Collections.Hashtable" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate of the specified type to represent the specified static method.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of delegate to create. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw an exception if <paramref name="method" /> cannot be bound; otherwise, false.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method)" />
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="type, target, or method" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="type" /> does not derive from <see cref="T:System.Delegate" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="method" /> is not a static method.</para>
          <para> -or-</para>
          <para>
            <paramref name="target" /> does not implement <paramref name="method" /> .</para>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <para>The caller does not have the required permission.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to access type information. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method creates delegates for static methods only. An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</para>
          <para>This method overload is equivalent to calling the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" /> method overload, specifying false for <paramref name="ignoreCase" /> and true for <paramref name="throwOnBindFailure" />.</para>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public methods if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a delegate of the specified type that represents the specified static method of the specified class.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate of the specified type that represents the specified static method of the specified class.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of delegate to create. </param>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the static method that the delegate is to represent. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overload and the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" /> method overload, which always throws on failure to bind, provide the most flexible way to create delegates. You can use them to create delegates for either static or instance methods, with or without a first argument.</para>
          <block subset="none" type="note">
            <para>If you do not supply a first argument, use the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" /> method overload for better performance.</para>
          </block>
          <para>The delegate type and the method must have compatible return types. That is, the return type of <paramref name="method" /> must be assignable to the return type of <paramref name="type" />.</para>
          <para>If <paramref name="firstArgument" /> is supplied, it is passed to <paramref name="method" /> every time the delegate is invoked; <paramref name="firstArgument" /> is said to be bound to the delegate, and the delegate is said to be closed over its first argument. If <paramref name="method" /> is static (Shared in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if <paramref name="method" /> is an instance method, then <paramref name="firstArgument" /> is passed to the hidden instance parameter (represented by this in C#, or by Me in Visual Basic).</para>
          <para>If <paramref name="firstArgument" /> is supplied, the first parameter of <paramref name="method" /> must be a reference type, and <paramref name="firstArgument" /> must be compatible with that type. </para>
          <block subset="none" type="note">
            <para>If <paramref name="method" /> is static (Shared in Visual Basic) and its first parameter is of type <see cref="T:System.Object" /> or <see cref="T:System.ValueType" />, then <paramref name="firstArgument" /> can be a value type. In this case <paramref name="firstArgument" /> is automatically boxed. Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call. </para>
          </block>
          <para>If <paramref name="firstArgument" /> is a null reference and <paramref name="method" /> is an instance method, the result depends on the signatures of the delegate type <paramref name="type" /> and of <paramref name="method" />:</para>
          <list type="bullet">
            <item>
              <para>If the signature of <paramref name="type" /> explicitly includes the hidden first parameter of <paramref name="method" />, the delegate is said to represent an open instance method. When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of <paramref name="method" />.</para>
            </item>
            <item>
              <para>If the signatures of <paramref name="method" /> and <paramref name="type" /> match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference. Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do. </para>
            </item>
          </list>
          <para>If <paramref name="firstArgument" /> is a null reference and <paramref name="method" /> is static, the result depends on the signatures of the delegate type <paramref name="type" /> and of <paramref name="method" />:</para>
          <list type="bullet">
            <item>
              <para>If the signature of <paramref name="method" /> and <paramref name="type" /> match (that is, all parameter types are compatible), the delegate is said to represent an open static method. This is the most common case for static methods. In this case, you can get slightly better performance by using the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" /> method overload.</para>
            </item>
            <item>
              <para>If the signature of <paramref name="type" /> begins with the second parameter of <paramref name="method" /> and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference. When the delegate is invoked, a null reference is passed to the first parameter of <paramref name="method" />. </para>
            </item>
          </list>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public methods if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
          <format type="text/html">
            <h2>Compatible Parameter Types and Return Type</h2>
          </format>
          <para>The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly. </para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 1.0 and 1.1 the types must match exactly.</para>
          </block>
          <para>A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</para>
          <para>Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</para>
          <para>For example, a delegate with a parameter of type <see cref="T:System.Collections.Hashtable" /> and a return type of <see cref="T:System.Object" /> can represent a method with a parameter of type <see cref="T:System.Object" /> and a return value of type <see cref="T:System.Collections.Hashtable" />.</para>
          <format type="text/html">
            <h2>Determining the Methods a Delegate Can Represent</h2>
          </format>
          <para>Another useful way to think of the flexibility provided by this overload of <see cref="Overload:System.Delegate.CreateDelegate" /> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance). Consider a delegate type D with one argument of type C. The following describes the methods D can represent, ignoring the return type since it must match in all cases:</para>
          <list type="bullet">
            <item>
              <para>D can represent any instance method that has exactly one argument of type C, regardless of what type the instance method belongs to. When <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> is called, <paramref name="firstArgument" /> is an instance of the type <paramref name="method" /> belongs to, and the resulting delegate is said to be closed over that instance. (Trivially, D can also be closed over a null reference if <paramref name="firstArgument" /> is null.)</para>
            </item>
            <item>
              <para>D can represent an instance method of C that has no arguments. When <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> is called, <paramref name="firstArgument" /> is a null reference. The resulting delegate represents an open instance method, and an instance of C must be supplied each time it is invoked. </para>
            </item>
            <item>
              <para>D can represent a static method that takes one argument of type C, and that method can belong to any type. When <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> is called, <paramref name="firstArgument" /> is a null reference. The resulting delegate represents an open static method, and an instance of C must be supplied each time it is invoked.</para>
            </item>
            <item>
              <para>D can represent a static method that belongs to type F and has two arguments, of type F and type C. When <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" /> is called, <paramref name="firstArgument" /> is an instance of F. The resulting delegate represents a static method that is closed over that instance of F. Note that in the case where F and C are the same type, the static method has two arguments of that type. (In this case, D is closed over a null reference if <paramref name="firstArgument" /> is null.)</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate of the specified type that represents the specified static or instance method, or null if <paramref name="throwOnBindFailure" /> is false and the delegate cannot be bound to <paramref name="method" />. </para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.Type" /> representing the type of delegate to create. </param>
        <param name="firstArgument">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents. For instance methods, it must be compatible with the instance type. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw an exception if <paramref name="method" /> cannot be bound; otherwise, false.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method creates delegates for instance methods only. An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</para>
          <para>This method overload is equivalent to calling the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" /> method overload, specifying true for <paramref name="throwOnBindFailure" />.</para>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public methods if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of delegate to create. </param>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The class instance on which <paramref name="method" /> is invoked. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the instance method that the delegate is to represent. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean indicating whether to ignore the case when comparing the name of the method. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method creates delegates for static methods only. An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</para>
          <para>This method overload is equivalent to calling the <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" /> method overload, specifying true for <paramref name="throwOnBindFailure" />.</para>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public methods if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate of the specified type that represents the specified static method of the specified class.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of delegate to create. </param>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the static method that the delegate is to represent. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method creates delegates for instance methods only. An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</para>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public methods if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of delegate to create. </param>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The class instance on which <paramref name="method" /> is invoked. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the instance method that the delegate is to represent. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean indicating whether to ignore the case when comparing the name of the method. </param>
        <param name="throwOnBindFailure">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw an exception if <paramref name="method" /> cannot be bound; otherwise, false.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method creates delegates for static methods only. An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</para>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public methods if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate of the specified type that represents the specified static method of the specified class.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> of delegate to create. </param>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Type" /> representing the class that implements <paramref name="method" />. </param>
        <param name="method">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the static method that the delegate is to represent. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw an exception if <paramref name="method" /> cannot be bound; otherwise, false.</param>
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object DynamicInvoke(class System.Object[] args)" />
      <MemberSignature Language="C#" Value="public object DynamicInvoke (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>The type of one or more elements in <paramref name="args" /> is invalid as a parameter to the methods implemented by the current instance.</para>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <para>The caller does not have the required permissions.</para>
          <para>-or-</para>
          <para>The number, order or type of parameters listed in <paramref name="args" /> is invalid.</para>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <para>A method in the invocation list of the current instance is an instance method and its target object is <see langword="null" />.</para>
          <para>-or-</para>
          <para>A method in the invocation list of the current instance was invoked on a target object or a class that does not implement it.</para>
        </exception>
        <exception cref="!:System.Reflection.TargetParamterCountException">
          <para> The number of elements in <paramref name="args" /> is not equal to the number of parameters required by the methods invoked by the current instance.</para>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A method in the invocation list of the current instance threw an exception.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method calls the <see cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Dynamically invokes (late-bound) the method represented by the current delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The object returned by the method represented by the delegate.</para>
        </returns>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of objects that are the arguments to pass to the method represented by the current delegate.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method implements the <see cref="M:System.Delegate.DynamicInvoke(System.Object[])" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Dynamically invokes (late-bound) the method represented by the current delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The object returned by the method represented by the delegate.</para>
        </returns>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of objects that are the arguments to pass to the method represented by the current delegate.</param>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool Equals(object obj)" />
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the two delegates are not of the same type, they are not considered equal.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</para>
          </block>
          <para>The methods and targets are compared for equality as follows: </para>
          <list type="bullet">
            <item>
              <para>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</para>
            </item>
            <item>
              <para>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</para>
            </item>
            <item>
              <para>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</para>
            </item>
          </list>
          <para>Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, false.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to compare with the current delegate. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetHashCode()" />
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The return value of this method must not be persisted for two reasons. First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless. Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a hash code for the delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A hash code for the delegate.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Delegate[] GetInvocationList()" />
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Each delegate in the array represents exactly one method.</para>
          <para>The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the invocation list of the delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of delegates representing the invocation list of the current delegate.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method applies only if the current delegate represents a static method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the static method represented by the current delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Not supported.</para>
        </summary>
        <param name="info">
          <attribution license="cc4" from="Microsoft" modified="false" />Not supported. </param>
        <param name="context">
          <attribution license="cc4" from="Microsoft" modified="false" />Not supported. </param>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="ILASM" Value=".property class System.Reflection.MethodInfo Method { public hidebysig specialname instance class System.Reflection.MethodInfo get_Method() }" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Reflection.MethodInfo" />
.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have the required permissions.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to access type information. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the method represented by the delegate.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2)" />
      <MemberSignature Language="C#" Value="public static bool op_Equality (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</para>
          <para>If the two delegates are not of the same type, they are not considered equal.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</para>
          </block>
          <para>The methods and targets are compared for equality as follows: </para>
          <list type="bullet">
            <item>
              <para>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</para>
            </item>
            <item>
              <para>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</para>
            </item>
            <item>
              <para>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</para>
            </item>
          </list>
          <para>Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the specified delegates are equal.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, false.</para>
        </returns>
        <param name="d1">
          <attribution license="cc4" from="Microsoft" modified="false" />The first delegate to compare. </param>
        <param name="d2">
          <attribution license="cc4" from="Microsoft" modified="false" />The second delegate to compare. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2)" />
      <MemberSignature Language="C#" Value="public static bool op_Inequality (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</para>
          <para>If the two delegates are not of the same type, they are not considered equal.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</para>
          </block>
          <para>The methods and targets are compared for equality as follows: </para>
          <list type="bullet">
            <item>
              <para>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</para>
            </item>
            <item>
              <para>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</para>
            </item>
            <item>
              <para>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</para>
            </item>
          </list>
          <para>Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the specified delegates are not equal.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, false.</para>
        </returns>
        <param name="d1">
          <attribution license="cc4" from="Microsoft" modified="false" />The first delegate to compare. </param>
        <param name="d2">
          <attribution license="cc4" from="Microsoft" modified="false" />The second delegate to compare. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate Remove(class System.Delegate source, class System.Delegate value)" />
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" /> method.</para>
          <code lang="C#">using System;
class MyClass {
    public string InstanceMethod(string s) {
    return ("Instance String " + s);
    }
}
class MyClass2 {
    public string InstanceMethod2(string s) {
    return ("Instance String2 " + s);
    }
}
public delegate string DelegatedMethod(string s);

class TestClass {
    public static void WriteDelegate (string label, Delegate d) {
    Console.WriteLine("Invocation list targets for {0}:",label);
    foreach(Delegate x in d.GetInvocationList())
        Console.WriteLine("{0}",x.Target);
    }

    public static void Main() {
    MyClass myInstance = new MyClass();
    DelegatedMethod delInstance = new DelegatedMethod(myInstance.InstanceMethod);
    MyClass2 myInstance2 = new MyClass2();
    DelegatedMethod delInstance2 = new DelegatedMethod(myInstance2.InstanceMethod2);
    DelegatedMethod [] sourceArray = {delInstance, delInstance2, delInstance2, delInstance};
    DelegatedMethod [] remove1 = {delInstance};
    DelegatedMethod [] remove2 = {delInstance2, delInstance2};
    DelegatedMethod [] remove3 = {delInstance2, delInstance};
    DelegatedMethod [] remove4 = {delInstance, delInstance2};
    DelegatedMethod [] remove5 = {delInstance, delInstance};
    Delegate source = Delegate.Combine(sourceArray);
    // Display invocation list of source
    TestClass.WriteDelegate("source", source);
    //Test 1: value occurs in source twice.
    Delegate value1 = Delegate.Combine(remove1);
    Delegate result1 = Delegate.Remove(source, value1);
    TestClass.WriteDelegate("value1", value1);
    if (result1==null) {
        Console.WriteLine("removal test 1 result is null");
    } else {
        TestClass.WriteDelegate("result1", result1);
    }
    //Test 2: value matches the middle two elements of source.
    Delegate value2 = Delegate.Combine(remove2);
    Delegate result2 = Delegate.Remove(source, value2);
    TestClass.WriteDelegate("value2", value2);
    if (result2==null) {
        Console.WriteLine("removal test 2 result2 is null");
    } else {
        TestClass.WriteDelegate("result2", result2);
    }
    //Test 3: value matches the last two elements of source.
    Delegate value3 = Delegate.Combine(remove3);
    Delegate result3 = Delegate.Remove(source, value3);
    TestClass.WriteDelegate("value3", value3);
    if (result3==null) {
        Console.WriteLine("removal test 3 result3 is null");
    } else {
        TestClass.WriteDelegate("result3", result3);
    }
    //Test 4: value matches the first two elements of source.
    Delegate value4 = Delegate.Combine(remove4);
    Delegate result4 = Delegate.Remove(source, value4);
    TestClass.WriteDelegate("value4", value4);
    if (result4==null) {
        Console.WriteLine("removal test 4 result4 is null");
    } else {
        TestClass.WriteDelegate("result4", result4);
    }
    //Test 5: value does not occur in source.
    Delegate value5 = Delegate.Combine(remove5);
    Delegate result5 = Delegate.Remove(source, value5);
    TestClass.WriteDelegate("value5", value5);
    if (result5==null) {
        Console.WriteLine("removal test 5 result5 is null");
    } else {
        TestClass.WriteDelegate("result5", result5);
    }
    //Test 6: value exactly matches source.
    Delegate result6 = Delegate.Remove(source, source);
    TestClass.WriteDelegate("value=source", source);
    if (result6==null) {
        Console.WriteLine("removal test 6 result6 is null");
    } else {

        TestClass.WriteDelegate("result6", result6);
    }
}
}
</code>
          <para>The output is</para>
          <c>
            <para>Invocation list targets for source:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>MyClass2</para>
            <para>MyClass</para>
            <para>Invocation list targets for value1:</para>
            <para>MyClass</para>
            <para>Invocation list targets for result1:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>MyClass2</para>
            <para>Invocation list targets for value2:</para>
            <para>MyClass2</para>
            <para>MyClass2</para>
            <para>Invocation list targets for result2:</para>
            <para>MyClass</para>
            <para>MyClass</para>
            <para>Invocation list targets for value3:</para>
            <para>MyClass2</para>
            <para>MyClass</para>
            <para>Invocation list targets for result3:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>Invocation list targets for value4:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>Invocation list targets for result4:</para>
            <para>MyClass2</para>
            <para>MyClass</para>
            <para>Invocation list targets for value5:</para>
            <para>MyClass</para>
            <para>MyClass</para>
            <para>Invocation list targets for result5:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>MyClass2</para>
            <para>MyClass</para>
            <para>Invocation list targets for value=source:</para>
            <para>MyClass</para>
            <para>MyClass2</para>
            <para>MyClass2</para>
            <para>MyClass</para>
            <para>removal test 6 result6 is null</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the invocation list of <paramref name="value" /> matches a contiguous set of elements in the invocation list of <paramref name="source" />, then the invocation list of <paramref name="value" /> is said to occur within the invocation list of <paramref name="source" />. If the invocation list of <paramref name="value" /> occurs more than once in the invocation list of <paramref name="source" />, the last occurrence is removed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is null or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</para>
        </returns>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate from which to remove the invocation list of <paramref name="value" />. </param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate that supplies the invocation list to remove from the invocation list of <paramref name="source" />. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value)" />
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the invocation list of <paramref name="value" /> matches a contiguous set of elements in the invocation list of <paramref name="source" />, then the invocation list of <paramref name="value" /> is said to occur within the invocation list of <paramref name="source" />. If the invocation list of <paramref name="value" /> occurs more than once in the invocation list of <paramref name="source" />, all occurrences are removed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is null or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</para>
        </returns>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate from which to remove the invocation list of <paramref name="value" />. </param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate that supplies the invocation list to remove from the invocation list of <paramref name="source" />. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the invocation list of <paramref name="value" /> matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of <paramref name="value" /> is said to occur within the current delegate's invocation list. If the invocation list of <paramref name="value" /> occurs more than once in the current delegate's invocation list, the last occurrence is removed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes the invocation list of a delegate from the invocation list of another delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list. Returns the current delegate if <paramref name="value" /> is null or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list. Returns null if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</para>
        </returns>
        <param name="d">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate that supplies the invocation list to remove from the invocation list of the current delegate. </param>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="ILASM" Value=".property object Target { public hidebysig specialname instance object get_Target() }" />
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Object" /> instance, or 
<see langword="null" /> if the delegate invokes only static methods.</para>
        </value>
        <example>
          <para>Example 1:</para>
          <para>The following example gets the <see cref="P:System.Delegate.Target" /> property values
   for two delegates. The first delegate invokes a static method, and the second
   invokes an instance method.</para>
          <code lang="C#">using System;
public delegate string DelegatedMethod(string s);
class MyClass {
  public static string StaticMethod(string s) {
    return ("Static method Arg=" + s);
  }
  public string InstanceMethod(string s) {
    return ("Instance method Arg=" + s);
  }
}
class TestClass {
  public static void Main() {
    MyClass myInstance = new MyClass();
     //Create  delegates from delegate type DelegatedMethod.
    DelegatedMethod delStatic = new DelegatedMethod(MyClass.StaticMethod);        
    DelegatedMethod delInstance = new DelegatedMethod(myInstance.InstanceMethod);
    object t = delStatic.Target; 
    Console.WriteLine ("Static target is {0}", t==null ? "null":t);    
    t = delInstance.Target;
    Console.WriteLine ("Instance target is {0}", t==null ? "null":t);
    }
}
</code>
          <para>The output is</para>
          <c>
            <para>Static target is null</para>
            <para>Instance target is MyClass</para>
          </c>
          <para>Example 2: </para>
          <para>The following example gets the <see cref="P:System.Delegate.Target" /> property value for three delegates
created using instance methods, static methods, and a combination of the two. </para>
          <code lang="C#">using System;
class MyClass {
  public static string StaticMethod(string s) {
    return ("Static String " + s);
  }
  public string InstanceMethod(string s) {
    return ("Instance String " + s);
  }
}
class MyClass2 {
  public static string StaticMethod2(string s) {
    return ("Static String2 " + s);
  }
  public string InstanceMethod2(string s) {
    return ("Instance String2 " + s);
  }
}
public delegate string DelegatedMethod(string s);

class TestClass {
    public static void Main() {
    DelegatedMethod delStatic = new DelegatedMethod(MyClass.StaticMethod);
    DelegatedMethod delStatic2 = new DelegatedMethod(MyClass2.StaticMethod2);
    
    MyClass myInstance = new MyClass();
    DelegatedMethod delInstance = new DelegatedMethod(myInstance.InstanceMethod);

    MyClass2 myInstance2 = new MyClass2();
    DelegatedMethod delInstance2 = new DelegatedMethod(myInstance2.InstanceMethod2);

    Delegate d = Delegate.Combine(delStatic, delInstance );
    Delegate e = Delegate.Combine(delInstance,delInstance2);
    Delegate f = Delegate.Combine(delStatic, delStatic2 );
    if (d!=null) {
        Console.WriteLine("Combined 1 static, 1 instance, same class:");
        Console.WriteLine("target...{0}", d.Target == null ? "null" : d.Target);
        foreach(Delegate x in d.GetInvocationList())
            Console.WriteLine("invoke element target: {0}",x.Target);

    }
    Console.WriteLine("");
    if (e!=null) {
        Console.WriteLine("Combined 2 instance methods, different classes:");
        Console.WriteLine("target...{0}", e.Target == null ? "null" : e.Target);
        foreach(Delegate x in e.GetInvocationList())
            Console.WriteLine("invoke element target: {0}",x.Target);
    }
    Console.WriteLine("");
    if (f!=null) {
        Console.WriteLine("Combined 2 static methods, different classes:");
        Console.WriteLine("target...{0}", f.Target == null ? "null" : f.Target);
        foreach(Delegate x in f.GetInvocationList())
            Console.WriteLine("invoke element target: {0}",x.Target);
    }

    }
}
</code>
          <para>The output is</para>
          <c>
            <para>Combined 1 static, 1 instance, same class:</para>
            <para>target...MyClass</para>
            <para>invoke element target:</para>
            <para>invoke element target: MyClass</para>
            <para>Combined 2 instance methods, different classes:</para>
            <para>target...MyClass2</para>
            <para>invoke element target: MyClass</para>
            <para>invoke element target: MyClass2</para>
            <para>Combined 2 static methods, different classes:</para>
            <para>target...null</para>
            <para>invoke element target:</para>
            <para>invoke element target:</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</para>
          <para>If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the class instance on which the current delegate invokes the instance method.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>