<?xml version="1.0" encoding="utf-8"?>
<Type Name="ResolveEventArgs" FullName="System.ResolveEventArgs">
  <TypeSignature Maintainer="auto" Language="C#" Value="public class ResolveEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ResolveEventArgs extends System.EventArgs" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the &lt;link location="node:gtk-sharp/programming/threads"&gt;Gtk# Thread Programming&lt;/link&gt; for details.</ThreadSafetyStatement>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>When the loader cannot resolve an assembly reference and a handler has been provided for the appropriate loader resolution event, the event is raised and the <see cref="T:System.ResolveEventArgs" /> contains information about the item to be resolved. </para>
      <list type="bullet">
        <item>
          <para>The <see cref="P:System.ResolveEventArgs.Name" /> property contains the name of the item to be resolved.</para>
        </item>
        <item>
          <para>Beginning with the net_v40_long, the <see cref="P:System.ResolveEventArgs.RequestingAssembly" />Â property contains the assembly that requested an assembly that can provide the named item. For more information, see the <see cref="P:System.ResolveEventArgs.RequestingAssembly" /> property.</para>
        </item>
      </list>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides data for loader resolution events, such as the <see cref="E:System.AppDomain.TypeResolve" />, <see cref="E:System.AppDomain.ResourceResolve" />, <see cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />, and <see cref="E:System.AppDomain.AssemblyResolve" /> events.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResolveEventArgs (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor is typically called only by the common language runtime.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.ResolveEventArgs" /> class, specifying the name of the item to resolve.</para>
        </summary>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of an item to resolve. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResolveEventArgs (string name, System.Reflection.Assembly requestingAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Reflection.Assembly requestingAssembly) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="requestingAssembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.ResolveEventArgs" /> class, specifying the name of the item to resolve and the assembly whose dependency is being resolved.</para>
        </summary>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of an item to resolve. </param>
        <param name="requestingAssembly">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly whose dependency is being resolved.</param>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>Full name of the assembly.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For the <see cref="E:System.AppDomain.AssemblyResolve" /> event, <see cref="P:System.ResolveEventArgs.Name" /> is the assembly name before policy is applied.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the name of the item to resolve.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RequestingAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly RequestingAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly RequestingAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly that is returned by this property is an assembly that was unable to resolve the item specified by the <see cref="P:System.ResolveEventArgs.Name" /> property, because the item did not exist in that assembly, in any of its loaded dependencies, or in any dependencies the loader could find through probing. </para>
          <para>For example, suppose the current assembly uses the <see cref="M:System.Reflection.Assembly.LoadFile(System.String)" /> method to load assembly A from a directory outside the probing path, in order to use class CA. Suppose further that class CA uses class CB, in assembly B, and that assembly A has a compile-time reference to assembly B, also located outside the probing path. When the current assembly attempts to instantiate CA, the loader attempts to resolve the reference to assembly B. However, because assembly A was loaded by using the <see cref="M:System.Reflection.Assembly.LoadFile(System.String)" /> method, the loader cannot resolve the dependency. If there is a handler for the <see cref="E:System.AppDomain.AssemblyResolve" /> event, the event is raised, and the <see cref="P:System.ResolveEventArgs.RequestingAssembly" /> property of the resulting <see cref="T:System.ResolveEventArgs" /> object contains assembly A, because assembly A is the assembly that is missing a dependency.</para>
          <para>The semantics of the <see cref="P:System.ResolveEventArgs.RequestingAssembly" /> property vary, depending on how the requesting assembly was loaded: </para>
          <list type="bullet">
            <item>
              <para>Load context: The value of the property might be null. The load context is load-order independent, and the identity of the requesting assembly is not necessarily meaningful. A non-null example occurs when the <see cref="M:System.Type.GetType(System.String,System.Boolean)" /> method is called and the specified type is not known to the requesting assembly or any of its dependencies.</para>
            </item>
            <item>
              <para>Load-from context: The property can be used as a probing hint, but the event handler should not get more than one request for a given assembly name.</para>
            </item>
            <item>
              <para>No context (that is, the requesting assembly was loaded by using the <see cref="M:System.Reflection.Assembly.LoadFile(System.String)" /> method, or as a byte stream, or in mixed mode): The handler can use the <see cref="P:System.ResolveEventArgs.RequestingAssembly" /> property to load different implementations of the same assembly based on the identity of the requesting assembly.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the assembly whose dependency is being resolved.</para>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>