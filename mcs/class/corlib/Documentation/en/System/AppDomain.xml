<?xml version="1.0" encoding="utf-8"?>
<Type Name="AppDomain" FullName="System.AppDomain" FullNameSP="System_AppDomain" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public sealed AppDomain extends System.MarshalByRefObject" />
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <MemberOfLibrary>RuntimeInfrastructure</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Application domains, which are represented by <see cref="T:System.AppDomain" /> objects, help provide isolation, unloading, and security boundaries for executing managed code.</para>
      <list type="bullet">
        <item>
          <para>Use application domains to isolate tasks that might bring down a process. If the state of the <see cref="T:System.AppDomain" /> that's executing a task becomes unstable, the <see cref="T:System.AppDomain" /> can be unloaded without affecting the process. This is important when a process must run for long periods without restarting. You can also use application domains to isolate tasks that should not share data.</para>
        </item>
        <item>
          <para>If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running. However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded. Use this technique to minimize the working set of long-running processes that occasionally use large DLLs. </para>
        </item>
      </list>
      <para>Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads. Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</para>
      <para>Application domains are created using the <see cref="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" /> method. <see cref="T:System.AppDomain" /> instances are used to load and execute assemblies (<see cref="T:System.Reflection.Assembly" />). When an <see cref="T:System.AppDomain" /> is no longer in use, it can be unloaded.</para>
      <para>The <see cref="T:System.AppDomain" /> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</para>
      <para>For more information on using application domains, see <format type="text/html"><a href="113a8bbf-6875-4a72-a49d-ca2d92e19cc8">Application Domains</a></format>.</para>
      <para>This class implements the <see cref="T:System.MarshalByRefObject" />, <see cref="T:System._AppDomain" />, and <see cref="T:System.Security.IEvidenceFactory" /> interfaces.</para>
      <para>You should never create a remotable wrapper for an <see cref="T:System.AppDomain" /> object. Doing so could publish a remote reference to that <see cref="T:System.AppDomain" />, exposing methods such as <see cref="Overload:System.AppDomain.CreateInstance" /> to remote access and effectively destroying code access security for that <see cref="T:System.AppDomain" />. Malicious clients connecting to the remoted <see cref="T:System.AppDomain" /> could obtain access to any resource the <see cref="T:System.AppDomain" /> itself has access to. Do not create remotable wrappers for any type that extends <see cref="T:System.MarshalByRefObject" /> and that implements methods that could be used by malicious clients to bypass the security system.</para>
      <block subset="none" type="note">
        <para>The default value for the <see cref="P:System.AppDomainSetup.DisallowCodeDownload" /> property is false. This setting is unsafe for services. To prevent services from downloading partially trusted code, set this property to true.</para>
      </block>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Represents an application domain, which is an isolated environment where applications execute. This class cannot be inherited.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the activation context for the current application domain.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded. Use the <see cref="P:System.AppDomainSetup.PrivateBinPath" /> property instead.</para>
          <para>The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Appends the specified directory name to the private path list.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the directory to be appended to the private path. </param>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the identity of the application in the application domain.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.AppDomain.ApplyPolicy(System.String)" /> method takes an assembly display name and returns the post-policy display name. This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the assembly display name after policy has been applied.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string containing the assembly display name after policy has been applied.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly display name, in the form provided by the <see cref="P:System.Reflection.Assembly.FullName" /> property.</param>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="ILASM" Value=".event public event AssemblyLoad" />
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.AssemblyLoadEventHandler" /> delegate for this event indicates what assembly was loaded.</para>
          <para>To register an event handler for this event, you must have the required permissions, or a <see cref="T:System.Security.SecurityException" /> is thrown.</para>
          <para>For more information about handling events, see <format type="text/html"><a href="01E4F1BC-E55E-413F-98C7-6588493E5F67">Events Overview</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when an assembly is loaded.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>It is the responsibility of the <see cref="T:System.ResolveEventHandler" /> for this event to return the assembly that is specified by the <see cref="P:System.ResolveEventArgs.Name" /> property, or to return null if the assembly is not recognized. The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails. </para>
          <para>For guidance on the use of this event, see <format type="text/html"><a href="5099e549-f4fd-49fb-a290-549edd456c6a">Resolving Assembly Loads</a></format>.</para>
          <para>Beginning with the net_v40_long, the <see cref="P:System.ResolveEventArgs.RequestingAssembly" /> property returns the assembly that requested the assembly load that could not be resolved. For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path. Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available. For more information, see <see cref="P:System.ResolveEventArgs.RequestingAssembly" />.</para>
          <block subset="none" type="note">
            <para>Beginning with the net_v40_short, the <see cref="T:System.ResolveEventHandler" /> event is raised for all assemblies, including resource assemblies. In earlier versions, the event was not raised for resource assemblies. If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</para>
          </block>
          <para>For this event, the <see cref="P:System.ResolveEventArgs.Name" /> property returns the assembly name before policy is applied.</para>
          <block subset="none" type="note">
            <para>If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't null. Subsequent event handlers are ignored. </para>
          </block>
          <para>For more information about handling events, see <format type="text/html"><a href="01E4F1BC-E55E-413F-98C7-6588493E5F67">Events Overview</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when the resolution of an assembly fails.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property corresponds to the <see cref="P:System.AppDomainSetup.ApplicationBase" /> property. It can also be retrieved using the <see cref="M:System.AppDomain.GetData(System.String)" /> method with the string "APPBASE".</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the base directory that the assembly resolver uses to probe for assemblies.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</para>
          <para>For more information, see <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Resets the path that specifies the location of private assemblies to the empty string ("").</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The shadow copy path is a list of directories where shadow copied assemblies are stored.</para>
          <para>For more information, see <see cref="P:System.AppDomainSetup.ShadowCopyDirectories" /> and <format type="text/html"><a href="de8b8759-fca7-4260-896b-5a4973157672">Shadow Copying Assemblies</a></format>. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Resets the list of directories containing shadow copied assemblies to the empty string ("").</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to create objects remotely without having to load the type locally.</para>
          <para>The return value must to be unwrapped to access the real object.</para>
          <para>A <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute with a value of true must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <see cref="T:System.TypeLoadException" /> is thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of a specified COM type. Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of a file containing an assembly that defines the requested type. </param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the requested type. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to create objects remotely without having to load the type locally.</para>
          <para>The return value must to be unwrapped to access the real object.</para>
          <para>A <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute with a value of true must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <see cref="T:System.TypeLoadException" /> is thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of a specified COM type. Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of a file containing an assembly that defines the requested type. </param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the requested type. </param>
        <param name="hashValue">
          <attribution license="cc4" from="Microsoft" modified="false" />Represents the value of the computed hash code. </param>
        <param name="hashAlgorithm">
          <attribution license="cc4" from="Microsoft" modified="false" />Represents the hash algorithm used by the assembly manifest. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.AppDomain CreateDomain(string friendlyName)" />
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> is <see langword="null" /> .</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="friendlyName" /> parameter is intended to identify the domain in a manner that is meaningful to humans. This string should be suitable for display in user interfaces.</para>
          <para>This method overload uses the <see cref="T:System.AppDomainSetup" /> information from the default application domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new application domain with the specified name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The newly created application domain.</para>
        </returns>
        <param name="friendlyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The friendly name of the domain. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overload uses the <see cref="T:System.AppDomainSetup" /> information from the default application domain.</para>
          <para>If <paramref name="securityInfo" /> is not supplied, the evidence from the current application domain is used.</para>
          <block subset="none" type="note">
            <para>Do not use this method overload to create sandboxed application domains. Beginning with the net_v40_long, the evidence that is supplied for <paramref name="securityInfo" /> no longer affects the grant set of the application domain. Use the <see cref="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" /> method overload to create sandboxed application domains.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new application domain with the given name using the supplied evidence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The newly created application domain.</para>
        </returns>
        <param name="friendlyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <see cref="P:System.AppDomain.FriendlyName" />. </param>
        <param name="securityInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence that establishes the identity of the code that runs in the application domain. Pass null to use the evidence of the current application domain.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="info" /> is not supplied, this method overload uses the <see cref="T:System.AppDomainSetup" /> information from the default application domain.</para>
          <para>If <paramref name="securityInfo" /> is not supplied, the evidence from the current application domain is used.</para>
          <block subset="none" type="note">
            <para>Do not use this method overload to create sandboxed application domains. Beginning with the net_v40_long, the evidence that is supplied for <paramref name="securityInfo" /> no longer affects the grant set of the application domain. Use the <see cref="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" /> method overload to create sandboxed application domains.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new application domain using the specified name, evidence, and application domain setup information.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The newly created application domain.</para>
        </returns>
        <param name="friendlyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <see cref="P:System.AppDomain.FriendlyName" />. </param>
        <param name="securityInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence that establishes the identity of the code that runs in the application domain. Pass null to use the evidence of the current application domain.</param>
        <param name="info">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains application domain initialization information. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You must set the <see cref="P:System.AppDomainSetup.ApplicationBase" /> property of the <see cref="T:System.AppDomainSetup" /> object that you supply for <paramref name="info" />. Otherwise, an exception is thrown. </para>
          <para>If <paramref name="securityInfo" /> is not supplied, the evidence from the current application domain is used.</para>
          <para>The information provided for <paramref name="grantSet" /> and <paramref name="fullTrustAssemblies" /> is used to create an <see cref="T:System.Security.Policy.ApplicationTrust" /> object for the new application domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The newly created application domain.</para>
        </returns>
        <param name="friendlyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see the description of <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence that establishes the identity of the code that runs in the application domain. Pass null to use the evidence of the current application domain.</param>
        <param name="info">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that contains application domain initialization information.</param>
        <param name="grantSet">
          <attribution license="cc4" from="Microsoft" modified="false" />A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants. </param>
        <param name="fullTrustAssemblies">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of strong names representing assemblies to be considered fully trusted in the new application domain.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="securityInfo" /> is not supplied, the evidence from the current application domain is used.</para>
          <para>For more information about shadow copying, see <see cref="P:System.AppDomain.ShadowCopyFiles" /> and <format type="text/html"><a href="de8b8759-fca7-4260-896b-5a4973157672">Shadow Copying Assemblies</a></format>. </para>
          <block subset="none" type="note">
            <para>Do not use this method overload to create sandboxed application domains. Beginning with the net_v40_long, the evidence that is supplied for <paramref name="securityInfo" /> no longer affects the grant set of the application domain. Use the <see cref="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" /> method overload to create sandboxed application domains.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The newly created application domain.</para>
        </returns>
        <param name="friendlyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <see cref="P:System.AppDomain.FriendlyName" />. </param>
        <param name="securityInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence that establishes the identity of the code that runs in the application domain. Pass null to use the evidence of the current application domain.</param>
        <param name="appBasePath">
          <attribution license="cc4" from="Microsoft" modified="false" />The base directory that the assembly resolver uses to probe for assemblies. For more information, see <see cref="P:System.AppDomain.BaseDirectory" />. </param>
        <param name="appRelativeSearchPath">
          <attribution license="cc4" from="Microsoft" modified="false" />The path relative to the base directory where the assembly resolver should probe for private assemblies. For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />. </param>
        <param name="shadowCopyFiles">
          <attribution license="cc4" from="Microsoft" modified="false" />If true, a shadow copy of an assembly is loaded into this application domain. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method represented by <paramref name="adInit" /> is executed in the context of the newly created application domain.</para>
          <para>If <paramref name="securityInfo" /> is not supplied, the evidence from the current application domain is used.</para>
          <para>For more information about shadow copying, see <see cref="P:System.AppDomain.ShadowCopyFiles" /> and <format type="text/html"><a href="de8b8759-fca7-4260-896b-5a4973157672">Shadow Copying Assemblies</a></format>.</para>
          <block subset="none" type="note">
            <para>Do not use this method overload to create sandboxed application domains. Beginning with the net_v40_long, the evidence that is supplied for <paramref name="securityInfo" /> no longer affects the grant set of the application domain. Use the <see cref="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" /> method overload to create sandboxed application domains.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain. Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The newly created application domain.</para>
        </returns>
        <param name="friendlyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The friendly name of the domain. This friendly name can be displayed in user interfaces to identify the domain. For more information, see <see cref="P:System.AppDomain.FriendlyName" />. </param>
        <param name="securityInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence that establishes the identity of the code that runs in the application domain. Pass null to use the evidence of the current application domain.</param>
        <param name="appBasePath">
          <attribution license="cc4" from="Microsoft" modified="false" />The base directory that the assembly resolver uses to probe for assemblies. For more information, see <see cref="P:System.AppDomain.BaseDirectory" />. </param>
        <param name="appRelativeSearchPath">
          <attribution license="cc4" from="Microsoft" modified="false" />The path relative to the base directory where the assembly resolver should probe for private assemblies. For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />. </param>
        <param name="shadowCopyFiles">
          <attribution license="cc4" from="Microsoft" modified="false" />true to load a shadow copy of an assembly into the application domain. </param>
        <param name="adInit">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.AppDomainInitializer" /> delegate that represents a callback method to invoke when the new <see cref="T:System.AppDomain" /> object is initialized.</param>
        <param name="adInitArgs">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of string arguments to be passed to the callback represented by <paramref name="adInit" />, when the new <see cref="T:System.AppDomain" /> object is initialized.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method calls the default constructor for <paramref name="typeName" />.</para>
          <para>See <see cref="T:System.Reflection.AssemblyName" /> for the format of <paramref name="assemblyName" />.</para>
          <para>An attempt to call <see cref="M:System.AppDomain.CreateInstance(System.String,System.String)" /> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain. Since an <see cref="T:System.Reflection.Assembly" /> is not <see cref="T:System.MarshalByRefObject" />, when this method attempts to return the <see cref="T:System.Reflection.Assembly" /> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail. The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method calls the default constructor for <paramref name="typeName" />.</para>
          <para>See <see cref="T:System.Reflection.AssemblyName" /> for the format of <paramref name="assemblyName" />.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <para>An attempt to call <see cref="M:System.AppDomain.CreateInstance(System.String,System.String)" /> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain. Since an <see cref="T:System.Reflection.Assembly" /> is not <see cref="T:System.MarshalByRefObject" />, when this method attempts to return the <see cref="T:System.Reflection.Assembly" /> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail. The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly. A parameter specifies an array of activation attributes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object.  </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>See <see cref="T:System.Reflection.AssemblyName" /> for the format of <paramref name="assemblyName" />.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <para>An attempt to call <see cref="M:System.AppDomain.CreateInstance(System.String,System.String)" /> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain. Since an <see cref="T:System.Reflection.Assembly" /> is not <see cref="T:System.MarshalByRefObject" />, when this method attempts to return the <see cref="T:System.Reflection.Assembly" /> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail. The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly. Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean value specifying whether to perform a case-sensitive search or not. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor. If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection. If <paramref name="binder" /> is null, the default binder is used. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <paramref name="args" /> must be an empty array or null. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor. If <paramref name="culture" /> is null, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>See <see cref="T:System.Reflection.AssemblyName" /> for the format of <paramref name="assemblyName" />.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>. </para>
          <para>An attempt to call <see cref="M:System.AppDomain.CreateInstance(System.String,System.String)" /> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain. Since an <see cref="T:System.Reflection.Assembly" /> is not <see cref="T:System.MarshalByRefObject" />, when this method attempts to return the <see cref="T:System.Reflection.Assembly" /> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail. The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly. Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is a wrapper for the new instance specified by <paramref name="typeName" />. The return value needs to be unwrapped to access the real object.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean value specifying whether to perform a case-sensitive search or not. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor. If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection. If <paramref name="binder" /> is null, the default binder is used. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <paramref name="args" /> must be an empty array or null. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor. If <paramref name="culture" /> is null, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object.  </param>
        <param name="securityAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />Information used to authorize creation of <paramref name="typeName" />. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a convenience method that combines <see cref="M:System.AppDomain.CreateInstance(System.String,System.String)" /> and <see cref="M:System.Runtime.Remoting.ObjectHandle.Unwrap" />. This method calls the default constructor for <paramref name="typeName" />.</para>
          <para>See <see cref="T:System.Reflection.AssemblyName" /> for the format of <paramref name="assemblyName" />. See the <see cref="P:System.Type.FullName" /> property for the format of <paramref name="typeName" />.</para>
          <block subset="none" type="note">
            <para>If you make an early-bound call to a method M of an object of type T1 that was returned by <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />, and that method makes an early-bound call to a method of an object of type T2 in an assembly C other than the current assembly or the assembly containing T1, assembly C is loaded into the current application domain. This loading occurs even if the early-bound call to T1.M() was made in the body of a <see cref="T:System.Reflection.Emit.DynamicMethod" />, or in other dynamically generated code. If the current domain is the default domain, assembly C cannot be unloaded until the process ends. If the current domain later attempts to load assembly C, the load might fail. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type. Parameters specify the assembly where the type is defined, and the name of the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance of the object specified by <paramref name="typeName" />.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a convenience method that combines <see cref="M:System.AppDomain.CreateInstance(System.String,System.String)" /> and <see cref="M:System.Runtime.Remoting.ObjectHandle.Unwrap" />. This method calls the default constructor for <paramref name="typeName" />.</para>
          <para>See <see cref="T:System.Reflection.AssemblyName" /> for the format of <paramref name="assemblyName" />. See the <see cref="P:System.Type.FullName" /> property for the format of <paramref name="typeName" />.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <block subset="none" type="note">
            <para>If you make an early-bound call to a method M of an object of type T1 that was returned by <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />, and that method makes an early-bound call to a method of an object of type T2 in an assembly C other than the current assembly or the assembly containing T1, assembly C is loaded into the current application domain. This loading occurs even if the early-bound call to T1.M() was made in the body of a <see cref="T:System.Reflection.Emit.DynamicMethod" />, or in other dynamically generated code. If the current domain is the default domain, assembly C cannot be unloaded until the process ends. If the current domain later attempts to load assembly C, the load might fail. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type. Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance of the object specified by <paramref name="typeName" />.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object.  </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a convenience method that combines <see cref="M:System.AppDomain.CreateInstance(System.String,System.String)" /> and <see cref="M:System.Runtime.Remoting.ObjectHandle.Unwrap" />. </para>
          <para>See <see cref="T:System.Reflection.AssemblyName" /> for the format of <paramref name="assemblyName" />. See the <see cref="P:System.Type.FullName" /> property for the format of <paramref name="typeName" />.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <block subset="none" type="note">
            <para>If you make an early-bound call to a method M of an object of type T1 that was returned by <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />, and that method makes an early-bound call to a method of an object of type T2 in an assembly C other than the current assembly or the assembly containing T1, assembly C is loaded into the current application domain. This loading occurs even if the early-bound call to T1.M() was made in the body of a <see cref="T:System.Reflection.Emit.DynamicMethod" />, or in other dynamically generated code. If the current domain is the default domain, assembly C cannot be unloaded until the process ends. If the current domain later attempts to load assembly C, the load might fail. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance of the object specified by <paramref name="typeName" />.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean value specifying whether to perform a case-sensitive search or not. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor. If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection. If <paramref name="binder" /> is null, the default binder is used. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <paramref name="args" /> must be an empty array or null. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />A culture-specific object used to govern the coercion of types. If <paramref name="culture" /> is null, the CultureInfo for the current thread is used. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a convenience method that combines <see cref="M:System.AppDomain.CreateInstance(System.String,System.String)" /> and <see cref="M:System.Runtime.Remoting.ObjectHandle.Unwrap" />. </para>
          <para>See <see cref="T:System.Reflection.AssemblyName" /> for the format of <paramref name="assemblyName" />. See the <see cref="P:System.Type.FullName" /> property for the format of <paramref name="typeName" />.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <block subset="none" type="note">
            <para>If you make an early-bound call to a method M of an object of type T1 that was returned by <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />, and that method makes an early-bound call to a method of an object of type T2 in an assembly C other than the current assembly or the assembly containing T1, assembly C is loaded into the current application domain. This loading occurs even if the early-bound call to T1.M() was made in the body of a <see cref="T:System.Reflection.Emit.DynamicMethod" />, or in other dynamically generated code. If the current domain is the default domain, assembly C cannot be unloaded until the process ends. If the current domain later attempts to load assembly C, the load might fail. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type. Parameters specify the name of the type, and how it is found and created.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance of the object specified by <paramref name="typeName" />.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean value specifying whether to perform a case-sensitive search or not. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor. If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection. If <paramref name="binder" /> is null, the default binder is used. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <paramref name="args" /> must be an empty array or null. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />A culture-specific object used to govern the coercion of types. If <paramref name="culture" /> is null, the CultureInfo for the current thread is used. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object.  </param>
        <param name="securityAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />Information used to authorize creation of <paramref name="typeName" />. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The default constructor for <paramref name="typeName" /> is invoked.</para>
          <para>For more information, see the <see cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" /> method.</para>
          <para>When the <see cref="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" /> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain. However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain. For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound. When the assembly is loaded into the calling application domain, exceptions can occur.</para>
          <list type="bullet">
            <item>
              <para>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <see cref="T:System.MissingMethodException" /> can occur. </para>
            </item>
            <item>
              <para>If the calling application domain makes early-bound calls to the instance type, <see cref="T:System.InvalidCastException" /> can be thrown when an attempt is made to cast the instance.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is a wrapper for the new instance, or null if <paramref name="typeName" /> is not found. The return value needs to be unwrapped to access the real object.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name, including the path, of a file that contains an assembly that defines the requested type. The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />  method.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The default constructor for <paramref name="typeName" /> is invoked.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <para>For more information about this method, see the <see cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" /> method.</para>
          <para>When the <see cref="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" /> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain. However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain. For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound. When the assembly is loaded into the calling application domain, exceptions can occur.</para>
          <list type="bullet">
            <item>
              <para>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <see cref="T:System.MissingMethodException" /> can occur. </para>
            </item>
            <item>
              <para>If the calling application domain makes early-bound calls to the instance type, <see cref="T:System.InvalidCastException" /> can be thrown when an attempt is made to cast the instance.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is a wrapper for the new instance, or null if <paramref name="typeName" /> is not found. The return value needs to be unwrapped to access the real object.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name, including the path, of a file that contains an assembly that defines the requested type. The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />  method. </param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object.  </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For more information, see the <see cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" /> method.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <para>When the <see cref="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" /> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain. However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain. For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound. When the assembly is loaded into the calling application domain, exceptions can occur. </para>
          <list type="bullet">
            <item>
              <para>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <see cref="T:System.MissingMethodException" /> can occur. </para>
            </item>
            <item>
              <para>If the calling application domain makes early-bound calls to the instance type, <see cref="T:System.InvalidCastException" /> can be thrown when an attempt is made to cast the instance.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is a wrapper for the new instance, or null if <paramref name="typeName" /> is not found. The return value needs to be unwrapped to access the real object.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name, including the path, of a file that contains an assembly that defines the requested type. The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />  method.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean value specifying whether to perform a case-sensitive search or not. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor. If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection. If <paramref name="binder" /> is null, the default binder is used. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <paramref name="args" /> must be an empty array or null. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor. If <paramref name="culture" /> is null, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For more information about this method, see the <see cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" /> method.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <para>When the <see cref="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" /> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain. However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain. For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound. When the assembly is loaded into the calling application domain, exceptions can occur. </para>
          <list type="bullet">
            <item>
              <para>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <see cref="T:System.MissingMethodException" /> can occur. </para>
            </item>
            <item>
              <para>If the calling application domain makes early-bound calls to the instance type, <see cref="T:System.InvalidCastException" /> can be thrown when an attempt is made to cast the instance.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is a wrapper for the new instance, or null if <paramref name="typeName" /> is not found. The return value needs to be unwrapped to access the real object.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name, including the path, of a file that contains an assembly that defines the requested type. The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />  method.</param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean value specifying whether to perform a case-sensitive search or not. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor. If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection. If <paramref name="binder" /> is null, the default binder is used. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <paramref name="args" /> must be an empty array or null. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor. If <paramref name="culture" /> is null, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object.  </param>
        <param name="securityAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />Information used to authorize creation of <paramref name="typeName" />. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a convenience method that combines <see cref="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" /> and <see cref="M:System.Runtime.Remoting.ObjectHandle.Unwrap" />. This method calls the default constructor for <paramref name="typeName" />.</para>
          <para>For more information, see the <see cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The requested object, or null if <paramref name="typeName" /> is not found.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The file name and path of the assembly that defines the requested type. </param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a convenience method that combines <see cref="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" /> and <see cref="M:System.Runtime.Remoting.ObjectHandle.Unwrap" />. This method calls the default constructor for <paramref name="typeName" />.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <para>For more information about this method, see the <see cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The requested object, or null if <paramref name="typeName" /> is not found.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The file name and path of the assembly that defines the requested type. </param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly (see the <see cref="P:System.Type.FullName" /> property). </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object.  </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a convenience method that combines <see cref="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" /> and <see cref="M:System.Runtime.Remoting.ObjectHandle.Unwrap" />. </para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <para>For more information about this method, see the <see cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The requested object, or null if <paramref name="typeName" /> is not found.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The file name and path of the assembly that defines the requested type. </param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean value specifying whether to perform a case-sensitive search or not. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor. If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection. If <paramref name="binder" /> is null, the default binder is used. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <paramref name="args" /> must be an empty array or null. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor. If <paramref name="culture" /> is null, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This is a convenience method that combines <see cref="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" /> and <see cref="M:System.Runtime.Remoting.ObjectHandle.Unwrap" />.</para>
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
          <para>For more information about this method, see the <see cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of the specified type defined in the specified assembly file.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The requested object, or null if <paramref name="typeName" /> is not found.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The file name and path of the assembly that defines the requested type. </param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />A Boolean value specifying whether to perform a case-sensitive search or not. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor. If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection. If <paramref name="binder" /> is null, the default binder is used. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to pass to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to invoke. If the default constructor is preferred, <paramref name="args" /> must be an empty array or null. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor. If <paramref name="culture" /> is null, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used. </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object.  </param>
        <param name="securityAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />Information used to authorize creation of <paramref name="typeName" />. </param>
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the current application domain for the current <see cref="T:System.Threading.Thread" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload. </para>
          <block subset="none" type="note">
            <para>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <see cref="Overload:System.AppDomain.DefineDynamicAssembly" /> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in <paramref name="refusedPermissions" />. Including <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in the <paramref name="refusedPermissions" /> parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <see cref="T:System.Security.SecurityException" /> to be thrown when used with code that demands full trust.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly with the specified name and access mode.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and access mode.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The access mode for the dynamic assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created. For example, security attributes such as <see cref="T:System.Security.SecurityTransparentAttribute" /> and <see cref="T:System.Security.SecurityCriticalAttribute" /> do not work correctly if they are added after a dynamic assembly has been created. </para>
          <para>This method should be used only to define a dynamic assembly in the current application domain. For more information about this restriction, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload. </para>
          <para>This method overload is introduced in the net_v35_long. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly with the specified name, access mode, and custom attributes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The access mode for the dynamic assembly. </param>
        <param name="assemblyAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An enumerable list of attributes to be applied to the assembly, or null if there are no attributes.</param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Only fully trusted callers can supply their <paramref name="evidence" /> when defining a dynamic <see cref="T:System.Reflection.Assembly" />. The runtime will map the <see cref="T:System.Security.Policy.Evidence" /> through the security policy to determine the granted permissions. Partially trusted callers must supply a null <paramref name="evidence" />. If <paramref name="evidence" /> is null, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <see cref="T:System.Reflection.Assembly" /> to the dynamic <see cref="T:System.Reflection.Assembly" /> being defined and marks policy as resolved.</para>
          <para>If the dynamic <see cref="T:System.Reflection.Assembly" /> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <see cref="T:System.Reflection.Assembly" /> was saved.</para>
          <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
          <block subset="none" type="note">
            <para>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <see cref="Overload:System.AppDomain.DefineDynamicAssembly" /> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in <paramref name="refusedPermissions" />. Including <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in the <paramref name="refusedPermissions" /> parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <see cref="T:System.Security.SecurityException" /> to be thrown when used with code that demands full trust.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly using the specified name, access mode, and evidence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The mode in which the dynamic assembly will be accessed. </param>
        <param name="evidence">
          <attribution license="cc4" from="Microsoft" modified="false" />The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
          <block subset="none" type="note">
            <para>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <see cref="Overload:System.AppDomain.DefineDynamicAssembly" /> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in <paramref name="refusedPermissions" />. Including <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in the <paramref name="refusedPermissions" /> parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <see cref="T:System.Security.SecurityException" /> to be thrown when used with code that demands full trust.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly using the specified name, access mode, and storage directory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The mode in which the dynamic assembly will be accessed. </param>
        <param name="dir">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the directory where the assembly will be saved. If <paramref name="dir" /> is null, the directory defaults to the current directory. </param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created. For example, security attributes such as <see cref="T:System.Security.SecurityTransparentAttribute" /> and <see cref="T:System.Security.SecurityCriticalAttribute" /> do not work correctly if they are added after a dynamic assembly has been created. </para>
          <para>This method should be used only to define a dynamic assembly in the current application domain. For more information about this restriction, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The access mode for the dynamic assembly. </param>
        <param name="assemblyAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An enumerable list of attributes to be applied to the assembly, or null if there are no attributes.</param>
        <param name="securityContextSource">
          <attribution license="cc4" from="Microsoft" modified="false" />The source of the security context.</param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Only fully trusted callers can supply their <paramref name="evidence" /> when defining a dynamic <see cref="T:System.Reflection.Assembly" />. The runtime will map the <see cref="T:System.Security.Policy.Evidence" /> through the security policy to determine the granted permissions. Partially trusted callers must supply a null <paramref name="evidence" />. If <paramref name="evidence" /> is null, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <see cref="T:System.Reflection.Assembly" /> to the dynamic <see cref="T:System.Reflection.Assembly" /> being defined and marks policy as resolved.</para>
          <para>If the dynamic <see cref="T:System.Reflection.Assembly" /> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <see cref="T:System.Reflection.Assembly" /> was saved.</para>
          <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
          <block subset="none" type="note">
            <para>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <see cref="Overload:System.AppDomain.DefineDynamicAssembly" /> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in <paramref name="refusedPermissions" />. Including <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in the <paramref name="refusedPermissions" /> parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <see cref="T:System.Security.SecurityException" /> to be thrown when used with code that demands full trust.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The mode in which the dynamic assembly will be accessed. </param>
        <param name="dir">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the directory where the assembly will be saved. If <paramref name="dir" /> is null, the directory defaults to the current directory. </param>
        <param name="evidence">
          <attribution license="cc4" from="Microsoft" modified="false" />The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The permission requests specified for <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> are not used unless the dynamic assembly has been saved and reloaded into memory. To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <see cref="Overload:System.AppDomain.DefineDynamicAssembly" /> method that specifies evidence as well as requested permissions, and supply an <see cref="T:System.Security.Policy.Evidence" /> object.</para>
          <block subset="none" type="note">
            <para>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <see cref="Overload:System.AppDomain.DefineDynamicAssembly" /> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in <paramref name="refusedPermissions" />. Including <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in the <paramref name="refusedPermissions" /> parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <see cref="T:System.Security.SecurityException" /> to be thrown when used with code that demands full trust.</para>
          </block>
          <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload .</para>
          <block subset="none" type="note">
            <para>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a dynamic assembly by using the <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> parameters are stored in the old XML metadata format. See <format type="text/html"><a href="9eeddee8-ca89-4440-b84b-fd613f590cd5">Emitting Declarative Security Attributes</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly using the specified name, access mode, and permission requests.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The mode in which the dynamic assembly will be accessed. </param>
        <param name="requiredPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The required permissions request. </param>
        <param name="optionalPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The optional permissions request. </param>
        <param name="refusedPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The refused permissions request. </param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created. For example, security attributes such as <see cref="T:System.Security.SecurityTransparentAttribute" /> and <see cref="T:System.Security.SecurityCriticalAttribute" /> do not work correctly if they are added after a dynamic assembly has been created. </para>
          <para>If <paramref name="isSynchronized" /> is true, the following methods of the resulting <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> will be synchronized: <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule" />, <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.DefineResource" />, <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.AddResourceFile" />, <see cref="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)" />, <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint" />, and <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.Save" />. If two of these methods are called on different threads, one will block until the other is completed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The mode in which the dynamic assembly will be accessed. </param>
        <param name="dir">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the directory where the dynamic assembly will be saved. If <paramref name="dir" /> is null, the current directory is used. </param>
        <param name="isSynchronized">
          <attribution license="cc4" from="Microsoft" modified="false" />true to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, false. </param>
        <param name="assemblyAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An enumerable list of attributes to be applied to the assembly, or null if there are no attributes.</param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The permission requests specified for <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> are used only if <paramref name="evidence" /> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</para>
          <block subset="none" type="note">
            <para>During the development of code that emits dynamic assemblies, it is recommended that you include <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in <paramref name="refusedPermissions" />. Including <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in the <paramref name="refusedPermissions" /> parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <see cref="T:System.Security.SecurityException" /> to be thrown when used with code that demands full trust.</para>
          </block>
          <para>Only fully trusted callers can supply their <paramref name="evidence" /> when defining a dynamic <see cref="T:System.Reflection.Assembly" />. The runtime will map the <see cref="T:System.Security.Policy.Evidence" /> through the security policy to determine the granted permissions. Partially trusted callers must supply a null <paramref name="evidence" />. If <paramref name="evidence" /> is null, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <see cref="T:System.Reflection.Assembly" /> to the dynamic <see cref="T:System.Reflection.Assembly" /> being defined and marks policy as resolved.</para>
          <para>If the dynamic <see cref="T:System.Reflection.Assembly" /> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <see cref="T:System.Reflection.Assembly" /> was saved.</para>
          <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a dynamic assembly by using the <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> parameters are stored in the old XML metadata format. See <format type="text/html"><a href="9eeddee8-ca89-4440-b84b-fd613f590cd5">Emitting Declarative Security Attributes</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The mode in which the dynamic assembly will be accessed. </param>
        <param name="evidence">
          <attribution license="cc4" from="Microsoft" modified="false" />The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </param>
        <param name="requiredPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The required permissions request. </param>
        <param name="optionalPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The optional permissions request. </param>
        <param name="refusedPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The refused permissions request. </param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The permission requests specified for <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> are not used unless the dynamic assembly has been saved and reloaded into memory. To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <see cref="Overload:System.AppDomain.DefineDynamicAssembly" /> method that specifies evidence as well as requested permissions, and supply an <see cref="T:System.Security.Policy.Evidence" /> object.</para>
          <block subset="none" type="note">
            <para>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <see cref="Overload:System.AppDomain.DefineDynamicAssembly" /> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in <paramref name="refusedPermissions" />. Including <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in the <paramref name="refusedPermissions" /> parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <see cref="T:System.Security.SecurityException" /> to be thrown when used with code that demands full trust.</para>
          </block>
          <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a dynamic assembly by using the <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> parameters are stored in the old XML metadata format. See <format type="text/html"><a href="9eeddee8-ca89-4440-b84b-fd613f590cd5">Emitting Declarative Security Attributes</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The mode in which the dynamic assembly will be accessed. </param>
        <param name="dir">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the directory where the assembly will be saved. If <paramref name="dir" /> is null, the directory defaults to the current directory. </param>
        <param name="requiredPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The required permissions request. </param>
        <param name="optionalPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The optional permissions request. </param>
        <param name="refusedPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The refused permissions request. </param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The permission requests specified for <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> are used only if <paramref name="evidence" /> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</para>
          <block subset="none" type="note">
            <para>During the development of code that emits dynamic assemblies, it is recommended that you include <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in <paramref name="refusedPermissions" />. Including <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in the <paramref name="refusedPermissions" /> parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <see cref="T:System.Security.SecurityException" /> to be thrown when used with code that demands full trust.</para>
          </block>
          <para>Only fully trusted callers can supply their <paramref name="evidence" /> when defining a dynamic <see cref="T:System.Reflection.Assembly" />. The runtime will map the <see cref="T:System.Security.Policy.Evidence" /> through the security policy to determine the granted permissions. Partially trusted callers must supply a null <paramref name="evidence" />. If <paramref name="evidence" /> is null, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <see cref="T:System.Reflection.Assembly" /> to the dynamic <see cref="T:System.Reflection.Assembly" /> being defined and marks policy as resolved.</para>
          <para>If the dynamic <see cref="T:System.Reflection.Assembly" /> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <see cref="T:System.Reflection.Assembly" /> was saved.</para>
          <para>This method should only be used to define a dynamic assembly in the current application domain. For more information, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a dynamic assembly by using the <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> parameters are stored in the old XML metadata format. See <format type="text/html"><a href="9eeddee8-ca89-4440-b84b-fd613f590cd5">Emitting Declarative Security Attributes</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The mode in which the dynamic assembly will be accessed. </param>
        <param name="dir">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the directory where the assembly will be saved. If <paramref name="dir" /> is null, the directory defaults to the current directory. </param>
        <param name="evidence">
          <attribution license="cc4" from="Microsoft" modified="false" />The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </param>
        <param name="requiredPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The required permissions request. </param>
        <param name="optionalPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The optional permissions request. </param>
        <param name="refusedPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The refused permissions request. </param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The permission requests specified for <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> are used only if <paramref name="evidence" /> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</para>
          <block subset="none" type="note">
            <para>During the development of code that emits dynamic assemblies, it is recommended that you include <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in <paramref name="refusedPermissions" />. Including <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> in the <paramref name="refusedPermissions" /> parameter ensures that the MSIL is verified. A limitation of this technique is that it also causes <see cref="T:System.Security.SecurityException" /> to be thrown when used with code that demands full trust.</para>
          </block>
          <para>Only fully trusted callers can supply their evidence when defining a dynamic <see cref="T:System.Reflection.Assembly" />. The runtime will map the <see cref="T:System.Security.Policy.Evidence" /> through the security policy to determine the granted permissions. Partially trusted callers must supply null for the <paramref name="evidence" /> parameter. If <paramref name="evidence" /> is null, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <see cref="T:System.Reflection.Assembly" /> to the dynamic <see cref="T:System.Reflection.Assembly" /> being defined and marks policy as resolved.</para>
          <para>If the dynamic <see cref="T:System.Reflection.Assembly" /> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <see cref="T:System.Reflection.Assembly" /> was saved.</para>
          <para>If <paramref name="isSynchronized" /> is true, the following methods of the resulting <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> will be synchronized: <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule" />, <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.DefineResource" />, <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.AddResourceFile" />, <see cref="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)" />, <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint" />, and <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.Save" />. If two of these methods are called on different threads, one will block until the other completes.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a dynamic assembly by using the <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> parameters are stored in the old XML metadata format. See <format type="text/html"><a href="9eeddee8-ca89-4440-b84b-fd613f590cd5">Emitting Declarative Security Attributes</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The mode in which the dynamic assembly will be accessed. </param>
        <param name="dir">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the directory where the dynamic assembly will be saved. If <paramref name="dir" /> is null, the directory defaults to the current directory. </param>
        <param name="evidence">
          <attribution license="cc4" from="Microsoft" modified="false" />The evidence supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </param>
        <param name="requiredPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The required permissions request. </param>
        <param name="optionalPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The optional permissions request. </param>
        <param name="refusedPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The refused permissions request. </param>
        <param name="isSynchronized">
          <attribution license="cc4" from="Microsoft" modified="false" />true to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created. For example, security attributes such as <see cref="T:System.Security.SecurityTransparentAttribute" /> and <see cref="T:System.Security.SecurityCriticalAttribute" /> do not work correctly if they are added after a dynamic assembly has been created. </para>
          <para>The permission requests specified for the <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> parameters are used only if the <paramref name="evidence" /> parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</para>
          <block subset="none" type="note">
            <para>When you develop code that emits dynamic assemblies, we recommend that you include the <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SkipVerification" /> flag in the <paramref name="refusedPermissions" /> parameter. The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified. This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect. A limitation of this technique is that it also causes <see cref="T:System.Security.SecurityException" /> to be thrown when it is used with code that demands full trust.</para>
          </block>
          <para>Only fully trusted callers can supply evidence when defining a dynamic <see cref="T:System.Reflection.Assembly" />. The runtime maps the <see cref="T:System.Security.Policy.Evidence" /> through the security policy to determine the granted permissions. Partially trusted callers must supply null for the <paramref name="evidence" /> parameter. If <paramref name="evidence" /> is null, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved. </para>
          <para>If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</para>
          <para>If <paramref name="isSynchronized" /> is true, the following methods of the resulting <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> will be synchronized: <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule" />, <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.DefineResource" />, <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.AddResourceFile" />, <see cref="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)" />, <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint" />, and <see cref="Overload:System.Reflection.Emit.AssemblyBuilder.Save" />. If two of these methods are called on different threads, one will block until the other is completed.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a dynamic assembly by using the <paramref name="requiredPermissions" />, <paramref name="optionalPermissions" />, and <paramref name="refusedPermissions" /> parameters are stored in the old XML metadata format. For more information about these attributes, see <format type="text/html"><a href="9eeddee8-ca89-4440-b84b-fd613f590cd5">Emitting Declarative Security Attributes</a></format>.</para>
          </block>
          <para>This method overload is introduced in the net_v35_long. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A dynamic assembly with the specified name and features.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The unique identity of the dynamic assembly. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />The mode in which the dynamic assembly will be accessed. </param>
        <param name="dir">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the directory where the dynamic assembly will be saved. If <paramref name="dir" /> is null, the current directory is used. </param>
        <param name="evidence">
          <attribution license="cc4" from="Microsoft" modified="false" />The evidence that is supplied for the dynamic assembly. The evidence is used unaltered as the final set of evidence used for policy resolution. </param>
        <param name="requiredPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The required permissions request. </param>
        <param name="optionalPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The optional permissions request. </param>
        <param name="refusedPermissions">
          <attribution license="cc4" from="Microsoft" modified="false" />The refused permissions request. </param>
        <param name="isSynchronized">
          <attribution license="cc4" from="Microsoft" modified="false" />true to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, false. </param>
        <param name="assemblyAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An enumerable list of attributes to be applied to the assembly, or null if there are no attributes.</param>
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <paramref name="callBackDelegate" /> can specify a marshal-by-value, <see cref="T:System.MarshalByRefObject" />, or <see cref="T:System.ContextBoundObject" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the code in another application domain that is identified by the specified delegate.</para>
        </summary>
        <param name="callBackDelegate">
          <attribution license="cc4" from="Microsoft" modified="false" />A delegate that specifies a method to call. </param>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An unmanaged host of the common language runtime (CLR) can provide a domain manager. The domain manager can participate in initializing the new application domain and supply other managers, such as a <see cref="T:System.Security.HostSecurityManager" />, that participate in the operations of the application domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the domain manager that was provided by the host when the application domain was initialized.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="ILASM" Value=".event public event DomainUnload" />
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.EventHandler" /> delegate for this event can perform any termination activities before the application domain is unloaded.</para>
          <para>Each application domain that needs to perform processing when it is unloaded should register an event handler for this event. A shared event handler should not be used, because the <see cref="T:System.EventHandler" /> delegate does not identify the domain that is being unloaded.</para>
          <block subset="none" type="note">
            <para>This event is never raised in the default application domain.</para>
          </block>
          <para>Do not make assumptions about the thread the event is raised on. The event can be raised on a different thread than the one that called the <see cref="M:System.AppDomain.Unload(System.AppDomain)" /> method.</para>
          <para>To register an event handler for this event, you must have the required permissions, or a <see cref="T:System.Security.SecurityException" /> is thrown.</para>
          <para>For more information about handling events, see <format type="text/html"><a href="01E4F1BC-E55E-413F-98C7-6588493E5F67">Events Overview</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when an <see cref="T:System.AppDomain" /> is about to be unloaded.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To set the dynamic directory, assign a base directory path to the <see cref="P:System.AppDomainSetup.DynamicBase" /> property of the <see cref="T:System.AppDomainSetup" /> object that will be used to create the new application domain. The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <see cref="P:System.AppDomainSetup.ApplicationName" /> property, so the format of the base directory is original path\hash code. The dynamic directory is a subdirectory of this base directory. Its simple name is the value of the <see cref="P:System.AppDomainSetup.ApplicationName" /> property, so its format is original path\hash code\application name.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Security.Policy.Evidence" /> associated with this application domain.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          <para>This method loads assemblies using the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. You can also execute assemblies using the <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method, which loads assemblies using the <see cref="Overload:System.Reflection.Assembly.Load" /> method. </para>
          <para>To create the <see cref="T:System.AppDomain" /> to load and execute, use the <see cref="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the assembly contained in the specified file.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the file that contains the assembly to execute. </param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>The <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          <para>This method loads assemblies using the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. You can also execute assemblies using the <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method, which loads assemblies using the <see cref="Overload:System.Reflection.Assembly.Load" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the assembly contained in the specified file, using the specified evidence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the file that contains the assembly to execute. </param>
        <param name="assemblySecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          <para>This method loads assemblies using the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. You can also execute assemblies using the <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method, which loads assemblies using the <see cref="Overload:System.Reflection.Assembly.Load" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the assembly contained in the specified file, using the specified arguments.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value that is returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the file that contains the assembly to execute.</param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to the entry point of the assembly.</param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          <para>This method loads assemblies using the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. You can also execute assemblies using the <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method, which loads assemblies using the <see cref="Overload:System.Reflection.Assembly.Load" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the assembly contained in the specified file, using the specified evidence and arguments.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the file that contains the assembly to execute. </param>
        <param name="assemblySecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />The supplied evidence for the assembly. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to the entry point of the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          <para>This method loads assemblies using the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. You can also execute assemblies using the <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method, which loads assemblies using the <see cref="Overload:System.Reflection.Assembly.Load" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value that is returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the file that contains the assembly to execute.</param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to the entry point of the assembly. </param>
        <param name="hashValue">
          <attribution license="cc4" from="Microsoft" modified="false" />Represents the value of the computed hash code. </param>
        <param name="hashAlgorithm">
          <attribution license="cc4" from="Microsoft" modified="false" />Represents the hash algorithm used by the assembly manifest. </param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          <para>This method loads assemblies using the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. You can also execute assemblies using the <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method, which loads assemblies using the <see cref="Overload:System.Reflection.Assembly.Load" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the file that contains the assembly to execute. </param>
        <param name="assemblySecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />The supplied evidence for the assembly. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />The arguments to the entry point of the assembly. </param>
        <param name="hashValue">
          <attribution license="cc4" from="Microsoft" modified="false" />Represents the value of the computed hash code. </param>
        <param name="hashAlgorithm">
          <attribution license="cc4" from="Microsoft" modified="false" />Represents the hash algorithm used by the assembly manifest. </param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method provides similar functionality to the <see cref="Overload:System.AppDomain.ExecuteAssembly" /> method, but specifies the assembly by display name or <see cref="T:System.Reflection.AssemblyName" /> rather than by file location. Therefore, <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> loads assemblies with the <see cref="Overload:System.Reflection.Assembly.Load" /> method rather than with the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. </para>
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          <para>To create the <see cref="T:System.AppDomain" /> to load and execute, use the <see cref="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes an assembly given its display name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method provides similar functionality to the <see cref="Overload:System.AppDomain.ExecuteAssembly" /> method, but specifies the assembly by display name or <see cref="T:System.Reflection.AssemblyName" /> rather than by file location. Therefore, <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> loads assemblies with the <see cref="Overload:System.Reflection.Assembly.Load" /> method rather than with the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. </para>
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified arguments.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value that is returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />Command-line arguments to pass when starting the process.</param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method provides similar functionality to the <see cref="Overload:System.AppDomain.ExecuteAssembly" /> method, but specifies the assembly by display name or <see cref="T:System.Reflection.AssemblyName" /> rather than by file location. Therefore, <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> loads assemblies with the <see cref="Overload:System.Reflection.Assembly.Load" /> method rather than with the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. </para>
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>The <see cref="M:System.AppDomain.ExecuteAssemblyByName(System.String)" /> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          <block subset="none" type="note">
            <para>When you use the <see cref="M:System.AppDomain.ExecuteAssemblyByName(System.String)" /> method with an <see cref="T:System.Security.Policy.Evidence" /> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <see cref="M:System.AppDomain.ExecuteAssemblyByName(System.String)" /> method supersede pieces of evidence supplied by the loader.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes an assembly given its display name, using the specified evidence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method provides similar functionality to the <see cref="Overload:System.AppDomain.ExecuteAssembly" /> method, but specifies the assembly by display name or <see cref="T:System.Reflection.AssemblyName" /> rather than by file location. Therefore, <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> loads assemblies with the <see cref="Overload:System.Reflection.Assembly.Load" /> method rather than with the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. </para>
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the assembly given its display name, using the specified arguments.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value that is returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />Command-line arguments to pass when starting the process.</param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method provides similar functionality to the <see cref="Overload:System.AppDomain.ExecuteAssembly" /> method, but specifies the assembly by display name or <see cref="T:System.Reflection.AssemblyName" /> rather than by file location. Therefore, <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> loads assemblies with the <see cref="Overload:System.Reflection.Assembly.Load" /> method rather than with the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. </para>
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          <block subset="none" type="note">
            <para>When you use the <see cref="M:System.AppDomain.ExecuteAssemblyByName(System.String)" /> method with an <see cref="T:System.Security.Policy.Evidence" /> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <see cref="M:System.AppDomain.ExecuteAssemblyByName(System.String)" /> method supersede pieces of evidence supplied by the loader.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified evidence and arguments.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly. </param>
        <param name="assemblySecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />Command-line arguments to pass when starting the process. </param>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> method provides similar functionality to the <see cref="Overload:System.AppDomain.ExecuteAssembly" /> method, but specifies the assembly by display name or <see cref="T:System.Reflection.AssemblyName" /> rather than by file location. Therefore, <see cref="Overload:System.AppDomain.ExecuteAssemblyByName" /> loads assemblies with the <see cref="Overload:System.Reflection.Assembly.Load" /> method rather than with the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method. </para>
          <para>The assembly begins executing at the entry point specified in the .NET Framework header.</para>
          <para>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</para>
          <block subset="none" type="note">
            <para>When you use the <see cref="M:System.AppDomain.ExecuteAssemblyByName(System.String)" /> method with an <see cref="T:System.Security.Policy.Evidence" /> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <see cref="M:System.AppDomain.ExecuteAssemblyByName(System.String)" /> method supersede pieces of evidence supplied by the loader.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes the assembly given its display name, using the specified evidence and arguments.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value returned by the entry point of the assembly.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />Command-line arguments to pass when starting the process. </param>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="ILASM" Value=".property string FriendlyName { public final hidebysig virtual specialname string get_FriendlyName() }" />
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para> A <see cref="T:System.String" /> containing the friendly name of the current application domain.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The friendly name of the default application domain is the file name of the process executable. For example, if the executable used to start the process is "c:\MyAppDirectory\MyAssembly.exe", the friendly name of the default application domain is "MyAssembly.exe".</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the friendly name of this application domain.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the assemblies that have been loaded into the execution context of this application domain.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of assemblies in this application domain.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="P:System.Threading.Thread.ManagedThreadId" /> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the current thread identifier.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that is the identifier of the current thread.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <see cref="T:System.AppDomain" />.</para>
          <para>The cache automatically contains predefined system entries that are inserted when the application domain is created. You can inspect their values with the <see cref="M:System.AppDomain.GetData(System.String)" /> method, or the equivalent <see cref="T:System.AppDomainSetup" /> properties. </para>
          <para>You can insert or modify your own user defined name-data pairs with the <see cref="M:System.AppDomain.SetData(System.String,System.Object)" /> method and inspect their values with the <see cref="M:System.AppDomain.GetData(System.String)" /> method.</para>
          <para>The following table describes the <paramref name="name" /> of each predefined system entry and its corresponding <see cref="T:System.AppDomainSetup" /> property.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value of 'name' </para>
                </term>
                <description>
                  <para>Property </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>"APPBASE" </para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.ApplicationBase" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>"LOADER_OPTIMIZATION"</para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.LoaderOptimization" />
                </para>
              </description>
            </item>
            <item>
              <term>
                <para>"APP_CONFIG_FILE" </para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.ConfigurationFile" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>"DYNAMIC_BASE" </para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.DynamicBase" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>"DEV_PATH" </para>
              </term>
              <description>
                <para>(no property) </para>
              </description>
            </item>
            <item>
              <term>
                <para>"APP_NAME" </para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.ApplicationName" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>"PRIVATE_BINPATH" </para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.PrivateBinPath" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>"BINPATH_PROBE_ONLY" </para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.PrivateBinPathProbe" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>"SHADOW_COPY_DIRS" </para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.ShadowCopyDirectories" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>"FORCE_CACHE_INSTALL" </para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.ShadowCopyFiles" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>"CACHE_BASE" </para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.CachePath" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>(application specific) </para>
              </term>
              <description>
                <para>
                  <see cref="P:System.AppDomainSetup.LicenseFile" /> </para>
              </description>
            </item>
            <item>
              <term>
                <para>"APP_LAUNCH_URL"</para>
              </term>
              <description>
                <para>(no property)</para>
              </description>
            </item>
          </list>
          <block subset="none" type="note">
            <para>"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection. It is available only when the application has been launched with a browser such as Internet Explorer. Not all browsers provide this value.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the value stored in the current application domain for the specified name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value of the <paramref name="name" /> property, or null if the property does not exist.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of a predefined application domain property, or the name of an application domain property you have defined.</param>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type of the current instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type of the current instance.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an integer that uniquely identifies the application domain within the process. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gives the <see cref="T:System.AppDomain" /> an infinite lifetime by preventing a lease from being created.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Always null.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method tests whether the current application domain reverses breaking changes that were introduced in the net_v40_long. The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Switch</para>
                </term>
                <description>
                  <para>Meaning</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>"NetFx40_LegacySecurityPolicy"</para>
              </term>
              <description>
                <para>Code access security (CAS) for the net_v35_short is enabled in this application domain. See <format type="text/html"><a href="07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; Element</a></format>. </para>
              </description>
            </item>
            <item>
              <term>
                <para>"NetFx40_Legacy20SortingBehavior"</para>
              </term>
              <description>
                <para>String sorting defaults for the net_v35_short are enabled in this application domain. Its success requires sort00001000.dll to be installed.</para>
              </description>
            </item>
            <item>
              <term>
                <para>"NetFx40_Legacy40SortingBehavior"</para>
              </term>
              <description>
                <para>String sorting defaults for the net_v40_short and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.</para>
              </description>
            </item>
            <item>
              <term>
                <para>"NetFx40_TimeSpanLegacyFormatMode"</para>
              </term>
              <description>
                <para>
                  <see cref="T:System.TimeSpan" /> formatting behavior for the net_v35_short is enabled in this application domain.</para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A null reference (Nothing in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <paramref name="value" /> is set.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The compatibility switch to test.</param>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Every managed process has a default application domain. Execution begins in the default domain.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a value that indicates whether the application domain is the default application domain for the process.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current <see cref="T:System.AppDomain" /> object represents the default application domain for the process; otherwise, false.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected. After finalization, the object is accessible but in an invalid state and therefore unusable. Eventually, garbage collection completes and reclaims the object.</para>
          <para>An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded. The <see cref="M:System.AppDomain.IsFinalizingForUnload" /> method returns true only in the last case; it does not return true if finalization results from routine garbage collection or from CLR shutdown. </para>
          <block subset="none" type="note">
            <para>To determine whether finalization is due to CLR shutdown, use the <see cref="P:System.Environment.HasShutdownStarted" /> property. It returns true if finalization is due to an application domain being unloaded or to the CLR shutting down. </para>
          </block>
          <para>While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method. However, you cannot reliably do so because the accessed object might already have been finalized.</para>
          <block subset="none" type="note">
            <para>An exception to this rule is the <see cref="T:System.Console" /> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</para>
          </block>
          <para>Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading. If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, false.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method always returns true for the default application domain of an application that runs on the desktop. It returns false for a sandboxed application domain that was created by using the <see cref="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" /> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property returns true for sandboxed application domains that were created by using the <see cref="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" /> method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</para>
          <para>Fully trusted code can use the <see cref="P:System.AppDomain.PermissionSet" /> property to determine the homogenous grant set of a sandboxed application domain.</para>
          <para>This property also returns true for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Beginning with the net_v40_long, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain. </para>
          <para>This method should be used only to load an assembly into the current application domain. This method is provided as a convenience for interoperability callers who cannot call the static <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method. To load assemblies into other application domains, use a method such as <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />.</para>
          <para>For information that is common to all overloads of this method, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="rawAssembly">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type byte that is a COFF-based image containing an emitted assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method should be used only to load an assembly into the current application domain. This method is provided as a convenience for interoperability callers who cannot call the static <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method. To load assemblies into other application domains, use a method such as <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />.</para>
          <para>If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</para>
          <para>Supplying a partial assembly name for <paramref name="assemblyRef" /> is not recommended. (A partial name omits one or more of culture, version, or public key token. For overloads that take a string instead of an <see cref="T:System.Reflection.AssemblyName" /> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance. In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<see cref="P:System.AppDomain.BaseDirectory" /> or <see cref="P:System.AppDomainSetup.ApplicationBase" />).</para>
          <para>If the current <see cref="T:System.AppDomain" /> object represents application domain A, and the <see cref="Overload:System.AppDomain.Load" /> method is called from application domain B, the assembly is loaded into both application domains. For example, the following code loads MyAssembly into the new application domain ChildDomain and also into the application domain where the code executes:</para>
          <para>code reference: System.AppDomain.Load#1</para>
          <para>The assembly is loaded into both domains because <see cref="T:System.Reflection.Assembly" /> does not derive from <see cref="T:System.MarshalByRefObject" />, and therefore the return value of the <see cref="Overload:System.AppDomain.Load" /> method cannot be marshaled. Instead, the common language runtime tries to load the assembly into the calling application domain. The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</para>
          <block subset="none" type="note">
            <para>If both the <see cref="P:System.Reflection.AssemblyName.Name" /> property and the <see cref="P:System.Reflection.AssemblyName.CodeBase" /> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <see cref="P:System.Reflection.Assembly.FullName" /> property). If the file is not found, the <see cref="P:System.Reflection.AssemblyName.CodeBase" /> property is used to search for the assembly. If the assembly is found using <see cref="P:System.Reflection.AssemblyName.CodeBase" />, the display name is matched against the assembly. If the match fails, a <see cref="T:System.IO.FileLoadException" /> is thrown.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyRef">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that describes the assembly to load. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method should be used only to load an assembly into the current application domain. This method is provided as a convenience for interoperability callers who cannot call the static <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method. To load assemblies into other application domains, use a method such as <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />.</para>
          <para>For information that is common to all overloads of this method, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyString">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Beginning with the net_v40_long, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain. </para>
          <para>This method should be used only to load an assembly into the current application domain. This method is provided as a convenience for interoperability callers who cannot call the static <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method. To load assemblies into other application domains, use a method such as <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />.</para>
          <para>For information that is common to all overloads of this method, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />. The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="rawAssembly">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type byte that is a COFF-based image containing an emitted assembly. </param>
        <param name="rawSymbolStore">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type byte containing the raw bytes representing the symbols for the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method should be used only to load an assembly into the current application domain. This method is provided as a convenience for interoperability callers who cannot call the static <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method. To load assemblies into other application domains, use a method such as <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />.</para>
          <para>For information that is common to all overloads of this method, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyRef">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that describes the assembly to load. </param>
        <param name="assemblySecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method should be used only to load an assembly into the current application domain. This method is provided as a convenience for interoperability callers who cannot call the static <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method. To load assemblies into other application domains, use a method such as <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />.</para>
          <para>For information that is common to all overloads of this method, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyString">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. See <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Beginning with the net_v40_long, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain. </para>
          <para>This method should be used only to load an assembly into the current application domain. This method is provided as a convenience for interoperability callers who cannot call the static <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method. To load assemblies into other application domains, use a method such as <see cref="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />.</para>
          <para>For information that is common to all overloads of this method, see the <see cref="M:System.AppDomain.Load(System.Reflection.AssemblyName)" /> method overload.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />. The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="rawAssembly">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type byte that is a COFF-based image containing an emitted assembly. </param>
        <param name="rawSymbolStore">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of type byte containing the raw bytes representing the symbols for the assembly. </param>
        <param name="securityEvidence">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This static property (Shared property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</para>
          <para>If you attempt to set this property to false, a <see cref="T:System.ArgumentException" /> exception is thrown, even if the current value of the property is false.</para>
          <para>Once monitoring is enabled, you can use the <see cref="P:System.AppDomain.MonitoringSurvivedMemorySize" />, <see cref="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />, <see cref="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />, and <see cref="P:System.AppDomain.MonitoringTotalProcessorTime" /> instance properties to monitor CPU and memory use of individual application domains.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process. Once monitoring is enabled for a process, it cannot be disabled.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The statistics are updated with each garbage collection. However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs. For example, the <see cref="M:System.GC.Collect" /> method overload performs a full, blocking collection. (Concurrent collection occurs in the background and does not block the application.) </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps. It should be close to the number reported by the <see cref="M:System.GC.GetTotalMemory(System.Boolean)" /> method. After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the total bytes that survived from the last collection for all application domains in the process.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</para>
          <para>A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</para>
          <para>When a thread is blocked or sleeping, it does not consume processor time.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sandboxed application domains that were created by using the <see cref="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" /> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the permission set of a sandboxed application domain.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.EventHandler" /> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</para>
          <para>Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</para>
          <block subset="none" type="note">
            <para>The total execution time of all <see cref="E:System.AppDomain.ProcessExit" /> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown. The default is two seconds. An unmanaged host can change this execution time by calling the <format type="text/html"><a href="954404fd-d52d-4e68-b582-8692f3a5f608">ICLRPolicyManager::SetTimeout</a></format> method with the <format type="text/html"><a href="5aef6808-5aac-4b2f-a2c7-fee1575c55ed">OPR_ProcessExit</a></format> enumeration value.</para>
          </block>
          <para>In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</para>
          <para>To register an event handler for this event, you must have the required permissions, or a <see cref="T:System.Security.SecurityException" /> is thrown.</para>
          <para>For more information about handling events, see <format type="text/html"><a href="01E4F1BC-E55E-413F-98C7-6588493E5F67">Events Overview</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when the default application domain's parent process exits.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In the reflection-only context, dependencies are not resolved automatically. They must be preloaded or returned by the handler for this event. This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context. The missing dependency is specified by the <see cref="P:System.ResolveEventArgs.Name" /> property. The <see cref="T:System.ResolveEventHandler" /> for this event must return an assembly that satisfies the dependency. The assembly that is returned must be loaded into the reflection-only context.</para>
          <block subset="none" type="note">
            <para>This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <see cref="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" /> method). It is not raised if the assembly that you are loading cannot be found.</para>
          </block>
          <para>Beginning with the net_v40_long, the <see cref="P:System.ResolveEventArgs.RequestingAssembly" /> property returns the assembly that requested the assembly load that could not be resolved. Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available. For more information, see <see cref="P:System.ResolveEventArgs.RequestingAssembly" />.</para>
          <para>For this event, the <see cref="P:System.ResolveEventArgs.Name" /> property returns the assembly name before policy is applied.</para>
          <para>For more information about handling events, see <format type="text/html"><a href="01E4F1BC-E55E-413F-98C7-6588493E5F67">Consuming Events</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when the resolution of an assembly fails in the reflection-only context.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method returns the assemblies that have been loaded into the reflection-only context. To get the assemblies that have been loaded for execution, use the <see cref="M:System.AppDomain.GetAssemblies" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the assemblies that have been loaded into the reflection-only context of the application domain.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.Assembly" /> objects that represent the assemblies loaded into the reflection-only context of the application domain.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Private assemblies are deployed in the same directory structure as the application. If the path specified by the <see cref="P:System.AppDomain.RelativeSearchPath" /> property is not under <see cref="P:System.AppDomainSetup.ApplicationBase" />, it is ignored. </para>
          <para>This property returns the value set using <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the path under the base directory where the assembly resolver should probe for private assemblies.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.ResolveEventHandler" /> for this event can attempt to locate the assembly containing the resource and return it.</para>
          <block subset="none" type="note">
            <para>This event is not raised if resolution fails because no file can be found for a valid linked resource. It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found. </para>
          </block>
          <para>Beginning with the net_v40_long, the <see cref="P:System.ResolveEventArgs.RequestingAssembly" /> property contains the assembly that requested the resource. For more information, see <see cref="P:System.ResolveEventArgs.RequestingAssembly" />.</para>
          <para>To register an event handler for this event, you must have the required permissions, or a <see cref="T:System.Security.SecurityException" />  is thrown.</para>
          <para>For more information about handling events, see <format type="text/html"><a href="01E4F1BC-E55E-413F-98C7-6588493E5F67">Events Overview</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Call this method before an assembly is loaded into the <see cref="T:System.AppDomain" /> in order for the security policy to have effect.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Establishes the security policy level for this application domain.</para>
        </summary>
        <param name="domainPolicy">
          <attribution license="cc4" from="Microsoft" modified="false" />The security policy level. </param>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The cache path is ignored if the <see cref="P:System.AppDomainSetup.ApplicationName" /> property is not set. See the <see cref="P:System.AppDomainSetup.CachePath" /> property.</para>
          <para>For more information on shadow copying see <format type="text/html"><a href="de8b8759-fca7-4260-896b-5a4973157672">Shadow Copying Assemblies</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Establishes the specified directory path as the location where assemblies are shadow copied.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified path to the shadow copy location. </param>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <see cref="T:System.AppDomain" />.</para>
          <para>The cache automatically contains predefined system entries that are inserted when the application domain is created. You cannot insert or modify system entries with this method. You can inspect their values with the <see cref="M:System.AppDomain.GetData(System.String)" /> method, or the equivalent <see cref="T:System.AppDomainSetup" /> properties described in <see cref="M:System.AppDomain.GetData(System.String)" />. </para>
          <para>You can insert or modify your own user defined name-data pairs with this method and inspect their values with the <see cref="M:System.AppDomain.GetData(System.String)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Assigns the specified value to the specified application domain property.</para>
        </summary>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of a user-defined application domain property to create or change. </param>
        <param name="data">
          <attribution license="cc4" from="Microsoft" modified="false" />The value of the property. </param>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain. When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.</para>
          <para>You cannot use this method to assign a security demand to a system-defined property string.</para>
          <para>The cache automatically contains predefined system entries that are inserted when the application domain is created. You cannot insert or modify system entries with this method. You can inspect their values with the <see cref="M:System.AppDomain.GetData(System.String)" /> method or the equivalent <see cref="T:System.AppDomainSetup" /> properties described in the Remarks section for the <see cref="M:System.AppDomain.GetData(System.String)" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</para>
        </summary>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of a user-defined application domain property to create or change. </param>
        <param name="data">
          <attribution license="cc4" from="Microsoft" modified="false" />The value of the property. </param>
        <param name="permission">
          <attribution license="cc4" from="Microsoft" modified="false" />The permission to demand of the caller when the property is retrieved.</param>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method sets the <see cref="P:System.AppDomainSetup.DynamicBase" /> property of the internal <see cref="T:System.AppDomainSetup" /> associated with this instance.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored. </param>
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Setting this value will only be effective if you set it before using the <see cref="P:System.Threading.Thread.CurrentPrincipal" /> property. For example, if you set <see cref="P:System.Threading.Thread.CurrentPrincipal" /> to a given principal (for example, a generic principal) and then use the <see cref="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" /> method to set the <see cref="T:System.Security.Principal.PrincipalPolicy" /> to <see cref="F:System.Security.Principal.PrincipalPolicy.WindowsPrincipal" />, the current principal will remain the generic principal.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</para>
        </summary>
        <param name="policy">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Security.Principal.PrincipalPolicy" /> values that specifies the type of the principal object to attach to threads. </param>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For more information on shadow copying, see <format type="text/html"><a href="de8b8759-fca7-4260-896b-5a4973157672">Shadow Copying Assemblies</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Turns on shadow copying.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>By default, a shadow copy includes all assemblies found through probing. The <see cref="M:System.AppDomain.SetShadowCopyPath(System.String)" /> method restricts the shadow copy to the assemblies in the directories specified by <paramref name="path" />.</para>
          <para>The <see cref="M:System.AppDomain.SetShadowCopyPath(System.String)" /> method does not specify additional directories to be searched for assemblies. Assemblies to be shadow-copied must already be located in the search path, for example under <see cref="P:System.AppDomain.BaseDirectory" />. The <see cref="M:System.AppDomain.SetShadowCopyPath(System.String)" /> method specifies which search paths are eligible to be shadow-copied.</para>
          <para>This method sets the <see cref="P:System.AppDomainSetup.ShadowCopyDirectories" /> property of the internal <see cref="T:System.AppDomainSetup" /> associated with this instance.</para>
          <para>For more information on shadow copying, see <format type="text/html"><a href="de8b8759-fca7-4260-896b-5a4973157672">Shadow Copying Assemblies</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Establishes the specified directory path as the location of assemblies to be shadow copied.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />A list of directory names, where each name is separated by a semicolon. </param>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</para>
        </summary>
        <param name="principal">
          <attribution license="cc4" from="Microsoft" modified="false" />The principal object to attach to threads. </param>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the application domain configuration information for this instance.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For more information, see <see cref="P:System.AppDomainSetup.ShadowCopyFiles" /> and <format type="text/html"><a href="de8b8759-fca7-4260-896b-5a4973157672">Shadow Copying Assemblies</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an indication whether the application domain is configured to shadow copy files.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">To be added.</param>
        <param name="rgszNames">To be added.</param>
        <param name="cNames">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="rgDispId">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <unmanagedCodeEntityReference>IDispatch::GetTypeInfo</unmanagedCodeEntityReference>, see the MSDN Library.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the type information for an object, which can then be used to get the type information for an interface.</para>
        </summary>
        <param name="iTInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />The type information to return.</param>
        <param name="lcid">
          <attribution license="cc4" from="Microsoft" modified="false" />The locale identifier for the type information.</param>
        <param name="ppTInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />Receives a pointer to the requested type information object.</param>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">To be added.</param>
        <param name="riid">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="wFlags">To be added.</param>
        <param name="pDispParams">To be added.</param>
        <param name="pVarResult">To be added.</param>
        <param name="pExcepInfo">To be added.</param>
        <param name="puArgErr">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual string ToString()" />
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <para> The string returned by this method includes the friendly name of the
 application domain.
 </para>
          <para>
            <block subset="none" type="note">This method
 overrides <see cref="M:System.Object.ToString" />
 .</block>
          </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Obtains a string representation that includes the friendly name of the application domain and any context policies.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies." </para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="E:System.AppDomain.TypeResolve" /> event occurs when the common language runtime is unable to determine the assembly that can create the requested type. This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in. The latter situation can occur when <see cref="M:System.Type.GetType" /> is called with a type name that is not qualified with the assembly name.</para>
          <para>The <see cref="T:System.ResolveEventHandler" /> for this event can attempt to locate and create the type.</para>
          <para>However, the <see cref="E:System.AppDomain.TypeResolve" /> event does not occur if the runtime knows it is not possible to find a type in certain assemblies. For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</para>
          <para>Beginning with the net_v40_long, the <see cref="P:System.ResolveEventArgs.RequestingAssembly" /> property contains the assembly that requested the type. For more information, see <see cref="P:System.ResolveEventArgs.RequestingAssembly" />.</para>
          <para>To register an event handler for this event, you must have the required permissions, or a <see cref="T:System.Security.SecurityException" /> is thrown.</para>
          <para>For more information about handling events, see <format type="text/html"><a href="01E4F1BC-E55E-413F-98C7-6588493E5F67">Events Overview</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when the resolution of a type fails.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="ILASM" Value=".event public event UnhandledException" />
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This event provides notification of uncaught exceptions. It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application. If sufficient information about the state of the application is available, other actions may be undertaken — such as saving program data for later recovery. Caution is advised, because program data can become corrupted when exceptions are not handled.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after. </para>
          </block>
          <para>This event can be handled in any application domain. However, the event is not necessarily raised in the application domain where the exception occurred. An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated. </para>
          <block subset="none" type="note">
            <para>In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started. If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</para>
          </block>
          <para>If the <see cref="E:System.AppDomain.UnhandledException" /> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in. If the thread started in an application domain that has an event handler for <see cref="E:System.AppDomain.UnhandledException" />, the event is raised in that application domain. If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</para>
          <para>For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception. The first application domain in which the <see cref="E:System.AppDomain.UnhandledException" /> event can be raised is "AD1". If that application domain is not the default application domain, the event can also be raised in the default application domain.</para>
          <block subset="none" type="note">
            <para>The common language runtime suspends thread aborts while event handlers for the <see cref="E:System.AppDomain.UnhandledException" /> event are executing.</para>
          </block>
          <para>If the event handler has a <see cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" /> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</para>
          <para>Starting with the net_v40_long, this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <see cref="T:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute" /> attribute.</para>
          <para>In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate. Thus, it is possible for the <see cref="E:System.AppDomain.UnhandledException" /> event to be raised without the application terminating. Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug. For more information, including a list of cases in which the runtime does not terminate, see <format type="text/html"><a href="11294769-2e89-43cb-890e-ad4ad79cfbee">Exceptions in Managed Threads</a></format>.</para>
          <para>To register an event handler for this event, you must have the required permissions, or a <see cref="T:System.Security.SecurityException" /> is thrown.</para>
          <para>For more information about handling events, see <format type="text/html"><a href="01E4F1BC-E55E-413F-98C7-6588493E5F67">Events Overview</a></format>.</para>
          <format type="text/html">
            <h2>Other Events for Unhandled Exceptions</h2>
          </format>
          <para>For certain application models, the <see cref="E:System.AppDomain.UnhandledException" /> event can be preempted by other events if the unhandled exception occurs in the main application thread.</para>
          <para>In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <see cref="E:System.Windows.Forms.Application.ThreadException" /> event to be raised. If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state. In that case, the <see cref="E:System.AppDomain.UnhandledException" /> event is not raised. This behavior can be changed by using the application configuration file, or by using the <see cref="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" /> method to change the mode to <see cref="F:System.Windows.Forms.UnhandledExceptionMode.ThrowException" /> before the <see cref="E:System.Windows.Forms.Application.ThreadException" /> event handler is hooked up. This applies only to the main application thread. The <see cref="E:System.AppDomain.UnhandledException" /> event is raised for unhandled exceptions thrown in other threads. </para>
          <para>Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread. See the <see cref="E:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException" /> event. This event has an event arguments object with the same name as the event arguments object used by <see cref="E:System.AppDomain.UnhandledException" />, but with different properties. In particular, this event arguments object has an <see cref="P:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication" /> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state). In that case, the <see cref="E:System.AppDomain.UnhandledException" /> event is not raised. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when an exception is not caught.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void Unload(class System.AppDomain domain)" />
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> is <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          <paramref name="domain" /> could not be unloaded.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains. This improves reliability, especially when the .NET Framework is hosted. When a thread calls <see cref="M:System.AppDomain.Unload(System.AppDomain)" />, the target domain is marked for unloading. The dedicated thread attempts to unload the domain, and all threads in the domain are aborted. If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a finally block, then after a period of time a <see cref="T:System.CannotUnloadAppDomainException" /> is thrown in the thread that originally called <see cref="M:System.AppDomain.Unload(System.AppDomain)" />. If the thread that could not be aborted eventually ends, the target domain is not unloaded. Thus, in the .NET Framework version 2.0 <paramref name="domain" /> is not guaranteed to unload, because it might not be possible to terminate executing threads. </para>
          <block subset="none" type="note">
            <para>In some cases, calling <see cref="M:System.AppDomain.Unload(System.AppDomain)" /> causes an immediate <see cref="T:System.CannotUnloadAppDomainException" />, for example if it is called in a finalizer.</para>
          </block>
          <para>The threads in <paramref name="domain" /> are terminated using the <see cref="M:System.Threading.Thread.Abort(System.Object)" /> method, which throws a <see cref="T:System.Threading.ThreadAbortException" /> in the thread. Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a finally clause.</para>
          <format type="text/html">
            <h2>Version Compatibility</h2>
          </format>
          <para>In the .NET Framework version 1.0 and 1.1 if the thread that calls <see cref="M:System.AppDomain.Unload(System.AppDomain)" /> is running in <paramref name="domain" />, another thread is started to perform the unload operation. If <paramref name="domain" /> cannot be unloaded, a <see cref="T:System.CannotUnloadAppDomainException" /> is thrown in that thread, not in the original thread that called <see cref="M:System.AppDomain.Unload(System.AppDomain)" />. However, if the thread that calls <see cref="M:System.AppDomain.Unload(System.AppDomain)" /> is running outside <paramref name="domain" />, that thread receives the exception.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unloads the specified application domain.</para>
        </summary>
        <param name="domain">
          <attribution license="cc4" from="Microsoft" modified="false" />An application domain to unload. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>