<?xml version="1.0" encoding="utf-8"?>
<Type Name="Type" FullName="System.Type" FullNameSP="System_Type" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public abstract serializable Type extends System.Object" />
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>This type is safe for multithreaded operations. </ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
    <ExcludedBaseTypeName>System.Reflection.MemberInfo</ExcludedBaseTypeName>
    <ExcludedLibraryName>Reflection</ExcludedLibraryName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Type is the root of the <see cref="N:System.Reflection" /> functionality and is the primary way to access metadata. Use the members of Type to get information about a type declaration, such as the constructors, methods, fields, properties, and events of a class, as well as the module and the assembly in which the class is deployed.</para>
      <para>The C# typeof operator (GetType operator in Visual Basic, typeid operator in Visual C++) returns a Type object.</para>
      <para>A Type object that represents a type is unique; that is, two Type object references refer to the same object if and only if they represent the same type. This allows for comparison of Type objects using reference equality.</para>
      <para>No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels. No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation. However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <see cref="T:System.Security.Permissions.ReflectionPermission" />. See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.</para>
      <para>Type is an abstract base class that allows multiple implementations. The system will always provide the derived class RuntimeType. In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</para>
      <block subset="none" type="note">
        <para>In multithreading scenarios, do not lock <see cref="T:System.Type" /> objects in order to synchronize access to static data. Other code, over which you have no control, might also lock your class type. This might result in a deadlock. Instead, synchronize access to static data by locking a private static object.</para>
      </block>
      <para>This class is thread safe; multiple threads can concurrently read from an instance of this type. An instance of Type can represent any of the following types: </para>
      <list type="bullet">
        <item>
          <para>Classes </para>
        </item>
        <item>
          <para>Value types </para>
        </item>
        <item>
          <para>Arrays </para>
        </item>
        <item>
          <para>Interfaces </para>
        </item>
        <item>
          <para>Pointers </para>
        </item>
        <item>
          <para>Enumerations </para>
        </item>
        <item>
          <para>Constructed generic types and generic type definitions</para>
        </item>
        <item>
          <para>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</para>
        </item>
      </list>
      <para>A reference to the Type object associated with a type can be obtained in the following ways:</para>
      <list type="bullet">
        <item>
          <para>The <see cref="M:System.Object.GetType" /> method returns a Type object that represents the type of an instance.</para>
        </item>
        <item>
          <para>The static GetType methods return a Type object that represents a type specified by its fully qualified name.</para>
        </item>
        <item>
          <para>The <see cref="M:System.Reflection.Module.GetTypes" />, <see cref="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />, and <see cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" /> methods return Type objects that represent the types defined in a module. The first method can be used to obtain an array of Type objects for all the public and private types defined in a module. (You can obtain an instance of Module through the <see cref="M:System.Reflection.Assembly.GetModule(System.String)" /> or <see cref="M:System.Reflection.Assembly.GetModules" /> method, or through the <see cref="P:System.Type.Module" /> property.) </para>
        </item>
        <item>
          <para>The <see cref="T:System.Reflection.Assembly" /> object contains a number of methods to retrieve the classes defined in an assembly, including <see cref="Overload:System.Reflection.Assembly.GetType" />, <see cref="M:System.Reflection.Assembly.GetTypes" />, and <see cref="M:System.Reflection.Assembly.GetExportedTypes" />. </para>
        </item>
        <item>
          <para>The <see cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" /> method returns a filtered list of interface types supported by a type.</para>
        </item>
        <item>
          <para>The <see cref="M:System.Type.GetElementType" /> method returns a Type object that represents the element.</para>
        </item>
        <item>
          <para>The <see cref="M:System.Type.GetInterfaces" /> and <see cref="M:System.Type.GetInterface(System.String)" /> methods return Type objects representing the interface types supported by a type.</para>
        </item>
        <item>
          <para>The <see cref="M:System.Type.GetTypeArray(System.Object[])" /> method returns an array of Type objects representing the types specified by an arbitrary set of objects. The objects are specified with an array of type Object.</para>
        </item>
        <item>
          <para>The <see cref="M:System.Type.GetTypeFromProgID(System.String)" /> and <see cref="M:System.Type.GetTypeFromCLSID(System.Guid)" /> methods are provided for COM interoperability. They return a Type object that represents the type specified by a ProgID or CLSID.</para>
        </item>
        <item>
          <para>The <see cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" /> method is provided for interoperability. It returns a Type object that represents the type specified by a class handle.</para>
        </item>
        <item>
          <para>The C# typeof operator, the C++ typeid operator, and the Visual Basic GetType operator obtain the Type object for a type.</para>
        </item>
        <item>
          <para>The <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method returns a <see cref="T:System.Type" /> object representing a constructed generic type, which is an open constructed type if its <see cref="P:System.Type.ContainsGenericParameters" /> property returns true, and a closed constructed type otherwise. A generic type can be instantiated only if it is closed. </para>
        </item>
        <item>
          <para>The <see cref="Overload:System.Type.MakeArrayType" />, <see cref="M:System.Type.MakePointerType" />, and <see cref="M:System.Type.MakeByRefType" /> methods return <see cref="T:System.Type" /> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (ref in C#, ByRef in Visual Basic). </para>
        </item>
      </list>
      <block subset="none" type="note">
        <para>A derived class can access protected members of the calling code's base classes. Also, access is allowed to assembly members of the calling code's assembly. As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</para>
      </block>
      <block subset="none" type="note">
        <para>Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</para>
      </block>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="family rtspecialname specialname instance void .ctor()" />
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor is invoked by derived classes during the construction of type objects.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Type" /> class.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="ILASM" Value=".property class System.Reflection.Assembly Assembly { public hidebysig virtual abstract specialname class System.Reflection.Assembly get_Assembly() }" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.  For generic types, the instance describes the assembly that contains the definition of the generic type.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> object represents a constructed generic type, this property returns the assembly that contains the generic type definition. For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition MyGenericStack&lt;T&gt; (MyGenericStack(Of T) in Visual Basic, generic&lt;T&gt; ref class MyGenericStack in C++). If you create an instance of MyGenericStack&lt;int&gt; (MyGenericStack(Of Integer) in Visual Basic) in another assembly, the <see cref="P:System.Type.Assembly" /> property for the constructed type returns an <see cref="T:System.Reflection.Assembly" /> object that represents MyGenerics.dll.</para>
          <para>Similarly, if the current <see cref="T:System.Type" /> object represents an unassigned generic parameter <paramref name="T" />, this property returns the assembly that contains the generic type that defines <paramref name="T" />.</para>
          <para>This property is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared. For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="ILASM" Value=".property string AssemblyQualifiedName { public hidebysig virtual abstract specialname string get_AssemblyQualifiedName() }" />
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>The assembly-qualified name of the <see cref="T:System.Type" />, including the name of the assembly from which the <see cref="T:System.Type" /> was loaded. If the current <see cref="T:System.Type" /> object represents a generic parameter, this property returns <see langword="null" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly. The display name of an assembly is obtained using the <see cref="P:System.Reflection.Assembly.FullName" /> property. </para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, "ProcessorArchitecture=msil". However, it is not included in the string returned by the <see cref="P:System.Type.AssemblyQualifiedName" /> property, for compatibility reasons. See <see cref="P:System.Reflection.AssemblyName.ProcessorArchitecture" />.</para>
          </block>
          <para>All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Delimiter </para>
                </term>
                <description>
                  <para>Meaning </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Backslash (\) </para>
              </term>
              <description>
                <para>Escape character. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Comma (,) </para>
              </term>
              <description>
                <para>Precedes the Assembly name. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Plus sign (+) </para>
              </term>
              <description>
                <para>Precedes a nested class. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Period (.) </para>
              </term>
              <description>
                <para>Denotes namespace identifiers. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Brackets ([]) </para>
              </term>
              <description>
                <para>After a type name, denotes an array of that type.</para>
                <para>-or-</para>
                <para>For a generic type, encloses the generic type argument list.</para>
                <para>-or-</para>
                <para>Within a type argument list, encloses an assembly-qualified type. </para>
              </description>
            </item>
          </list>
          <para>For example, the assembly-qualified name for a class might look like this: </para>
          <code>TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089</code>
          <para>If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection would emit this string as follows: </para>
          <code>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089 </code>
          <para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
          <para>This qualified name can be persisted and later used to load the <see cref="T:System.Type" />. To search for and load a <see cref="T:System.Type" />, use <see cref="M:System.Type.GetType" /> either with the type name only or with the assembly qualified type name. <see cref="M:System.Type.GetType" /> with the type name only will look for the <see cref="T:System.Type" /> in the caller's assembly and then in the System assembly. <see cref="M:System.Type.GetType" /> with the assembly qualified type name will look for the <see cref="T:System.Type" /> in any assembly.</para>
          <para>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use t.GetElementType().ToString(), where <paramref name="t" /> is the type.</para>
          <para>Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</para>
          <para>Generic arguments of generic types are themselves qualified by assembly name. For example, in the assembly-qualified type name for MyGenericClass&lt;int&gt; (MyGenericClass(Of Integer) in Visual Basic), int is expanded to the assembly-qualified type name for <see cref="T:System.Int32" />.</para>
          <para>If the current <see cref="T:System.Type" /> object represents a generic parameter, this property returns null.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="ILASM" Value=".property valuetype System.Reflection.TypeAttributes Attributes { public hidebysig specialname instance valuetype System.Reflection.TypeAttributes get_Attributes() }" />
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property returns the attributes of the generic type definition. For example, the attributes returned for MyGenericClass&lt;int&gt; (MyGenericClass(Of Integer) in Visual Basic) are the attributes of MyGenericClass&lt;T&gt; (MyGenericClass(Of T) in Visual Basic).</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type parameter — that is, if the <see cref="P:System.Type.IsGenericParameter" /> property returns true — the <see cref="T:System.Reflection.TypeAttributes" /> value returned by this property is unspecified.  </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the attributes associated with the <see cref="T:System.Type" />.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="ILASM" Value=".property class System.Type BaseType { public hidebysig virtual abstract specialname class System.Type get_BaseType() }" />
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Type" /> object 
   representing the type from which the current <see cref="T:System.Type" /> directly inherits, or
<see langword="null" /> 
if the current <see cref="T:System.Type" /> represents the <see cref="T:System.Object" /> class.</para>
        </value>
        <example>
          <para>The following example demonstrates using the <see cref="P:System.Type.BaseType" />
property.</para>
          <code lang="C#">using System;
class TestType {
 public static void Main() {
 Type t = typeof(int);
 Console.WriteLine("{0} inherits from {1}", t,t.BaseType);
 }
}
</code>
          <para>The output is</para>
          <para>
            <c>System.Int32
   inherits from System.ValueType</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The base type is the type from which the current type directly inherits. <see cref="T:System.Object" /> is the only type that does not have a base type, therefore null is returned as the base type of <see cref="T:System.Object" />.</para>
          <para>Interfaces inherit from zero or more base interfaces; therefore, this property returns null if the Type object represents an interface. The base interfaces can be determined with <see cref="M:System.Type.GetInterfaces" /> or <see cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, the base type reflects the generic arguments. For example, consider the following declarations: </para>
          <para>code reference: System.Type.BaseType#1</para>
          <para>For the constructed type C&lt;int&gt; (C(Of Integer) in Visual Basic), the <see cref="P:System.Type.BaseType" /> property returns B&lt;int&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type definition, <see cref="P:System.Type.BaseType" /> returns the class constraint, that is, the class the type parameter must inherit. If there is no class constraint, <see cref="P:System.Type.BaseType" /> returns <see cref="T:System.Object" />.</para>
          <para>This property is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <para>
            <see langword="true" /> if a <see cref="T:System.Type" /> object contains unassigned generic parameters; otherwise <see langword="false" />.</para>
        </value>
        <since version=".NET 2.0" />
        <example>
          <para>For an example of using this method, see the example for <see cref="P:System.Type.GenericParameterPosition" />.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type. Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</para>
          <para>Since types can be arbitrarily complex, making this determination is difficult. For convenience and to reduce the chance of error, the <see cref="P:System.Type.ContainsGenericParameters" /> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot. If the <see cref="P:System.Type.ContainsGenericParameters" /> property returns true, the type cannot be instantiated.</para>
          <para>The <see cref="P:System.Type.ContainsGenericParameters" /> property searches recursively for type parameters. For example, it returns true for an array whose elements are type A&lt;T&gt; (A(Of T) in Visual Basic), even though the array is not itself generic. Contrast this with the behavior of the <see cref="P:System.Type.IsGenericType" /> property, which returns false for arrays.</para>
          <para>For a set of example classes and a table showing the values of the <see cref="P:System.Type.ContainsGenericParameters" /> property, see <see cref="P:System.Type.IsGenericType" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodInfo" />  that represents the declaring method; otherwise <see langword="null" />.</para>
        </value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The declaring method is a generic method definition. That is, if <see cref="P:System.Type.DeclaringMethod" /> does not return null, then DeclaringMethod.IsGenericMethodDefinition returns true.</para>
          <para>The <see cref="P:System.Type.DeclaringType" /> and <see cref="P:System.Type.DeclaringMethod" /> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</para>
          <list type="bullet">
            <item>
              <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns a <see cref="T:System.Reflection.MethodInfo" />, that <see cref="T:System.Reflection.MethodInfo" /> represents a generic method definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic method definition.</para>
            </item>
            <item>
              <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns null, then the <see cref="P:System.Type.DeclaringType" /> property always returns a <see cref="T:System.Type" /> object representing a generic type definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic type definition.</para>
            </item>
            <item>
              <para>Getting the <see cref="P:System.Type.DeclaringMethod" /> property on a type whose <see cref="P:System.Type.IsGenericParameter" /> property is false throws an <see cref="T:System.InvalidOperationException" />.</para>
            </item>
          </list>
          <para>The <see cref="T:System.Reflection.MethodBase" /> that is returned by the <see cref="P:System.Type.DeclaringMethod" /> property is either a <see cref="T:System.Reflection.MethodInfo" /> in the case of a generic method, or a <see cref="T:System.Reflection.ConstructorInfo" /> in the case of a generic constructor.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 2.0, generic constructors are not supported.</para>
          </block>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property remarks. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="ILASM" Value=".property class System.Type DeclaringType { public hidebysig virtual specialname class System.Type get_DeclaringType() }" />
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>The <see cref="T:System.Type" /> object for
   the class that declares the type represented by the current
   instance. If the type is a nested type, this property returns the enclosing type; otherwise, returns
   the current instance.</para>
        </value>
        <example>
          <para>The following example demonstrates the
   <see cref="P:System.Type.DeclaringType" /> property. </para>
          <code lang="C#">using System;
using System.Reflection;

public abstract class DeclaringTypeTest{
   public abstract class MyClassA {
      public abstract int m(); 
   }
   public abstract class MyClassB : MyClassA {
   }
   public static void Main() { 
      Console.WriteLine("Declaring type of m is {0}",
         typeof(MyClassB).GetMethod("m").DeclaringType);
   }
}
   </code>
          <para> The output is </para>
          <c>
            <para>Declaring type of m is DeclaringTypeTest+MyClassA </para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> object represents a type parameter of a generic type, this property returns the generic type definition.</para>
          <para>If the current <see cref="T:System.Type" /> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition. If the type is generic, the generic type definition is returned. That is, the following code returns the generic type definition of the <see cref="T:System.Collections.Generic.List`1" /> generic class, which contains the <see cref="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" /> generic method:</para>
          <para>code reference: System.Type.DeclaringType#1</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, the <see cref="P:System.Type.DeclaringType" /> and <see cref="P:System.Type.DeclaringMethod" /> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</para>
          <list type="bullet">
            <item>
              <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns a <see cref="T:System.Reflection.MethodInfo" />, that <see cref="T:System.Reflection.MethodInfo" /> represents a generic method definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic method definition.</para>
            </item>
            <item>
              <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns null, then the <see cref="P:System.Type.DeclaringType" /> property always returns a <see cref="T:System.Type" /> object representing a generic type definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic type definition.</para>
            </item>
            <item>
              <para>Getting the <see cref="P:System.Type.DeclaringType" /> property on a type whose <see cref="P:System.Type.IsGenericParameter" /> property is false throws an <see cref="T:System.InvalidOperationException" />.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type that declares the current nested type or generic type parameter.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="ILASM" Value=".property class System.Reflection.Binder DefaultBinder { public hidebysig static specialname class System.Reflection.Binder get_DefaultBinder() }" />
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>The default <see cref="T:System.Reflection.Binder" /> used by the system.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The default binder provided with the common language runtime is applicable in all but the most specialized circumstances. If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <see cref="T:System.Reflection.Binder" /> class and pass an instance of that type using the <paramref name="binder" /> parameter of one of the <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> overloads.</para>
          <para>Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs <see cref="T:System.Security.Permissions.ReflectionPermission" />. This is consistent with lookup of members that are protected, private, and so on.</para>
          <para>The general principle is that <see cref="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" /> should perform only widening conversions, which never lose data. An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer. This is distinguished from a narrowing conversion, which may lose data. An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</para>
          <para>The following table lists the conversions supported by the default binder.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Source Type </para>
                </term>
                <description>
                  <para>Target Type </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Any type </para>
              </term>
              <description>
                <para>Its base type. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Any type </para>
              </term>
              <description>
                <para>The interface it implements. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Char </para>
              </term>
              <description>
                <para>Unt16, UInt32, Int32, UInt64, Int64, Single, Double </para>
              </description>
            </item>
            <item>
              <term>
                <para>Byte </para>
              </term>
              <description>
                <para>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double </para>
              </description>
            </item>
            <item>
              <term>
                <para>SByte </para>
              </term>
              <description>
                <para>Int16, Int32, Int64, Single, Double </para>
              </description>
            </item>
            <item>
              <term>
                <para>UInt16 </para>
              </term>
              <description>
                <para>UInt32, Int32, UInt64, Int64, Single, Double </para>
              </description>
            </item>
            <item>
              <term>
                <para>Int16 </para>
              </term>
              <description>
                <para>Int32, Int64, Single, Double </para>
              </description>
            </item>
            <item>
              <term>
                <para>UInt32 </para>
              </term>
              <description>
                <para>UInt64, Int64, Single, Double </para>
              </description>
            </item>
            <item>
              <term>
                <para>Int32 </para>
              </term>
              <description>
                <para>Int64, Single, Double </para>
              </description>
            </item>
            <item>
              <term>
                <para>UInt64 </para>
              </term>
              <description>
                <para>Single, Double </para>
              </description>
            </item>
            <item>
              <term>
                <para>Int64 </para>
              </term>
              <description>
                <para>Single, Double </para>
              </description>
            </item>
            <item>
              <term>
                <para>Single </para>
              </term>
              <description>
                <para>Double </para>
              </description>
            </item>
            <item>
              <term>
                <para>Non-reference </para>
              </term>
              <description>
                <para>By-reference. </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="ILASM" Value=".field public static initOnly valuetype System.Char Delimiter" />
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <para>This field is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Separates names in the namespace of the <see cref="T:System.Type" />. This field is read-only.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="ILASM" Value=".field public static initOnly class System.Type[] EmptyTypes" />
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <para>This field is read-only.</para>
          <para>The empty <see cref="T:System.Type" /> array returned by this field is used to specify that 
   lookup methods in the <see cref="T:System.Type" /> class, such as <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />,
   search for members that do not take parameters. <block subset="none" type="note">For example, to locate the public instance constructor that takes no
   parameters, invoke <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> (<see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Instance" />, <see langword="null" />, <see cref="F:System.Type.EmptyTypes" />,
<see langword="null" />).</block></para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Represents an empty array of type <see cref="T:System.Type" />. This field is read-only.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.Object.Equals(System.Object)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, false. This method also returns false if the object specified by the <paramref name="o" /> parameter is not a Type.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />. </param>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance bool Equals(class System.Type o)" />
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, false.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This field holds a reference to the delegate used by the <see cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" /> method. The method encapsulated by this delegate takes two parameters: the first is a <see cref="T:System.Reflection.MemberInfo" /> object and the second is an Object. The method determines whether the MemberInfo object matches the criteria specified by the Object. The Object may be assigned the value of any one of the fields on the classes <see cref="T:System.Reflection.FieldAttributes" />, <see cref="T:System.Reflection.MethodAttributes" />, or <see cref="T:System.Reflection.MethodImplAttributes" />.</para>
          <para>For example, the Object can be assigned the value of a field from FieldAttributes such as Public. In that case, when the FilterAttribute delegate is invoked, it will return true only if the method represented by the MemberInfo object is decorated with the public field attribute in metadata.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Represents the member filter used on attributes. This field is read-only.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This field holds a reference to the delegate used by the <see cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" /> method. The method encapsulated by this delegate takes two parameters: the first is a <see cref="T:System.Reflection.MemberInfo" /> object and the second is an Object. The method determines whether the MemberInfo object matches the criteria specified by the Object. The Object is assigned a string value, which may include a trailing "*" wildcard character. Only wildcard end string matching is supported.</para>
          <para>For example, the Object may be assigned the value "Byte*". In that case, when the FilterName delegate is invoked, it will return true only if the method represented by the MemberInfo object has a name that begins with "Byte".</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Represents the case-sensitive member filter used on names. This field is read-only.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This field holds a reference to the delegate used by the <see cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" /> method. The method encapsulated by this delegate takes two parameters: the first is a <see cref="T:System.Reflection.MemberInfo" /> object and the second is an Object. The method determines whether the MemberInfo object matches the criteria specified by the Object. The Object is assigned a string value, which may include a trailing "*" wildcard character. Only wildcard end string matching is supported.</para>
          <para>For example, the Object may be assigned the value "ByTe*". In that case, when the FilterName delegate is invoked, it will return true only if the method represented by the MemberInfo object has a name that begins with "byte", ignoring case.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Represents the case-insensitive member filter used on names. This field is read-only.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method can be overridden by a derived class.</para>
          <para>The <see cref="F:System.Reflection.Module.FilterTypeName" /> and <see cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" /> delegates supplied by the <see cref="T:System.Reflection.Module" /> class may also be used, in lieu of the <see cref="T:System.Reflection.TypeFilter" /> delegate.</para>
          <para>All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</para>
          <para>This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned). No duplicate interfaces are returned.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, <see cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" /> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints. If the current <see cref="T:System.Type" /> represents a type argument of a generic type, <see cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" /> searches all the interfaces implemented by the type, whether or not they match constraints.</para>
          <block subset="none" type="note">
            <para>
              <see cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" /> can return generic interfaces, even on types that are not generic. For example, a nongeneric type might implement IEnumerable&lt;int&gt; (IEnumerable(Of Integer) in Visual Basic).</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</para>
        </returns>
        <param name="filter">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate that compares the interfaces against <paramref name="filterCriteria" />. </param>
        <param name="filterCriteria">
          <attribution license="cc4" from="Microsoft" modified="false" />The search criteria that determines whether an interface should be included in the returned array. </param>
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method can be overridden by a derived class.</para>
          <para>Members include properties, methods, fields, events, and so on. </para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which members to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Instance to include instance members in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Static to include static members in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public members in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public members (that is, private, internal, and protected members) in the search.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.DeclaredOnly to search only the members declared on the <see cref="T:System.Type" />, not members that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>Valid values for <see cref="P:System.Type.MemberType" /> are defined in <see cref="T:System.Reflection.MemberInfo" />. If no such members are found, an empty array is returned.</para>
          <para>To get the class initializer (.cctor) using this method, you must specify <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic). You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type or generic method, <see cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" /> processes any members declared by the class constraint and the interface constraints of the type parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</para>
        </returns>
        <param name="memberType">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that indicates the type of member to search for. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
        <param name="filter">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate that does the comparisons, returning true if the member currently being inspected matches the <paramref name="filterCriteria" /> and false otherwise. You can use the FilterAttribute, FilterName, and FilterNameIgnoreCase delegates supplied by this class. The first uses the fields of FieldAttributes, MethodAttributes, and MethodImplAttributes as search criteria, and the other two delegates use String objects as the search criteria. </param>
        <param name="filterCriteria">
          <attribution license="cc4" from="Microsoft" modified="false" />The search criteria that determines whether a member is returned in the array of MemberInfo objects.</param>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="ILASM" Value=".property string FullName { public hidebysig virtual abstract specialname string get_FullName() }" />
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.String" /> containing the fully qualified name of the <see cref="T:System.Type" />.</para>
        </value>
        <example>
          <para>The following example demonstrates using the <see cref="P:System.Type.FullName" />
property.</para>
          <code lang="C#">using System;
class TestType {
 public static void Main() {
 Type t = typeof(Array);
 Console.WriteLine("Full name of Array type is {0}",t.FullName);
 }
}
</code>
          <para>The output is</para>
          <para>
            <c>Full name of
   Array type is System.Array</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For example, the fully qualified name of the C# string type is System.String. Contrast this with the assembly-qualified name, which is the full name plus the assembly, provided by the <see cref="P:System.Type.AssemblyQualifiedName" /> property.</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type, the type arguments in the string returned by <see cref="P:System.Type.FullName" /> are qualified by their assembly, version, and so on, even though the string representation of the generic type itself is not qualified by assembly. Thus, concatenating t.FullName + ", " + t.Assembly.FullName produces a result that is equivalent to t.AssemblyQualifiedName, as is the case with types that are not generic. </para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, or an array type, pointer type, or byref type based on a type parameter, this property returns null. </para>
          <para>If the current type contains generic type parameters that have not been replaced by specific types (that is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns true), but the type is not a generic type definition (that is, the <see cref="P:System.Type.IsGenericTypeDefinition" /> property returns false), this property returns null. For example, consider the classes Base and Derived in the following code.</para>
          <para>code reference: System.Type.FullName#1</para>
          <para>If you use the <see cref="P:System.Type.BaseType" /> property to obtain the base type of Derived, the <see cref="P:System.Type.FullName" /> property of the resulting <see cref="T:System.Type" /> object returns null. To get a non-null <see cref="P:System.Type.FullName" />, you can use the <see cref="M:System.Type.GetGenericTypeDefinition" /> method to get the generic type definition.</para>
          <para>This property is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the fully qualified name of the <see cref="T:System.Type" />, including the namespace of the <see cref="T:System.Type" /> but not the assembly.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <para>A <see cref="T:System.Reflection.GenericParameterAttributes" /> value that describes the variance and special constraints of the current generic type parameter.</para>
        </value>
        <since version=".NET 2.0" />
        <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Type" /> object is not a generic type parameter. That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints. Use the <see cref="F:System.Reflection.GenericParameterAttributes.VarianceMask" /> value to select the covariance flags, and use the <see cref="F:System.Reflection.GenericParameterAttributes.SpecialConstraintMask" /> value to select the constraint flags.</para>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property remarks. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <para>A zero-based integer representing the position of a type parameter in the type parameter list of the generic type or generic method that declared the parameter.</para>
        </value>
        <since version=".NET 2.0" />
        <exception cref="T:System.InvalidOperationException">The current type does not represent a type parameter. That is, <see cref="P:System.Type.IsGenericParameter" />  returns <see langword="false" />.</exception>
        <example>
          <para>The following example defines a generic class with two type parameters, and a generic class that derives from it. The base class of the derived type has one unbound type parameter and one type parameter bound to <see cref="T:System.Int32" />. The example displays information about these generic classes, including the positions reported by <see cref="P:System.Type.GenericParameterPosition" />.</para>
          <code lang="C#">using System;
using System.Reflection;
using System.Collections.Generic;
// Define a base class with two type parameters.
public class Base&lt;T, U&gt; { }

// Define a derived class. The derived class inherits from a constructed
// class that meets the following criteria:
//   (1) Its generic type definition is Base&lt;T, U&gt;.
//   (2) It specifies int for the first type parameter.
//   (3) For the second type parameter, it uses the same type that is used
//       for the type parameter of the derived class.
// Thus, the derived class is a generic type with one type parameter, but
// its base class is an open constructed type with one type argument and
// one type parameter.
public class Derived&lt;V&gt;: Base&lt;int,V&gt; { }

public class Test
{
	public static void Main()
	{
		Console.WriteLine("\n--- Display a generic type and the open constructed");
		Console.WriteLine("    type from which it is derived.");

		// Create a Type object representing the generic type Derived.
		//
		Type derivedType = Type.GetType("Derived");

		DisplayGenericTypeInfo(derivedType);

		// Display its open constructed base type.
		DisplayGenericTypeInfo(derivedType.BaseType);
	}

	private static void DisplayGenericTypeInfo(Type t)
	{
		Console.WriteLine("\n{0}", t);
		Console.WriteLine("\tIs this a generic type definition? {0}", t.IsGenericTypeDefinition);
		Console.WriteLine("\tDoes it have generic arguments? {0}", t.HasGenericArguments);
		Console.WriteLine("\tDoes it have unbound generic parameters? {0}", t.ContainsGenericParameters);
		if (t.HasGenericArguments)
		{
			// If the type is a generic type definition or a 
			// constructed type, display the type arguments.
			//
			Type[] typeArguments = t.GetGenericArguments();

			Console.WriteLine("\tList type arguments ({0}):", typeArguments.Length);
			foreach (Type tParam in typeArguments)
			{
				// IsGenericParameter is true only for generic type
				// parameters.
				//
				if (tParam.IsGenericParameter)
				{
					Console.WriteLine("\t\t{0}  (unbound - parameter position {1})", tParam, tParam.GenericParameterPosition);
				}
				else
				{
					Console.WriteLine("\t\t{0}", tParam);
				}
			}
		}
		else
		{
			Console.WriteLine("\tThis is not a generic or constructed type.");
		}
	}
}

/* This example produces the following output:

--- Display a generic type and the open constructed
    type from which it is derived.

Derived[V]
        Is this a generic type definition? True
        Does it have generic arguments? True
        Does it have unbound generic parameters? True
        List type arguments (1):
                V  (unbound - parameter position 0)

Base[System.Int32, V]
        Is this a generic type definition? False
        Does it have generic arguments? True
        Does it have unbound generic parameters? True
        List type arguments (2):
                System.Int32
                V  (unbound - parameter position 0)
 */</code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Type.GenericParameterPosition" /> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined. The <see cref="P:System.Type.DeclaringType" /> and <see cref="P:System.Type.DeclaringMethod" /> properties identify the generic type or method definition:</para>
          <list type="bullet">
            <item>
              <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns a <see cref="T:System.Reflection.MethodInfo" />, that <see cref="T:System.Reflection.MethodInfo" /> represents a generic method definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic method definition.</para>
            </item>
            <item>
              <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns null, then the <see cref="P:System.Type.DeclaringType" /> property always returns a <see cref="T:System.Type" /> object representing a generic type definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic type definition.</para>
            </item>
          </list>
          <para>To provide the correct context for the value of the <see cref="P:System.Type.GenericParameterPosition" /> property, it is necessary to identify the generic type or method a type parameter belongs to. For example, consider the return value of the generic method GetSomething in the following code: </para>
          <para>code reference: System.Type.GenericParameterPosition#1</para>
          <para>The type returned by GetSomething depends on the type arguments supplied to class A and to GetSomething itself. You can obtain a <see cref="T:System.Reflection.MethodInfo" /> for GetSomething, and from that you can obtain the return type. When you examine the type parameters of the return type, <see cref="P:System.Type.GenericParameterPosition" /> returns 0 for both. The position of V is 0 because V is the first type parameter in the type parameter list for class A. The position of X is 0 because X is the first type parameter in the type parameter list for GetSomething.</para>
          <block subset="none" type="note">
            <para>Calling the <see cref="P:System.Type.GenericParameterPosition" /> property causes an exception if the current <see cref="T:System.Type" /> does not represent a type parameter. When you examine the type arguments of an open constructed type, use the <see cref="P:System.Type.IsGenericParameter" /> property to tell which are type parameters and which are types. The <see cref="P:System.Type.IsGenericParameter" /> property returns true for a type parameter; you can then use the <see cref="P:System.Type.GenericParameterPosition" /> method to obtain its position and use the <see cref="P:System.Type.DeclaringMethod" /> and <see cref="P:System.Type.DeclaringType" /> properties to determine the generic method or type definition that defines it.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type. If the current type is a generic type definition, this property returns an empty array. </para>
          <block subset="none" type="note">
            <para>If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type. </para>
          </block>
          <para>To get the generic type parameters of a type that represents a generic type definition, use the <see cref="P:System.Reflection.TypeInfo.GenericTypeParameters" /> property. To get a <see cref="T:System.Reflection.TypeInfo" /> object for the current <see cref="T:System.Type" /> object, use the <see cref="M:System.Reflection.IntrospectionExtensions.GetTypeInfo(System.Type)" /> extension method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an array of the generic type arguments for this type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetArrayRank()" />
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Type" /> is  not an array.</exception>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of dimensions in an <see cref="T:System.Array" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An <see cref="T:System.Int32" /> containing the number of dimensions in the current Type.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl()" />
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <block subset="none" type="behaviors">
            <para>This property is read-only.</para>
            <para>This method returns a <see cref="T:System.Reflection.TypeAttributes" /> value that indicates the attributes set in
      the metadata of the type represented by the current
      instance.</para>
          </block>
          <para>
            <block subset="none" type="usage">Use this property to determine the
   visibility, semantics, and layout format of the type represented by the
   current instance. Also use this property to determine if the type represented by
   the current instance has a special name.</block>
          </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitmask indicating the attributes associated with the <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types)" />
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor). To get a class initializer, use an overload that takes <see cref="T:System.Reflection.BindingFlags" />, and specify <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic). You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <para>If the requested constructor is non-public, this method returns null.</para>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.ConstructorInfo" /> with the type parameters replaced by the appropriate type arguments. If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method always returns null.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for a public instance constructor whose parameters match the types in the specified array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, null.</para>
        </returns>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, class System.Reflection.ParameterModifier[] modifiers)" />
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If an exact match does not exist, the <paramref name="binder" /> will attempt to coerce the parameter types specified in the <paramref name="types" /> array in order to select a match. If the <paramref name="binder" /> is unable to select a match, then null is returned.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which constructors to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public constructors in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public constructors (that is, private, internal, and protected constructors) in the search.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>To get the class initializer (.cctor) using this method overload, you must specify <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic). You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.ConstructorInfo" /> with the type parameters replaced by the appropriate type arguments. If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method always returns null.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Although the default binder does not process <see cref="T:System.Reflection.ParameterModifier" /> (the <paramref name="modifiers" /> parameter), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="modifiers" />. ParameterModifier is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
          <para>If an exact match does not exist, the <paramref name="binder" /> will attempt to coerce the parameter types specified in the <paramref name="types" /> array in order to select a match. If the <paramref name="binder" /> is unable to select a match, then null is returned.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which constructors to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public constructors in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public constructors (that is, private, internal, and protected constructors) in the search.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>To get the class initializer (.cctor) using this method, you must specify <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic). You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.ConstructorInfo" /> with the type parameters replaced by the appropriate type arguments. If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method always returns null.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the constructor that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="callConvention">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. The default binder does not process this parameter. </param>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Although the default binder does not process <see cref="T:System.Reflection.ParameterModifier" /> (the <paramref name="modifiers" /> parameter), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="modifiers" />. ParameterModifier is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
          <para>If an exact match does not exist, the <paramref name="binder" /> will attempt to coerce the parameter types specified in the <paramref name="types" /> array in order to select a match. If the <paramref name="binder" /> is unable to select a match, then null is returned.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which constructors to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public constructors in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public constructors (that is, private, internal, and protected constructors) in the search.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>This method implements <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="callConvention">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. The default binder does not process this parameter. </param>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo[] GetConstructors()" />
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.GetConstructors" /> method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>This method overload calls the <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" /> method overload, with <see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> (<see cref="F:System.Reflection.BindingFlags.Public" /> Or <see cref="F:System.Reflection.BindingFlags.Instance" /> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <see cref="T:System.Reflection.BindingFlags" />, and specify <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic). You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.ConstructorInfo" /> objects with the type parameters replaced by the appropriate type arguments. For example, if class C&lt;T&gt; has a constructor C(T t1) (Sub New(ByVal t1 As T) in Visual Basic), calling <see cref="M:System.Type.GetConstructors" /> on C&lt;int&gt; returns a <see cref="T:System.Reflection.ConstructorInfo" /> that represents C(int t1) in C# (Sub New(ByVal t1 As Integer) in Visual Basic).</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type parameter, the <see cref="M:System.Type.GetConstructors" /> method returns an empty array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns all the public constructors defined for the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor). If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" /> method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.</para>
          <para>
            <paramref name="bindingAttr" /> can be used to specify whether to return only public constructors or both public and non-public constructors.</para>
          <para>If an exact match does not exist, the <paramref name="binder" /> will attempt to coerce the parameter types specified in the <paramref name="types" /> array in order to select a match. If the <paramref name="binder" /> is unable to select a match, then null is returned.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which constructors to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public constructors in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public constructors (that is, private, internal, and protected constructors) in the search. Constructors of base classes are not returned.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>To get the class initializer (.cctor) using this method overload, you must specify <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic). You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.ConstructorInfo" /> objects with the type parameters replaced by the appropriate type arguments. For example, if class C&lt;T&gt; has a constructor C(T t1) (Sub New(ByVal t1 As T) in Visual Basic), calling <see cref="M:System.Type.GetConstructors" /> on C&lt;int&gt; returns a <see cref="T:System.Reflection.ConstructorInfo" /> that represents C(int t1) in C# (Sub New(ByVal t1 As Integer) in Visual Basic).</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type parameter, the <see cref="M:System.Type.GetConstructors" /> method returns an empty array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified BindingFlags.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined. Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</para>
        </returns>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Reflection.MemberInfo[] GetDefaultMembers()" />
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.GetDefaultMembers" /> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.</para>
          <para>This method can be overridden by a derived class.</para>
          <para>Members include properties, methods, fields, events, and so on.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> objects with the type parameters replaced by the appropriate type arguments. For example, if class C&lt;T&gt; has a property P that returns T, calling <see cref="M:System.Type.GetDefaultMembers" /> on C&lt;int&gt; returns int P in C# (Property P As Integer in Visual Basic).</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Type GetElementType()" />
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Type.GetElementType" />
method.</para>
          <code lang="C#">using System;
class TestType {
 public static void Main() {
 int[] array = {1,2,3};
 Type t = array.GetType();
 Type t2 = t.GetElementType();
 Console.WriteLine("{0} element type is {1}",array, t2.ToString());

 TestType newMe = new TestType();
 t = newMe.GetType();
 t2 = t.GetElementType();
 Console.WriteLine("{0} element type is {1}", newMe, t2==null? "null" : t2.ToString());
 }
}
</code>
          <para>The output is</para>
          <c>
            <para>System.Int32[] element type is System.Int32</para>
            <para>TestType element type is null</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method returns null for the <see cref="T:System.Array" /> class.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or null if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the name of the constant that has the specified value, for the current enumeration type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The name of the member of the current enumeration type that has the specified value, or null if no such constant is found.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The value whose name is to be retrieved.</param>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants. If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the names of the members of the current enumeration type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array that contains the names of the members of the enumeration.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>By default, the underlying type of an enumeration in C# and Visual Basic is <see cref="T:System.Int32" />. Other integer types can be specified.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the underlying type of the current enumeration type. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The underlying type of the current enumeration.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an array of the values of the constants in the current enumeration type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array that contains the values. The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.EventInfo GetEvent(string name)" />
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance events.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.EventInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which events to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public events in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public events (that is, private, internal, and protected events) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the events declared on the <see cref="T:System.Type" />, not events that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.EventInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Reflection.EventInfo[] GetEvents()" />
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>The <see cref="M:System.Type.GetEvents" /> method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.</para>
          <para>This method can be overridden by a derived class.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.EventInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" /> method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which events to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public events in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public events (that is, private, internal, and protected events) in the search. Only protected and internal events on base classes are returned; private events on base classes are not returned.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.DeclaredOnly to search only the events declared on the <see cref="T:System.Type" />, not events that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.EventInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</para>
        </returns>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name)" />
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance fields.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.FieldInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the public field with the specified name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the public field with the specified name, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the data field to get. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which fields to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public fields in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public fields (that is, private, internal, and protected fields) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the fields declared on the <see cref="T:System.Type" />, not fields that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.FieldInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified field, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the field that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the data field to get. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields()" />
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.GetFields" /> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.FieldInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns all the public fields of the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of a type in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.GetFields" /> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which fields to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public fields in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public fields (that is, private, internal, and protected fields) in the search. Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.DeclaredOnly to search only the fields declared on the <see cref="T:System.Type" />, not fields that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.FieldInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</para>
        </returns>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <example>
          <para>For an example of using this method, see the example for <see cref="P:System.Type.GenericParameterPosition" />.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</para>
          <list type="bullet">
            <item>
              <para>If the current type is a closed constructed type (that is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns false), the array returned by the <see cref="M:System.Type.GetGenericArguments" /> method contains the types that have been assigned to the generic type parameters of the generic type definition. </para>
            </item>
            <item>
              <para>If the current type is a generic type definition, the array contains the type parameters. </para>
            </item>
            <item>
              <para>If the current type is an open constructed type (that is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns true) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters. Use the <see cref="P:System.Type.IsGenericParameter" /> property to tell them apart. For a demonstration of this scenario, see the code example for the <see cref="P:System.Type.ContainsGenericParameters" /> property.</para>
            </item>
          </list>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property remarks. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type or the type parameters of a generic type definition.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type. Returns an empty array if the current type is not a generic type.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Type" /> object is not a generic type parameter. That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Each constraint on a generic type parameter is expressed as a <see cref="T:System.Type" /> object. Use the <see cref="P:System.Type.IsClass" /> property to determine whether a constraint is the base class constraint; if the property returns false, the constraint is an interface constraint. If a type parameter has no class constraint and no interface constraints, an empty array is returned. </para>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property remarks. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.InvalidOperationException">The current type is not a generic type.  That is, <see cref="P:System.Type.HasGenericArguments" /> returns <see langword="false" />. </exception>
        <example>
          <para>For an example of using this method, see the example for <see cref="M:System.Type.MakeGenericType" />.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A generic type definition is a template from which other types can be constructed. For example, from the generic type definition G&lt;T&gt; (expressed in C# syntax; G(Of T) in Visual Basic or generic &lt;typename T&gt; ref class G in C++) you can construct and instantiate the type G&lt;int&gt; (G(Of Integer) in Visual Basic). Given a <see cref="T:System.Type" /> object representing this constructed type, the <see cref="M:System.Type.GetGenericTypeDefinition" /> method returns the generic type definition.</para>
          <para>If two constructed types are created from the same generic type definition, using the same type arguments, the <see cref="M:System.Type.GetGenericTypeDefinition" /> method returns the same <see cref="T:System.Type" /> object for both types.</para>
          <para>If you call the <see cref="M:System.Type.GetGenericTypeDefinition" /> method on a <see cref="T:System.Type" /> object that already represents a generic type definition, it returns the current <see cref="T:System.Type" />.</para>
          <block subset="none" type="note">
            <para>An array of generic types is not itself generic. In the C# code A&lt;int&gt;[] v; or the Visual Basic code Dim v() As A(Of Integer), the type of variable v is not generic. Use <see cref="P:System.Type.IsGenericType" /> to determine whether a type is generic before calling <see cref="M:System.Type.GetGenericTypeDefinition" />.</para>
          </block>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property remarks. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetHashCode()" />
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.Object.GetHashCode" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the hash code for this instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The hash code for this instance.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Type GetInterface(string name)" />
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">The current instance represents a type that implements the same generic interface with different type arguments.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Type" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</para>
          <block subset="none" type="note">
            <para>For generic interfaces, the <paramref name="name" /> parameter is the mangled name, ending with a grave accent (`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find IExample&lt;T&gt; (IExample(Of T) in Visual Basic) or IExample&lt;string&gt; (IExample(Of String) in Visual Basic), search for "IExample`1".</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the interface with the specified name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the interface to get. For generic interfaces, this is the mangled name.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Type GetInterface(string name, bool ignoreCase)" />
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">The current instance represents a type that implements the same generic interface with different type arguments.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="ignoreCase" /> parameter applies only to the simple interface name, not to the namespace. The portion of <paramref name="name" /> that specifies the namespace must have the correct case, or the interface will not be found. For example, the string "System.icomparable" finds the <see cref="T:System.IComparable" /> interface, but the string "system.icomparable" does not. </para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Type" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</para>
          <block subset="none" type="note">
            <para>For generic interfaces, the <paramref name="name" /> parameter is the mangled name, ending with a grave accent (`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find IExample&lt;T&gt; (IExample(Of T) in Visual Basic) or IExample&lt;string&gt; (IExample(Of String) in Visual Basic), search for "IExample`1".</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the interface to get. For generic interfaces, this is the mangled name.</param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />true to ignore the case of that part of <paramref name="name" /> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The interface map denotes how an interface is mapped into the actual methods on a class that implements that interface.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <see cref="T:System.Reflection.InterfaceMapping" /> returned by this method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an interface mapping for the specified interface type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that represents the interface mapping for <paramref name="interfaceType" />.</para>
        </returns>
        <param name="interfaceType">
          <attribution license="cc4" from="Microsoft" modified="false" />The interface type to retrieve a mapping for. </param>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Type[] GetInterfaces()" />
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.GetInterfaces" /> method does not return interfaces in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which interfaces are returned, because that order varies.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Type" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMember(string name)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance members.</para>
          <para>Members include properties, methods, fields, events, and so on.</para>
          <para>The <see cref="M:System.Type.GetMember(System.String)" /> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.</para>
          <para>This method overload will not find class initializers (.cctor). To find class initializers, use an overload that takes <see cref="T:System.Reflection.BindingFlags" />, and specify <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic). You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint.</para>
          <block subset="none" type="note">
            <para>For generic methods, do not include the type arguments in <paramref name="name" />. For example, the C# code GetMember("MyMethod&lt;int&gt;") searches for a member with the text name "MyMethod&lt;int&gt;", rather than for a method named MyMethod that has one generic argument of type int.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the public members with the specified name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the public members to get. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method can be overridden by a derived class.</para>
          <para>Members include properties, methods, fields, events, and so on.</para>
          <para>The <see cref="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" /> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which members to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public members in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public members (that is, private, internal, and protected members) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the members declared on the <see cref="T:System.Type" />, not members that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <paramref name="name" />, and <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic) for <paramref name="bindingAttr" />. You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint.</para>
          <block subset="none" type="note">
            <para>For generic methods, do not include the type arguments in <paramref name="name" />. For example, the C# code GetMember("MyMethod&lt;int&gt;") searches for a member with the text name "MyMethod&lt;int&gt;", rather than for a method named MyMethod that has one generic argument of type int.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified members, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the members to get. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Members include properties, methods, fields, events, and so on. </para>
          <para>The <see cref="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" /> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which members to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public members in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public members (that is, private, internal, and protected members) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the members declared on the <see cref="T:System.Type" />, not members that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <paramref name="name" />, <see cref="F:System.Reflection.MemberTypes.Constructor" /> for <paramref name="type" />, and  <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic) for <paramref name="bindingAttr" />. You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint.</para>
          <block subset="none" type="note">
            <para>For generic methods, do not include the type arguments in <paramref name="name" />. For example, the C# code GetMember("MyMethod&lt;int&gt;") searches for a member with the text name "MyMethod&lt;int&gt;", rather than for a method named MyMethod that has one generic argument of type int.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified members of the specified member type, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the members to get. </param>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to search for. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMembers()" />
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Members include properties, methods, fields, events, and so on.</para>
          <para>The <see cref="M:System.Type.GetMembers" /> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.</para>
          <para>This method overload calls the <see cref="M:System.Type.GetMembers(System.Reflection.BindingFlags)" /> method overload, with <see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Instance" />  | <see cref="F:System.Reflection.BindingFlags.Static" /> (<see cref="F:System.Reflection.BindingFlags.Public" /> Or <see cref="F:System.Reflection.BindingFlags.Instance" /> Or <see cref="F:System.Reflection.BindingFlags.Static" /> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <see cref="T:System.Reflection.BindingFlags" />, and specify <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic). You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns all the public members of the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Members include properties, methods, fields, events, and so on.</para>
          <para>The <see cref="M:System.Type.GetMembers(System.Reflection.BindingFlags)" /> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which members to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public members in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public members (that is, private, internal, and protected members) in the search. Only protected and internal members on base classes are returned; private members on base classes are not returned.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.DeclaredOnly to search only the members declared on the <see cref="T:System.Type" />, not members that were simply inherited.</para>
            </item>
          </list>
          <para>Calling this method with only the Public flag or only the NonPublic flag will return the specified members and does not require any other flags.</para>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>To get the class initializer (.cctor) using this method overload, you must specify <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.NonPublic" /> (<see cref="F:System.Reflection.BindingFlags.Static" /> Or <see cref="F:System.Reflection.BindingFlags.NonPublic" /> in Visual Basic). You can also get the class initializer using the <see cref="P:System.Type.TypeInitializer" /> property.</para>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</para>
        </returns>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance methods.</para>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint.</para>
          <block subset="none" type="note">
            <para>For generic methods, do not include the type arguments in <paramref name="name" />. For example, the C# code GetMember("MyMethod&lt;int&gt;") searches for a member with the text name "MyMethod&lt;int&gt;", rather than for a method named MyMethod that has one generic argument of type int.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the public method with the specified name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that represents the public method with the specified name, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the public method to get. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which methods to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public methods in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public methods (that is, private, internal, and protected methods) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the methods declared on the <see cref="T:System.Type" />, not methods that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint.</para>
          <block subset="none" type="note">
            <para>For generic methods, do not include the type arguments in <paramref name="name" />. For example, the C# code GetMember("MyMethod&lt;int&gt;") searches for a member with the text name "MyMethod&lt;int&gt;", rather than for a method named MyMethod that has one generic argument of type int.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified method, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the method that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the method to get. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />.</para>
          <para>-or-</para>
          <para>At least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance methods.</para>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint.</para>
          <block subset="none" type="note">
            <para>The <paramref name="name" /> parameter cannot include type arguments. For example, the C# code GetMethod("MyGenericMethod&lt;int&gt;") searches for a method with the text name "MyGenericMethod&lt;int&gt;", rather than for a method named MyGenericMethod that has one generic argument of type int. Instead, use GetMethod("MyGenericMethod") with the appropriate parameter in the <paramref name="types" /> array.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified public method whose parameters match the specified argument types.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the public method whose parameters match the specified argument types, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the public method to get. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, class System.Reflection.ParameterModifier[] modifiers)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />.</para>
          <para>-or-</para>
          <para>At least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Although the default binder does not process <see cref="T:System.Reflection.ParameterModifier" /> (the <paramref name="modifiers" /> parameter), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="modifiers" />. ParameterModifier is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance methods.</para>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint.</para>
          <block subset="none" type="note">
            <para>For generic methods, do not include the type arguments in <paramref name="name" />. For example, the C# code GetMethod("MyMethod&lt;int&gt;") searches for a member with the text name "MyMethod&lt;int&gt;", rather than for a method named MyMethod that has one generic argument of type int. Instead, use GetMethod("MyMethod") with the appropriate parameter in the <paramref name="types" /> array.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified public method whose parameters match the specified argument types and modifiers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the public method that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the public method to get. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.  </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, class System.Reflection.ParameterModifier[] modifiers)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />.</para>
          <para>-or-</para>
          <para>At least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Although the default binder does not process <see cref="T:System.Reflection.ParameterModifier" /> (the <paramref name="modifiers" /> parameter), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="modifiers" />. ParameterModifier is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which methods to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public methods in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include nonpublic methods (that is, private, internal, and protected methods) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the methods declared on the <see cref="T:System.Type" />, not methods that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint.</para>
          <block subset="none" type="note">
            <para>For generic methods, do not include the type arguments in <paramref name="name" />. For example, the C# code GetMember("MyMethod&lt;int&gt;") searches for a member with the text name "MyMethod&lt;int&gt;", rather than for a method named MyMethod that has one generic argument of type int.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the method that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the method to get. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Although the default binder does not process <see cref="T:System.Reflection.ParameterModifier" /> (the <paramref name="modifiers" /> parameter), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="modifiers" />. ParameterModifier is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
          <para>The following table shows what members of a base class are returned by the GetXXX methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which methods to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public methods in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include nonpublic methods (that is, private, internal, and protected methods) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the methods declared on the <see cref="T:System.Type" />, not methods that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint.</para>
          <block subset="none" type="note">
            <para>For generic methods, do not include the type arguments in <paramref name="name" />. For example, the C# code GetMember("MyMethod&lt;int&gt;") searches for a member with the text name "MyMethod&lt;int&gt;", rather than for a method named MyMethod that has one generic argument of type int.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the method that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the method to get. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="callConvention">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter. </param>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Although the default binder does not process <see cref="T:System.Reflection.ParameterModifier" /> (the <paramref name="modifiers" /> parameter), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="modifiers" />. ParameterModifier is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
          <para>If <paramref name="types" /> is null, arguments are not matched.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which methods to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public methods in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public methods (that is, private, internal, and protected methods) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the methods declared on the <see cref="T:System.Type" />, not methods that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the method that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the method to get. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="callConvention">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. The default binder does not process this parameter. </param>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods()" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.GetMethods" /> method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.</para>
          <para>Constructors are not included in the array of methods returned by this call. Make a separate call to GetConstructors() to get the constructor methods.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns all the public methods of the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" /> method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which methods to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public methods in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public methods (that is, private, internal, and protected methods) in the search. Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.DeclaredOnly to search only the methods declared on the <see cref="T:System.Type" />, not methods that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <block subset="none" type="note">
            <para>You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.</para>
          </block>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</para>
        </returns>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Type GetNestedType(string name)" />
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>Use the simple name of the nested class for <paramref name="name" />. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments. For example, use the string "Inner`1" to get the generic nested class Inner&lt;T&gt; (Inner(Of T) in Visual Basic). Do not include language-specific syntax for type parameters.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</para>
          <para>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type. </para>
          <block subset="none" type="note">
            <para>If the current <see cref="T:System.Type" /> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <format type="text/html"><a href="4ca3a4f0-4400-47ce-8936-8e219961c76f">MSIL Assembler (Ilasm.exe)</a></format>. </para>
          </block>
          <para>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <see cref="M:System.Type.MakeGenericType(System.Type[])" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the public nested type with the specified name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the public nested type with the specified name, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the nested type to get. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the simple name of the nested class for <paramref name="name" />. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters. For example, use the string "Inner`1" to get the generic nested class Inner&lt;T&gt; (Inner(Of T) in Visual Basic). Do not include language-specific syntax for type parameters.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which nested types to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Public or BindingFlags.NonPublic to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public nested types in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public nested types (that is, private, internal, and protected nested types) in the search.</para>
            </item>
          </list>
          <para>This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" /> at each level.</para>
          <para>BindingFlags.Instance and BindingFlags.Static are ignored. </para>
          <para>Calling this method with only the <see cref="F:System.Reflection.BindingFlags.Public" /> flag or only the <see cref="F:System.Reflection.BindingFlags.NonPublic" /> flag will return the specified nested types and does not require any other flags.</para>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</para>
          <para>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type. </para>
          <block subset="none" type="note">
            <para>If the current <see cref="T:System.Type" /> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <format type="text/html"><a href="4ca3a4f0-4400-47ce-8936-8e219961c76f">MSIL Assembler (Ilasm.exe)</a></format>. </para>
          </block>
          <para>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <see cref="M:System.Type.MakeGenericType(System.Type[])" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the nested type that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the nested type to get. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Type[] GetNestedTypes()" />
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.GetNestedTypes" /> method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.</para>
          <para>Only the public types immediately nested in the current type are returned; the search is not recursive.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</para>
          <para>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type. </para>
          <block subset="none" type="note">
            <para>If the current <see cref="T:System.Type" /> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <format type="text/html"><a href="4ca3a4f0-4400-47ce-8936-8e219961c76f">MSIL Assembler (Ilasm.exe)</a></format>. </para>
          </block>
          <para>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <see cref="M:System.Type.MakeGenericType(System.Type[])" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the public types nested in the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The search for nested types is not recursive.</para>
          <para>The <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" /> method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which nested types to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Public or BindingFlags.NonPublic to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public nested types in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public nested types (that is, private, internal, and protected nested types) in the search.</para>
            </item>
          </list>
          <para>This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" /> at each level.</para>
          <para>BindingFlags.Instance and BindingFlags.Static are ignored. </para>
          <para>Calling this method with only the <see cref="F:System.Reflection.BindingFlags.Public" /> flag or only the <see cref="F:System.Reflection.BindingFlags.NonPublic" /> flag will return the specified nested types and does not require any other flags.</para>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</para>
          <para>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type. </para>
          <block subset="none" type="note">
            <para>If the current <see cref="T:System.Type" /> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <format type="text/html"><a href="4ca3a4f0-4400-47ce-8936-8e219961c76f">MSIL Assembler (Ilasm.exe)</a></format>. </para>
          </block>
          <para>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <see cref="M:System.Type.MakeGenericType(System.Type[])" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</para>
        </returns>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.PropertyInfo[] GetProperties()" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>The <see cref="M:System.Type.GetProperties" /> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns all the public properties of the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>The <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" /> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which nested types to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public properties in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public properties (that is, private, internal, and protected properties) in the search. Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.DeclaredOnly to search only the properties declared on the <see cref="T:System.Type" />, not properties that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>If the current T:System.Type represents a constructed generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</para>
          <para>-or- </para>
          <para>An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</para>
        </returns>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> is <see langword="null" />.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance properties.</para>
          <para>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          <para>Situations in which <see cref="T:System.Reflection.AmbiguousMatchException" /> occurs include the following:</para>
          <list type="bullet">
            <item>
              <para>A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <see cref="Overload:System.Type.GetProperty" /> method that specifies parameter types.</para>
            </item>
            <item>
              <para>A derived type declares a property that hides an inherited property with the same name, by using the new modifier (Shadows in Visual Basic). To resolve the ambiguity, use the <see cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" /> method overload and include <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to restrict the search to members that are not inherited.</para>
            </item>
          </list>
          <format type="text/html">
            <h2>Indexers and Default Properties</h2>
          </format>
          <para>vbprvblong, csprcslong, and vcprvclong have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable myList refers to an <see cref="T:System.Collections.ArrayList" />, the syntax myList[3] (myList(3) in Visual Basic) retrieves the element with the index of 3. You can overload the property.</para>
          <para>In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named "Item". However, a class library developer can use the <see cref="T:System.Runtime.CompilerServices.IndexerNameAttribute" /> attribute to change the name of the indexer in the metadata. For example, the <see cref="T:System.String" /> class has an indexer named <see cref="P:System.String.Chars(System.Int32)" />. Indexed properties created using languages other than C# can have names other than Item, as well. </para>
          <para>To determine whether a type has a default property, use the <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> method to test for the <see cref="T:System.Reflection.DefaultMemberAttribute" /> attribute. If the type has <see cref="T:System.Reflection.DefaultMemberAttribute" />, the <see cref="P:System.Reflection.DefaultMemberAttribute.MemberName" /> property returns the name of the default property.  </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the public property with the specified name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the public property with the specified name, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the public property to get. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> is <see langword="null" />.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which properties to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public properties in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public properties (that is, private, internal, and protected properties) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the properties declared on the <see cref="T:System.Type" />, not properties that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          <para>Situations in which <see cref="T:System.Reflection.AmbiguousMatchException" /> occurs include the following:</para>
          <list type="bullet">
            <item>
              <para>A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <see cref="Overload:System.Type.GetProperty" /> method that specifies parameter types.</para>
            </item>
            <item>
              <para>A derived type declares a property that hides an inherited property with the same name, using the new modifier (Shadows in Visual Basic). To resolve the ambiguity, include <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to restrict the search to members that are not inherited.</para>
            </item>
          </list>
          <format type="text/html">
            <h2>Indexers and Default Properties</h2>
          </format>
          <para>vbprvblong, csprcslong, and vcprvclong have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable myList refers to an <see cref="T:System.Collections.ArrayList" />, the syntax myList[3] (myList(3) in Visual Basic) retrieves the element with the index of 3. You can overload the property.</para>
          <para>In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named "Item". However, a class library developer can use the <see cref="T:System.Runtime.CompilerServices.IndexerNameAttribute" /> attribute to change the name of the indexer in the metadata. For example, the <see cref="T:System.String" /> class has an indexer named <see cref="P:System.String.Chars(System.Int32)" />. Indexed properties created using languages other than C# can have names other than Item, as well. </para>
          <para>To determine whether a type has a default property, use the <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> method to test for the <see cref="T:System.Reflection.DefaultMemberAttribute" /> attribute. If the type has <see cref="T:System.Reflection.DefaultMemberAttribute" />, the <see cref="P:System.Reflection.DefaultMemberAttribute.MemberName" /> property returns the name of the default property.  </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified property, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the property that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the property to get. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> is <see langword="null" />.</para>
        </exception>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The return type of the property. </param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance properties.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          <format type="text/html">
            <h2>Indexers and Default Properties</h2>
          </format>
          <para>vbprvblong, csprcslong, and vcprvclong have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable myList refers to an <see cref="T:System.Collections.ArrayList" />, the syntax myList[3] (myList(3) in Visual Basic) retrieves the element with the index of 3. You can overload the property.</para>
          <para>In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named "Item". However, a class library developer can use the <see cref="T:System.Runtime.CompilerServices.IndexerNameAttribute" /> attribute to change the name of the indexer in the metadata. For example, the <see cref="T:System.String" /> class has an indexer named <see cref="P:System.String.Chars(System.Int32)" />. Indexed properties created using languages other than C# can have names other than Item, as well. </para>
          <para>To determine whether a type has a default property, use the <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> method to test for the <see cref="T:System.Reflection.DefaultMemberAttribute" /> attribute. If the type has <see cref="T:System.Reflection.DefaultMemberAttribute" />, the <see cref="P:System.Reflection.DefaultMemberAttribute.MemberName" /> property returns the name of the default property.  </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the public property with the specified name and return type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the public property with the specified name, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the public property to get. </param>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The return type of the property. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance properties.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          <format type="text/html">
            <h2>Indexers and Default Properties</h2>
          </format>
          <para>vbprvblong, csprcslong, and vcprvclong have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable myList refers to an <see cref="T:System.Collections.ArrayList" />, the syntax myList[3] (myList(3) in Visual Basic) retrieves the element with the index of 3. You can overload the property.</para>
          <para>In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named "Item". However, a class library developer can use the <see cref="T:System.Runtime.CompilerServices.IndexerNameAttribute" /> attribute to change the name of the indexer in the metadata. For example, the <see cref="T:System.String" /> class has an indexer named <see cref="P:System.String.Chars(System.Int32)" />. Indexed properties created using languages other than C# can have names other than Item, as well. </para>
          <para>To determine whether a type has a default property, use the <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> method to test for the <see cref="T:System.Reflection.DefaultMemberAttribute" /> attribute. If the type has <see cref="T:System.Reflection.DefaultMemberAttribute" />, the <see cref="P:System.Reflection.DefaultMemberAttribute.MemberName" /> property returns the name of the default property.  </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified public property whose parameters match the specified argument types.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the public property whose parameters match the specified argument types, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the public property to get. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> has more than one dimension.</exception>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The return type of the property. </param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance properties.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          <format type="text/html">
            <h2>Indexers and Default Properties</h2>
          </format>
          <para>vbprvblong, csprcslong, and vcprvclong have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable myList refers to an <see cref="T:System.Collections.ArrayList" />, the syntax myList[3] (myList(3) in Visual Basic) retrieves the element with the index of 3. You can overload the property.</para>
          <para>In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named "Item". However, a class library developer can use the <see cref="T:System.Runtime.CompilerServices.IndexerNameAttribute" /> attribute to change the name of the indexer in the metadata. For example, the <see cref="T:System.String" /> class has an indexer named <see cref="P:System.String.Chars(System.Int32)" />. Indexed properties created using languages other than C# can have names other than Item, as well. </para>
          <para>To determine whether a type has a default property, use the <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> method to test for the <see cref="T:System.Reflection.DefaultMemberAttribute" /> attribute. If the type has <see cref="T:System.Reflection.DefaultMemberAttribute" />, the <see cref="P:System.Reflection.DefaultMemberAttribute.MemberName" /> property returns the name of the default property.  </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified public property whose parameters match the specified argument types.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the public property whose parameters match the specified argument types, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the public property to get. </param>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The return type of the property. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>Although the default binder does not process <see cref="T:System.Reflection.ParameterModifier" /> (the <paramref name="modifiers" /> parameter), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="modifiers" />. ParameterModifier is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
          <para>The search for <paramref name="name" /> is case-sensitive. The search includes public static and public instance properties.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          <format type="text/html">
            <h2>Indexers and Default Properties</h2>
          </format>
          <para>vbprvblong, csprcslong, and vcprvclong have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable myList refers to an <see cref="T:System.Collections.ArrayList" />, the syntax myList[3] (myList(3) in Visual Basic) retrieves the element with the index of 3. You can overload the property.</para>
          <para>In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named "Item". However, a class library developer can use the <see cref="T:System.Runtime.CompilerServices.IndexerNameAttribute" /> attribute to change the name of the indexer in the metadata. For example, the <see cref="T:System.String" /> class has an indexer named <see cref="P:System.String.Chars(System.Int32)" />. Indexed properties created using languages other than C# can have names other than Item, as well. </para>
          <para>To determine whether a type has a default property, use the <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> method to test for the <see cref="T:System.Reflection.DefaultMemberAttribute" /> attribute. If the type has <see cref="T:System.Reflection.DefaultMemberAttribute" />, the <see cref="P:System.Reflection.DefaultMemberAttribute.MemberName" /> property returns the name of the default property.  </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified public property whose parameters match the specified argument types and modifiers.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the public property that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the public property to get. </param>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The return type of the property. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. The default binder does not process this parameter. </param>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, class System.Reflection.ParameterModifier[] modifiers)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The return type of the property. </param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <see cref="F:System.Reflection.BindingFlags.NonPublic" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> (in Visual Basic, combine the values using Or) to get it.</para>
          <para>Although the default binder does not process <see cref="T:System.Reflection.ParameterModifier" /> (the <paramref name="modifiers" /> parameter), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="modifiers" />. ParameterModifier is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which properties to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public properties in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public properties (that is, private, internal, and protected properties) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the properties declared on the <see cref="T:System.Type" />, not properties that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</para>
          <format type="text/html">
            <h2>Indexers and Default Properties</h2>
          </format>
          <para>vbprvblong, csprcslong, and vcprvclong have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable myList refers to an <see cref="T:System.Collections.ArrayList" />, the syntax myList[3] (myList(3) in Visual Basic) retrieves the element with the index of 3. You can overload the property.</para>
          <para>In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named "Item". However, a class library developer can use the <see cref="T:System.Runtime.CompilerServices.IndexerNameAttribute" /> attribute to change the name of the indexer in the metadata. For example, the <see cref="T:System.String" /> class has an indexer named <see cref="P:System.String.Chars(System.Int32)" />. Indexed properties created using languages other than C# can have names other than Item, as well. </para>
          <para>To determine whether a type has a default property, use the <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> method to test for the <see cref="T:System.Reflection.DefaultMemberAttribute" /> attribute. If the type has <see cref="T:System.Reflection.DefaultMemberAttribute" />, the <see cref="P:System.Reflection.DefaultMemberAttribute.MemberName" /> property returns the name of the default property.  </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the property that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the property to get. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The return type of the property. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. The default binder does not process this parameter. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, class System.Reflection.ParameterModifier[] modifiers)" />
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The return type of the property. </param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Although the default binder does not process <see cref="T:System.Reflection.ParameterModifier" /> (the <paramref name="modifiers" /> parameter), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="modifiers" />. ParameterModifier is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which properties to include in the search: </para>
          <list type="bullet">
            <item>
              <para>You must specify either BindingFlags.Instance or BindingFlags.Static in order to get a return.</para>
            </item>
            <item>
              <para>Specify BindingFlags.Public to include public properties in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public properties (that is, private, internal, and protected properties) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include public and protected static members up the hierarchy; private static members in inherited classes are not included.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the properties declared on the <see cref="T:System.Type" />, not properties that were simply inherited.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the property that matches the specified requirements, if found; otherwise, null.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the property to get. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="returnType">
          <attribution license="cc4" from="Microsoft" modified="false" />The return type of the property. </param>
        <param name="types">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. The default binder does not process this parameter. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The current <see cref="T:System.Type" />.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Type GetType(string typeName)" />
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />. </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A type initializer was invoked and threw an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use the <see cref="M:System.Type.GetType" /> method to obtain a <see cref="T:System.Type" /> object for a type in another assembly, if the you know its namespace-qualified name. <see cref="M:System.Type.GetType" /> causes loading of the assembly specified in <paramref name="typeName" />. You can also load an assembly using the <see cref="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" /> method, and then use the <see cref="M:System.Type.GetType" /> or <see cref="M:System.Reflection.Assembly.GetTypes" /> methods of the <see cref="T:System.Reflection.Assembly" /> class to get <see cref="T:System.Type" /> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use typeof in C#, <see cref="M:System.Type.GetType" /> in Visual Basic, or typeid in C++.</para>
          <para>GetType only works on assemblies loaded from disk. If you call GetType to look up a type defined in a dynamic assembly defined using the <see cref="N:System.Reflection.Emit" /> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the RunAndSave or Save access modes of the <see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /> enumeration. If the dynamic assembly is persistent and has been written to disk before GetType is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when GetType is called, the method returns null. GetType does not understand transient dynamic assemblies; therefore, calling GetType to retrieve a type in a transient dynamic assembly returns null.</para>
          <para>To use GetType on a dynamic module, subscribe to the <see cref="E:System.AppDomain.AssemblyResolve" /> event and call GetType before saving. Otherwise, you will get two copies of the assembly in memory.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</para>
          <para>
            <paramref name="typeName" /> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <see cref="P:System.Type.AssemblyQualifiedName" />.</para>
          <para>If <paramref name="typeName" /> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.</para>
          <para>The <see cref="P:System.Type.AssemblyQualifiedName" /> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, "ProcessorArchitecture=msil". However, it is not included in the string returned by the <see cref="P:System.Type.AssemblyQualifiedName" /> property, for compatibility reasons. You can also load types by creating an <see cref="T:System.Reflection.AssemblyName" /> object and passing it to an appropriate overload of the <see cref="Overload:System.Reflection.Assembly.Load" /> method. You can then use the <see cref="M:System.Reflection.Assembly.GetType(System.String)" /> method to load types from the assembly. See also <see cref="P:System.Reflection.AssemblyName.ProcessorArchitecture" />.</para>
          </block>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Delimiter </para>
                </term>
                <description>
                  <para>Meaning </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Backslash (\) </para>
              </term>
              <description>
                <para>Escape character. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Backtick (`)</para>
              </term>
              <description>
                <para>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</para>
              </description>
            </item>
            <item>
              <term>
                <para>Brackets ([]) </para>
              </term>
              <description>
                <para>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Comma (,) </para>
              </term>
              <description>
                <para>Precedes the Assembly name. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Period (.) </para>
              </term>
              <description>
                <para>Denotes namespace identifiers. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Plus sign (+) </para>
              </term>
              <description>
                <para>Precedes a nested class. </para>
              </description>
            </item>
          </list>
          <para>For example, the fully qualified name for a class might look like this: </para>
          <code>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly</code>
          <para>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows: </para>
          <code>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</code>
          <para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
          <para>This qualified name can be persisted and later used to load the <see cref="T:System.Type" />. To search for and load a <see cref="T:System.Type" />, use <see cref="M:System.Type.GetType" /> either with the type name only or with the assembly qualified type name. <see cref="M:System.Type.GetType" /> with the type name only will look for the <see cref="T:System.Type" /> in the caller's assembly and then in the System assembly. <see cref="M:System.Type.GetType" /> with the assembly qualified type name will look for the <see cref="T:System.Type" /> in any assembly.</para>
          <para>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use t.GetElementType().ToString(), where <paramref name="t" /> is the type.</para>
          <para>Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</para>
          <para>The name of a generic type ends with a backtick (`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names Tuple`1 and Tuple`2 from the generic methods Tuple(Of T) and Tuple(Of T0, T1) in Visual Basic, or Tuple&lt;T&gt; and Tuple&lt;T0, T1&gt; in Visual C#.</para>
          <para>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <see cref="T:System.Collections.Generic.Dictionary`2" /> has two type parameters. A <see cref="T:System.Collections.Generic.Dictionary`2" /> of MyType with keys of type <see cref="T:System.String" /> might be represented as follows: </para>
          <code>System.Collections.Generic.Dictionary`2[System.String,MyType]</code>
          <para>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <see cref="T:System.Collections.Generic.Dictionary`2" /> of MyType from MyAssembly.dll, with keys of type <see cref="T:System.String" />, might be specified as follows: </para>
          <code>Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")</code>
          <block subset="none" type="note">
            <para>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</para>
          </block>
          <para>Nullable types are a special case of generic types. For example, a nullable <see cref="T:System.Int32" /> is represented by the string "System.Nullable`1[System.Int32]". </para>
          <block subset="none" type="note">
            <para>In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <see cref="T:System.Boolean" /> type is returned by typeof(Nullable&lt;bool&gt;) in C#, by Nullable&lt;Boolean&gt;::typeid in C++, and by GetType(Nullable(Of Boolean)) in Visual Basic. </para>
          </block>
          <para>The following table shows the syntax you use with GetType for various types.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>To Get </para>
                </term>
                <description>
                  <para>Use </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>A nullable <see cref="T:System.Int32" /></para>
              </term>
              <description>
                <para>Type.GetType("System.Nullable`1[System.Int32]")</para>
              </description>
            </item>
            <item>
              <term>
                <para>An unmanaged pointer to MyType </para>
              </term>
              <description>
                <para>Type.GetType("MyType*") </para>
              </description>
            </item>
            <item>
              <term>
                <para>An unmanaged pointer to a pointer to MyType </para>
              </term>
              <description>
                <para>Type.GetType("MyType**") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A managed pointer or reference to MyType </para>
              </term>
              <description>
                <para>Type.GetType("MyType&amp;"). Note that unlike pointers, references are limited to one level. </para>
              </description>
            </item>
            <item>
              <term>
                <para>A parent class and a nested class </para>
              </term>
              <description>
                <para>Type.GetType("MyParentClass+MyNestedClass") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A one-dimensional array with a lower bound of 0 </para>
              </term>
              <description>
                <para>Type.GetType("MyType[]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A one-dimensional array with an unknown lower bound </para>
              </term>
              <description>
                <para>Type.GetType("MyType[*]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>An n-dimensional array </para>
              </term>
              <description>
                <para>A comma (,) inside the brackets a total of n-1 times. For example, System.Object[,,] represents a three-dimensional Object array. </para>
              </description>
            </item>
            <item>
              <term>
                <para>An array of one-dimensional arrays </para>
              </term>
              <description>
                <para>Type.GetType("MyType[][]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A rectangular two-dimensional array with unknown lower bounds </para>
              </term>
              <description>
                <para>Type.GetType("MyType[,]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type with one type argument </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`1[MyType]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type with two type arguments </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`2[MyType,AnotherType]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type with two assembly-qualified type arguments </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>An assembly-qualified generic type with an assembly-qualified type argument </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type whose type argument is a generic type with two type arguments </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]") </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type with the specified name, if found; otherwise, null.</para>
        </returns>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly-qualified name of the type to get. See <see cref="P:System.Type.AssemblyQualifiedName" />. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Type GetType(string typeName, bool throwOnError)" />
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />. </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A type initializer was invoked and threw an exception.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> is <see langword="true" /> and an error was encountered while loading the <see cref="T:System.Type" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public objects. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true" /></permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use the <see cref="M:System.Type.GetType" /> method to obtain a <see cref="T:System.Type" /> object for a type in another assembly, if the you know its namespace-qualified name. <see cref="M:System.Type.GetType" /> causes loading of the assembly specified in <paramref name="typeName" />. You can also load an assembly using the <see cref="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" /> method, and then use the <see cref="M:System.Type.GetType" /> or <see cref="M:System.Reflection.Assembly.GetTypes" /> methods of the <see cref="T:System.Reflection.Assembly" /> class to get <see cref="T:System.Type" /> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use typeof in C#, <see cref="M:System.Type.GetType" /> in Visual Basic, or typeid in C++.</para>
          <para>GetType only works on assemblies loaded from disk. If you call GetType to look up a type defined in a dynamic assembly defined using the <see cref="N:System.Reflection.Emit" /> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the RunAndSave or Save access modes of the <see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /> enumeration. If the dynamic assembly is persistent and has been written to disk before GetType is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when GetType is called, the method returns null. GetType does not understand transient dynamic assemblies; therefore, calling GetType to retrieve a type in a transient dynamic assembly returns null.</para>
          <para>To use GetType on a dynamic module, subscribe to the <see cref="E:System.AppDomain.AssemblyResolve" /> event and call GetType before saving. Otherwise, you will get two copies of the assembly in memory.</para>
          <para>The <paramref name="throwOnError" /> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of <paramref name="throwOnError" />. For example, if the type is found but cannot be loaded, a <see cref="T:System.TypeLoadException" /> is thrown even if <paramref name="throwOnError" /> is false.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</para>
          <para>
            <paramref name="typeName" /> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <see cref="P:System.Type.AssemblyQualifiedName" />.</para>
          <para>If <paramref name="typeName" /> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.</para>
          <para>The <see cref="P:System.Type.AssemblyQualifiedName" /> property returns a fully qualified type name including nested types, the assembly name, and generic arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, "ProcessorArchitecture=msil". However, it is not included in the string returned by the <see cref="P:System.Type.AssemblyQualifiedName" /> property, for compatibility reasons. You can also load types by creating an <see cref="T:System.Reflection.AssemblyName" /> object and passing it to an appropriate overload of the <see cref="Overload:System.Reflection.Assembly.Load" /> method. You can then use the <see cref="M:System.Reflection.Assembly.GetType(System.String)" /> method to load types from the assembly. See also <see cref="P:System.Reflection.AssemblyName.ProcessorArchitecture" />.</para>
          </block>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Delimiter </para>
                </term>
                <description>
                  <para>Meaning </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Backslash (\) </para>
              </term>
              <description>
                <para>Escape character. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Backtick (`)</para>
              </term>
              <description>
                <para>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</para>
              </description>
            </item>
            <item>
              <term>
                <para>Brackets ([]) </para>
              </term>
              <description>
                <para>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Comma (,) </para>
              </term>
              <description>
                <para>Precedes the Assembly name. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Period (.) </para>
              </term>
              <description>
                <para>Denotes namespace identifiers. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Plus sign (+) </para>
              </term>
              <description>
                <para>Precedes a nested class. </para>
              </description>
            </item>
          </list>
          <para>For example, the fully qualified name for a class might look like this: </para>
          <code>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly</code>
          <para>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows: </para>
          <code>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</code>
          <para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
          <para>This qualified name can be persisted and later used to load the <see cref="T:System.Type" />. To search for and load a <see cref="T:System.Type" />, use <see cref="M:System.Type.GetType" /> either with the type name only or with the assembly qualified type name. <see cref="M:System.Type.GetType" /> with the type name only will look for the <see cref="T:System.Type" /> in the caller's assembly and then in the System assembly. <see cref="M:System.Type.GetType" /> with the assembly qualified type name will look for the <see cref="T:System.Type" /> in any assembly.</para>
          <para>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use t.GetElementType().ToString(), where <paramref name="t" /> is the type.</para>
          <para>Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</para>
          <para>The name of a generic type ends with a backtick (`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names Tuple`1 and Tuple`2 from the generic methods Tuple(Of T) and Tuple(Of T0, T1) in Visual Basic, or Tuple&lt;T&gt; and Tuple&lt;T0, T1&gt; in Visual C#.</para>
          <para>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <see cref="T:System.Collections.Generic.Dictionary`2" /> has two type parameters. A <see cref="T:System.Collections.Generic.Dictionary`2" /> of MyType with keys of type <see cref="T:System.String" /> might be represented as follows: </para>
          <code>System.Collections.Generic.Dictionary`2[System.String,MyType]</code>
          <para>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <see cref="T:System.Collections.Generic.Dictionary`2" /> of MyType from MyAssembly.dll, with keys of type <see cref="T:System.String" />, might be specified as follows: </para>
          <code>Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")</code>
          <block subset="none" type="note">
            <para>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</para>
          </block>
          <para>Nullable types are a special case of generic types. For example, a nullable <see cref="T:System.Int32" /> is represented by the string "System.Nullable`1[System.Int32]". </para>
          <block subset="none" type="note">
            <para>In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <see cref="T:System.Boolean" /> type is returned by typeof(Nullable&lt;bool&gt;) in C#, by Nullable&lt;Boolean&gt;::typeid in C++, and by GetType(Nullable(Of Boolean)) in Visual Basic. </para>
          </block>
          <para>The following table shows the syntax you use with GetType for various types.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>To Get </para>
                </term>
                <description>
                  <para>Use </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>A nullable <see cref="T:System.Int32" /></para>
              </term>
              <description>
                <para>Type.GetType("System.Nullable`1[System.Int32]")</para>
              </description>
            </item>
            <item>
              <term>
                <para>An unmanaged pointer to MyType </para>
              </term>
              <description>
                <para>Type.GetType("MyType*") </para>
              </description>
            </item>
            <item>
              <term>
                <para>An unmanaged pointer to a pointer to MyType </para>
              </term>
              <description>
                <para>Type.GetType("MyType**") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A managed pointer or reference to MyType </para>
              </term>
              <description>
                <para>Type.GetType("MyType&amp;"). Note that unlike pointers, references are limited to one level. </para>
              </description>
            </item>
            <item>
              <term>
                <para>A parent class and a nested class </para>
              </term>
              <description>
                <para>Type.GetType("MyParentClass+MyNestedClass") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A one-dimensional array with a lower bound of 0 </para>
              </term>
              <description>
                <para>Type.GetType("MyArray[]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A one-dimensional array with an unknown lower bound </para>
              </term>
              <description>
                <para>Type.GetType("MyArray[*]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>An n-dimensional array </para>
              </term>
              <description>
                <para>A comma (,) inside the brackets a total of n-1 times. For example, System.Object[,,] represents a three-dimensional Object array. </para>
              </description>
            </item>
            <item>
              <term>
                <para>A two-dimensional array's array </para>
              </term>
              <description>
                <para>Type.GetType("MyArray[][]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A rectangular two-dimensional array with unknown lower bounds </para>
              </term>
              <description>
                <para>Type.GetType("MyArray[,]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type with one type argument </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`1[MyType]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type with two type arguments </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`2[MyType,AnotherType]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type with two assembly-qualified type arguments </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>An assembly-qualified generic type with an assembly-qualified type argument </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type whose type argument is a generic type with two type arguments </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]") </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type with the specified name. If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether null is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />. See the Exceptions section. </para>
        </returns>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly-qualified name of the type to get. See <see cref="P:System.Type.AssemblyQualifiedName" />. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</param>
        <param name="throwOnError">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw an exception if the type cannot be found; false to return null. Specifying false also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase)" />
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A type initializer was invoked and threw an exception.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> is <see langword="true" /> and an error was encountered while loading the selected <see cref="T:System.Type" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use the <see cref="M:System.Type.GetType" /> method to obtain a <see cref="T:System.Type" /> object for a type in another assembly, if the you know its namespace-qualified name. <see cref="M:System.Type.GetType" /> causes loading of the assembly specified in <paramref name="typeName" />. You can also load an assembly using the <see cref="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" /> method, and then use the <see cref="M:System.Type.GetType" /> or <see cref="M:System.Reflection.Assembly.GetTypes" /> methods of the <see cref="T:System.Reflection.Assembly" /> class to get <see cref="T:System.Type" /> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use typeof in C#, <see cref="M:System.Type.GetType" /> in Visual Basic, or typeid in C++.</para>
          <para>GetType only works on assemblies loaded from disk. If you call GetType to look up a type defined in a dynamic assembly defined using the <see cref="N:System.Reflection.Emit" /> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the RunAndSave or Save access modes of the <see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /> enumeration. If the dynamic assembly is persistent and has been written to disk before GetType is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when GetType is called, the method returns null. GetType does not understand transient dynamic assemblies; therefore, calling GetType to retrieve a type in a transient dynamic assembly returns null.</para>
          <para>To use GetType on a dynamic module, subscribe to the <see cref="E:System.AppDomain.AssemblyResolve" /> event and call GetType before saving. Otherwise, you will get two copies of the assembly in memory.</para>
          <para>The <paramref name="throwOnError" /> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of <paramref name="throwOnError" />. For example, if the type is found but cannot be loaded, a <see cref="T:System.TypeLoadException" /> is thrown even if <paramref name="throwOnError" /> is false.</para>
          <para>The following table shows what members of a base class are returned by the Get methods when reflecting on a type.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Member Type </para>
                </term>
                <description>
                  <para>Static </para>
                </description>
                <description>
                  <para>Non-Static </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Constructor </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Field </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A field is always hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Event </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Method </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Nested Type </para>
              </term>
              <description>
                <para>No </para>
              </description>
              <description>
                <para>No </para>
              </description>
            </item>
            <item>
              <term>
                <para>Property </para>
              </term>
              <description>
                <para>Not applicable </para>
              </description>
              <description>
                <para>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below. </para>
              </description>
            </item>
          </list>
          <list type="ordered">
            <item>
              <para>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.</para>
            </item>
            <item>
              <para>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</para>
            </item>
            <item>
              <para>Custom attributes are not part of the common type system.</para>
            </item>
          </list>
          <para>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</para>
          <para>
            <paramref name="typeName" /> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <see cref="P:System.Type.AssemblyQualifiedName" />.</para>
          <para>If <paramref name="typeName" /> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.</para>
          <para>The <see cref="P:System.Type.AssemblyQualifiedName" /> property returns a fully qualified type name including nested types, the assembly name, and type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, "ProcessorArchitecture=msil". However, it is not included in the string returned by the <see cref="P:System.Type.AssemblyQualifiedName" /> property, for compatibility reasons. You can also load types by creating an <see cref="T:System.Reflection.AssemblyName" /> object and passing it to an appropriate overload of the <see cref="Overload:System.Reflection.Assembly.Load" /> method. You can then use the <see cref="M:System.Reflection.Assembly.GetType(System.String)" /> method to load types from the assembly. See also <see cref="P:System.Reflection.AssemblyName.ProcessorArchitecture" />.</para>
          </block>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Delimiter </para>
                </term>
                <description>
                  <para>Meaning </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Backslash (\) </para>
              </term>
              <description>
                <para>Escape character. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Backtick (`)</para>
              </term>
              <description>
                <para>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</para>
              </description>
            </item>
            <item>
              <term>
                <para>Brackets ([]) </para>
              </term>
              <description>
                <para>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Comma (,) </para>
              </term>
              <description>
                <para>Precedes the Assembly name. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Period (.) </para>
              </term>
              <description>
                <para>Denotes namespace identifiers. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Plus sign (+) </para>
              </term>
              <description>
                <para>Precedes a nested class. </para>
              </description>
            </item>
          </list>
          <para>For example, the fully qualified name for a class might look like this: </para>
          <code>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly</code>
          <para>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows: </para>
          <code>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</code>
          <para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
          <para>This qualified name can be persisted and later used to load the <see cref="T:System.Type" />. To search for and load a <see cref="T:System.Type" />, use <see cref="M:System.Type.GetType" /> either with the type name only or with the assembly qualified type name. <see cref="M:System.Type.GetType" /> with the type name only will look for the <see cref="T:System.Type" /> in the caller's assembly and then in the System assembly. <see cref="M:System.Type.GetType" /> with the assembly qualified type name will look for the <see cref="T:System.Type" /> in any assembly.</para>
          <para>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use t.GetElementType().ToString(), where <paramref name="t" /> is the type.</para>
          <para>Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</para>
          <para>The name of a generic type ends with a backtick (`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names Tuple`1 and Tuple`2 from the generic methods Tuple(Of T) and Tuple(Of T0, T1) in Visual Basic, or Tuple&lt;T&gt; and Tuple&lt;T0, T1&gt; in Visual C#.</para>
          <para>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <see cref="T:System.Collections.Generic.Dictionary`2" /> has two type parameters. A <see cref="T:System.Collections.Generic.Dictionary`2" /> of MyType with keys of type <see cref="T:System.String" /> might be represented as follows: </para>
          <code>System.Collections.Generic.Dictionary`2[System.String,MyType]</code>
          <para>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <see cref="T:System.Collections.Generic.Dictionary`2" /> of MyType from MyAssembly.dll, with keys of type <see cref="T:System.String" />, might be specified as follows: </para>
          <code>Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")</code>
          <block subset="none" type="note">
            <para>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</para>
          </block>
          <para>Nullable types are a special case of generic types. For example, a nullable <see cref="T:System.Int32" /> is represented by the string "System.Nullable`1[System.Int32]". </para>
          <block subset="none" type="note">
            <para>In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <see cref="T:System.Boolean" /> type is returned by typeof(Nullable&lt;bool&gt;) in C#, by Nullable&lt;Boolean&gt;::typeid in C++, and by GetType(Nullable(Of Boolean)) in Visual Basic. </para>
          </block>
          <para>The following table shows the syntax you use with GetType for various types.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>To Get </para>
                </term>
                <description>
                  <para>Use </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>A nullable <see cref="T:System.Int32" /></para>
              </term>
              <description>
                <para>Type.GetType("System.Nullable`1[System.Int32]")</para>
              </description>
            </item>
            <item>
              <term>
                <para>An unmanaged pointer to MyType </para>
              </term>
              <description>
                <para>Type.GetType("MyType*") </para>
              </description>
            </item>
            <item>
              <term>
                <para>An unmanaged pointer to a pointer to MyType </para>
              </term>
              <description>
                <para>Type.GetType("MyType**") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A managed pointer or reference to MyType </para>
              </term>
              <description>
                <para>Type.GetType("MyType&amp;"). Note that unlike pointers, references are limited to one level. </para>
              </description>
            </item>
            <item>
              <term>
                <para>A parent class and a nested class </para>
              </term>
              <description>
                <para>Type.GetType("MyParentClass+MyNestedClass") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A one-dimensional array with a lower bound of 0 </para>
              </term>
              <description>
                <para>Type.GetType("MyArray[]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A one-dimensional array with an unknown lower bound </para>
              </term>
              <description>
                <para>Type.GetType("MyArray[*]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>An n-dimensional array </para>
              </term>
              <description>
                <para>A comma (,) inside the brackets a total of n-1 times. For example, System.Object[,,] represents a three-dimensional Object array. </para>
              </description>
            </item>
            <item>
              <term>
                <para>A two-dimensional array's array </para>
              </term>
              <description>
                <para>Type.GetType("MyArray[][]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A rectangular two-dimensional array with unknown lower bounds </para>
              </term>
              <description>
                <para>Type.GetType("MyArray[,]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type with one type argument </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`1[MyType]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type with two type arguments </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`2[MyType,AnotherType]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type with two assembly-qualified type arguments </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]") </para>
              </description>
            </item>
            <item>
              <term>
                <para>An assembly-qualified generic type with an assembly-qualified type argument </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly") </para>
              </description>
            </item>
            <item>
              <term>
                <para>A generic type whose type argument is a generic type with two type arguments </para>
              </term>
              <description>
                <para>Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]") </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type with the specified name. If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether null is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />. See the Exceptions section. </para>
        </returns>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly-qualified name of the type to get. See <see cref="P:System.Type.AssemblyQualifiedName" />. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</param>
        <param name="throwOnError">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw an exception if the type cannot be found; false to return null.Specifying false also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />true to perform a case-insensitive search for <paramref name="typeName" />, false to perform a case-sensitive search for <paramref name="typeName" />. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Usage scenarios for this method and details about the <paramref name="assemblyResolver" /> and <paramref name="typeResolver" /> parameters can be found in the <see cref="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" /> method overload.</para>
          <para>Calling this method overload is the same as calling the <see cref="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" /> method overload and specifying false for the <paramref name="throwOnError" /> and <paramref name="ignoreCase" /> parameters. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type with the specified name, or null if the type is not found. </para>
        </returns>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the type to get. If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving. If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</param>
        <param name="assemblyResolver">
          <attribution license="cc4" from="Microsoft" modified="false" />A method that locates and returns the assembly that is specified in <paramref name="typeName" />. The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object. If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called. If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed. </param>
        <param name="typeResolver">
          <attribution license="cc4" from="Microsoft" modified="false" />A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution. If no assembly is provided, the <paramref name="typeResolver" /> method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; false is passed to that parameter. </param>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Usage scenarios for this method and details about the <paramref name="assemblyResolver" /> and <paramref name="typeResolver" /> parameters can be found in the <see cref="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" /> method overload.</para>
          <para>Calling this method overload is the same as calling the <see cref="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" /> method overload and specifying false for the <paramref name="ignoreCase" /> parameter. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type with the specified name. If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether null is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />. See the Exceptions section. </para>
        </returns>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the type to get. If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving. If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</param>
        <param name="assemblyResolver">
          <attribution license="cc4" from="Microsoft" modified="false" />A method that locates and returns the assembly that is specified in <paramref name="typeName" />. The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object. If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called. If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed. </param>
        <param name="typeResolver">
          <attribution license="cc4" from="Microsoft" modified="false" />A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; false is passed to that parameter. </param>
        <param name="throwOnError">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw an exception if the type cannot be found; false to return null. Specifying false also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method overload and its associated overloads (<see cref="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" /> and <see cref="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />) to replace the default implementation of the <see cref="M:System.Type.GetType(System.String)" /> method with more flexible implementations. By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</para>
          <list type="bullet">
            <item>
              <para>Control which version of an assembly a type is loaded from.</para>
            </item>
            <item>
              <para>Provide another place to look for a type name that does not include an assembly name.</para>
            </item>
            <item>
              <para>Load assemblies using partial assembly names.</para>
            </item>
            <item>
              <para>Return subclasses of <see cref="T:System.Type" /> that are not created by the common language runtime (CLR).</para>
            </item>
          </list>
          <para>For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name. Other overloads of the <see cref="M:System.Type.GetType(System.String)" /> method require an assembly-qualified type name, which includes the version number. </para>
          <para>Alternate implementations of the type system may need to return subclasses of <see cref="T:System.Type" /> that are not created by the CLR; all types that are returned by other overloads of the <see cref="M:System.Type.GetType(System.String)" /> method are runtime types.</para>
          <format type="text/html">
            <a href="#usage_notes" />
          </format>
          <format type="text/html">
            <h2>Usage Notes</h2>
          </format>
          <para>This method overload and its associated overloads parse <paramref name="typeName" /> into the name of a type and the name of an assembly, and then resolve the names. Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly. </para>
          <block subset="none" type="note">
            <para>If you are unfamiliar with the concept of assembly-qualified type names, see the <see cref="P:System.Type.AssemblyQualifiedName" /> property.</para>
          </block>
          <para>If <paramref name="typeName" /> is not an assembly-qualified name, assembly resolution is skipped. Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the <paramref name="typeResolver" /> parameter. The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the <format type="text/html"><a href="#mixed_name_resolution">Mixed Name Resolution</a></format> section.</para>
          <para>General usage notes:</para>
          <list type="bullet">
            <item>
              <para>Do not pass methods to <paramref name="assemblyResolver" /> or <paramref name="typeResolver" /> if they come from unknown or untrusted callers. Use only methods that you provide or that you are familiar with.</para>
              <block subset="none" type="note">
                <para>Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code. </para>
              </block>
            </item>
            <item>
              <para>If you omit the <paramref name="assemblyResolver" /> and/or <paramref name="typeResolver" /> parameters, the value of the <paramref name="throwOnError" /> parameter is passed to the methods that perform the default resolution. </para>
            </item>
            <item>
              <para>If <paramref name="throwOnError" /> is true, this method throws a <see cref="T:System.TypeLoadException" /> when <paramref name="typeResolver" /> returns null, and a <see cref="T:System.IO.FileNotFoundException" /> when <paramref name="assemblyResolver" /> returns null.</para>
            </item>
            <item>
              <para>This method does not catch exceptions thrown by <paramref name="assemblyResolver" /> and <paramref name="typeResolver" />. You are responsible for any exceptions that are thrown by the resolver methods.</para>
            </item>
          </list>
          <format type="text/html">
            <a href="#resolving_assemblies" />
          </format>
          <format type="text/html">
            <h2>Resolving Assemblies</h2>
          </format>
          <para>The <paramref name="assemblyResolver" /> method receives an <see cref="T:System.Reflection.AssemblyName" /> object, which is produced by parsing the string assembly name that is included in <paramref name="typeName" />. If <paramref name="typeName" /> does not contain an assembly name, <paramref name="assemblyResolver" /> is not called and null is passed to <paramref name="typeResolver" />. </para>
          <para>If <paramref name="assemblyResolver" /> is not supplied, standard assembly probing is used to locate the assembly. If <paramref name="assemblyResolver" /> is provided, the <see cref="M:System.Type.GetType(System.String)" /> method does not do standard probing; in that case you must ensure that your <paramref name="assemblyResolver" /> can handle all the assemblies you pass to it.</para>
          <para>The <paramref name="assemblyResolver" /> method should return null if the assembly cannot be resolved. If <paramref name="assemblyResolver" /> returns null, <paramref name="typeResolver" /> is not called and no further processing occurs; additionally, if <paramref name="throwOnError" /> is true, a <see cref="T:System.IO.FileNotFoundException" /> is thrown.</para>
          <para>If the <see cref="T:System.Reflection.AssemblyName" /> that is passed to <paramref name="assemblyResolver" /> is a partial name, one or more of its parts are null. For example, if it has no version, the <see cref="P:System.Reflection.AssemblyName.Version" /> property is null. If the <see cref="P:System.Reflection.AssemblyName.Version" /> property, the <see cref="P:System.Reflection.AssemblyName.CultureInfo" /> property, and the <see cref="M:System.Reflection.AssemblyName.GetPublicKeyToken" /> method all return null, then only the simple name of the assembly was supplied. The <paramref name="assemblyResolver" /> method can use or ignore all parts of the assembly name.</para>
          <para>The effects of different assembly resolution options are displayed as a table in the <format type="text/html"><a href="#mixed_name_resolution">Mixed Name Resolution</a></format> section, for simple and assembly-qualified type names.</para>
          <format type="text/html">
            <a href="#resolving_types" />
          </format>
          <format type="text/html">
            <h2>Resolving Types</h2>
          </format>
          <para>If <paramref name="typeName" /> does not specify an assembly name, <paramref name="typeResolver" /> is always called. If <paramref name="typeName" /> specifies an assembly name, <paramref name="typeResolver" /> is called only when the assembly name is successfully resolved. If <paramref name="assemblyResolver" /> or standard assembly probing returns null, <paramref name="typeResolver" /> is not called. </para>
          <para>The <paramref name="typeResolver" /> method receives three arguments: </para>
          <list type="bullet">
            <item>
              <para>The assembly to search or null if <paramref name="typeName" /> does not contain an assembly name.</para>
            </item>
            <item>
              <para>The simple name of the type. In the case of a nested type, this is the outermost containing type. In the case of a generic type, this is the simple name of the generic type.</para>
            </item>
            <item>
              <para>A Boolean value that is true if the case of type names is to be ignored. </para>
            </item>
          </list>
          <para>The implementation determines the way these arguments are used. The <paramref name="typeResolver" /> method should return null if it cannot resolve the type. If <paramref name="typeResolver" /> returns null and <paramref name="throwOnError" /> is true, this overload of <see cref="M:System.Type.GetType(System.String)" /> throws a <see cref="T:System.TypeLoadException" />. </para>
          <para>The effects of different type resolution options are displayed as a table in the <format type="text/html"><a href="#mixed_name_resolution">Mixed Name Resolution</a></format> section, for simple and assembly-qualified type names.</para>
          <format type="text/html">
            <h2>Resolving Nested Types</h2>
          </format>
          <para>If <paramref name="typeName" /> is a nested type, only the name of the outermost containing type is passed to <paramref name="typeResolver" />. When <paramref name="typeResolver" /> returns this type, the <see cref="M:System.Type.GetNestedType(System.String)" /> method is called recursively until the innermost nested type has been resolved. </para>
          <format type="text/html">
            <h2>Resolving Generic Types</h2>
          </format>
          <para>The <see cref="M:System.Type.GetType(System.String)" /> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments. If a type argument is generic, <see cref="M:System.Type.GetType(System.String)" /> is called recursively to resolve its type arguments, and so on.</para>
          <para>The combination of <paramref name="assemblyResolver" /> and <paramref name="typeResolver" /> that you provide must be capable of resolving all levels of this recursion. For example, suppose you supply an <paramref name="assemblyResolver" /> that controls the loading of MyAssembly. Suppose you want to resolve the generic type Dictionary&lt;string, MyType&gt; (Dictionary(Of String, MyType) in Visual Basic). You might pass the following generic type name:</para>
          <code>"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"</code>
          <para>Notice that MyType is the only assembly-qualified type argument. The names of the <see cref="T:System.Collections.Generic.Dictionary`2" /> and <see cref="T:System.String" /> classes are not assembly-qualified. Your <paramref name="typeResolver" /> must be able handle either an assembly or null, because it will receive null for <see cref="T:System.Collections.Generic.Dictionary`2" /> and <see cref="T:System.String" />. It can handle that case by calling an overload of the <see cref="M:System.Type.GetType(System.String)" /> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</para>
          <para>code reference: GetTypeOnSteroids#1</para>
          <para>The <paramref name="assemblyResolver" /> method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</para>
          <para>Now suppose that instead of System.String, the first generic argument type is YourType, from YourAssembly: </para>
          <code>"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"</code>
          <para>Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve YourType without an assembly-qualified name. Because your <paramref name="assemblyResolve" /> will be called recursively, it must be able to handle this case. Instead of returning null for assemblies other than MyAssembly, it now performs an assembly load using the supplied <see cref="T:System.Reflection.AssemblyName" /> object.</para>
          <para>code reference: GetTypeOnSteroids#2</para>
          <para>Back to <format type="text/html"><a href="#usage_notes">Usage Notes</a></format>.</para>
          <format type="text/html">
            <h2>Resolving Type Names with Special Characters</h2>
          </format>
          <para>Certain characters have special meanings in assembly-qualified names. If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name. To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <see cref="M:System.Type.GetType(System.String)" /> method. For example, if a type is named Strange]Type, the escape character must be added ahead of the square bracket as follows: Strange\]Type. </para>
          <block subset="none" type="note">
            <para>Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies. </para>
          </block>
          <para>The following table shows the special characters for type names.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Character</para>
                </term>
                <description>
                  <para>Meaning</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>, (comma)</para>
              </term>
              <description>
                <para>Delimiter for assembly-qualified names.</para>
              </description>
            </item>
            <item>
              <term>
                <para>[] (square brackets)</para>
              </term>
              <description>
                <para>As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</para>
              </description>
            </item>
            <item>
              <term>
                <para>&amp; (ampersand)</para>
              </term>
              <description>
                <para>As a suffix, indicates that a type is a reference type.</para>
              </description>
            </item>
            <item>
              <term>
                <para>* (asterisk)</para>
              </term>
              <description>
                <para>As a suffix, indicates that a type is a pointer type.</para>
              </description>
            </item>
            <item>
              <term>
                <para>+ (plus)</para>
              </term>
              <description>
                <para>Delimiter for nested types.</para>
              </description>
            </item>
            <item>
              <term>
                <para>\ (backslash)</para>
              </term>
              <description>
                <para>Escape character.</para>
              </description>
            </item>
          </list>
          <para>Properties such as <see cref="P:System.Type.AssemblyQualifiedName" /> return correctly escaped strings. You must pass correctly escaped strings to the <see cref="M:System.Type.GetType(System.String)" /> method. In turn, the <see cref="M:System.Type.GetType(System.String)" /> method passes correctly escaped names to <paramref name="typeResolver" /> and to the default type resolution methods. If you need to compare a name to an unescaped name in <paramref name="typeResolver" />, you must remove the escape characters. </para>
          <para>Back to <format type="text/html"><a href="#usage_notes">Usage Notes</a></format>.</para>
          <format type="text/html">
            <a href="#mixed_name_resolution" />
          </format>
          <format type="text/html">
            <h2>Mixed Name Resolution</h2>
          </format>
          <para>The following table summarizes the interactions between <paramref name="assemblyResolver" />, <paramref name="typeResolver" />, and default name resolution, for all combinations of type name and assembly name in <paramref name="typeName" />:</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Contents of type name</para>
                </term>
                <description>
                  <para>Assembly resolver method</para>
                </description>
                <description>
                  <para>Type resolver method</para>
                </description>
                <description>
                  <para>Result</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>type, assembly</para>
              </term>
              <description>
                <para>null</para>
              </description>
              <description>
                <para>null</para>
              </description>
              <description>
                <para>Equivalent to calling the <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" /> method overload. </para>
              </description>
            </item>
            <item>
              <term>
                <para>type, assembly</para>
              </term>
              <description>
                <para>provided</para>
              </description>
              <description>
                <para>null</para>
              </description>
              <description>
                <para>
                  <paramref name="assemblyResolver" /> returns the assembly or returns null if it cannot resolve the assembly. If the assembly is resolved, the <see cref="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" /> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</para>
              </description>
            </item>
            <item>
              <term>
                <para>type, assembly</para>
              </term>
              <description>
                <para>null</para>
              </description>
              <description>
                <para>provided</para>
              </description>
              <description>
                <para>Equivalent to converting the assembly name to an <see cref="T:System.Reflection.AssemblyName" /> object and calling the <see cref="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" /> method overload to get the assembly. If the assembly is resolved, it is passed to <paramref name="typeResolver" />; otherwise, <paramref name="typeResolver" /> is not called and there is no further attempt to resolve the type.</para>
              </description>
            </item>
            <item>
              <term>
                <para>type, assembly</para>
              </term>
              <description>
                <para>provided</para>
              </description>
              <description>
                <para>provided</para>
              </description>
              <description>
                <para>
                  <paramref name="assemblyResolver" /> returns the assembly or returns null if it cannot resolve the assembly. If the assembly is resolved, it is passed to <paramref name="typeResolver" />; otherwise, <paramref name="typeResolver" /> is not called and there is no further attempt to resolve the type.</para>
              </description>
            </item>
            <item>
              <term>
                <para>type</para>
              </term>
              <description>
                <para>null, provided</para>
              </description>
              <description>
                <para>null</para>
              </description>
              <description>
                <para>Equivalent to calling the <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" /> method overload. Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched. If <paramref name="assemblyResolver" /> is provided, it is ignored.</para>
              </description>
            </item>
            <item>
              <term>
                <para>type</para>
              </term>
              <description>
                <para>null, provided</para>
              </description>
              <description>
                <para>provided</para>
              </description>
              <description>
                <para>
                  <paramref name="typeResolver" /> is called, and null is passed for the assembly. <paramref name="typeResolver" /> can provide a type from any assembly, including assemblies it loads for the purpose. If <paramref name="assemblyResolver" /> is provided, it is ignored.</para>
              </description>
            </item>
            <item>
              <term>
                <para>assembly</para>
              </term>
              <description>
                <para>null, provided</para>
              </description>
              <description>
                <para>null, provided</para>
              </description>
              <description>
                <para>A <see cref="T:System.IO.FileLoadException" /> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name. This results in an invalid assembly name.</para>
              </description>
            </item>
          </list>
          <para>Back to: <format type="text/html"><a href="#usage_notes">Usage Notes</a></format>, <format type="text/html"><a href="#resolving_assemblies">Resolving Assemblies</a></format>, <format type="text/html"><a href="#resolving_types">Resolving Types</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type with the specified name. If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether null is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />. See the Exceptions section. </para>
        </returns>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the type to get. If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving. If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</param>
        <param name="assemblyResolver">
          <attribution license="cc4" from="Microsoft" modified="false" />A method that locates and returns the assembly that is specified in <paramref name="typeName" />. The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object. If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called. If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed. </param>
        <param name="typeResolver">
          <attribution license="cc4" from="Microsoft" modified="false" />A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <paramref name="ignoreCase" /> is passed to that parameter. </param>
        <param name="throwOnError">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw an exception if the type cannot be found; false to return null. Specifying false also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />true to perform a case-insensitive search for <paramref name="typeName" />, false to perform a case-sensitive search for <paramref name="typeName" />. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Type[] GetTypeArray(class System.Object[] args)" />
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> is <see langword="null" />. </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The type initializers were invoked and at least one threw an exception. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the types of the objects in the specified array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</para>
        </returns>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of objects whose types to determine. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When you inherit from <see cref="T:System.Type" />, you can change the behavior of this method by overriding the <see cref="M:System.Type.GetTypeCodeImpl" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the underlying type code of the specified <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is null.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The type whose underlying type code to get. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method provides the implementation for the <see cref="M:System.Type.GetTypeCode(System.Type)" /> method. When you inherit from <see cref="T:System.Type" />, you can override this method to provide your own implementation of <see cref="M:System.Type.GetTypeCode(System.Type)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the underlying type code of the specified <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The code of the underlying type.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type associated with the specified class identifier (CLSID).</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>System.__ComObject regardless of whether the CLSID is valid.</para>
        </returns>
        <param name="clsid">
          <attribution license="cc4" from="Microsoft" modified="false" />The CLSID of the type to get. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Exceptions such as <see cref="T:System.OutOfMemoryException" /> will be thrown when specifying true for <paramref name="throwOnError" />, but it will not fail for unregistered CLSIDs.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>System.__ComObject regardless of whether the CLSID is valid.</para>
        </returns>
        <param name="clsid">
          <attribution license="cc4" from="Microsoft" modified="false" />The CLSID of the type to get. </param>
        <param name="throwOnError">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw any exception that occurs.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type associated with the specified class identifier (CLSID) from the specified server.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>System.__ComObject regardless of whether the CLSID is valid.</para>
        </returns>
        <param name="clsid">
          <attribution license="cc4" from="Microsoft" modified="false" />The CLSID of the type to get. </param>
        <param name="server">
          <attribution license="cc4" from="Microsoft" modified="false" />The server from which to load the type. If the server name is null, this method automatically reverts to the local machine. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Exceptions such as <see cref="T:System.OutOfMemoryException" /> will be thrown when specifying true for <paramref name="throwOnError" />, but it will not fail for unregistered CLSIDs.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>System.__ComObject regardless of whether the CLSID is valid.</para>
        </returns>
        <param name="clsid">
          <attribution license="cc4" from="Microsoft" modified="false" />The CLSID of the type to get. </param>
        <param name="server">
          <attribution license="cc4" from="Microsoft" modified="false" />The server from which to load the type. If the server name is null, this method automatically reverts to the local machine. </param>
        <param name="throwOnError">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw any exception that occurs.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle)" />
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The requested type is non-public and outside the current assembly, and the caller does not have the required permission.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A type initializer was invoked and threw an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public objects. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true" /></permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The handles are valid only in the application domain in which they were obtained.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type referenced by the specified type handle.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or null if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is null.</para>
        </returns>
        <param name="handle">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that refers to the type. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is provided for COM support. ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, null.</para>
        </returns>
        <param name="progID">
          <attribution license="cc4" from="Microsoft" modified="false" />The ProgID of the type to get. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, null.</para>
        </returns>
        <param name="progID">
          <attribution license="cc4" from="Microsoft" modified="false" />The ProgID of the type to get. </param>
        <param name="throwOnError">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw any exception that occurs.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, null.</para>
        </returns>
        <param name="progID">
          <attribution license="cc4" from="Microsoft" modified="false" />The progID of the type to get. </param>
        <param name="server">
          <attribution license="cc4" from="Microsoft" modified="false" />The server from which to load the type. If the server name is null, this method automatically reverts to the local machine. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, null.</para>
        </returns>
        <param name="progID">
          <attribution license="cc4" from="Microsoft" modified="false" />The progID of the <see cref="T:System.Type" /> to get. </param>
        <param name="server">
          <attribution license="cc4" from="Microsoft" modified="false" />The server from which to load the type. If the server name is null, this method automatically reverts to the local machine. </param>
        <param name="throwOnError">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw any exception that occurs.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static valuetype System.RuntimeTypeHandle GetTypeHandle(object o)" />
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The handles are valid only in the application domain in which they were obtained.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the handle for the <see cref="T:System.Type" /> of a specified object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object for which to get the type handle. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A GUID is associated with a type using the <see cref="T:System.Runtime.InteropServices.GuidAttribute" /> attribute.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the GUID associated with the <see cref="T:System.Type" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="ILASM" Value=".property bool HasElementType { public hidebysig specialname instance bool get_HasElementType() }" />
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For example, Type.GetType("Int32[]").HasElementType returns true, but Type.GetType("Int32").HasElementType returns false. HasElementType also returns true for "Int32*" and "Int32&amp;".</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool HasElementTypeImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For example, Type.GetType("Int32[]").HasElementTypeImpl returns true, but Type.GetType("Int32").HasElementTypeImpl returns false. HasElementTypeImpl also returns true for "Int32*" and "Int32&amp;".</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, false.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, class System.Object[] args)" />
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="args" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> value.</para>
          <para>-or-</para>
          <para>The member to be invoked is a constructor and <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be invoked is a method that is not a type initializer or instance constructor, and <see cref="F:System.Reflection.BindingFlags.InvokeMethod" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a field, and neither <see cref="F:System.Reflection.BindingFlags.GetField" /> nor <see cref="F:System.Reflection.BindingFlags.SetField" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a property, and neither <see cref="F:System.Reflection.BindingFlags.GetProperty" /> nor <see cref="F:System.Reflection.BindingFlags.SetProperty" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> and at least one of <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />, <see cref="F:System.Reflection.BindingFlags.GetField" />, <see cref="F:System.Reflection.BindingFlags.SetField" />, <see cref="F:System.Reflection.BindingFlags.GetProperty" />, or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetField" /> and <see cref="F:System.Reflection.BindingFlags.SetField" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetProperty" /> and <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.InvokeMethod" /> and at least one of <see cref="F:System.Reflection.BindingFlags.SetField" /> or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.SetField" /> and <paramref name="args" /> has more than one element.</para>
        </exception>
        <exception cref="T:System.MissingFieldException">A field or property matching the specified criteria was not found.</exception>
        <exception cref="T:System.MissingMethodException">
          <para>A method matching the specified criteria cannot be found.</para>
          <para>-or-</para>
          <para>The current instance object represents a type that contains open type parameters (that is, </para>
          <see cref="P:System.Type.ContainsGenericParameters" />
          <para> returns </para>
          <see langword="true" />
          <para>).</para>
        </exception>
        <exception cref="T:System.MethodAccessException">The requested member is non-public and the caller does not have the required permission.</exception>
        <exception cref="T:System.Reflection.TargetException">The member matching the specified criteria cannot be invoked on <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The member matching the specified criteria threw an exception.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one member matches the specified criteria.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>You cannot use <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" /> to invoke a generic method.</para>
          </block>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which members to include in the search: </para>
          <list type="bullet">
            <item>
              <para>Specify BindingFlags.Public to include public members in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public members (that is, private and protected members) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include static members up the hierarchy.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the members declared on the <see cref="T:System.Type" />, not members that were simply inherited.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> invocation flags can be used to denote what action to take with the member: </para>
          <list type="bullet">
            <item>
              <para>CreateInstance to invoke a constructor. <paramref name="name" /> is ignored. Not valid with other invocation flags.</para>
            </item>
            <item>
              <para>InvokeMethod to invoke a method, but not a constructor or a type initializer. Not valid with SetField or SetProperty. If InvokeMethod is specified by itself, BindingFlags.Public, BindingFlags.Instance, and BindingFlags.Static are automatically included.</para>
            </item>
            <item>
              <para>GetField to get the value of a field. Not valid with SetField.</para>
            </item>
            <item>
              <para>SetField to set the value of a field. Not valid with GetField.</para>
            </item>
            <item>
              <para>GetProperty to get a property. Not valid with SetProperty.</para>
            </item>
            <item>
              <para>SetProperty to set a property. Not valid with GetProperty.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>A method will be invoked if both of the following conditions are true: </para>
          <list type="bullet">
            <item>
              <para>The number of parameters in the method declaration equals the number of arguments in the <paramref name="args" /> array (unless default arguments are defined on the member and BindingFlags.OptionalParamBinding is specified). </para>
            </item>
            <item>
              <para>The type of each argument can be converted by the binder to the type of the parameter.</para>
            </item>
          </list>
          <para>The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<see cref="T:System.Reflection.BindingFlags" /> values InvokeMethod, GetProperty, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder. </para>
          <para>After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" /> method of the <see cref="T:System.Reflection.Binder" /> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</para>
          <para>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <see cref="N:System.Reflection" /> whenever the code is fully trusted.</para>
          <para>You can use Type.InvokeMember to set a field to a particular value by specifying <see cref="F:System.Reflection.BindingFlags.SetField" />. For example, if you want to set a public instance field named F on class C, and F is a String, you can use code such as: </para>
          <para>typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}); </para>
          <para>If F is a String[], you can use code such as: </para>
          <para>typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}); </para>
          <para>which will initialize the field F to this new array. You can also use Type.InvokeMember to set a position in an array by supplying the index of the value and then the next value by using code such as the following: </para>
          <para>typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}); </para>
          <para>This will change string "z" in the array that F holds to string "b".</para>
          <para>When you invoke an <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> member, you can specify the DispID instead of the member name, using the string format "[DispID=##]". For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</para>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public members if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the return value of the invoked member.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the constructor, method, property, or field member to invoke.</param>
        <param name="invokeAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted. The access can be one of the BindingFlags such as Public, NonPublic, Private, InvokeMethod, GetField, and so on. The type of lookup need not be specified. If the type of lookup is omitted, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static are used. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to invoke the specified member. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An array containing the arguments to pass to the member to invoke. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, class System.Object[] args, class System.Globalization.CultureInfo culture)" />
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="n" />
            <paramref name="ame" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="args" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> value.</para>
          <para>-or-</para>
          <para>The member to be invoked is a constructor and <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be invoked is a method that is not a type initializer or instance constructor, and <see cref="F:System.Reflection.BindingFlags.InvokeMethod" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a field, and neither <see cref="F:System.Reflection.BindingFlags.GetField" /> nor <see cref="F:System.Reflection.BindingFlags.SetField" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a property, and neither <see cref="F:System.Reflection.BindingFlags.GetProperty" /> nor <see cref="F:System.Reflection.BindingFlags.SetProperty" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> and at least one of <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />, <see cref="F:System.Reflection.BindingFlags.GetField" />, <see cref="F:System.Reflection.BindingFlags.SetField" />, <see cref="F:System.Reflection.BindingFlags.GetProperty" />, or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetField" /> and <see cref="F:System.Reflection.BindingFlags.SetField" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetProperty" /> and <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />and at least one of <see cref="F:System.Reflection.BindingFlags.SetField" /> or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.SetField" /> and <paramref name="args" /> has more than one element.</para>
        </exception>
        <exception cref="T:System.MissingFieldException">A field or property matching the specified criteria was not found.</exception>
        <exception cref="T:System.MissingMethodException">
          <para>A method matching the specified criteria was not found.</para>
          <para>-or-</para>
          <para>The current instance object represents a type that contains open type parameters (that is, </para>
          <see cref="P:System.Type.ContainsGenericParameters" />
          <para> returns </para>
          <see langword="true" />
          <para>).</para>
        </exception>
        <exception cref="T:System.MethodAccessException">The requested member is non-public and the caller does not have the required permission.</exception>
        <exception cref="T:System.Reflection.TargetException">The member matching the specified criteria cannot be invoked on <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The member matching the specified criteria threw an exception.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one member matches the specified criteria.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <example>
          <para> For an example that demonstrates
   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> , see <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />(
   <see cref="T:System.String" />, <see cref="T:System.Reflection.BindingFlags" />,
   <see cref="T:System.Reflection.Binder" />, <see cref="T:System.Object" />, <see cref="T:System.Object" />[], <see cref="T:System.Reflection.ParameterModifier" />[], <see cref="T:System.Globalization.CultureInfo" />, <see cref="T:System.String" />[]).
      </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Although the default binder does not process <see cref="T:System.Globalization.CultureInfo" /> (the <paramref name="culture" /> parameter), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="culture" />.</para>
          <block subset="none" type="note">
            <para>You cannot use <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" /> to invoke a generic method.</para>
          </block>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which members to include in the search: </para>
          <list type="bullet">
            <item>
              <para>Specify BindingFlags.Public to include public members in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public members (that is, private, internal, and protected members) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include static members up the hierarchy.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the members declared on the <see cref="T:System.Type" />, not members that were simply inherited.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> invocation flags can be used to denote what action to take with the member: </para>
          <list type="bullet">
            <item>
              <para>CreateInstance to invoke a constructor. <paramref name="name" /> is ignored. Not valid with other invocation flags.</para>
            </item>
            <item>
              <para>InvokeMethod to invoke a method, but not a constructor or a type initializer. Not valid with SetField or SetProperty. If InvokeMethod is specified by itself, BindingFlags.Public, BindingFlags.Instance, and BindingFlags.Static are automatically included.</para>
            </item>
            <item>
              <para>GetField to get the value of a field. Not valid with SetField.</para>
            </item>
            <item>
              <para>SetField to set the value of a field. Not valid with GetField.</para>
            </item>
            <item>
              <para>GetProperty to get a property. Not valid with SetProperty.</para>
            </item>
            <item>
              <para>SetProperty to set a property. Not valid with GetProperty.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>A method will be invoked if both of the following conditions are true: </para>
          <list type="bullet">
            <item>
              <para>The number of parameters in the method declaration equals the number of arguments in the <paramref name="args" /> array (unless default arguments are defined on the member and BindingFlags.OptionalParamBinding is specified).</para>
            </item>
            <item>
              <para>The type of each argument can be converted by the binder to the type of the parameter.</para>
            </item>
          </list>
          <para>The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<see cref="T:System.Reflection.BindingFlags" /> values InvokeMethod, GetProperty, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder. </para>
          <para>After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" /> method of the <see cref="T:System.Reflection.Binder" /> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</para>
          <para>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</para>
          <para>You can use Type.InvokeMember to set a field to a particular value by specifying <see cref="F:System.Reflection.BindingFlags.SetField" />. For example, if you want to set a public instance field named F on class C, and F is a String you can use code such as: </para>
          <para>typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null); </para>
          <para>If F is a String[], you can use code such as: </para>
          <para>typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null); </para>
          <para>which will initialize the field F to this new array. You can also use Type.InvokeMember to set a position in an array by supplying the index of the value and then the next value by using code such as the following: </para>
          <para>typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null); </para>
          <para>This will change string "z" in the array that F holds to string "b".</para>
          <para>When you invoke an <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> member you can specify the DispID instead of the member name, using the string format "[DispID=##]". For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</para>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public members if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the return value of the invoked member.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the constructor, method, property, or field member to invoke.</param>
        <param name="invokeAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted. The access can be one of the BindingFlags such as Public, NonPublic, Private, InvokeMethod, GetField, and so on. The type of lookup need not be specified. If the type of lookup is omitted, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static are used. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to invoke the specified member. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An array containing the arguments to pass to the member to invoke. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, class System.Object[] args, class System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, class System.String[] namedParameters)" />
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="args" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> value.</para>
          <para>-or-</para>
          <para>The member to be invoked is a constructor and <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be invoked is a method that is not a type initializer or instance constructor, and <see cref="F:System.Reflection.BindingFlags.InvokeMethod" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a field, and neither <see cref="F:System.Reflection.BindingFlags.GetField" /> nor <see cref="F:System.Reflection.BindingFlags.SetField" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a property, and neither <see cref="F:System.Reflection.BindingFlags.GetProperty" /> nor <see cref="F:System.Reflection.BindingFlags.SetProperty" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> and at least one of <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />, <see cref="F:System.Reflection.BindingFlags.GetField" />, <see cref="F:System.Reflection.BindingFlags.SetField" />, <see cref="F:System.Reflection.BindingFlags.GetProperty" />, or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetField" /> and <see cref="F:System.Reflection.BindingFlags.SetField" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetProperty" /> and <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.InvokeMethod" /> and at least one of <see cref="F:System.Reflection.BindingFlags.SetField" /> or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.SetField" /> and <paramref name="args" /> has more than one element.</para>
          <para>-or-</para>
          <para>
            <paramref name="namedParameters" />.Length &gt; <paramref name="args" />.Length .</para>
          <para>-or-</para>
          <para>At least one element in <paramref name="namedParameters" /> is <see langword="null" />.</para>
          <para>-or-</para>
          <para>At least one element in <paramref name="args" /> is not assignment-compatible with the corresponding parameter in <paramref name="namedParameters" />.</para>
        </exception>
        <exception cref="T:System.MissingFieldException">A field or property matching the specified criteria was not found.</exception>
        <exception cref="T:System.MissingMethodException">
          <para>A method matching the specified criteria cannot be found.</para>
          <para>-or-</para>
          <para>The current instance object represents a type that contains open type parameters (that is, </para>
          <see cref="P:System.Type.ContainsGenericParameters" />
          <para> returns </para>
          <see langword="true" />
          <para>).</para>
        </exception>
        <exception cref="T:System.MethodAccessException">The requested member is non-public and the caller does not have the required permission.</exception>
        <exception cref="T:System.Reflection.TargetException">The member matching the specified criteria cannot be invoked on <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The member matching the specified criteria threw an exception.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one member matches the specified criteria.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <example>
          <para>The following example demonstrates the use of <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> to
   construct a <see cref="T:System.String" />, obtain its <see cref="P:System.String.Length" /> property, invoke <see cref="M:System.String.Insert(System.Int32,System.String)" /> on it, and
   then set its value using the <see cref="F:System.String.Empty" /> field.</para>
          <code lang="C#">using System;
using System.Reflection;

class InvokeMemberExample
{
   static void Main(string[] args)
   {
      // Create the parameter arrays that will
      // be passed to InvokeMember.
      char[] cAry = 
      new char[] {'A',' ','s','t','r','i','n','g'};
      object[] oAry = new object[] {cAry, 0, cAry.Length};

      Type t = typeof(string);

      // Invoke the constructor of a string.
      string str =
         (string)t.InvokeMember(null, BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.CreateInstance, null,
         null, oAry, null, null, null);
      Console.WriteLine("The string is \"{0}\".", str);

      // Access a property of the string.
      int i =
         (int) t.InvokeMember("Length", BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.GetProperty, null, 
         str, null, null, null, null);
      Console.WriteLine("The length of the string is {0}.", i);

      // Invoke a method on the string.
      string newStr = "new ";
      object[] oAry2 = new Object[] {2, newStr};
      str = (string) t.InvokeMember("Insert", BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.InvokeMethod, null, str, 
         oAry2, null, null, null);
      Console.WriteLine("The modified string is \"{0}\".", str);

      // Access a field of the string.
      str = (string) t.InvokeMember("Empty", BindingFlags.Static | 
         BindingFlags.Public | BindingFlags.GetField, null, str, 
         null);
      Console.WriteLine("The empty string is \"{0}\".", str);
  
   }
}
</code>
          <para>The output is </para>
          <c>
            <para>The string is "A string". </para>
            <para>The length of the string is 8. </para>
            <para> The modified string is "A new string"</para>
            <para>The empty string is "". </para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>InvokeMember calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</para>
          <block subset="none" type="note">
            <para>You cannot use <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" /> to invoke a generic method.</para>
          </block>
          <para>When you invoke an <unmanagedCodeEntityReference>IDispatch</unmanagedCodeEntityReference> member you can specify the DispID instead of the member name, using the string format "[DispID=##]". For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</para>
          <para>Although the default binder does not process <see cref="T:System.Reflection.ParameterModifier" /> or <see cref="T:System.Globalization.CultureInfo" /> (the <paramref name="modifiers" /> and <paramref name="culture" /> parameters), you can use the abstract <see cref="T:System.Reflection.Binder" /> class to write a custom binder that does process <paramref name="modifiers" /> and <paramref name="culture" />. ParameterModifier is only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
          <para>Each parameter in the <paramref name="namedParameters" /> array gets the value in the corresponding element in the <paramref name="args" /> array. If the length of <paramref name="args" /> is greater than the length of <paramref name="namedParameters" />, the remaining argument values are passed in order.</para>
          <para>The <paramref name="namedParameters" /> array can be used to change the order of arguments in an input array. For example, given the method M(string a, int b) (M(ByVal a As String, ByVal b As Integer) in Visual Basic) and the input array { 42, "x" }, the input array can be passed unchanged to <paramref name="args" /> if the array { "b", "a" } is supplied for <paramref name="namedParameters" />.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> filter flags can be used to define which members to include in the search: </para>
          <list type="bullet">
            <item>
              <para>Specify BindingFlags.Public to include public members in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.NonPublic to include non-public members (that is, private, internal, and protected members) in the search.</para>
            </item>
            <item>
              <para>Specify BindingFlags.FlattenHierarchy to include static members up the hierarchy.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> modifier flags can be used to change how the search works: </para>
          <list type="bullet">
            <item>
              <para>BindingFlags.IgnoreCase to ignore the case of <paramref name="name" />.</para>
            </item>
            <item>
              <para>BindingFlags.DeclaredOnly to search only the members declared on the <see cref="T:System.Type" />, not members that were simply inherited.</para>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> invocation flags can be used to denote what action to take with the member: </para>
          <list type="bullet">
            <item>
              <para>CreateInstance to invoke a constructor. <paramref name="name" /> is ignored. Not valid with other invocation flags.</para>
            </item>
            <item>
              <para>InvokeMethod to invoke a method, but not a constructor or a type initializer. Not valid with SetField or SetProperty. If InvokeMethod is specified by itself, BindingFlags.Public, BindingFlags.Instance, and BindingFlags.Static are automatically included.</para>
            </item>
            <item>
              <para>GetField to get the value of a field. Not valid with SetField.</para>
            </item>
            <item>
              <para>SetField to set the value of a field. Not valid with GetField.</para>
            </item>
            <item>
              <para>GetProperty to get a property. Not valid with SetProperty.</para>
            </item>
            <item>
              <para>SetProperty to set a property. Not valid with GetProperty.</para>
            </item>
          </list>
          <para>See <see cref="T:System.Reflection.BindingFlags" /> for more information.</para>
          <para>A method will be invoked if both of the following conditions are true: </para>
          <list type="bullet">
            <item>
              <para>The number of parameters in the method declaration equals the number of arguments in the <paramref name="args" /> array (unless default arguments are defined on the member and BindingFlags.OptionalParamBinding is specified).</para>
            </item>
            <item>
              <para>The type of each argument can be converted by the binder to the type of the parameter.</para>
            </item>
          </list>
          <para>The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<see cref="T:System.Reflection.BindingFlags" /> values InvokeMethod, GetProperty, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder. </para>
          <para>After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" /> method of the <see cref="T:System.Reflection.Binder" /> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.</para>
          <para>InvokeMember can be used to invoke methods with parameters that have default values. To bind to these methods, Reflection requires <see cref="F:System.Reflection.BindingFlags.OptionalParamBinding" /> to be specified. For a parameter that has a default value, you can either supply a different value, or supply <see cref="F:System.Reflection.Missing.Value" /> to use the default value.</para>
          <para>For example, consider a method such as MyMethod(int x, float y = 2.0). To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and Missing.Value for the second argument. Unless you use Missing.Value, you may not omit optional parameters with the Invoke method. If you must do so, use InvokeMember instead.</para>
          <para>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <see cref="N:System.Reflection" /> whenever the code is fully trusted.</para>
          <para>You can use Type.InvokeMember to set a field to a particular value by specifying <see cref="F:System.Reflection.BindingFlags.SetField" />. For example, if you want to set a public instance field named F on class C, and F is a String, you can use code such as: </para>
          <para>typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null); </para>
          <para>If F is a String[], you can use code such as: </para>
          <para>typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null); </para>
          <para>which will initialize the field F to this new array. You can also use Type.InvokeMember to set a position in an array by supplying the index of the value and then the next value by using code such as the following: </para>
          <para>typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null); </para>
          <para>This will change string "z" in the array that F holds to string "b".</para>
          <block subset="none" type="note">
            <para>Starting with the net_v20sp1_long, this method can be used to access non-public members if the caller has been granted <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" /> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>.) </para>
            <para>To use this functionality, your application should target the net_v35_long or later.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing the return value of the invoked member.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the name of the constructor, method, property, or field member to invoke.</param>
        <param name="invokeAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted. The access can be one of the BindingFlags such as Public, NonPublic, Private, InvokeMethod, GetField, and so on. The type of lookup need not be specified. If the type of lookup is omitted, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static are used. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</param>
        <param name="target">
          <attribution license="cc4" from="Microsoft" modified="false" />The object on which to invoke the specified member. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An array containing the arguments to pass to the member to invoke. </param>
        <param name="modifiers">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="args" /> array. A parameter's associated attributes are stored in the member's signature. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</param>
        <param name="namedParameters">
          <attribution license="cc4" from="Microsoft" modified="false" />An array containing the names of the parameters to which the values in the <paramref name="args" /> array are passed. </param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="ILASM" Value=".property bool IsAbstract { public hidebysig specialname instance bool get_IsAbstract() }" />
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <see langword="true" /> if the type attribute <see cref="F:System.Reflection.TypeAttributes.AnsiClass" />  is selected for the current type; otherwise, <see langword="false" />.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="F:System.Reflection.TypeAttributes.StringFormatMask" /> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type, this property pertains to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the string format attribute AnsiClass is selected for the <see cref="T:System.Type" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="ILASM" Value=".property bool IsArray { public hidebysig specialname instance bool get_IsArray() }" />
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" /> represents an
   array; otherwise <see langword="false" />. </para>
        </value>
        <example>
          <para>The following example demonstrates using the <see cref="P:System.Type.IsArray" />
property.</para>
          <code lang="C#">using System;
class TestType {
 public static void Main() {
 int [] array = {1,2,3,4};
 Type at = typeof(Array);
 Type t = array.GetType();
 Console.WriteLine("Type is {0}. IsArray? {1}", at, at.IsArray);
 Console.WriteLine("Type is {0}. IsArray? {1}", t, t.IsArray);
 }
}
</code>
          <para>The output is</para>
          <c>
            <para>Type is System.Array. IsArray? False</para>
            <para>Type is System.Int32[]. IsArray? True</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Type.IsArray" /> property returns false for the <see cref="T:System.Array" /> class.</para>
          <para>To check for an array, use code such as typeof(Array).IsAssignableFrom(type).</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
          <para>This property is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is an array.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool IsArrayImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance of the <see cref="T:System.Array" /> class must return false because it is an object, not an array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <see cref="T:System.Type" /> is an array; otherwise, false.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool IsAssignableFrom(class System.Type c)" />
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Type.IsAssignableFrom(System.Type)" />
method using arrays.</para>
          <code lang="C#">using System;
class ArrayTypeTest {
 public static void Main() {
 int i = 1;
 int [] array10 = new int [10];
 int [] array2 = new int[2];
 int [,]array22 = new int[2,2];
 int [,]array24 = new int[2,4];
 int [,,]array333 = new int[3,3,3];
 Type array10Type = array10.GetType();
 Type array2Type = array2.GetType();
 Type array22Type = array22.GetType();
 Type array24Type = array24.GetType();
 Type array333Type = array333.GetType();

 // If X and Y are not both arrays, then false
 Console.WriteLine("int[2] is assignable from int? {0} ", array2Type.IsAssignableFrom(i.GetType()));
 // If X and Y have same type and rank, then true.
 Console.WriteLine("int[2] is assignable from int[10]? {0} ",  array2Type.IsAssignableFrom(array10Type));
 Console.WriteLine("int[2,2] is assignable from int[2,4]? {0}",  array22Type.IsAssignableFrom(array24Type));
 Console.WriteLine("int[2,4] is assignable from int[2,2]? {0}",  array24Type.IsAssignableFrom(array22Type));
 Console.WriteLine("");
 // If X and Y do not have the same rank, then false.
 Console.WriteLine("int[2,2] is assignable from int[10]? {0}",  array22Type.IsAssignableFrom(array10Type));
 Console.WriteLine("int[2,2] is assignable from int[3,3,3]? {0}",  array22Type.IsAssignableFrom(array333Type));
 Console.WriteLine("int[3,3,3] is assignable from int[2,2]? {0}",  array333Type.IsAssignableFrom(array22Type));
 }
}
</code>
          <para>The output is</para>
          <c>
            <para>int[2] is assignable from int? False</para>
            <para>int[2] is assignable from int[10]? True</para>
            <para>int[2,2] is assignable from int[2,4]? True</para>
            <para>int[2,4] is assignable from int[2,2]? True</para>
            <para>int[2,2] is assignable from int[10]? False</para>
            <para>int[2,2] is assignable from int[3,3,3]? False</para>
            <para>int[3,3,3] is assignable from int[2,2]? False</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method can be overridden by a derived class.</para>
          <block subset="none" type="note">
            <para>A generic type definition is not assignable from a closed constructed type. That is, you cannot assign the closed constructed type MyGenericList&lt;int&gt; (MyGenericList(Of Integer) in Visual Basic) to a variable of type MyGenericList&lt;T&gt;.</para>
          </block>
          <para>You can determine the element types of a Type using <see cref="M:System.Type.GetElementType" />.</para>
          <para>If the <paramref name="c" /> parameter is of type <see cref="T:System.Reflection.Emit.TypeBuilder" />, the result is based on the type that is to be built. The following code example demonstrates this using a built type named B.</para>
          <code>TypeBuilder b1 = moduleBuilder.DefineType("B", TypeAttributes.Public, typeof(A));
// Returns true:
typeof(A).IsAssignableFrom(b1))</code>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether an instance of the current <see cref="T:System.Type" /> can be assigned from an instance of the specified Type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="c" /> and the current Type represent the same type, or if the current Type is in the inheritance hierarchy of <paramref name="c" />, or if the current Type is an interface that <paramref name="c" /> implements, or if <paramref name="c" /> is a generic type parameter and the current Type represents one of the constraints of <paramref name="c" />, or if <paramref name="c" /> represents a value type and the current Type represents Nullable&lt;c&gt; (Nullable(Of c) in Visual Basic). false if none of these conditions are true, or if <paramref name="c" /> is null.</para>
        </returns>
        <param name="c">
          <attribution license="cc4" from="Microsoft" modified="false" />The type to compare with the current type. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <see langword="true" /> if the type attribute <see cref="F:System.Reflection.TypeAttributes.AutoClass" />  is selected for the current type; otherwise, <see langword="false" />.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="F:System.Reflection.TypeAttributes.StringFormatMask" /> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the string format attribute AutoClass is selected for the <see cref="T:System.Type" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="ILASM" Value=".property bool IsAutoLayout { public hidebysig specialname instance bool get_IsAutoLayout() }" />
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the type
   layout attribute <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> is specified for the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property is provided as a convenience. Alternatively, you can use the <see cref="F:System.Reflection.TypeAttributes.LayoutMask" /> enumeration value to select the type layout attributes, and then test whether <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> is set. The <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />, <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />, and <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> enumeration values indicate the way the fields of the type are laid out in memory. </para>
          <para>For dynamic types, you can specify <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> when you create the type. In code, apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> attribute with the <see cref="F:System.Runtime.InteropServices.LayoutKind.Auto" /> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</para>
          <block subset="none" type="note">
            <para>You cannot use the <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> method to determine whether the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> has been applied to a type.</para>
          </block>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="ILASM" Value=".property bool IsByRef { public hidebysig specialname instance bool get_IsByRef() }" />
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To get to the actual type, dereference the type that was passed by reference, and then call <see cref="M:System.Type.GetElementType" /> on that type.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool IsByRefImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <see cref="T:System.Type" /> is passed by reference; otherwise, false.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="ILASM" Value=".property bool IsClass { public hidebysig specialname instance bool get_IsClass() }" />
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" /> represents a class;
   otherwise <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property returns true for value types even if they are boxed. </para>
          <para>The <see cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" /> distinguishes a type declaration as class, interface, or value type.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property returns true if the generic type definition is a class definition; that is, it does not define an interface or a value type.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
          <block subset="none" type="note">
            <para>This property returns true for Type instances that represent the <see cref="T:System.Enum" /> and <see cref="T:System.ValueType" /> classes. These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves. For more information, see the <see cref="P:System.Type.IsValueType" /> and <see cref="P:System.Type.IsEnum" /> properties. </para>
          </block>
          <para>This property is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is a class; that is, not a value type or interface.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method returns false for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.</para>
          <para>You can also load a COM class and get a Type object for that COM class by using the <format type="text/html"><a href="EC0A8D63-11B3-4ACD-B398-DA1E37E97382">[&lt;topic://cpgrftypelibraryimportertlbimpexe&gt;]</a></format> tool.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool IsCOMObjectImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method returns false for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <see cref="T:System.Type" /> is a COM object; otherwise, false.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A constructed generic type has had explicit types supplied for all of its generic type parameters. It is also referred to as a closed generic type. </para>
          <para>When this property is true, you can create instances of the current type; when it is false, you can't. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether this object represents a constructed generic type. You can create instances of a constructed generic type. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization. For more detailed information on remoting contexts, see <see cref="T:System.Runtime.Remoting.Contexts.Context" />.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method can be overridden by a derived class.</para>
          <para>A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, false.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="ILASM" Value=".property bool IsEnum { public hidebysig specialname instance bool get_IsEnum() }" />
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" /> represents an
   enumeration; otherwise <see langword="false" />. </para>
        </value>
        <example>
          <para>The following example demonstrates using the <see cref="P:System.Type.IsEnum" />
property.</para>
          <code lang="C#">using System;
public enum Color {
Red, Blue, Green
}
class TestType {
 public static void Main() {
 Type colorType = typeof(Color);
 Type enumType = typeof(Enum);
 Console.WriteLine("Color is enum ? {0}", colorType.IsEnum);
 Console.WriteLine("Color is valueType? {0}", colorType.IsValueType);
 Console.WriteLine("Enum is enum Type? {0}", enumType.IsEnum);
 Console.WriteLine("Enum is value? {0}", enumType.IsValueType);
 }
}
</code>
          <para>The output is</para>
          <c>
            <para>Color is enum ? True</para>
            <para>Color is valueType? True</para>
            <para>Enum is enum Type? False</para>
            <para>Enum is value? False</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property returns true for an enumeration, but not for the <see cref="T:System.Enum" /> type itself.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
          <para>This property is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a value that indicates whether the specified value exists in the current enumeration type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the specified value is a member of the current enumeration type; otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to be tested.</param>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Beginning with the net_v40_long, the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies. Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type. Each managed assembly has a different <see cref="T:System.Type" /> object to represent its view of the COM type. The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</para>
          <para>Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly. The <see cref="M:System.Type.IsEquivalentTo(System.Type)" /> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type. </para>
          <para>For more information, see <format type="text/html"><a href="78892eba-2a58-4165-b4b1-0250ee2f41dc">Type Equivalence and Embedded Interop Types</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether two COM types have the same identity and are eligible for type equivalence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the COM types are equivalent; otherwise, false. This method also returns false if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</para>
        </returns>
        <param name="other">
          <attribution license="cc4" from="Microsoft" modified="false" />The COM type that is tested for equivalence with the current type.</param>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="ILASM" Value=".property bool IsExplicitLayout { public hidebysig specialname instance bool get_IsExplicitLayout() }" />
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the type layout attribute <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> is specified for the current <see cref="T:System.Type" />; otherwise,
<see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property is provided as a convenience. Alternatively, you can use the <see cref="F:System.Reflection.TypeAttributes.LayoutMask" /> enumeration value to select the type layout attributes, and then test whether <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> is set. The <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />, <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />, and <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> enumeration values indicate the way the fields of the type are laid out in memory.</para>
          <para>For dynamic types, you can specify <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> when you create the type. In code, apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> attribute with the <see cref="F:System.Runtime.InteropServices.LayoutKind.Explicit" /> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</para>
          <block subset="none" type="note">
            <para>You cannot use the <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> method to determine whether the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> has been applied to a type.</para>
          </block>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <see langword="true" /> if the current object represents a type parameter of a generic type or method; otherwise <see langword="false" />.</value>
        <since version=".NET 2.0" />
        <example>
          <para>For an example of using this method, see the example for <see cref="P:System.Type.GenericParameterPosition" />.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Type" /> objects that represent generic type parameters can be obtained by calling the <see cref="M:System.Type.GetGenericArguments" /> method of a <see cref="T:System.Type" /> object that represents a generic type definition, or the <see cref="M:System.Reflection.MethodInfo.GetGenericArguments" /> method of a <see cref="T:System.Reflection.MethodInfo" /> object that represents a generic method definition.</para>
          <list type="bullet">
            <item>
              <para>For a generic type or method definition, the <see cref="P:System.Type.IsGenericParameter" /> property returns true for every element of the resulting array.</para>
            </item>
            <item>
              <para>For a closed constructed type or method, the <see cref="P:System.Type.IsGenericParameter" /> property returns false for every element of the array returned by the <see cref="M:System.Type.GetGenericArguments" /> method.</para>
            </item>
            <item>
              <para>For an open constructed type or method, some elements of the array might be specific types and others might be type parameters. <see cref="P:System.Type.IsGenericParameter" /> returns false for the types and true for the type parameters. The code example for the <see cref="P:System.Type.ContainsGenericParameters" /> property demonstrates a generic class with a mixture of types and type parameters.</para>
            </item>
          </list>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property remarks. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <see langword="true" /> if the current type has type arguments; otherwise <see langword="false" />.</value>
        <since version=".NET 2.0" />
        <example>
          <para>For an example of using this method, see the example for <see cref="M:System.Type.MakeGenericType" />.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="P:System.Type.IsGenericType" /> property to determine whether a <see cref="T:System.Type" /> object represents a generic type. Use the <see cref="P:System.Type.ContainsGenericParameters" /> property to determine whether a <see cref="T:System.Type" /> object represents an open constructed type or a closed constructed type.</para>
          <block subset="none" type="note">
            <para>The <see cref="P:System.Type.IsGenericType" /> property returns false if the immediate type is not generic. For example, an array whose elements are of type A&lt;int&gt; (A(Of Integer) in Visual Basic) is not itself a generic type.</para>
          </block>
          <para>The following table summarizes the invariant conditions for common terms used in generic reflection.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Term</para>
                </term>
                <description>
                  <para>Invariant</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>generic type definition</para>
              </term>
              <description>
                <para>The <see cref="P:System.Type.IsGenericTypeDefinition" /> property is true.</para>
                <para>Defines a generic type. A constructed type is created by calling the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method on a <see cref="T:System.Type" /> object that represents a generic type definition and specifying an array of type arguments.</para>
                <para>
                  <see cref="M:System.Type.MakeGenericType(System.Type[])" /> can be called only on generic type definitions. </para>
                <para>Any generic type definition is a generic type (the <see cref="P:System.Type.IsGenericType" /> property is true), but the converse is not true.</para>
              </description>
            </item>
            <item>
              <term>
                <para>generic type</para>
              </term>
              <description>
                <para>The <see cref="P:System.Type.IsGenericType" /> property is true.</para>
                <para>Can be a generic type definition, an open constructed type, or a closed constructed type. </para>
                <para>Note that an array type whose element type is generic is not itself a generic type. The same is true of a <see cref="T:System.Type" /> object representing a pointer to a generic type.</para>
              </description>
            </item>
            <item>
              <term>
                <para>open constructed type</para>
              </term>
              <description>
                <para>The <see cref="P:System.Type.ContainsGenericParameters" /> property is true.</para>
                <para>Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <see cref="P:System.Type.ContainsGenericParameters" /> property is true.</para>
                <para>It is not possible to create an instance of an open constructed type.</para>
                <para>Note that not all open constructed types are generic. For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</para>
              </description>
            </item>
            <item>
              <term>
                <para>closed constructed type</para>
              </term>
              <description>
                <para>The <see cref="P:System.Type.ContainsGenericParameters" /> property is false.</para>
                <para>When examined recursively, the type has no unassigned generic parameters. </para>
              </description>
            </item>
            <item>
              <term>
                <para>generic type parameter</para>
              </term>
              <description>
                <para>The <see cref="P:System.Type.IsGenericParameter" /> property is true.</para>
                <para>The <see cref="P:System.Type.ContainsGenericParameters" /> property is true.</para>
                <para>In a generic type definition, a placeholder for a type that will be assigned later. </para>
              </description>
            </item>
            <item>
              <term>
                <para>generic type argument</para>
              </term>
              <description>
                <para>Can be any type, including a generic type parameter.</para>
                <para>Type arguments are specified as an array of <see cref="T:System.Type" /> objects passed to the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method when creating a constructed generic type. If instances of the resulting type are to be created, the <see cref="P:System.Type.ContainsGenericParameters" /> property must be false for all the type arguments.</para>
              </description>
            </item>
          </list>
          <para>The following code example and table illustrate some of these terms and invariants. The Derived class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.  </para>
          <para>code reference: System.Type.IsGenericType#2</para>
          <para>The following table shows examples that use and build on the classes Base, Derived, and G. When the C++ and C# code is the same, only one entry is shown.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Example</para>
                </term>
                <description>
                  <para>Invariants</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Derived(Of V)</para>
                <para>Derived&lt;V&gt;</para>
              </term>
              <description>
                <para>For this type:</para>
                <para>
                  <see cref="P:System.Type.IsGenericType" /> is true.</para>
                <para>
                  <see cref="P:System.Type.IsGenericTypeDefinition" /> is true.</para>
                <para>
                  <see cref="P:System.Type.ContainsGenericParameters" /> is true.</para>
              </description>
            </item>
            <item>
              <term>
                <para>Base(Of String, V)</para>
                <para>Base&lt;String,V&gt;</para>
                <para>Base&lt;String^,V&gt;</para>
              </term>
              <description>
                <para>For this type:</para>
                <para>
                  <see cref="P:System.Type.IsGenericType" /> is true.</para>
                <para>
                  <see cref="P:System.Type.IsGenericTypeDefinition" /> is false.</para>
                <para>
                  <see cref="P:System.Type.ContainsGenericParameters" /> is true.</para>
              </description>
            </item>
            <item>
              <term>
                <para>Dim d() As Derived(Of Integer)</para>
                <para>Derived&lt;int&gt;[] d;</para>
                <para>array&lt;Derived&lt;int&gt;^&gt;^ d;</para>
              </term>
              <description>
                <para>For the type of variable d:</para>
                <para>
                  <see cref="P:System.Type.IsGenericType" /> is false because d is an array.</para>
                <para>
                  <see cref="P:System.Type.IsGenericTypeDefinition" /> is false.</para>
                <para>
                  <see cref="P:System.Type.ContainsGenericParameters" /> is false.</para>
              </description>
            </item>
            <item>
              <term>
                <para>T, U, and V (everywhere they appear)</para>
              </term>
              <description>
                <para>
                  <see cref="P:System.Type.IsGenericParameter" /> is true.</para>
                <para>
                  <see cref="P:System.Type.IsGenericType" /> is false because there is no way to constrain a type parameter to generic types.</para>
                <para>
                  <see cref="P:System.Type.IsGenericTypeDefinition" /> is false.</para>
                <para>
                  <see cref="P:System.Type.ContainsGenericParameters" /> is true because T, U, and V are themselves generic type parameters. This does not imply anything about type arguments that are assigned to them later.</para>
              </description>
            </item>
            <item>
              <term>
                <para>The type of field F</para>
              </term>
              <description>
                <para>
                  <see cref="P:System.Type.IsGenericType" /> is true.</para>
                <para>
                  <see cref="P:System.Type.IsGenericTypeDefinition" /> is false because a type has been assigned to to the type parameter of G. Note that this is equivalent to having called the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method.</para>
                <para>
                  <see cref="P:System.Type.ContainsGenericParameters" /> is true because the type of field F has a type argument that is an open constructed type. The constructed type is open because its type argument (that is, Base) is a generic type definition. This illustrates the recursive nature of the <see cref="P:System.Type.IsGenericType" /> property. </para>
              </description>
            </item>
            <item>
              <term>
                <para>The nested class Nested</para>
              </term>
              <description>
                <para>
                  <see cref="P:System.Type.IsGenericType" /> is true, even though the Nested class has no generic type parameters of its own, because it is nested in a generic type.</para>
                <para>
                  <see cref="P:System.Type.IsGenericTypeDefinition" /> is true. That is, you can call the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method and supply the type parameter of the enclosing type, Derived.</para>
                <para>
                  <see cref="P:System.Type.ContainsGenericParameters" /> is true because the enclosing type, Derived, has generic type parameters. This illustrates the recursive nature of the <see cref="P:System.Type.ContainsGenericParameters" /> property. </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current type is a generic type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <see langword="true" /> if the current object represents the definition of a generic type, none of whose type parameters have been bound to specific types; otherwise <see langword="false" />.</value>
        <since version=".NET 2.0" />
        <example>
          <para>For an example of using this method, see the example for <see cref="M:System.Type.MakeGenericType." />.</para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A generic type definition is a template from which other types can be constructed. For example, from the generic type definition G&lt;T&gt; (expressed in C# syntax; G(Of T) in Visual Basic or generic &lt;typename T&gt; ref class G in C++) you can construct and instantiate the type G&lt;int&gt; (G(Of Integer) in Visual Basic), by calling the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method with a generic argument list containing the <see cref="T:System.Int32" /> type. Given a <see cref="T:System.Type" /> object representing this constructed type, the <see cref="M:System.Type.GetGenericTypeDefinition" /> method gets the generic type definition back again.</para>
          <para>Use the <see cref="P:System.Type.IsGenericTypeDefinition" /> property to determine whether you can create new types from the current type. If the <see cref="P:System.Type.IsGenericTypeDefinition" /> property returns true, you can call the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method to create new generic types.</para>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property remarks. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="ILASM" Value=".property bool IsImport { public hidebysig specialname instance bool get_IsImport() }" />
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> was imported from another class; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool IsInstanceOfType(object o)" />
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Type.IsInstanceOfType(System.Object)" />
method.</para>
          <code lang="C#">using System;
public interface IFoo { }
public class MyClass : IFoo {}
public class MyDerivedClass : MyClass {}
class IsInstanceTest {
 public static void Main() {
 Type ifooType=typeof(IFoo);
 MyClass mc = new MyClass();
 Type mcType = mc.GetType();
 MyClass mdc = new MyDerivedClass();
 Type mdcType = mdc.GetType();
 int [] array = new int [10];
 Type arrayType = typeof(Array);
 Console.WriteLine("int[] is instance of Array? {0}", arrayType.IsInstanceOfType(array));
 Console.WriteLine("myclass instance is instance of MyClass? {0}", mcType.IsInstanceOfType(mc));
 Console.WriteLine("myderivedclass instance is instance of MyClass? {0}",  mcType.IsInstanceOfType(mdc));
 Console.WriteLine("myclass instance is instance of IFoo? {0}", ifooType.IsInstanceOfType(mc));
 Console.WriteLine("myderivedclass instance is instance of IFoo? {0}",  ifooType.IsInstanceOfType(mdc));
 }
}
</code>
          <para>The output is </para>
          <c>
            <para>int[] is instance of Array? True</para>
            <para>myclass instance is instance of MyClass? True</para>
            <para>myderivedclass instance is instance of MyClass? True</para>
            <para>myclass instance is instance of IFoo? True</para>
            <para>myderivedclass instance is instance of IFoo? True</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method can be overridden by a derived class.</para>
          <block subset="none" type="note">
            <para>A constructed type is not an instance of its generic type definition. That is, MyGenericList&lt;int&gt; (MyGenericList(Of Integer) in Visual Basic) is not an instance of MyGenericList&lt;T&gt; (MyGenericList(Of T) in Visual Basic).</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current Type is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current Type is an interface that <paramref name="o" /> supports. false if neither of these conditions is the case, or if <paramref name="o" /> is null, or if the current Type is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns true).</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to compare with the current type. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="ILASM" Value=".property bool IsInterface { public hidebysig specialname instance bool get_IsInterface() }" />
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" />  represents an
   interface; otherwise <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" /> distinguishes a type declaration as class, interface or value type.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
          <para>This property is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="ILASM" Value=".property bool IsLayoutSequential { public hidebysig specialname instance bool get_IsLayoutSequential() }" />
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the type layout attribute
<see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> is specified for the current 
<see cref="T:System.Type" />; otherwise, 
<see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property is provided as a convenience. Alternatively, you can use the <see cref="F:System.Reflection.TypeAttributes.LayoutMask" /> enumeration value to select the type layout attributes, and then test whether <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> is set. The <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />, <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />, and <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> enumeration values indicate the way the fields of the type are laid out in memory.</para>
          <para>For dynamic types, you can specify <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> when you create the type. In code, apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> attribute with the <see cref="F:System.Runtime.InteropServices.LayoutKind.Sequential" /> enumeration value to the type, to specify that layout is sequential.</para>
          <block subset="none" type="note">
            <para>You cannot use the <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /> method to determine whether the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> has been applied to a type.</para>
          </block>
          <para>For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics". The documentation is available online; see <see cref="http://go.microsoft.com/fwlink/?LinkID=99212">ECMA C# and Common Language Infrastructure Standards</see> on MSDN and <see cref="http://go.microsoft.com/fwlink/?LinkID=65552">Standard ECMA-335 - Common Language Infrastructure (CLI)</see> on the Ecma International Web site.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="ILASM" Value=".property bool IsMarshalByRef { public hidebysig specialname instance bool get_IsMarshalByRef() }" />
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method can be overridden by a derived class.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, false.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Type.IsNested" /> property returns true for all nested types, regardless of visibility. To test for nesting and visibility at the same time, use the related properties <see cref="P:System.Type.IsNestedAssembly" />, <see cref="P:System.Type.IsNestedFamily" />, <see cref="P:System.Type.IsNestedFamANDAssem" />, <see cref="P:System.Type.IsNestedFamORAssem" />, <see cref="P:System.Type.IsNestedPrivate" />, or <see cref="P:System.Type.IsNestedPublic" />.</para>
          <block subset="none" type="note">
            <para>The <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> enumeration member selects the visibility attributes for a type.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedAssembly { public hidebysig specialname instance bool get_IsNestedAssembly() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property always returns false.</para>
          <para>
            <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> selects the visibility attributes.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedFamANDAssem { public hidebysig specialname instance bool get_IsNestedFamANDAssem() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is nested
   and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property always returns false.</para>
          <para>
            <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> selects the visibility attributes.</para>
          <para>A <see cref="T:System.Type" /> object's family is defined as all objects of the exact same <see cref="T:System.Type" /> and of its subtypes.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedFamily { public hidebysig specialname instance bool get_IsNestedFamily() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is nested
   and visible only within its own family; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property always returns false.</para>
          <para>
            <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> selects the visibility attributes.</para>
          <para>A <see cref="T:System.Type" /> object's family is defined as all objects of the exact same <see cref="T:System.Type" /> and of its subtypes.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedFamORAssem { public hidebysig specialname instance bool get_IsNestedFamORAssem() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is nested
   and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property always returns false.</para>
          <para>
            <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> selects the visibility attributes.</para>
          <para>A <see cref="T:System.Type" /> object's family is defined as all objects of the exact same <see cref="T:System.Type" /> and of its subtypes.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedPrivate { public hidebysig specialname instance bool get_IsNestedPrivate() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property always returns false.</para>
          <para>
            <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> selects the visibility attributes.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedPublic { public hidebysig specialname instance bool get_IsNestedPublic() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if
   the class is nested and declared public; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property always returns false.</para>
          <para>
            <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> selects the visibility attributes.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether a class is nested and declared public.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="ILASM" Value=".property bool IsNotPublic { public hidebysig specialname instance bool get_IsNotPublic() }" />
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the
   top-level <see cref="T:System.Type" /> is not declared public; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Do not use with nested types; use <see cref="P:System.Type.IsNestedPublic" /> instead.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property returns false.</para>
          <para>
            <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> selects the visibility attributes.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="ILASM" Value=".property bool IsPointer { public hidebysig specialname instance bool get_IsPointer() }" />
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>This property is read-only.</para>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" /> represents a
   pointer; otherwise <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
          <para>This property is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool IsPointerImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <see cref="T:System.Type" /> is a pointer; otherwise, false.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="ILASM" Value=".property bool IsPrimitive { public hidebysig specialname instance bool get_IsPrimitive() }" />
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The primitive types are <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.IntPtr" />, <see cref="T:System.UIntPtr" />, <see cref="T:System.Char" />, <see cref="T:System.Double" />, and <see cref="T:System.Single" />.</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool IsPrimitiveImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The primitive types are <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Char" />, <see cref="T:System.Double" />, and <see cref="T:System.Single" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, false.</para>
        </returns>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="ILASM" Value=".property bool IsPublic { public hidebysig specialname instance bool get_IsPublic() }" />
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the top-level <see cref="T:System.Type" /> is declared public; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Do not use with nested types; use <see cref="P:System.Type.IsNestedPublic" /> instead.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property returns true.</para>
          <para>
            <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> selects the visibility attributes.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="ILASM" Value=".property bool IsSealed { public hidebysig specialname instance bool get_IsSealed() }" />
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type, this property always returns true.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Type.IsSecurityCritical" />, <see cref="P:System.Type.IsSecuritySafeCritical" />, and <see cref="P:System.Type.IsSecurityTransparent" /> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Security level</para>
                </term>
                <description>
                  <para>IsSecurityCritical</para>
                </description>
                <description>
                  <para>IsSecuritySafeCritical</para>
                </description>
                <description>
                  <para>IsSecurityTransparent</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Critical</para>
              </term>
              <description>
                <para>true</para>
              </description>
              <description>
                <para>false</para>
              </description>
              <description>
                <para>false</para>
              </description>
            </item>
            <item>
              <term>
                <para>Safe critical</para>
              </term>
              <description>
                <para>true</para>
              </description>
              <description>
                <para>true</para>
              </description>
              <description>
                <para>false</para>
              </description>
            </item>
            <item>
              <term>
                <para>Transparent</para>
              </term>
              <description>
                <para>false</para>
              </description>
              <description>
                <para>false</para>
              </description>
              <description>
                <para>true</para>
              </description>
            </item>
          </list>
          <para>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</para>
          <block subset="none" type="note">
            <para>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <see cref="P:System.Reflection.Assembly.IsFullyTrusted" /> and <see cref="P:System.AppDomain.IsFullyTrusted" /> properties. </para>
          </block>
          <para>For more information about reflection and transparency, see <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>. For information about transparency, see <format type="text/html"><a href="5e87881c-9c13-4b52-8ad1-e34bb46e8aaa">Security Changes in the .NET Framework Version 4.0</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Type.IsSecurityCritical" />, <see cref="P:System.Type.IsSecuritySafeCritical" />, and <see cref="P:System.Type.IsSecurityTransparent" /> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Security level</para>
                </term>
                <description>
                  <para>IsSecurityCritical</para>
                </description>
                <description>
                  <para>IsSecuritySafeCritical</para>
                </description>
                <description>
                  <para>IsSecurityTransparent</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Critical</para>
              </term>
              <description>
                <para>true</para>
              </description>
              <description>
                <para>false</para>
              </description>
              <description>
                <para>false</para>
              </description>
            </item>
            <item>
              <term>
                <para>Safe critical</para>
              </term>
              <description>
                <para>true</para>
              </description>
              <description>
                <para>true</para>
              </description>
              <description>
                <para>false</para>
              </description>
            </item>
            <item>
              <term>
                <para>Transparent</para>
              </term>
              <description>
                <para>false</para>
              </description>
              <description>
                <para>false</para>
              </description>
              <description>
                <para>true</para>
              </description>
            </item>
          </list>
          <para>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</para>
          <block subset="none" type="note">
            <para>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <see cref="P:System.Reflection.Assembly.IsFullyTrusted" /> and <see cref="P:System.AppDomain.IsFullyTrusted" /> properties. </para>
          </block>
          <para>For more information about reflection and transparency, see <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>. For information about transparency, see <format type="text/html"><a href="5e87881c-9c13-4b52-8ad1-e34bb46e8aaa">Security Changes in the .NET Framework Version 4.0</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If this property returns true, the <see cref="P:System.Type.IsSecurityCritical" /> and <see cref="P:System.Type.IsSecuritySafeCritical" /> properties return false.</para>
          <para>The <see cref="P:System.Type.IsSecurityCritical" />, <see cref="P:System.Type.IsSecuritySafeCritical" />, and <see cref="P:System.Type.IsSecurityTransparent" /> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</para>
          <block subset="none" type="note">
            <para>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <see cref="P:System.Reflection.Assembly.IsFullyTrusted" /> and <see cref="P:System.AppDomain.IsFullyTrusted" /> properties. </para>
          </block>
          <para>For more information about reflection and transparency, see <format type="text/html"><a href="42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5">Security Considerations for Reflection</a></format>. For information about transparency, see <format type="text/html"><a href="5e87881c-9c13-4b52-8ad1-e34bb46e8aaa">Security Changes in the .NET Framework Version 4.0</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="ILASM" Value=".property bool IsSpecialName { public hidebysig specialname instance bool get_IsSpecialName() }" />
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> has a name that requires special handling; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> has a name that requires special handling.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool IsSubclassOf(class System.Type c)" />
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Type.IsSubclassOf(System.Type)" />
method.</para>
          <code lang="C#">using System;
public interface IFoo { }
public interface IBar:IFoo{}
public class MyClass : IFoo {}
public class MyDerivedClass : MyClass {}
class IsSubclassTest {
 public static void Main() {
 Type ifooType = typeof(IFoo);
 Type ibarType = typeof(IBar);
 MyClass mc = new MyClass();
 Type mcType = mc.GetType();
 MyClass mdc = new MyDerivedClass();
 Type mdcType = mdc.GetType();
 int [] array = new int [10];
 Type arrayOfIntsType = array.GetType();
 Type arrayType = typeof(Array);
 
 Console.WriteLine("Array is subclass of int[]? {0}", arrayType.IsSubclassOf(arrayOfIntsType));
 Console.WriteLine("int [] is subclass of Array? {0}", arrayOfIntsType.IsSubclassOf(arrayType));
 Console.WriteLine("IFoo is subclass of IBar? {0}", ifooType.IsSubclassOf(ibarType));
 Console.WriteLine("myclass is subclass of MyClass? {0}", mcType.IsSubclassOf(mcType));
 Console.WriteLine("myderivedclass is subclass of MyClass? {0}", mdcType.IsSubclassOf(mcType));
 Console.WriteLine("IBar is subclass of IFoo? {0}", ibarType.IsSubclassOf(ifooType)); 
  }
}
</code>
          <para>The output is </para>
          <c>
            <para>Array is subclass of int[]? False</para>
            <para>int [] is subclass of Array? True</para>
            <para>IFoo is subclass of IBar? False</para>
            <para>myclass is subclass of MyClass? False</para>
            <para>myderivedclass is subclass of MyClass? True</para>
            <para>IBar is subclass of IFoo? False</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.IsSubclassOf(System.Type)" /> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface. Use the <see cref="Overload:System.Type.GetInterface" /> method for that purpose. Note that if a type is dervived from an interface, this method returns true for that type being a subclass of <see cref="T:System.Object" />.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <see cref="T:System.Object" /> if it has no class constraint.</para>
          <block subset="none" type="note">
            <para>If the <see cref="M:System.Type.IsSubclassOf(System.Type)" /> is the converse of <see cref="M:System.Type.IsAssignableFrom(System.Type)" />. That is, if t1.IsSubclassOf(t2) is true, then t2.IsAssignableFrom(t1) is also true.</para>
          </block>
          <para>This method can be overridden by a derived class.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the class represented by the current <see cref="T:System.Type" /> derives from the class represented by the specified <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the Type represented by the <paramref name="c" /> parameter and the current Type represent classes, and the class represented by the current Type derives from the class represented by <paramref name="c" />; otherwise, false. This method also returns false if <paramref name="c" /> and the current Type represent the same class.</para>
        </returns>
        <param name="c">
          <attribution license="cc4" from="Microsoft" modified="false" />The type to compare with the current type. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <see langword="true" /> if the type attribute <see cref="F:System.Reflection.TypeAttributes.UnicodeClass" />  is selected for the current type; otherwise, <see langword="false" />.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="F:System.Reflection.TypeAttributes.StringFormatMask" /> is used to select the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the string format attribute UnicodeClass is selected for the <see cref="T:System.Type" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="ILASM" Value=".property bool IsValueType { public hidebysig specialname instance bool get_IsValueType() }" />
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" /> represents a value
   type (structure); otherwise <see langword="false" />. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Value types are types that are represented as sequences of bits; value types are not classes or interfaces. Value types are referred to as "structs" in some programming languages. Enums are a special case of value types.</para>
          <para>This property returns false for the <see cref="T:System.ValueType" /> class, because <see cref="T:System.ValueType" /> is not a value type itself. It is the base class for all value types, and therefore any value type can be assigned to it. This would not be possible if <see cref="T:System.ValueType" /> itself was a value type. Value types are boxed when they are assigned to a field of type <see cref="T:System.ValueType" />. </para>
          <para>This property returns true for enumerations, but not for the <see cref="T:System.Enum" /> type itself. For an example that demonstrates this behavior, see <see cref="P:System.Type.IsEnum" />.</para>
          <para>This property is read-only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is provided to enable the implementation of alternate type systems. It is not generally used in application code. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <see cref="T:System.Type" /> is a value type; otherwise, false.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this property to determine whether a type is part of the public interface of a component assembly. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.MakeArrayType" /> method provides a way to generate array types whose element types are computed at run time.</para>
          <para>Note   The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. This method overload can only be used to create vector types, and it is the only way to create a vector type. Use the <see cref="M:System.Type.MakeArrayType(System.Int32)" /> method overload to create multidimensional array types. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="rank" /> is invalid (being less than 1, for example).</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.MakeArrayType" /> method provides a way to generate array types whose element types are computed at run time.</para>
          <block subset="none" type="note">
            <para>The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. You cannot use this method overload to create a vector type; if <paramref name="rank" /> is 1, this method overload returns a multidimensional array type that happens to have one dimension. Use the <see cref="M:System.Type.MakeArrayType" /> method overload to create vector types. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object representing an array of the current type, with the specified number of dimensions.</para>
        </returns>
        <param name="rank">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of dimensions for the array. This number must be less than or equal to 32.</param>
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.MakeByRefType" /> method provides a way to generate ref types (ByRef in Visual Basic) for parameter lists.</para>
          <para>Using the syntax of Microsoft intermediate language (MSIL), if the current <see cref="T:System.Type" /> object represents <see cref="T:System.Int32" />, this method returns a <see cref="T:System.Type" /> object representing Int32&amp;.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a ref parameter (ByRef parameter in Visual Basic).</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Type" /> object that represents the current type when passed as a ref parameter (ByRef parameter in Visual Basic).</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>The number of elements in 
<paramref name="typeArguments" /> is not the same as the number of type parameters of the current generic type definition.</para>
          <para>-or-</para>
          <para>An element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type definition.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="typeArguments" /> is <see langword="null" />. </para>
          <para>-or-</para>
          <para>An element of <paramref name="typeArguments" /> is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>The current type does not represent the definition of a generic type. That is, <see cref="T:System.Type.IsGenericTypeDefinition" />  returns <see langword="false" />. </para>
        </exception>
        <example>
          <para>The following example uses <see cref="M:System.Type.GetType" /> and <see cref="M:System.Type.MakeGenericType" /> to create a constructed type from the generic <see cref="T:System.Collections.Generic.Dictionary" /> type. The constructed type represents a <see cref="T:System.Collections.Generic.Dictionary" /> of <see langword="Test" /> objects with string keys.   </para>
          <code lang="C#">using System;
using System.Reflection;
using System.Collections.Generic;

public class Test
{
	public static void Main()
	{
		Console.WriteLine("\n--- Create a constructed type from the generic  Dictionary type.");

		// Create a type object representing the generic Dictionary 
		// type.       
		Type generic = Type.GetType("System.Collections.Generic.Dictionary");

		DisplayTypeInfo(generic);

		// Create an array of types to substitute for the type
		// parameters of Dictionary. The key is of type string, and
		// the type to be contained in the Dictionary is Test.
		Type[] typeArgs = { typeof(string), typeof(Test) };
		Type constructed = generic.MakeGenericType(typeArgs);

		DisplayTypeInfo(constructed);

		// Compare the type objects obtained above to type objects
		// obtained using typeof() and GetGenericTypeDefinition().
		Console.WriteLine("\n--- Compare types obtained by different methods:");

		Type t = typeof(Dictionary&lt;string, Test&gt;);

		Console.WriteLine("\tAre the constructed types equal? {0}", t == constructed);
		Console.WriteLine("\tAre the generic types equal? {0}", t.GetGenericTypeDefinition() == generic);
	}

	private static void DisplayTypeInfo(Type t)
	{
		Console.WriteLine("\n{0}", t);
		Console.WriteLine("\tIs this a generic type definition? {0}", t.IsGenericTypeDefinition);
		Console.WriteLine("\tDoes it have generic type arguments? {0}", t.HasGenericArguments);

		Type[] typeArguments = t.GetGenericArguments();

		Console.WriteLine("\tList type arguments ({0}):", typeArguments.Length);
		foreach (Type tParam in typeArguments)
		{
			Console.WriteLine("\t\t{0}", tParam);
		}
	}
}

/* This example produces the following output:

--- Create a constructed type from the generic Dictionary type.

System.Collections.Generic.Dictionary[KeyType,ValueType]
        Is this a generic type definition? True
        Does it have generic type arguments? True
        List type arguments (2):
                K
                V

System.Collections.Generic.Dictionary[System.String, Test]
        Is this a generic type definition? False
        Does it have generic type arguments? True
        List type arguments (2):
                System.String
                Test

--- Compare types obtained by different methods:
        Are the constructed types equal? True
        Are the generic types equal? True
 */
</code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <see cref="T:System.Type" /> object that represents a particular constructed type. You can use this <see cref="T:System.Type" /> object to create run-time instances of the constructed type.</para>
          <para>Types constructed with <see cref="M:System.Type.MakeGenericType(System.Type[])" /> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types. You might use such open constructed types when you emit dynamic assemblies. For example, consider the classes Base and Derived in the following code.</para>
          <para>code reference: System.Type.MakeGenericType#1</para>
          <para>To generate Derived in a dynamic assembly, it is necessary to construct its base type. To do this, call the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method on a <see cref="T:System.Type" /> object representing the class Base, using the generic type arguments <see cref="T:System.Int32" /> and the type parameter V from Derived. Because types and generic type parameters are both represented by <see cref="T:System.Type" /> objects, an array containing both can be passed to the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method.</para>
          <block subset="none" type="note">
            <para>A constructed type such as Base&lt;int, V&gt; is useful when emitting code, but you cannot call the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method on this type because it is not a generic type definition. To create a closed constructed type that can be instantiated, first call the <see cref="M:System.Type.GetGenericTypeDefinition" /> method to get a <see cref="T:System.Type" /> object representing the generic type definition and then call <see cref="M:System.Type.MakeGenericType(System.Type[])" /> with the desired type arguments.</para>
          </block>
          <para>The <see cref="T:System.Type" /> object returned by <see cref="M:System.Type.MakeGenericType(System.Type[])" /> is the same as the <see cref="T:System.Type" /> obtained by calling the <see cref="M:System.Object.GetType" /> method of the resulting constructed type, or the <see cref="M:System.Object.GetType" /> method of any constructed type that was created from the same generic type definition using the same type arguments.</para>
          <block subset="none" type="note">
            <para>An array of generic types is not itself a generic type. You cannot call <see cref="M:System.Type.MakeGenericType(System.Type[])" /> on an array type such as C&lt;T&gt;[] (Dim ac() As C(Of T) in Visual Basic). To construct a closed generic type from C&lt;T&gt;[], call <see cref="M:System.Type.GetElementType" /> to obtain the generic type definition C&lt;T&gt;; call <see cref="M:System.Type.MakeGenericType(System.Type[])" /> on the generic type definition to create the constructed type; and finally call the <see cref="Overload:System.Type.MakeArrayType" /> method on the constructed type to create the array type. The same is true of pointer types and ref types (ByRef in Visual Basic).</para>
          </block>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property remarks. </para>
          <format type="text/html">
            <h2>Nested Types</h2>
          </format>
          <para>If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic. This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types. Consider the following classes:</para>
          <para>code reference: System.Type.MakeGenericType#2</para>
          <para>The type parameter list of the nested class Inner has two type parameters, <paramref name="T" /> and <paramref name="U" />, the first of which is the type parameter of its enclosing class. Similarly, the type parameter list of the nested class Innermost1 has three type parameters, <paramref name="T" />, <paramref name="U" />, and <paramref name="V" />, with <paramref name="T" /> and <paramref name="U" /> coming from its enclosing classes. The nested class Innermost2 has two type parameters, <paramref name="T" /> and <paramref name="U" />, which come from its enclosing classes. </para>
          <para>If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</para>
          <para>To construct a generic type from the generic type definition for a nested type, call the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own. To create an instance of Innermost1, call the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method with an array containing three types, to be assigned to T, U, and V. To create an instance of Innermost2, call the <see cref="M:System.Type.MakeGenericType(System.Type[])" /> method with an array containing two types, to be assigned to T and U. </para>
          <para>The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types. Otherwise, the type parameters would not be in scope within the bodies of the nested types. It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the <format type="text/html"><a href="4ca3a4f0-4400-47ce-8936-8e219961c76f">MSIL Assembler (Ilasm.exe)</a></format>. Consider the following code for the MSIL assembler:</para>
          <code>.class public Outer&lt;T&gt; {
    .class nested public Inner&lt;U&gt; {
        .class nested public Innermost {
        }
    }
}</code>
          <para>In this example, it is not possible to define a field of type <paramref name="T" /> or <paramref name="U" /> in class Innermost, because those type parameters are not in scope. The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</para>
          <code>.class public Outer&lt;T&gt; {
    .class nested public Inner&lt;T, U&gt; {
        .class nested public Innermost&lt;T, U, V&gt; {
        }
    }
}</code>
          <para>You can use the <format type="text/html"><a href="db27f6b2-f1ec-499e-be3a-7eecf95ca42b">MSIL Disassembler (Ildasm.exe)</a></format> to examine nested classes defined in the high-level languages and observe this naming scheme.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</para>
        </returns>
        <param name="typeArguments">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of types to be substituted for the type parameters of the current generic type.</param>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Type.MakePointerType" /> method provides a way to generate pointer types for parameter lists.</para>
          <para>Using the syntax of Microsoft intermediate language (MSIL), if the current <see cref="T:System.Type" /> object represents <see cref="T:System.Int32" />, this method returns a <see cref="T:System.Type" /> object representing Int32*.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Type" /> object that represents a pointer to the current type.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property overrides <see cref="P:System.Reflection.MemberInfo.MemberType" />. Therefore, when you examine a set of <see cref="T:System.Reflection.MemberInfo" /> objects—for example, the array returned by <see cref="Overload:System.Type.GetMembers" />—the <see cref="P:System.Reflection.MemberInfo.MemberType" /> property returns <see cref="F:System.Reflection.MemberTypes.NestedType" /> when a given member is a nested type.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <see cref="T:System.Type" /> represents MyGenericType&lt;int&gt; (MyGenericType(Of Integer) in Visual Basic), the value of this property is determined by MyGenericType&lt;T&gt;.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property always returns <see cref="F:System.Reflection.MemberTypes.TypeInfo" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="ILASM" Value=".field public static initOnly object Missing" />
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <MemberValue>null</MemberValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the Missing field for invocation through reflection to obtain the default value of a parameter. If the Missing field is passed in for a parameter value and there is no default value for that parameter, an <see cref="T:System.ArgumentException" /> is thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Represents a missing value in the <see cref="T:System.Type" /> information. This field is read-only.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="ILASM" Value=".property class System.Reflection.Module Module { public hidebysig virtual abstract specialname class System.Reflection.Module get_Module() }" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Reflection.Module" /> that reflects the module in which the current <see cref="T:System.Type" /> is defined.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property returns the module in which the generic type definition was defined. For example, if you create an instance of MyGenericStack&lt;int&gt;, the <see cref="P:System.Type.Module" /> property for the constructed type returns the module in which MyGenericStack&lt;T&gt; is defined.</para>
          <para>Similarly, if the current <see cref="T:System.Type" /> represents a generic parameter <paramref name="T" />, this property returns the assembly that contains the generic type that defines <paramref name="T" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="ILASM" Value=".property string Namespace { public hidebysig virtual abstract specialname string get_Namespace() }" />
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.String" /> containing the namespace of the current <see cref="T:System.Type" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure. From the viewpoint of the runtime, there are no namespaces.</para>
          <para>If the current <see cref="T:System.Type" /> represents a constructed generic type, this property returns the namespace that contains the generic type definition. Similarly, if the current <see cref="T:System.Type" /> represents a generic parameter <paramref name="T" />, this property returns the namespace that contains the generic type definition that defines <paramref name="T" />.</para>
          <para>If the current <see cref="T:System.Type" /> object represents a generic parameter, this property returns null.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the namespace of the <see cref="T:System.Type" />.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether two <see cref="T:System.Type" /> objects are equal.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, false.</para>
        </returns>
        <param name="left">
          <attribution license="cc4" from="Microsoft" modified="false" />The first object to compare.</param>
        <param name="right">
          <attribution license="cc4" from="Microsoft" modified="false" />The second object to compare.</param>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether two <see cref="T:System.Type" /> objects are not equal.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, false.</para>
        </returns>
        <param name="left">
          <attribution license="cc4" from="Microsoft" modified="false" />The first object to compare.</param>
        <param name="right">
          <attribution license="cc4" from="Microsoft" modified="false" />The second object to compare.</param>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="ILASM" Value=".property class System.Type ReflectedType { public hidebysig virtual specialname class System.Type get_ReflectedType() }" />
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>The <see langword="Type" /> object
   through which the current instance was obtained.</para>
        </value>
        <example>
          <para>The following example demonstrates the <see cref="P:System.Type.ReflectedType" /> property. Although the method <paramref name="m" /> is
   declared in <see langword="MyClassA" />, its reflected type is obtained from
<see langword="MyClassB" /> .</para>
          <code lang="C#">using System;
using System.Reflection;
public abstract class ReflectedTypeTest {
    public abstract class MyClassA {
        public abstract int m();
    }
    public abstract class MyClassB : MyClassA {
    }
    public static void Main(string[] args) {
        Console.WriteLine("Reflected type of m is {0}",
            typeof(MyClassB).GetMethod("m").ReflectedType);
    }
}
</code>
          <para>The output is </para>
          <c>
            <para>Reflected type of m is ReflectedTypeTest+MyClassB</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For <see cref="T:System.Type" /> objects, the value of this property is always the same as the value of the <see cref="P:System.Type.DeclaringType" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the class object that was used to obtain this member. </para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the assembly containing the type is not already loaded into the reflection-only context, using the <see cref="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" /> method is equivalent to first loading the assembly for reflection only, using the <see cref="Overload:System.Reflection.Assembly.ReflectionOnlyLoad" /> method, and then loading the type by calling the assembly's <see cref="Overload:System.Reflection.Assembly.GetType" /> method. For information about assembly-qualified names, see the <see cref="P:System.Type.AssemblyQualifiedName" /> property. For additional details on specifying type names, see the <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" /> method overload.</para>
          <para>If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</para>
          <para>The <paramref name="throwIfNotFound" /> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of <paramref name="throwIfNotFound" />. For example, if the assembly is not valid, a <see cref="T:System.BadImageFormatException" /> is thrown even if <paramref name="throwIfNotFound" /> is false.</para>
          <para>For more information about using the reflection-only context, see <format type="text/html"><a href="9818b660-52f5-423d-a9af-e75163aa7068">How to: Load Assemblies into the Reflection-Only Context</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found. The type is loaded for reflection only, not for execution.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type with the specified name, if found; otherwise, null. If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether null is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />. See the Exceptions section.</para>
        </returns>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly-qualified name of the <see cref="T:System.Type" /> to get. </param>
        <param name="throwIfNotFound">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; false to return null if the type cannot be found. Specifying false also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />true to perform a case-insensitive search for <paramref name="typeName" />; false to perform a case-sensitive search for <paramref name="typeName" />. </param>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> is not returned by the <see cref="Overload:System.Reflection.MemberInfo.GetCustomAttributes" /> method. Instead, use this property to get it.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">To be added.</param>
        <param name="rgszNames">To be added.</param>
        <param name="cNames">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="rgDispId">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <unmanagedCodeEntityReference>IDispatch::GetTypeInfo</unmanagedCodeEntityReference>, see the MSDN Library.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the type information for an object, which can then be used to get the type information for an interface.</para>
        </summary>
        <param name="iTInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />The type information to return.</param>
        <param name="lcid">
          <attribution license="cc4" from="Microsoft" modified="false" />The locale identifier for the type information.</param>
        <param name="ppTInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the requested type information object.</param>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">To be added.</param>
        <param name="riid">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="wFlags">To be added.</param>
        <param name="pDispParams">To be added.</param>
        <param name="pVarResult">To be added.</param>
        <param name="pExcepInfo">To be added.</param>
        <param name="puArgErr">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual string ToString()" />
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method returns the fully qualified common language runtime namespace and name for all primitive types. For example, the C# instruction, (long)0.Type().ToString() returns "System.Int64" instead of merely "Int64".</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly. If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a String representing the name of the current Type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="ILASM" Value=".property valuetype System.RuntimeTypeHandle TypeHandle { public hidebysig virtual abstract specialname valuetype System.RuntimeTypeHandle get_TypeHandle() }" />
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>The <see cref="T:System.RuntimeTypeHandle" /> for the current <see cref="T:System.Type" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>TypeHandle encapsulates a pointer to an internal data structure that represents the type. This handle is unique during the process lifetime. The handle is valid only in the application domain in which it was obtained.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the handle for the current <see cref="T:System.Type" />.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="ILASM" Value=".property class System.Reflection.ConstructorInfo TypeInitializer { public hidebysig specialname instance class System.Reflection.ConstructorInfo get_TypeInitializer() }" />
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Reflection.ConstructorInfo" /> containing the name of the static
   constructor for the type represented by the current instance</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Class initializers are also available through the <see cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" /> method, or through overloads of the <see cref="Overload:System.Type.GetMember" />, <see cref="Overload:System.Type.GetMembers" />, <see cref="Overload:System.Type.GetConstructor" />, and <see cref="Overload:System.Type.GetConstructors" /> methods that take <see cref="T:System.Reflection.BindingFlags" /> as a parameter.</para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, this property returns null.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the initializer for the <see cref="T:System.Type" />.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="ILASM" Value=".property class System.Type UnderlyingSystemType { public hidebysig virtual abstract specialname class System.Type get_UnderlyingSystemType() }" />
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>The underlying system type for the <see cref="T:System.Type" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>
            <block subset="none" type="behaviors">As described 
      above.</block>
          </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates the type provided by the common language runtime that represents this type.</para>
        </summary>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>