<Type Name="Type" FullName="System.Type" FullNameSP="System_Type" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public abstract serializable Type extends System.Object" />
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>This type is safe for multithreaded operations. </ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
    <ExcludedBaseTypeName>System.Reflection.MemberInfo</ExcludedBaseTypeName>
    <ExcludedLibraryName>Reflection</ExcludedLibraryName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <para>Provides information about a type.</para>
    </summary>
    <remarks>
      <para> The <see cref="T:System.Type" /> class is abstract, as is the <see cref="T:System.Reflection.MemberInfo" />
class and its subclasses <see cref="T:System.Reflection.FieldInfo" />, <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodBase" />,
and <see cref="T:System.Reflection.EventInfo" />. <see cref="T:System.Reflection.ConstructorInfo" /> and <see cref="T:System.Reflection.MethodInfo" />
are subclasses of <see cref="T:System.Reflection.MethodBase" />. The runtime
provides non-public implementations of these classes. <block subset="none" type="note"> For example, <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> is typed
as returning a <see cref="T:System.Reflection.MethodInfo" /> object. The
returned object is actually an instance of the non-public runtime type that
implements <see cref="T:System.Reflection.MethodInfo" /> .</block></para>
      <para>A conforming CLI program which is written to run on only the Kernel profile 
   cannot subclass <see cref="T:System.Type" />. <block subset="none" type="note"> This only applies
   to conforming programs not conforming implementations.</block></para>
      <para> A <see cref="T:System.Type" /> object that represents a type is unique; that is, two
<see cref="T:System.Type" /> object 
references refer to the same object if and only if they represent the same type.
This allows for comparison of <see cref="T:System.Type" />
objects using reference
equality.</para>
      <block subset="none" type="note">
        <para> An instance of <see cref="T:System.Type" />
can represent any one of the following
types:</para>
        <list type="bullet">
          <item>
            <term>Classes</term>
          </item>
          <item>
            <term>Value types</term>
          </item>
          <item>
            <term>Arrays</term>
          </item>
          <item>
            <term>Interfaces</term>
          </item>
          <item>
            <term>Pointers</term>
          </item>
          <item>
            <term>Enumerations</term>
          </item>
          <item>
            <term>Constructed generic types and generic type definitions</term>
          </item>
          <item>
            <term>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</term>
          </item>
        </list>
        <para>The following table shows what members of a base class are returned by the
   methods that return members of types, such as <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and
<see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />.</para>
        <para>
          <list type="table">
            <listheader>
              <term>Member Type</term>
              <description>Static</description>
              <description>Non-Static</description>
            </listheader>
            <item>
              <term> Constructor</term>
              <description>No</description>
              <description>No</description>
            </item>
            <item>
              <term> Field</term>
              <description>No</description>
              <description>Yes. A field is always
         hide-by-name-and-signature.</description>
            </item>
            <item>
              <term> Event</term>
              <description>Not applicable</description>
              <description> The common type system rule is
         that the inheritance of an event is the same as that of
         the accessors that implement the event.
         Reflection treats events as hide-by-name-and-signature.</description>
            </item>
            <item>
              <term> Method</term>
              <description>No</description>
              <description>Yes. A method (both virtual and non-virtual)
         can be hide-by-name or hide-by-name-and-signature.</description>
            </item>
            <item>
              <term> Nested Type</term>
              <description>No</description>
              <description>No</description>
            </item>
            <item>
              <term> Property</term>
              <description>Not applicable</description>
              <description> The common type system
         rule is that the inheritance is the same as that of the
         accessors that implement the property. Reflection treats
         properties as hide-by-name-and-signature.</description>
            </item>
          </list>
        </para>
        <para>For reflection, properties and events are hide-by-name-and-signature. If a
   property has both a get and a set accessor in the base class, but the derived
   class has only a get accessor, the derived class property hides the base class
   property, and the setter on the base class will not be accessible. </para>
      </block>
      <para>The description of <see cref="P:System.Type.IsGenericType" />  contains definitions for some important terms.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="family rtspecialname specialname instance void .ctor()" />
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>
          <para> Constructs a new instance of the <see cref="T:System.Type" /> class.
   </para>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="ILASM" Value=".property class System.Reflection.Assembly Assembly { public hidebysig virtual abstract specialname class System.Reflection.Assembly get_Assembly() }" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.  For generic types, gets the <see cref="T:System.Reflection.Assembly" /> that contains the generic type definition.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.  For generic types, the instance describes the assembly that contains the definition of the generic type.</para>
        </value>
        <remarks>
          <para>If the current instance represents a generic type, this property returns the assembly in which the type was defined. For example, suppose you create an assembly named MyGenerics.dll that contains a class named <see langword="MyGenericStack&lt;T&gt;" />. If you create an instance of <see langword="MyGenericStack&lt;int&gt;" /> in another assembly, the <see cref="T:System.Type.Assembly" /> property for the constructed type returns a <see cref="T:System.Reflection.Assembly" /> that represents MyGenerics.dll.</para>
          <para>Similarly, if the current instance represents a generic parameter T, this property returns the assembly that contains the generic type definition that defines T.</para>
          <para>
            <block subset="none" type="behaviors">This property is read-only.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="ILASM" Value=".property string AssemblyQualifiedName { public hidebysig virtual abstract specialname string get_AssemblyQualifiedName() }" />
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the fully qualified name of the type represented by 
      the current instance
      including the name of the assembly from which the <see cref="T:System.Type" /> was loaded.</para>
        </summary>
        <value>
          <para>The assembly-qualified name of the <see cref="T:System.Type" />, including the name of the assembly from which the <see cref="T:System.Type" /> was loaded. If the current <see cref="T:System.Type" /> object represents a generic parameter, this property returns <see langword="null" />.</para>
        </value>
        <remarks>
          <block subset="none" type="behaviors">
            <para> 
         This property is read-only.</para>
            <para>Compilers emit the simple name of a nested class, and reflection constructs a 
         mangled name when queried, in accordance with the following conventions.</para>
            <list type="table">
              <listheader>
                <term>Delimiter</term>
                <description>Meaning</description>
              </listheader>
              <item>
                <term> Backslash (\)</term>
                <description>Escape character.</description>
              </item>
              <item>
                <term> Comma (,)</term>
                <description>Precedes the Assembly name.</description>
              </item>
              <item>
                <term> Plus sign (+)</term>
                <description>Precedes a nested class.</description>
              </item>
              <item>
                <term> Period (.)</term>
                <description>Denotes namespace identifiers. </description>
              </item>
              <item>
                <term>Square brackets ([])</term>
                <description>
                  <para>After a type name, denotes an array of that type.</para>
                  <para>-or-</para>
                  <para>For a generic type, encloses the entire generic type argument list.</para>
                  <para>-or-</para>
                  <para>Within a type argument list, encloses an assembly-qualified type.</para>
                </description>
              </item>
            </list>
            <block subset="none" type="note">
              <para>For example, the fully qualified name for a class might look like this: </para>
              <para>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly </para>
              <para>If the namespace were TopNamespace.Sub+Namespace, then the string would
            have to precede the plus sign (+) with an escape character (\) to prevent
            it from being interpreted as a nesting separator. Reflection
            emits this string as follows:</para>
              <para>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</para>
              <para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
            </block>
            <para>Type names are permitted to include trailing characters that denote
         additional information about the type, such as whether the type is a reference
         type, a pointer type or an array type. To retrieve the type name without these
         trailing characters, use <c>t.GetElementType().ToString()</c>, where <paramref name="t" />
      is the type.</para>
            <para>Spaces are significant in all type name components except the assembly
      name. In the assembly name, spaces before the ',' separator are significant, but
      spaces after the ',' separator are ignored.</para>
            <para>Generic arguments of generic types are themselves fully qualified. For example, the output from the following C# program, if compiled to an assembly called Try64</para>
            <code>using System;
using System.Reflection;

class MyTest {
  public static void Main(String[] args) {
    Type b = typeof(B&lt;string,object&gt;);
    Console.WriteLine(b.AssemblyQualifiedName);
  }
}
public class B&lt;T,U&gt; { }</code>
            <para>is as follows:</para>
            <code>B`2[[System.String, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Object, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Try64, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null</code>
          </block>
          <block subset="none" type="usage">
            <para>The name returned by this method can be persisted and later used to load the <see cref="T:System.Type" />.
   To search for and load a <see cref="T:System.Type" />, use <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" /> either with the type name only or with
   the assembly qualified type name. <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" /> with the type name only will look for
   the <see cref="T:System.Type" />
   in the caller's assembly and then in the System assembly. <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" /> with the
   assembly qualified type name will look for the <see cref="T:System.Type" /> in any assembly.</para>
          </block>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="ILASM" Value=".property valuetype System.Reflection.TypeAttributes Attributes { public hidebysig specialname instance valuetype System.Reflection.TypeAttributes get_Attributes() }" />
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets the attributes associated with the type represented 
      by the current instance.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents a generic type, this property returns the attributes of the generic type definition.</para>
          <para>If the current instance represents a generic type parameter T, the <see cref="System.Reflection.TypeAttributes" /> returned by this property includes <see cref="System.Reflection.TypeAttributes.Abstract" />, <see cref="System.Reflection.TypeAttributes.AnsiClass" />, <see cref="System.Reflection.TypeAttributes.AutoLayout" />, <see cref="System.Reflection.TypeAttributes.Class" />, <see cref="System.Reflection.TypeAttributes.Public" />, and <see cref="System.Reflection.TypeAttributes.Sealed" />. These are arbitrary choices which have no meaning in the context of a type parameter.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="ILASM" Value=".property class System.Type BaseType { public hidebysig virtual abstract specialname class System.Type get_BaseType() }" />
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the base <see cref="T:System.Type" /> of the current <see cref="T:System.Type" /> .</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Type" /> object 
   representing the type from which the current <see cref="T:System.Type" /> directly inherits, or
<see langword="null" /> 
if the current <see cref="T:System.Type" /> represents the <see cref="T:System.Object" /> class.</para>
        </value>
        <remarks>
          <para>The base type is the type from which the current type directly inherits. <see cref="T:System.Object" /> is the only type that does not have a base type, therefore <see langword="null" /> is returned as the base type of <see cref="T:System.Object" /> .</para>
          <para>Interfaces inherit from <see cref="T:System.Object" /> and from zero or more base interfaces; therefore, the base type of an interface is considered to be <see cref="T:System.Object" /> .</para>
          <para>If the current instance represents a constructed generic type, the base type reflects the generic arguments.</para>
          <para>If the current instance represents an unassigned type parameter, <see cref="T:System.Type.BaseType" /> returns the base class type constraint declared for that parameter, or <see cref="T:System.Object" /> if no base class type constraint was declared.</para>
          <para>
            <block subset="none" type="behaviors"> This property is read-only.</block>
          </para>
        </remarks>
        <example>
          <para>The following example demonstrates using the <see cref="P:System.Type.BaseType" />
property.</para>
          <code lang="C#">using System;
class TestType {
 public static void Main() {
 Type t = typeof(int);
 Console.WriteLine("{0} inherits from {1}", t,t.BaseType);
 }
}
</code>
          <para>The output is</para>
          <para>
            <c>System.Int32
   inherits from System.ValueType</c>
          </para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Gets a value that indicates whether a <see cref="T:System.Type" /> object contains unassigned generic parameters.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if a <see cref="T:System.Type" /> object contains unassigned generic parameters; otherwise <see langword="false" />.</para>
        </value>
        <remarks>
          <para>In order to create an instance of a generic type, there must be no generic type definitions or open constructed types in the type arguments. For other constructed types, such as arrays and managed pointers, the types from which they are constructed must be able to be instantiated. If the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" />, the type cannot be instantiated.</para>
          <para>The  <see cref="P:System.Type.ContainsGenericParameters" /> property searches recursively for type parameters. For example, it returns true for an array whose element type is <see langword="A&lt;T&gt;" />, even though the array type itself is not generic. Contrast this with the behavior of the <see cref="P:System.Type.IsGenericType" /> property, which returns <see langword="false" /> for arrays.</para>
          <para>For a set of example classes and a table showing the values of the <see cref="P:System.Type.ContainsGenericParameters" /> property, see the <see cref="P:System.Type.IsGenericType" /> property description.</para>
          <block subset="none" type="behaviors">
            <para>This property is read-only.</para>
          </block>
        </remarks>
        <since version=".NET 2.0" />
        <example>
          <para>For an example of using this method, see the example for <see cref="P:System.Type.GenericParameterPosition" />.</para>
        </example>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, gets a <see cref="T:System.Reflection.MethodInfo" />  that represents the declaring method.</para>
        </summary>
        <value>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodInfo" />  that represents the declaring method; otherwise <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The declaring method is a generic method definition. That is, if <see cref="P:System.Type.DeclaringMethod" /> does not return <see langword="null" />, then <see cref="P:DeclaringMethod.IsGenericMethodDefinition" /> returns <see langword="true" />.</para>
          <para>The <see cref="P:System.Type.DeclaringType" /> and <see cref="P:System.Type.DeclaringMethod" /> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</para>
          <list type="bullet">
            <item>
              <term>
                <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns a <see cref="T:System.Reflection.MethodBase" />, that <see cref="T:System.Reflection.MethodBase" /> represents a generic method definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic method definition.</para>
              </term>
            </item>
            <item>
              <term>
                <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns a <see langword="null" />, then the <see cref="P:System.Type.DeclaringType" /> property always returns a <see cref="T:System.Type" /> object representing a generic type definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic type definition.</para>
              </term>
            </item>
          </list>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property description.</para>
          <block subset="none" type="behaviors">
            <para>This property is read-only.</para>
          </block>
        </remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="ILASM" Value=".property class System.Type DeclaringType { public hidebysig virtual specialname class System.Type get_DeclaringType() }" />
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the type that declares the type represented by the current instance.</para>
        </summary>
        <value>
          <para>The <see cref="T:System.Type" /> object for
   the class that declares the type represented by the current
   instance. If the type is a nested type, this property returns the enclosing type; otherwise, returns
   the current instance.</para>
        </value>
        <remarks>
          <para>
            <block subset="none" type="note">This property implements the abstract property inherited from <see cref="P:System.Reflection.MemberInfo" />.</block>
          </para>
          <para>If the current <see cref="T:System.Type" /> represents a type parameter of a generic type or method definition, the <see cref="P:System.Type.DeclaringType" /> and <see cref="P:System.Type.DeclaringMethod" /> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</para>
          <list type="bullet">
            <item>
              <term>
                <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns a <see cref="T:System.Reflection.MethodBase" />, that <see cref="T:System.Reflection.MethodBase" /> represents a generic method definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic method definition.</para>
              </term>
            </item>
            <item>
              <term>
                <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns a <see langword="null" />, then the <see cref="P:System.Type.DeclaringType" /> property always returns a <see cref="T:System.Type" /> object representing a generic type definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic type definition.</para>
              </term>
            </item>
          </list>
          <para>For a type parameter of a generic method, this property returns the type that contains the generic method definition.</para>
        </remarks>
        <example>
          <para>The following example demonstrates the
   <see cref="P:System.Type.DeclaringType" /> property. </para>
          <code lang="C#">using System;
using System.Reflection;

public abstract class DeclaringTypeTest{
   public abstract class MyClassA {
      public abstract int m(); 
   }
   public abstract class MyClassB : MyClassA {
   }
   public static void Main() { 
      Console.WriteLine("Declaring type of m is {0}",
         typeof(MyClassB).GetMethod("m").DeclaringType);
   }
}
   </code>
          <para> The output is </para>
          <c>
            <para>Declaring type of m is DeclaringTypeTest+MyClassA </para>
          </c>
        </example>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="ILASM" Value=".property class System.Reflection.Binder DefaultBinder { public hidebysig static specialname class System.Reflection.Binder get_DefaultBinder() }" />
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the default binder used by the system.</para>
        </summary>
        <value>
          <para>The default <see cref="T:System.Reflection.Binder" /> used by the system.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>Reflection models the accessibility rules of the common
      type system. For example, if the caller is in the same assembly, the caller does
      not need special permissions for internal members. Otherwise, the caller needs
   <see cref="T:System.Security.Permissions.ReflectionPermission" />
   . This is consistent with lookup of members that
   are protected, private, and so on. </para>
          <para>
            <block subset="none" type="note">The general principle is that <see cref="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" /> 
typically performs only widening coercions,
which never lose data. An example of a widening coercion is coercing a
value that is a 32-bit signed integer to a value that is a 64-bit signed integer.
This is distinguished from a narrowing coercion, which can lose data. An
example of a narrowing coercion is coercing a 64-bit signed integer to a 32-bit
signed integer. </block>
          </para>
          <para>The following table lists the coercions performed by the default binder's implementation of
<see langword="ChangeType" />.</para>
          <list type="table">
            <listheader>
              <term>Source Type</term>
              <description>Target Type</description>
            </listheader>
            <item>
              <term> Any type</term>
              <description>Its base type.</description>
            </item>
            <item>
              <term> Any type</term>
              <description>The interface it implements.</description>
            </item>
            <item>
              <term> Char</term>
              <description>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</description>
            </item>
            <item>
              <term> Byte</term>
              <description>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</description>
            </item>
            <item>
              <term> SByte</term>
              <description>Int16, Int32, Int64, Single, Double</description>
            </item>
            <item>
              <term> UInt16</term>
              <description>UInt32, Int32, UInt64, Int64, Single, Double</description>
            </item>
            <item>
              <term> Int16</term>
              <description>Int32, Int64, Single, Double</description>
            </item>
            <item>
              <term> UInt32</term>
              <description>UInt64, Int64, Single, Double</description>
            </item>
            <item>
              <term> Int32</term>
              <description>Int64, Single, Double</description>
            </item>
            <item>
              <term> UInt64</term>
              <description>Single, Double</description>
            </item>
            <item>
              <term> Int64</term>
              <description>Single, Double</description>
            </item>
            <item>
              <term> Single</term>
              <description>Double</description>
            </item>
            <item>
              <term> Non-reference</term>
              <description>By-reference.</description>
            </item>
          </list>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="ILASM" Value=".field public static initOnly valuetype System.Char Delimiter" />
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Specifies the character that separates elements in the fully qualified name
      of a <see cref="T:System.Type" />
      .</para>
        </summary>
        <remarks>
          <para>This field is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="ILASM" Value=".field public static initOnly class System.Type[] EmptyTypes" />
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Returns an empty array of type <see cref="T:System.Type" /> .</para>
        </summary>
        <remarks>
          <para>This field is read-only.</para>
          <para>The empty <see cref="T:System.Type" /> array returned by this field is used to specify that 
   lookup methods in the <see cref="T:System.Type" /> class, such as <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />,
   search for members that do not take parameters. <block subset="none" type="note">For example, to locate the public instance constructor that takes no
   parameters, invoke <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> (<see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Instance" />, <see langword="null" />, <see cref="F:System.Type.EmptyTypes" />,
<see langword="null" />).</block></para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance bool Equals(class System.Type o)" />
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">The <see cref="T:System.Type" /> whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</param>
        <summary>
          <para>Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the
   underlying system type of the specified <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same
   as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</para>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">To be added.</param>
        <param name="filterCriteria">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="filterCriteria">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="ILASM" Value=".property string FullName { public hidebysig virtual abstract specialname string get_FullName() }" />
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the fully qualified name of the type represented by 
      the current instance.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.String" /> containing the fully qualified name of the <see cref="T:System.Type" />.</para>
        </value>
        <remarks>
          <para>
            <block subset="none" type="note">For example, the
      fully qualified name of the C# string type is "System.String".</block>
          </para>
          <para>If the current instance represents a generic type, the type arguments in the string returned by <see cref="P:System.Type.FullName" /> are qualified by their assembly, version, and so on, even though the string representation of the generic type itself is not qualified by assembly. Thus, <see langword="t.FullName + &quot;, &quot; + t.Assembly.FullName" /> produces the same result as <see langword="t.AssemblyQualifiedName" />, as with types that are not generic.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property returns <see langword="null" />.</para>
          <para>
            <block subset="none" type="behaviors">This property is
      read-only.</block>
          </para>
        </remarks>
        <example>
          <para>The following example demonstrates using the <see cref="P:System.Type.FullName" />
property.</para>
          <code lang="C#">using System;
class TestType {
 public static void Main() {
 Type t = typeof(Array);
 Console.WriteLine("Full name of Array type is {0}",t.FullName);
 }
}
</code>
          <para>The output is</para>
          <para>
            <c>Full name of
   Array type is System.Array</c>
          </para>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the variance and special constraints of the current generic type parameter. </para>
        </summary>
        <value>
          <para>A <see cref="T:System.Reflection.GenericParameterAttributes" /> value that describes the variance and special constraints of the current generic type parameter.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>The value of this property contains flags that describe whether the current generic type parameter is variant, and flags that describe any special constraints. Use <see cref="F:System.GenericParameterAttributes.VarianceMask" /> to select the variance flags, and <see cref="F:System.GenericParameterAttributes.SpecialConstraintMask" /> to select the constraint flags. Use <see cref="M:System.Reflection.GetGenericParameterConstraints" /> to get the type constraints.</para>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property description.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Type" /> object is not a generic type parameter. That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>For a <see cref="T:System.Type" /> object that represents a type parameter of a generic type or generic method, gets the position of the type parameter in the type parameter list of the generic type or generic method.</para>
        </summary>
        <value>
          <para>A zero-based integer representing the position of a type parameter in the type parameter list of the generic type or generic method that declared the parameter.</para>
        </value>
        <remarks>
          <para>This read-only property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined. The <see cref="P:System.Type.DeclaringType" /> and <see cref="T:System.Type.DeclaringMethod" /> properties identify the generic type or method definition:</para>
          <list type="bullet">
            <item>
              <term>
                <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns a <see cref="T:System.Reflection.MethodBase" />, that <see cref="T:System.Reflection.MethodBase" /> represents a generic method definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic method definition.</para>
              </term>
            </item>
            <item>
              <term>
                <para>If the <see cref="P:System.Type.DeclaringMethod" /> property returns a <see langword="null" />, then the <see cref="P:System.Type.DeclaringType" /> property always returns a <see cref="T:System.Type" /> object representing a generic type definition, and the current <see cref="T:System.Type" /> object represents a type parameter of that generic type definition.</para>
              </term>
            </item>
          </list>
          <para>To provide the correct context for the value of the <see cref="P:System.Type.GenericParameterPosition" /> property, it is necessary to identify the generic type or method a type parameter belongs to. For example, consider the return value of the generic method <see langword="GetSomething" /> in the following C# code: </para>
          <code>public class B&lt;T, U&gt; { }
 public class A&lt;V&gt;
 {
     public B&lt;V, X&gt; GetSomething&lt;X&gt;()
     {
         return new Base&lt;V, X&gt;();
     }
 }</code>
          <para>The type returned by <see langword="GetSomething" /> depends on the type arguments supplied to class <see langword="A" /> and <see langword="GetSomething" /> itself. You can obtain a <see cref="T:System.Reflection.MethodInfo" /> for <see langword="GetSomething" /> and from that you can obtain the return type. When you examine the type parameters of the return type, <see cref="P:System.Type.GenericParameterPosition" /> returns zero for both. The position of <see langword="V" /> is zero because <see langword="V" /> is the first type parameter in the type parameter list for class <see langword="A" />. The position of<see langword="X" /> is zero because <see langword="X" /> is the first type parameter in the type parameter list for <see langword="GetSomething" />.</para>
          <block subset="none" type="note">
            <para>Calling the <see cref="P:System.Type.GenericParameterPosition" /> property causes an exception if the current <see cref="T:System.Type" /> does not represent a type parameter. When you examine the type arguments of an open constructed type, use the <see cref="P:System.Type.IsGenericParameter" /> property to tell which are type parameters and which are types. The <see cref="P:System.Type.IsGenericParameter" /> property returns<see langword="true" /> for a type parameter; you can then use the <see cref="M:System.Type.GenericParameterPosition" /> method to obtain its position, and the <see cref="P:System.Type.DeclaringMethod" /> and <see cref="P:System.Type.DeclaringType" /> properties to determine the generic method or type definition that defines it.</para>
          </block>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.InvalidOperationException">The current type does not represent a type parameter. That is, <see cref="P:System.Type.IsGenericParameter" />  returns <see langword="false" />.</exception>
        <example>
          <para>The following example defines a generic class with two type parameters, and a generic class that derives from it. The base class of the derived type has one unbound type parameter and one type parameter bound to <see cref="T:System.Int32" />. The example displays information about these generic classes, including the positions reported by <see cref="P:System.Type.GenericParameterPosition" />.</para>
          <code lang="C#">using System;
using System.Reflection;
using System.Collections.Generic;
// Define a base class with two type parameters.
public class Base&lt;T, U&gt; { }

// Define a derived class. The derived class inherits from a constructed
// class that meets the following criteria:
//   (1) Its generic type definition is Base&lt;T, U&gt;.
//   (2) It specifies int for the first type parameter.
//   (3) For the second type parameter, it uses the same type that is used
//       for the type parameter of the derived class.
// Thus, the derived class is a generic type with one type parameter, but
// its base class is an open constructed type with one type argument and
// one type parameter.
public class Derived&lt;V&gt;: Base&lt;int,V&gt; { }

public class Test
{
	public static void Main()
	{
		Console.WriteLine("\n--- Display a generic type and the open constructed");
		Console.WriteLine("    type from which it is derived.");

		// Create a Type object representing the generic type Derived.
		//
		Type derivedType = Type.GetType("Derived");

		DisplayGenericTypeInfo(derivedType);

		// Display its open constructed base type.
		DisplayGenericTypeInfo(derivedType.BaseType);
	}

	private static void DisplayGenericTypeInfo(Type t)
	{
		Console.WriteLine("\n{0}", t);
		Console.WriteLine("\tIs this a generic type definition? {0}", t.IsGenericTypeDefinition);
		Console.WriteLine("\tDoes it have generic arguments? {0}", t.HasGenericArguments);
		Console.WriteLine("\tDoes it have unbound generic parameters? {0}", t.ContainsGenericParameters);
		if (t.HasGenericArguments)
		{
			// If the type is a generic type definition or a 
			// constructed type, display the type arguments.
			//
			Type[] typeArguments = t.GetGenericArguments();

			Console.WriteLine("\tList type arguments ({0}):", typeArguments.Length);
			foreach (Type tParam in typeArguments)
			{
				// IsGenericParameter is true only for generic type
				// parameters.
				//
				if (tParam.IsGenericParameter)
				{
					Console.WriteLine("\t\t{0}  (unbound - parameter position {1})", tParam, tParam.GenericParameterPosition);
				}
				else
				{
					Console.WriteLine("\t\t{0}", tParam);
				}
			}
		}
		else
		{
			Console.WriteLine("\tThis is not a generic or constructed type.");
		}
	}
}

/* This example produces the following output:

--- Display a generic type and the open constructed
    type from which it is derived.

Derived[V]
        Is this a generic type definition? True
        Does it have generic arguments? True
        Does it have unbound generic parameters? True
        List type arguments (1):
                V  (unbound - parameter position 0)

Base[System.Int32, V]
        Is this a generic type definition? False
        Does it have generic arguments? True
        Does it have unbound generic parameters? True
        List type arguments (2):
                System.Int32
                V  (unbound - parameter position 0)
 */</code>
        </example>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetArrayRank()" />
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Returns the number of dimensions in the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" /> containing the number of dimensions in the  current
<see cref="T:System.Type" />.</para>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The current <see cref="T:System.Type" /> is  not an array.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl()" />
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>When overridden in a derived type implements the <see cref="P:System.Type.Attributes" />
property and returns the attributes specified for the type represented by the current instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.TypeAttributes" /> value that signifies the attributes of the
   type represented by the current instance.</para>
        </returns>
        <remarks>
          <block subset="none" type="behaviors">
            <para>This property is read-only.</para>
            <para>This method returns a <see cref="T:System.Reflection.TypeAttributes" /> value that indicates the attributes set in
      the metadata of the type represented by the current
      instance.</para>
          </block>
          <para>
            <block subset="none" type="usage">Use this property to determine the
   visibility, semantics, and layout format of the type represented by the
   current instance. Also use this property to determine if the type represented by
   the current instance has a special name.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types)" />
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">
          <para>An array of <see cref="T:System.Type" /> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the constructor to be returned. Specify <see cref="F:System.Type.EmptyTypes" /> to obtain a constructor that takes no parameters.</para>
        </param>
        <summary>
          <para>Returns a public instance constructor defined in the type represented by the
      current instance. The parameters of the constructor match the specified argument
      types.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the public instance
   constructor whose parameters match exactly the types in <paramref name="types" /> , if found;
   otherwise, <see langword="null" />. If the type represented by the current
   instance is contained in a loaded assembly, the constructor that matches the
   specified criteria is not public, and the caller does not have sufficient
   permissions, returns <see langword="null" />. </para>
          <para>If the current instance represents a generic type, this method returns the  <see cref="T:System.Reflection.ConstructorInfo" /> with the type parameters replaced by the appropriate type arguments. If the current instance represents an unassigned type parameter of a generic type or method, this method always returns <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />(<see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Instance" />, <see langword="null" />,
<paramref name="types" />, <see langword="null" />).</para>
          <see langword="" />
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, class System.Reflection.ParameterModifier[] modifiers)" />
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns null. </para>
        </param>
        <param name="binder">
          <para>A <see cref="T:System.Reflection.Binder" /> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <see langword="null" /> to use the <see cref="P:System.Type.DefaultBinder" /> .</para>
        </param>
        <param name="types">
          <para>An array of <see cref="T:System.Type" /> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the constructor to be returned.</para>
        </param>
        <param name="modifiers">The only defined value for this parameter is <see langword="null" /> .</param>
        <summary>
          <para>Returns a constructor defined in the type represented by the current
      instance. The parameters of the constructor match the specified argument types
      and modifiers, under the specified binding constraints.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.ConstructorInfo" /> object that reflects the constructor
   that matches the specified criteria. If an exact match does not exist,
<paramref name="binder" /> will attempt to coerce the parameter types specified in 
<paramref name="types" /> to select a match. If <paramref name="binder" /> is unable to select a 
   match, returns <see langword="null" /> . If the type represented by the current
   instance is contained in a loaded assembly, the constructor that matches the
   specified criteria is not public, and the caller does not have sufficient
   permissions, returns <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   constructors to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public constructors
      in the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public
      constructors (that is, private and protected constructors) in the
      search.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents a generic type, this method returns the  <see cref="T:System.Reflection.ConstructorInfo" /> with the type parameters replaced by the appropriate type arguments. If the current instance represents an unassigned type parameter of a generic type or method, this method always returns <see langword="null" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo[] GetConstructors()" />
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns an array of the public constructors defined in the type represented
      by the current instance.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects that reflect the public constructors
   defined in the type represented by the current instance. If no public
   constructors are defined in the type represented by the current instance, or if the current instance represents an unassigned type parameter of a generic type or method,
   returns an empty array.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.ConstructorInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents a generic type parameter, the <see cref="M:System.Type.GetConstructors" />method returns an empty array.</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetConstructors" /> is equivalent to <see cref="M:System.Type.GetConstructors" />(<see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Instance" />).</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para>Returns an array of constructors defined in the type represented by the
      current instance, under the specified binding constraints.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects that reflect the constructors that
   are defined in the type represented by the current instance and match the
   constraints of <paramref name="bindingAttr" />. If <see cref="F:System.Reflection.BindingFlags.NonPublic" /> and <see cref="F:System.Reflection.BindingFlags.Static" /> are specified, this array
   includes the type initializer if it is defined. If no constructors meeting the
   constraints of <paramref name="bindingAttr" /> are defined in the type represented by the
   current instance, or if the current instance represents an unassigned type parameter of a generic type or method, returns an empty array. If the type represented by the current
   instance is contained in a loaded assembly, the constructors that match the
   specified criteria are not public, and the caller does not have sufficient
   permission, returns <see langword="null" /> .</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.ConstructorInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents a generic type parameter, the <see cref="M:System.Type.GetConstructors" />method returns an empty array.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   constructors to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public constructors
      in the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public
      constructors (that is, private and protected constructors) in the
      search.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Reflection.MemberInfo[] GetDefaultMembers()" />
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects that reflect the default members
   defined in the type represented by the current instance.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects reflecting the default members of the
   type represented by the current instance. If the type represented by the current
   instance does not have any default members, returns an empty array.</para>
        </returns>
        <remarks>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint; the members of all interface constraints; and the members of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="behaviors">The members returned
      by this method have the <see cref="T:System.Reflection.DefaultMemberAttribute" />
      attribute.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Type GetElementType()" />
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns the element type of the current <see cref="T:System.Type" />
.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Type" /> that represents 
   the type used to create the current instance if the current
   instance represents an array, pointer, or an argument
   passed by reference. Otherwise, returns <see langword="null" />
 if the current instance is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter of a generic type or method.</para>
        </returns>
        <remarks>To be added.</remarks>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Type.GetElementType" />
method.</para>
          <code lang="C#">using System;
class TestType {
 public static void Main() {
 int[] array = {1,2,3};
 Type t = array.GetType();
 Type t2 = t.GetElementType();
 Console.WriteLine("{0} element type is {1}",array, t2.ToString());

 TestType newMe = new TestType();
 t = newMe.GetType();
 t2 = t.GetElementType();
 Console.WriteLine("{0} element type is {1}", newMe, t2==null? "null" : t2.ToString());
 }
}
</code>
          <para>The output is</para>
          <c>
            <para>System.Int32[] element type is System.Int32</para>
            <para>TestType element type is null</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.EventInfo GetEvent(string name)" />
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the public event to be returned.</param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.EventInfo" /> object reflecting the public event that has the
   specified name and is defined in the type represented by the current
   instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.EventInfo" /> object 
   reflecting the public event that is named
<paramref name="name" /> and is defined in the type represented by the current instance, if 
   found; otherwise, <see langword="null" />.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.EventInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetEvent(System.String)" /> is equivalent to <see cref="M:System.Type.GetEvent(System.String)" />( <paramref name="name" />, <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Public" /> ).</para>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the events of the class constraint; the events of all interface constraints; and the events of any interfaces inherited from class or interface constraints.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the event to be returned.</param>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns null. </para>
        </param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.EventInfo" /> object reflecting the event that has the
   specified name, is defined in the type represented by the current instance, and
   matches the specified binding constraints.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.EventInfo" /> object reflecting the event that is named
<paramref name="name" />, is defined in the type represented by the current instance, and 
   matches the constraints of <paramref name="bindingAttr" />. If an event
   matching these criteria is not found, returns <see langword="null" />. If the event is not
   public, the current instance represents
   a type from a loaded assembly, and the caller does not have sufficient
   permission, returns <see langword="null" />.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.EventInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   events to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public events in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public
      events(that is, private and protected events) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> value can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the events
      declared on the type, not events that were simply inherited.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the events of the class constraint; the events of all interface constraints; and the events of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Reflection.EventInfo[] GetEvents()" />
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects that reflect the public events
   defined in the type represented by the current instance.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.EventInfo" /> objects that reflect the public events
   defined in the type represented by the current instance. If no public events
   are defined in the type represented by the current instance, returns an empty
   array.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.EventInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
        </returns>
        <remarks>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the events of the class constraint; the events of all interface constraints; and the events of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
          <para>
            <block subset="none" type="default">This version of <see cref="M:System.Type.GetEvents" /> is
   equivalent to <see cref="M:System.Type.GetEvents" />(<see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" />).</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns null. </para>
        </param>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects that reflect the events that are
   defined in the type represented by the current instance and match the specified
   binding constraints.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.EventInfo" /> objects that reflect the events that are
   defined in the type represented by the current instance and match the
   constraints of <paramref name="bindingAttr" /> . If no events match
   these constraints, returns an empty array. If the type reflected by the current
   instance is from a loaded assembly and the caller does not have permission to
   reflect on non-public objects in loaded assemblies, returns only public
   events.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.EventInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   events to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public events in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public
      events (that is, private and protected events) in the
      search.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the events of the class constraint; the events of all interface constraints; and the events of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name)" />
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the field to be returned.</param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.FieldInfo" /> object reflecting the field that has the
   specified name and is defined in the type represented by the current
   instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.FieldInfo" /> object reflecting the field that is named
<paramref name="name" /> and is defined in the type represented by the current instance, if 
   found; otherwise, <see langword="null" />. If the selected field is non-public, the type represented by the
   current instance is from a loaded assembly and the caller does not have
   sufficient permission to reflect on non-public objects in loaded assemblies,
   returns <see langword="null" />.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.FieldInfo" /> with the type parameters replaced by the appropriate type arguments.
</para>
        </returns>
        <remarks>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>This version of <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" /> is equivalent to <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />(
<paramref name="name" />, <see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> ).</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the fields of the class constraint; the fields of all interface constraints; and the fields of any interfaces inherited from class or interface constraints. </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the field to be returned.</param>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.FieldInfo" /> object reflecting the field that has the
   specified name, is defined in the type represented by the current instance, and
   matches the specified binding constraints.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.FieldInfo" /> object reflecting the field that is named
<paramref name="name" />, is defined in the type represented by the current instance, and 
   matches the constraints of <paramref name="bindingAttr" />. If a field matching these criteria
   cannot be found, returns <see langword="null" />. If the field is not public, the current type is
   from a loaded assembly, and the caller does not have sufficient permission,
   returns <see langword="null" />.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.FieldInfo" /> with the type parameters replaced by the appropriate type arguments.
</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   fields to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public fields in
      the search.</term>
            </item>
            <item>
              <term>
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public fields
      (that is, private and protected fields) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the fields
   declared in the type, not fields that were simply inherited.</term>
            </item>
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.IgnoreCase" /> to ignore the case of
   <paramref name="name" />.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the fields of the class constraint; the fields of all interface constraints; and the fields of any interfaces inherited from class or interface constraints. </para>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields()" />
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects that reflect the public fields
   defined in the type represented by the current instance.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.FieldInfo" /> objects that reflect the public fields
   defined in the type represented by the current instance. If no public fields
   are defined in the type represented by the current instance, returns an empty
   array.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.FieldInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetFields" /> is equivalent to <see cref="M:System.Type.GetFields" />( <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Public" /> ).</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the fields of the class constraint; the fields of all interface constraints; and the fields of any interfaces inherited from class or interface constraints. </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects that reflect the fields that are
   defined in the type represented by the current instance and match the specified
   binding constraints.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.FieldInfo" /> objects that reflect the fields that are
   defined in the type represented by the current instance and match the
   constraints of <paramref name="bindingAttr" /> . If no fields match
   these constraints, returns an empty array. If the type represented by the
   current instance is from a loaded assembly and the caller does not have
   sufficient permission to reflect on non-public objects in loaded assemblies,
   returns only public fields.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.FieldInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   fields to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" /> in
      order to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public fields in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public fields
      (that is, private and protected fields) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the fields
      declared in the type, not fields that were simply inherited.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the fields of the class constraint; the fields of all interface constraints; and the fields of any interfaces inherited from class or interface constraints. </para>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of a type in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type or the type parameters of a generic type definition.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type or the type parameters of a generic type definition. Returns an empty array if the current type is not a generic type. The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</para>
        </returns>
        <remarks>
          <para>If the current type is a closed constructed type, the array returned by the <see cref="T:System.Type.GetGenericArguments" /> method contains the type arguments that are bound to the type parameters. If the current type is a generic type definition, the array contains the type parameters. If the current type is an open constructed type in which some of the type parameters are bound to specific types, the array contains both type arguments and type parameters.</para>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property description.</para>
        </remarks>
        <since version=".NET 2.0" />
        <example>
          <para>For an example of using this method, see the example for <see cref="P:System.Type.GenericParameterPosition" />.</para>
        </example>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns an array of <see cref="T:System.Type" /> objects that represent the type constraints on the current generic type parameter.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Type" /> objects that represent the type constraints on the current generic type parameter.</para>
        </returns>
        <remarks>
          <para>Each constraint on a generic type parameter is expressed as a <see cref="T:System.Type" /> object. The first element of the array is the class constraint, if any. If a type parameter has no class constraint and no interface constraints, an empty array of <see cref="T:System.Type" /> is returned for that type parameter. Use <see cref="M:System.Reflection.GenericParameterAttributes" /> to get the special constraints.</para>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property description.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Type" /> object is not a generic type parameter. That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns a <see cref="T:System.Type" /> object that represents a generic type from which the current type can be constructed.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</para>
        </returns>
        <remarks>
          <para>If two constructed types are created from the same generic type definition, the <see cref="M:System.Type.GetGenericTypeDefinition" /> method  returns the same <see cref="T:System.Type" /> object for both types.</para>
          <para>If you call <see cref="M:System.Type.GetGenericTypeDefinition" /> on a <see cref="T:System.Type" /> object that already represents a generic type definition, it returns the current <see cref="T:System.Type" />.</para>
          <para>
            <block subset="none" type="note">An array type whose element type is a generic type is not itself generic. Use <see cref="M:System.Type.IsGenericType" />  to determine whether a type is generic before calling <see cref="M:System.Type.GetGenericTypeDefinition" />.</block>
          </para>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property description.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.InvalidOperationException">The current type is not a generic type.  That is, <see cref="P:System.Type.HasGenericArguments" /> returns <see langword="false" />. </exception>
        <example>
          <para>For an example of using this method, see the example for <see cref="M:System.Type.MakeGenericType" />.</para>
        </example>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetHashCode()" />
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Generates a hash code for the current instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int32" />
containing the hash code for this instance.</para>
        </returns>
        <remarks>
          <para>The algorithm used to
      generate the hash code is unspecified.</para>
          <para>
            <block subset="none" type="note">This method
      overrides <see cref="M:System.Object.GetHashCode" />
      .</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Type GetInterface(string name)" />
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the interface to get. </param>
        <summary>
          <para> Searches for the interface with the specified name.
      </para>
        </summary>
        <returns>
          <para> A <see cref="T:System.Type" /> object
   representing the interface with the specified name, implemented or inherited by
   the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.
   </para>
        </returns>
        <remarks>
          <para> The search for <paramref name="name" /> is case-sensitive.
   </para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Type" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments.</block>
          </para>
          <para>
            <block subset="none" type="note">Even with the introduction of generics, this method continues to return only non-generic members. To get the generic ones, one must call <see cref="M:System.Type.GetInterfaces" />, and filter them out.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">The current instance represents a type that implements the same generic interface with different type arguments.</exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Type GetInterface(string name, bool ignoreCase)" />
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the interface to return.</param>
        <param name="ignoreCase">
          <para> A <see cref="T:System.Boolean" /> where<see langword=" true" /> indicates that the name search is to be done case-insensitively, and <see langword="false" /> performs a case-sensitive search.</para>
        </param>
        <summary>
          <para> Returns the specified interface,
      specifying whether to do a case-sensitive search.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Type" /> object representing
   the interface with the specified name, implemented or inherited by the type
   represented by the instance, if found; otherwise, <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Type" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments.</block>
          </para>
          <para>
            <block subset="none" type="note">Even with the introduction of generics, this method continues to return only non-generic members. To get the generic ones, one must call <see cref="M:System.Type.GetInterfaces" />, and filter them out.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">The current instance represents a type that implements the same generic interface with different type arguments.</exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Type[] GetInterfaces()" />
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns all interfaces implemented or inherited by the
      type represented by the current instance.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Type" /> objects representing the interfaces implemented or
   inherited by the type represented by the current instance. If no interfaces are
   found, returns an empty <see cref="T:System.Type" /> array.</para>
        </returns>
        <remarks>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Type" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="note">Even with the introduction of generics, the overloads of <see cref="M:System.Type.GetInterface" /> continue to return only non-generic members. To get the generic ones, one must call <see cref="M:System.Type.GetInterfaces" />, and filter them out.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMember(string name)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the members to be returned.</param>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects that reflect the public members that
   have the specified name and are defined in the type represented by the current
   instance.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects that reflect the public members that
   are named <paramref name="name" /> and are defined in the type represented by the current instance. If no public
   members with the specified name are defined in the type represented by the
   current instance, returns an empty array.</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetMember(System.String)" /> is equivalent to <see cref="M:System.Type.GetMember(System.String)" />( <paramref name="name" />, <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Public" /> ).</para>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint; the members of all interface constraints; and the members of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the member to be returned.</param>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects that reflect the members defined in
   the type represented by the current instance that have the specified name
   and match the specified binding constraints.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects that reflect the members
   named <paramref name="name" />, are defined in the type represented by the current instance
   and match the constraints of <paramref name="bindingAttr" /> .
   If no members match these constraints, returns an empty array.
   If the selected member is non-public, the type reflected by the current instance is from a
   loaded assembly and the caller does not have sufficient permission to reflect on
   non-public objects in loaded assemblies, returns <see langword="null" /> .</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members
   declared in the type, not members that were simply inherited.</term>
            </item>
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.IgnoreCase" /> to ignore the case of
   <paramref name="name" />.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint; the members of all interface constraints; and the members of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments.</block>
          </para>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="type">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMembers()" />
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects that reflect the public members
   defined in the type represented by the current instance.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects that reflect the public members
   defined in the type represented by the current instance. If no public members
   are defined in the type represented by the current instance, returns an empty
   array.</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetMembers" /> is equivalent to <see cref="M:System.Type.GetMembers" />(<see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" />).</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint; the members of all interface constraints; and the members of any interfaces inherited from class or interface constraints.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects that reflect the members that are
   defined in the type represented by the current instance and match the specified
   binding constraints.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.MemberInfo" /> objects that reflect the members
   defined in the type represented by the current instance that match the
   constraints of <paramref name="bindingAttr" /> . If no members match these constraints,
   returns an empty array. If the type represented by the current instance is from
   a loaded assembly and the caller does not have sufficient permission to reflect
   on non-public objects in loaded assemblies, returns only public members.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members
      declared in the type, not members that were simply inherited.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MemberInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the members of the class constraint, or the members of <see cref="T:System.Object" /> if there is no class constraint; the members of all interface constraints; and the members of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the public method to be returned.</param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.MethodInfo" /> object that reflects the public method that
   has the specified name and is defined in the type represented by the current
   instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.MethodInfo" /> object reflecting the public method that is
   defined in the type represented by the current instance and has the specified
   name, if found; otherwise, <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>This version of <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />(<paramref name="name" />, <see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" />, <see langword="null" />,
<see langword="null" />, <see langword="null" />).</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments.</block>
          </para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the method to be returned.</param>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.MethodInfo" /> object that reflects the method that has the
   specified name and is defined in the type represented by the current
   instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.MethodInfo" /> object
   that reflects the method that is defined
   in the type represented by the current instance and matches the specified
   criteria, if found; otherwise, <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members 
      declared in the type, not members that were simply inherited.</term>
            </item>
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.IgnoreCase" /> to ignore the case of
   <paramref name="name" />.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>This version of <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />(<paramref name="name" />, <paramref name="bindingAttr" /> ,
<see langword="null" />, <see langword="null" />, <see langword="null" />).</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments.</block>
          </para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the public method to be returned.</param>
        <param name="types">
          <para>An array of <see cref="T:System.Type" /> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the method to be returned.</para>
        </param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.MethodInfo" /> object that reflects the public method defined in
   the type represented by the current instance that has the specified name and parameter
   information.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.MethodInfo" /> object reflecting
   the public method defined in the type represented by the current instance
   that matches the specified criteria. If no public method matching the specified criteria
   is found, returns <see langword="null" /> . </para>
        </returns>
        <remarks>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>This version of <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />(<paramref name="name" />, <see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" />, <see langword="null" />,
<paramref name="types" />, <see langword="null" />).</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments.</block>
          </para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />.</para>
          <para>-or-</para>
          <para>At least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, class System.Reflection.ParameterModifier[] modifiers)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the public method to be returned.</param>
        <param name="types">
          <para>An array of <see cref="T:System.Type" /> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the method to be returned.</para>
        </param>
        <param name="modifiers">The only defined value for this parameter is <see langword="null" /> .</param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.MethodInfo" /> object that reflects the public method that
   has the specified name and is defined in the type represented by the current
   instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.MethodInfo" /> object reflecting the public method that is
   defined in the type represented by the current instance and matches the
   specified criteria, if found; otherwise, <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>The default binder does not process
      <paramref name="modifier" /> . </para>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>This version of <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> ( <paramref name="name" />, <see cref="F:System.Reflection.BindingFlags.Public" /> |<see cref="F:System.Reflection.BindingFlags.Static" /> |<see cref="F:System.Reflection.BindingFlags.Instance" /> , <see langword="null" />,<paramref name=" types" /> , <paramref name="modifiers" />).</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments.</block>
          </para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />.</para>
          <para>-or-</para>
          <para>At least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, class System.Reflection.ParameterModifier[] modifiers)" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the method to be returned.</param>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <param name="binder">
          <para>A <see cref="T:System.Reflection.Binder" /> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <see langword="null" /> to use the <see cref="P:System.Type.DefaultBinder" /> .</para>
        </param>
        <param name="types">
          <para>An array of <see cref="T:System.Type" /> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the method to be returned.</para>
        </param>
        <param name="modifiers">The only defined value for this parameter is <see langword="null" /> .</param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.MethodInfo" /> object that reflects the method that matches the
   specified criteria and is defined in the type represented by the current
   instance.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.MethodInfo" /> object that reflects
   the method defined in the type represented by the current instance that
   matches the specified criteria. If no method matching the specified criteria is found, returns
<see langword="null" /> . If the 
   selected method is non-public, the type reflected by
   the current instance is from a loaded assembly, and the caller
   does not have permission to reflect on non-public objects in loaded assemblies,
   returns <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members 
      declared in the type, not members that were simply inherited.</term>
            </item>
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.IgnoreCase" /> to ignore the case of
   <paramref name="name" />.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments.</block>
          </para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />.</para>
          <para>-or-</para>
          <para>At least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods()" />
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns the public methods defined in the type represented by the current
      instance.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.MethodInfo" /> objects reflecting the public methods defined in the type represented by the current instance. If no methods are found, returns an empty array.</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetMethods" /> is equivalent to <see cref="M:System.Type.GetMethods" />( <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Public" /> ).</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects that reflect the methods defined in the type
   represented by the current instance that match the specified binding constraints.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.MethodInfo" /> objects reflecting the methods defined in the type
   represented by the current instance that match the constraints of
<paramref name="bindingAttr" /> . If no such methods found, returns an 
   empty array. If the type represented by the current instance is from a loaded
   assembly and the caller does not have permission to reflect on non-public
   objects in loaded assemblies, returns only public methods.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members
      declared in the type, not members that were simply inherited.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.MethodInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <see cref="T:System.Object" /> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Type GetNestedType(string name)" />
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the public nested type to return. Specify the unqualified name of the nested type. <block subset="none" type="note">For example, for a type B nested within A, if typeA represents the type object for A, the correct invocation is typeA.GetNestedType("B"). </block></param>
        <summary>
          <para>Returns the public nested type defined in the type represented by the current instance</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Type" /> object
   representing the public nested type with the specified
   name, if found; otherwise, <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>Use the simple name of the nested class for <paramref name="name" />; do not qualify it with the name of the outer class. CLS rules require a naming pattern for nested types; see Partition I.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method definition, this method does not search the nested types of the class constraint.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments. For example, passing "MyGenericNestedType&lt;int&gt;" to this method searches for a nested type with the text name "MyGenericNestedType&lt;int&gt;", rather than for a nested type named MyGenericNestedType that has one generic argument of type <see langword="int" />.</block>
            <block subset="none" type="note">If the nested type is generic, what is returned is always a generic type definition.</block>
          </para>
          <para>For information on constructing nested generic types from their generic type definitions, see the  <see cref="M:System.Type.MakeGenericType" /><see langword="(System.Type[])" /> method.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the nested type to return. Specify the unqualified name of the nested type. <block subset="none" type="note">For example, for a type B nested within A, if typeA represents the type object for A, the correct invocation is typeA.GetNestedType("B").</block></param>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para> Returns a nested types defined in the type represented by the current instance that match the specified binding constraints.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Type" /> object representing the nested type that
   matches the specified criteria, if found; otherwise, <see langword="null" />. If the selected nested
   type is non-public, the current instance represents a type contained in a loaded
   assembly and the caller does not have sufficient permissions, returns
<see langword="null" /> 
.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members 
      declared in the type, not members that were simply inherited.</term>
            </item>
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.IgnoreCase" /> to ignore the case of
   <paramref name="name" />.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the nested types of the class constraint.</para>
          <para>
            <block subset="none" type="note">The <paramref name="name" /> parameter cannot include type arguments.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Type[] GetNestedTypes()" />
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns all the public types nested within the current <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Type" /> objects representing all public types nested within the type
   represented by the current instance, if any. Otherwise, returns an empty <see cref="T:System.Type" /> array.</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetNestedTypes" /> is equivalent to <see cref="M:System.Type.GetNestedTypes" />(<see cref="F:System.Reflection.BindingFlags.Public" />).</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the nested types of the class constraint.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para> Returns an array containing the nested types defined in
      the type represented by the current instance that match the specified binding constraints.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Type" /> objects representing all types nested within the type
   represented by the current instance that match the specified binding constraints,
   if any. Otherwise, returns an empty <see cref="T:System.Type" /> array. If the type reflected by the current instance is
   contained in a loaded assembly, the type that matches the specified criteria is
   not public, and the caller does not have sufficient permission, returns only
   public types.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members
      declared in the type, not members that were simply inherited.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the nested types of the class constraint.</para>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.PropertyInfo[] GetProperties()" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.PropertyInfo" /> objects that reflect the public properties
   defined in the type represented by the current instance.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.PropertyInfo" /> 
objects that reflect the public properties defined in the type
represented by the current instance. If no public properties are found, returns
an empty array.</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" /> is equivalent to <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />(
<see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Public" /> ).</para>
          <para>A property is considered by reflection
   to be <see langword="public" /> if it has at least one accessor that is
<see langword="public" />. Otherwise, the property is considered to be not 
<see langword="public" />.</para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para>Returns an array of <see cref="T:System.Reflection.PropertyInfo" /> objects that reflect the properties
   defined for the type represented by the current instance that match the specified
   binding constraints.</para>
        </summary>
        <returns>
          <para>An array of <see cref="T:System.Reflection.PropertyInfo" /> objects that reflect the properties
   defined in the type represented by the current instance and match the
   constraints of <paramref name="bindingAttr" /> . If no matching properties are found,
   returns an empty array. If the type represented by the current instance is from
   a loaded assembly and the caller does not have permission to reflect on
   non-public objects in loaded assemblies, returns only public properties.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members
      declared in the type, not members that were simply inherited.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>If the current instance represents a generic type, this method returns the <see cref="T:System.Reflection.PropertyInfo" /> objects with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.</para>
          <para>
            <block subset="none" type="behaviors">A property is considered by
   reflection to be <see langword="public" /> if it has at least one accessor that is
<see langword="public" /> . Otherwise, the property is not
<see langword="public" />.</block>
          </para>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the property to be returned.</param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.PropertyInfo" /> object that reflects the public
   property defined in the type represented by the current instance that has the specified
   name.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.PropertyInfo" /> object reflecting the public property defined 
   on the type represented by the current instance that has the specified name. If
   no matching property is found, returns <see langword="null" /> . </para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />(<paramref name="name" />, <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Public" />,
<see langword="null" />, <see langword="null" />, <see langword="null" />, 
<see langword="null" />).</para>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>If the current instance represents a generic type, this method returns the <see langword="System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.</para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> is <see langword="null" />.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the property to be returned.</param>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.PropertyInfo" /> object that reflects the property defined
   in the type represented by the current instance that matches the specified search
   criteria.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.PropertyInfo" />
object reflecting the property defined in the type represented by
the current instance that matches the specified criteria. If no matching property is
found, returns <see langword="null" /> . If the type reflected by the current
instance is contained in a loaded assembly, the property that matches the
specified criteria is not public, and the caller does not have sufficient
permission, returns <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members 
      declared in the type, not members that were simply inherited.</term>
            </item>
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.IgnoreCase" /> to ignore the case of
   <paramref name="name" />.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>This version of <see cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />(<paramref name="name" />, <paramref name="bindingAttr" />,
<see langword="null" />, <see langword="null" />, <see langword="null" />, 
<see langword="null" />).</para>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>If the current instance represents a generic type, this method returns the <see langword="System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.</para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> is <see langword="null" />.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the property to be returned.</param>
        <param name="returnType">A <see cref="T:System.Type" /> object that represents the type of the property to be returned.</param>
        <param name="returnType">To be added.</param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.PropertyInfo" /> 
object that reflects the public property defined in the type represented by the current
instance that matches the specified search criteria.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.PropertyInfo" /> object reflecting the public property defined 
   on the type represented by the current instance that matches the specified
   criteria. If no matching property is found, returns <see langword="null" /> .</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />(<paramref name="name" />, <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Public" />,
<see langword="null" />, <paramref name="returnType" />, <see langword="null" />, 
<see langword="null" />).</para>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>If the current instance represents a generic type, this method returns the <see langword="System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.</para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> is <see langword="null" />.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the public property to be returned.</param>
        <param name="types">
          <para>An array of <see cref="T:System.Type" /> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify <see cref="F:System.Type.EmptyTypes" /> to obtain a property that is not indexed.</para>
        </param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.PropertyInfo" /> object that reflects the public property defined
   in the type represented by the current instance that matches the specified search
   criteria.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.PropertyInfo" /> object reflecting the public property defined
   on the type represented by the current instance that matches the specified
   criteria. If no matching property is found, returns <see langword="null" /> .</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />(<paramref name="name" />, <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Public" />,
<see langword="null" />, <see langword="null" />, <paramref name="types" />, 
<see langword="null" />).</para>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>Different programming languages use different syntax to 
   specify indexed properties. Internally, this property is referred to by the name
   "Item" in the metadata. Therefore, any attempt to retrieve an indexed property
   using reflection is required to
   specify this internal name in order for the <see langword="PropertyInfo" /> to be returned correctly.</para>
          <para>If the current instance represents a generic type, this method returns the <see langword="System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.</para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the public property to be returned.</param>
        <param name="returnType">A <see cref="T:System.Type" /> object that represents the type of the public property to be returned.</param>
        <param name="types">
          <para>An array of <see cref="T:System.Type" /> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify <see cref="F:System.Type.EmptyTypes" /> for a property that is not indexed.</para>
        </param>
        <param name="returnType">To be added.</param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.PropertyInfo" /> object that reflects the public property
   defined in the type represented by the current instance that matches the specified search
   criteria.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.PropertyInfo" /> object
   reflecting the public property defined in the type represented by
   the current instance that matches the specified criteria. If no matching property is
   found, returns <see langword="null" /> . </para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />(<paramref name="name" />, <see cref="F:System.Reflection.BindingFlags.Static" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> | <see cref="F:System.Reflection.BindingFlags.Public" />,
<see langword="null" />, <paramref name="returnTypes" />, <paramref name="types" />, 
<see langword="null" />).</para>
          <para>The search for <paramref name="name" /> is case-sensitive.</para>
          <para>Different programming languages use different syntax to 
   specify indexed properties. Internally, this property is referred to by the name
   "Item" in the metadata. Therefore, any attempt to retrieve an indexed
   property using reflection is required to
   specify this internal name in order for the <see langword="PropertyInfo" /> to be returned correctly.</para>
          <para>If the current instance represents a generic type, this method returns the <see langword="System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.</para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> has more than one dimension.</exception>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, class System.Reflection.ParameterModifier[] modifiers)" />
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the property to be returned.</param>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <param name="binder">
          <para>A <see cref="T:System.Reflection.Binder" /> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <see langword="null" /> to use the <see cref="P:System.Type.DefaultBinder" /> .</para>
        </param>
        <param name="returnType">A <see cref="T:System.Type" /> object that represents the type of the property to be returned.</param>
        <param name="types">
          <para>An array of <see cref="T:System.Type" /> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify <see cref="F:System.Type.EmptyTypes" /> to obtain a property that is not indexed.</para>
        </param>
        <param name="modifiers">The only defined value for this parameter is <see langword="null" /> .</param>
        <param name="returnType">To be added.</param>
        <summary>
          <para>Returns a <see cref="T:System.Reflection.PropertyInfo" /> object that reflects the property
   defined in the type represented by the current instance that matches the specified search
   criteria .</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.PropertyInfo" /> object
   reflecting the property that is defined in the type represented by the
   current instance and matches the specified criteria. If no matching property is
   found, returns <see langword="null" /> . If the type reflected by the current
   instance is contained in a loaded assembly, the property that matches the
   specified criteria is not public, and the caller does not have sufficient
   permission, returns <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members 
      declared in the type, not members that were simply inherited.</term>
            </item>
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.IgnoreCase" /> to ignore the case of
   <paramref name="name" />.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>This version of <see cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" /> is equivalent to <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />(<paramref name="name" />, <paramref name="bindingAttr" />, <paramref name="binder" />,
<paramref name="returnType" />, <paramref name="types" />, <paramref name="modifiers" />).</para>
          <para> Different programming languages use different syntax to
   specify indexed properties. Internally, this property is referred to by the name
   "Item" in the metadata. Therefore, any attempt to retrieve an indexed property
   using reflection is required to specify this internal
   name in order for the <see langword="PropertyInfo" /> to be returned correctly.</para>
          <para>If the current instance represents a generic type, this method returns the <see langword="System.Reflection.PropertyInfo" /> with the type parameters replaced by the appropriate type arguments.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.</para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, class System.Reflection.ParameterModifier[] modifiers)" />
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:System.String" /> containing the name of the property to be returned.</param>
        <param name="bindingAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, this method returns <see langword="null" /> . </para>
        </param>
        <param name="binder">
          <para>A <see cref="T:System.Reflection.Binder" /> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <see langword="null" /> to use the <see cref="P:System.Type.DefaultBinder" /> .</para>
        </param>
        <param name="returnType">A <see cref="T:System.Type" /> object that represents the type of the property to be returned.</param>
        <param name="types">
          <para>An array of <see cref="T:System.Type" /> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify <see cref="F:System.Type.EmptyTypes" /> to obtain a property that is not indexed.</para>
        </param>
        <param name="modifiers">The only defined value for this parameter is <see langword="null" /> .</param>
        <param name="returnType">To be added.</param>
        <summary>
          <para>When overridden in a derived class implements the 
   <see cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" /> 
   method and returns a <see cref="T:System.Reflection.PropertyInfo" /> object that reflects the property defined
   in the type represented by the current instance that matches the specified search
   criteria.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Reflection.PropertyInfo" /> object representing the property that matches the
   specified search criteria, if found; otherwise, <see langword="null" />. If the type reflected by the current
   instance is from a loaded assembly, the matching property is not
   public, and the caller does not have permission to reflect on non-public
   objects in loaded assemblies, returns <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
   members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members 
      declared in the type, not members that were simply inherited.</term>
            </item>
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.IgnoreCase" /> to ignore the case of
   <paramref name="name" />.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <para>
            <block subset="none" type="behaviors"> Different
   programming languages use different syntax to specify indexed properties.
   Internally, this property is referred to by the name "Item" in the metadata.
   Therefore, any attempt to retrieve an indexed property using reflection is required to
   specify this internal name in order for the <see langword="PropertyInfo" /> to be returned correctly.
</block>
          </para>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property matching the specified criteria was found.</exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> or <paramref name="types" /> is <see langword="null" />, or at least one of the elements in <paramref name="types" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="types" /> has more than one dimension.</para>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Type GetType(string typeName)" />
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">A <see cref="T:System.String" /> containing the case-sensitive name of the <see cref="T:System.Type" /> to return.</param>
        <summary>
          <para>Returns the <see cref="T:System.Type" /> with the specified name.</para>
        </summary>
        <returns>
          <para>The <see cref="T:System.Type" /> with the specified name, if found; otherwise, <see langword="null" />. If the
   requested type is non-public and the caller does not have permission to reflect
   non-public objects outside the current assembly, this method returns
<see langword="null" />.</para>
        </returns>
        <remarks>
          <para>This method is equivalent to <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />(<paramref name="name" />, <see langword="false" />,
<see langword="false" />).</para>
          <para>
            <paramref name="typeName" /> can be a simple
type name, a type name that includes a namespace, or a complex name that
includes an assembly name specification. If <paramref name="typeName" /> includes only the name of the <see cref="T:System.Type" />, this method
searches in the calling object's assembly, then in the mscorlib.dll assembly. If
<paramref name="typeName" /> 
is fully qualified with the partial or complete assembly name, this method
searches in the specified assembly.</para>
          <para>
            <block subset="none" type="note">
              <see cref="P:System.Type.AssemblyQualifiedName" /> can return a fully qualified type name including
   nested types, the assembly name, and generic type arguments. For complete details, see <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />(<see cref="T:System.String" />, <see cref="T:System.Boolean" />, <see cref="T:System.Boolean" />).</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />. </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A type initializer was invoked and threw an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Type GetType(string typeName, bool throwOnError)" />
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">A <see cref="T:System.String" /> containing the case-sensitive name of the <see cref="T:System.Type" /> to return.</param>
        <param name="throwOnError">
          <para>A <see cref="T:System.Boolean" />. Specify <see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if an error occurs while loading the <see cref="T:System.Type" />. Specify <see langword="false" /> to ignore errors while loading the <see cref="T:System.Type" />.</para>
        </param>
        <summary>
          <para>Returns the <see cref="T:System.Type" /> with the specified name, optionally throwing an
   exception if an error occurs while loading the <see cref="T:System.Type" /> .</para>
        </summary>
        <returns>
          <para>The <see cref="T:System.Type" /> with the specified name, if found; otherwise, <see langword="null" /> . If the
   requested type is non-public and the caller does not have permission to reflect non-public objects
   outside the current assembly, this method returns <see langword="null" /> .</para>
        </returns>
        <remarks>
          <para>This method is equivalent to <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />(<paramref name="name" />, <paramref name="throwOnError" />, 
<see langword="false" />).</para>
          <para>
            <paramref name="typeName" /> can be a simple
type name, a fully qualified name, or a complex name that includes an assembly
name specification. If <paramref name="typeName" /> includes only the name of the <see cref="T:System.Type" />, this method searches in the
calling object's assembly, then in the mscorlib.dll assembly. If
<paramref name="typeName" /> 
is fully qualified with the partial or complete assembly name, this method
searches in the specified assembly.</para>
          <para>
            <block subset="none" type="note">
              <see cref="P:System.Type.AssemblyQualifiedName" /> can return a fully
qualified type name including nested types, the assembly name, and generic type arguments. For complete
details, see <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />(<see cref="T:System.String" />, <see cref="T:System.Boolean" />, <see cref="T:System.Boolean" />). </block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />. </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A type initializer was invoked and threw an exception.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> is <see langword="true" /> and an error was encountered while loading the <see cref="T:System.Type" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public objects. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true" /></permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase)" />
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">A <see cref="T:System.String" /> containing the name of the <see cref="T:System.Type" /> to return.</param>
        <param name="throwOnError">
          <para> A <see cref="T:System.Boolean" />. Specify <see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if an error occurs while loading the <see cref="T:System.Type" />. Specify <see langword="false" /> to ignore errors while loading the <see cref="T:System.Type" />.</para>
        </param>
        <param name="ignoreCase">
          <para> A <see cref="T:System.Boolean" />. Specify<see langword=" true" /> to perform a case-insensitive search for <paramref name="typeName." /> Specify <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" /> .</para>
        </param>
        <summary>
          <para>Returns the <see cref="T:System.Type" />
with the specified name, optionally performing a case-insensitive search
and optionally throwing an exception if an error occurs while loading the <see cref="T:System.Type" />.</para>
        </summary>
        <returns>
          <para>The <see cref="T:System.Type" /> with the specified name, if found; otherwise, <see langword="null" />. If the
   requested type is non-public and the caller does not have permission to reflect non-public objects
   outside the current assembly, this method returns <see langword="null" />.</para>
        </returns>
        <remarks>
          <para>
            <paramref name="typeName" /> can be a simple
   type name, a fully qualified name, or a complex name that includes an assembly
   name. <block subset="none" type="note"><see cref="P:System.Type.AssemblyQualifiedName" />
   returns a fully qualified type name including nested types,
  the assembly name, and generic type arguments. </block></para>
          <para>If <paramref name="typeName" /> includes only the name of the <see cref="T:System.Type" />, this method searches in the
calling object's assembly, then in the mscorlib.dll assembly. If
<paramref name="typeName" /> 
is fully qualified with the partial or complete assembly name, this
method searches in the specified assembly.</para>
          <block subset="none" type="note">
            <para>
              <see langword="" />
            </para>
            <para> The following table shows calls to
<see langword="GetType" /> for various types.  (Some long strings have been wrapped to fit in the right column.)</para>
            <list type="table">
              <listheader>
                <term>To Get this Type</term>
                <description>Use this String</description>
              </listheader>
              <item>
                <term>An unmanaged pointer to <see langword="MyType" /></term>
                <description>
                  <c>Type.GetType("MyType*")</c>
                </description>
              </item>
              <item>
                <term>An unmanaged pointer to a pointer to <see langword="MyType" /></term>
                <description>
                  <c>Type.GetType("MyType**")</c>
                </description>
              </item>
              <item>
                <term>A managed pointer or reference to <see langword="MyType" /></term>
                <description>
                  <c>Type.GetType("MyType&amp;")</c>Note that unlike pointers, references are limited to one level.</description>
              </item>
              <item>
                <term>A parent class and a nested class</term>
                <description>
                  <c>Type.GetType("MyParentClass+MyNestedClass")</c>
                </description>
              </item>
              <item>
                <term>A one-dimensional array with a lower bound of 0</term>
                <description>
                  <c>Type.GetType("MyArray[]")</c>
                </description>
              </item>
              <item>
                <term>A one-dimensional array with an unknown lower bound</term>
                <description>
                  <c>Type.GetType("MyArray[*]")</c>
                </description>
              </item>
              <item>
                <term>An n-dimensional array</term>
                <description>A comma (,) inside the brackets a total of n-1 times. For example, <c>System.Object[,,]</c> represents a three-dimensional <see langword="Object" /> array.</description>
              </item>
              <item>
                <term>A two-dimensional array's array</term>
                <description>
                  <c>Type.GetType("MyArray[][]")</c>
                </description>
              </item>
              <item>
                <term>A rectangular two-dimensional array with unknown lower bounds</term>
                <description>
                  <c>Type.GetType("MyArray[*,*]") </c>or <c> Type.GetType("MyArray[,]")</c></description>
              </item>
              <item>
                <term>A generic type with one type argument</term>
                <description>
                  <c>Type.GetType("MyGenericType[MyType]")</c>
                </description>
              </item>
              <item>
                <term>A generic type with two type arguments</term>
                <description>
                  <c>Type.GetType("MyGenericType[MyType,AnotherType]")</c>
                </description>
              </item>
              <item>
                <term>A generic type with two assembly-qualified type arguments</term>
                <description>
                  <c>Type.GetType("MyGenericType[[MyType,MyAssembly],
[AnotherType,AnotherAssembly]]")
</c>
                </description>
              </item>
              <item>
                <term>An assembly-qualified generic type with an assembly-qualified type argument</term>
                <description>
                  <c>Type.GetType("MyGenericType[[MyType,MyAssembly]]
,MyGenericTypeAssembly")</c>
                </description>
              </item>
              <item>
                <term>A generic type whose type argument is a generic type with two type arguments</term>
                <description>
                  <c>Type.GetType("MyGenericType[AnotherGenericType
[MyType,AnotherType]]")
</c>
                </description>
              </item>
            </list>
          </block>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A type initializer was invoked and threw an exception.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> is <see langword="true" /> and an error was encountered while loading the selected <see cref="T:System.Type" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">To be added.</param>
        <param name="assemblyResolver">To be added.</param>
        <param name="typeResolver">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">To be added.</param>
        <param name="assemblyResolver">To be added.</param>
        <param name="typeResolver">To be added.</param>
        <param name="throwOnError">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">To be added.</param>
        <param name="assemblyResolver">To be added.</param>
        <param name="typeResolver">To be added.</param>
        <param name="throwOnError">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Type[] GetTypeArray(class System.Object[] args)" />
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">An array of objects whose types are to be returned. </param>
        <summary>
          <para> Returns the types of the objects in the specified array.
      </para>
        </summary>
        <returns>
          <para> An array of <see cref="T:System.Type" /> objects representing the types of the corresponding
   elements in <paramref name="args" />. If a requested type is not public
   and the caller does not have permission to
   reflect non-public objects outside the current assembly, the corresponding element in the
   array returned by this method will be <see langword="null" />.
   </para>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> is <see langword="null" />. </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The type initializers were invoked and at least one threw an exception. </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">To be added.</param>
        <param name="throwOnError">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">To be added.</param>
        <param name="server">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">To be added.</param>
        <param name="server">To be added.</param>
        <param name="throwOnError">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle)" />
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">The <see cref="T:System.RuntimeTypeHandle" /> object that refers to the desired <see cref="T:System.Type" />.</param>
        <summary>
          <para>Gets the <see cref="T:System.Type" /> referenced by the specified type handle.</para>
        </summary>
        <returns>
          <para>The <see cref="T:System.Type" /> referenced by the specified <see cref="T:System.RuntimeTypeHandle" />.</para>
        </returns>
        <remarks>
          <para>The handles are valid only in the application domain in which they were obtained. </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The requested type is non-public and outside the current assembly, and the caller does not have the required permission.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A type initializer was invoked and threw an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public objects. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true" /></permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">To be added.</param>
        <param name="throwOnError">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">To be added.</param>
        <param name="server">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">To be added.</param>
        <param name="server">To be added.</param>
        <param name="throwOnError">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static valuetype System.RuntimeTypeHandle GetTypeHandle(object o)" />
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">The object for which to get the type handle.</param>
        <summary>
          <para>Returns the handle for the <see cref="T:System.Type" /> of the specified object.</para>
        </summary>
        <returns>
          <para>The <see cref="T:System.RuntimeTypeHandle" /> for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</para>
        </returns>
        <remarks>
          <para>The handle is valid only in the application domain in which it was obtained. </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="ILASM" Value=".property bool HasElementType { public hidebysig specialname instance bool get_HasElementType() }" />
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value indicating whether the type represented by the 
   current instance encompasses or refers
   to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>
            <block subset="none" type="note">For example, <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />("<see cref="T:System.Int32" /> []").HasElementType returns
<see langword="true" />, but <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />("<see cref="T:System.Int32" /> ").HasElementType returns
<see langword="false" />. <see cref="P:System.Type.HasElementType" /> also returns
<see langword="true" /> for "Int32*" and "Int32&amp;".</block>
          </para>
          <para>If the current instance represents a generic type, or a type parameter of a generic type or method, this property returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool HasElementTypeImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and
   determines whether the current <see cref="T:System.Type" /> encompasses or
   refers to another type; that is,
   whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by
   reference.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />. </para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">For example, 
   <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" /> ("System.Int32[]").HasElementTypeImpl returns
   <see langword="true" />, but <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" /> ("System.Int32").HasElementTypeImpl returns
   <see langword="false" />. <see cref="M:System.Type.HasElementTypeImpl" /> also returns <see langword="true" /> for "System.Int32*" and "System.Int32&amp;".</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, class System.Object[] args)" />
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <para>A <see cref="T:System.String" /> containing the name of the constructor or method to invoke, or property or field to access. If the type represented by the current instance has a default member, specify <see cref="F:System.String.Empty" /> to invoke that member. <block subset="none" type="note">For more information on default members, see <see cref="T:System.Reflection.DefaultMemberAttribute" /> .</block></para>
        </param>
        <param name="invokeAttr">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, <see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> is used by default.</param>
        <param name="binder">
          <para>A <see cref="T:System.Reflection.Binder" /> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <see langword="null" /> to use the <see cref="P:System.Type.DefaultBinder" /> .</para>
        </param>
        <param name="target">A <see cref="T:System.Object" /> on which to invoke the member that matches the other specified criteria. If the matching member is <see langword="static" /> , this parameter is ignored.</param>
        <param name="args">An array of objects containing the arguments to pass to the member to be invoked. The elements of this array are of the same number and in the same order by assignment-compatible type as specified by the contract of the member to be bound. Specify an empty array or <see langword="null" /> for a member that has no parameters.</param>
        <summary>
          <para>Invokes the specified member, using the specified binding constraints and
      matching the specified argument list.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" />
containing the return value of the invoked member. If the invoked member does
not have a return value, returns a <see cref="T:System.Object" /> containing <see cref="T:System.Void" /> .</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> is equivalent to <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />(<paramref name="name" />, <paramref name="invokeAttr" />, <paramref name="binder" />,
<paramref name="target" />, <paramref name="args" />, <see langword="null" />, <see langword="null" />, 
<see langword="null" />).</para>
          <para>
            <block subset="none" type="note">For a demonstration of the use of
<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />, see the example for <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />( 
<see cref="T:System.String" />, <see cref="T:System.Reflection.BindingFlags" />, 
<see cref="T:System.Reflection.Binder" />, <see cref="T:System.Object" />, <see cref="T:System.Object" />[], <see cref="T:System.Reflection.ParameterModifier" />[], <see cref="T:System.Globalization.CultureInfo" />, <see cref="T:System.String" />[]).</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="args" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> value.</para>
          <para>-or-</para>
          <para>The member to be invoked is a constructor and <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be invoked is a method that is not a type initializer or instance constructor, and <see cref="F:System.Reflection.BindingFlags.InvokeMethod" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a field, and neither <see cref="F:System.Reflection.BindingFlags.GetField" /> nor <see cref="F:System.Reflection.BindingFlags.SetField" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a property, and neither <see cref="F:System.Reflection.BindingFlags.GetProperty" /> nor <see cref="F:System.Reflection.BindingFlags.SetProperty" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> and at least one of <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />, <see cref="F:System.Reflection.BindingFlags.GetField" />, <see cref="F:System.Reflection.BindingFlags.SetField" />, <see cref="F:System.Reflection.BindingFlags.GetProperty" />, or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetField" /> and <see cref="F:System.Reflection.BindingFlags.SetField" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetProperty" /> and <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.InvokeMethod" /> and at least one of <see cref="F:System.Reflection.BindingFlags.SetField" /> or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.SetField" /> and <paramref name="args" /> has more than one element.</para>
        </exception>
        <exception cref="T:System.MissingFieldException">A field or property matching the specified criteria was not found.</exception>
        <exception cref="T:System.MissingMethodException">
          <para>A method matching the specified criteria cannot be found.</para>
          <para>-or-</para>
          <para>The current instance object represents a type that contains open type parameters (that is, </para>
          <see cref="P:System.Type.ContainsGenericParameters" />
          <para> returns </para>
          <see langword="true" />
          <para>).</para>
        </exception>
        <exception cref="T:System.MethodAccessException">The requested member is non-public and the caller does not have the required permission.</exception>
        <exception cref="T:System.Reflection.TargetException">The member matching the specified criteria cannot be invoked on <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The member matching the specified criteria threw an exception.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one member matches the specified criteria.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, class System.Object[] args, class System.Globalization.CultureInfo culture)" />
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">
          <para>A <see cref="T:System.String" /> containing the name of the constructor or method to invoke, or property or field to access. If the type represented by the current instance has a default member, specify <see cref="F:System.String.Empty" /> to invoke that member. <block subset="none" type="note">For more information on default members, see <see cref="T:System.Reflection.DefaultMemberAttribute" /> .</block></para>
        </param>
        <param name="invokeAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, <see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> is used by default. </para>
        </param>
        <param name="binder">
          <para>A <see cref="T:System.Reflection.Binder" /> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <see langword="null" /> to use the <see cref="P:System.Type.DefaultBinder" /> .</para>
        </param>
        <param name="target">A <see cref="T:System.Object" /> on which to invoke the member that matches the other specified criteria. If the matching member is <see langword="static" /> , this parameter is ignored.</param>
        <param name="args">An array of objects containing the arguments to pass to the member to be invoked. The elements of this array are of the same number and in the same order by assignment-compatible type as specified by the contract of the member to be bound. Specify an empty array or <see langword="null" /> for a member that has no parameters.</param>
        <param name="culture">
          <para>The only defined value for this parameter is <see langword="null" /> .</para>
        </param>
        <summary>
          <para>Invokes the specified member, using the specified binding constraints
      and matching the specified argument list and culture.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" />
containing the return value of the invoked member. If the invoked member does
not have a return value, returns a <see cref="T:System.Object" /> containing <see cref="T:System.Void" /> .</para>
        </returns>
        <remarks>
          <para>This version of <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> is equivalent to <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />(
<paramref name="name" />, <paramref name="invokeAttr" />, <paramref name="binder" />, <paramref name="target" />, <paramref name="args" />, 
<see langword="null" />, <paramref name="culture" />, <see langword="null" /> ). </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="n" />
            <paramref name="ame" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="args" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> value.</para>
          <para>-or-</para>
          <para>The member to be invoked is a constructor and <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be invoked is a method that is not a type initializer or instance constructor, and <see cref="F:System.Reflection.BindingFlags.InvokeMethod" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a field, and neither <see cref="F:System.Reflection.BindingFlags.GetField" /> nor <see cref="F:System.Reflection.BindingFlags.SetField" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a property, and neither <see cref="F:System.Reflection.BindingFlags.GetProperty" /> nor <see cref="F:System.Reflection.BindingFlags.SetProperty" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> and at least one of <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />, <see cref="F:System.Reflection.BindingFlags.GetField" />, <see cref="F:System.Reflection.BindingFlags.SetField" />, <see cref="F:System.Reflection.BindingFlags.GetProperty" />, or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetField" /> and <see cref="F:System.Reflection.BindingFlags.SetField" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetProperty" /> and <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />and at least one of <see cref="F:System.Reflection.BindingFlags.SetField" /> or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.SetField" /> and <paramref name="args" /> has more than one element.</para>
        </exception>
        <exception cref="T:System.MissingFieldException">A field or property matching the specified criteria was not found.</exception>
        <exception cref="T:System.MissingMethodException">
          <para>A method matching the specified criteria was not found.</para>
          <para>-or-</para>
          <para>The current instance object represents a type that contains open type parameters (that is, </para>
          <see cref="P:System.Type.ContainsGenericParameters" />
          <para> returns </para>
          <see langword="true" />
          <para>).</para>
        </exception>
        <exception cref="T:System.MethodAccessException">The requested member is non-public and the caller does not have the required permission.</exception>
        <exception cref="T:System.Reflection.TargetException">The member matching the specified criteria cannot be invoked on <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The member matching the specified criteria threw an exception.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one member matches the specified criteria.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <example>
          <para> For an example that demonstrates
   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> , see <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />(
   <see cref="T:System.String" />, <see cref="T:System.Reflection.BindingFlags" />,
   <see cref="T:System.Reflection.Binder" />, <see cref="T:System.Object" />, <see cref="T:System.Object" />[], <see cref="T:System.Reflection.ParameterModifier" />[], <see cref="T:System.Globalization.CultureInfo" />, <see cref="T:System.String" />[]).
      </para>
        </example>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, class System.Object[] args, class System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, class System.String[] namedParameters)" />
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <para>A <see cref="T:System.String" /> containing the name of the constructor or method to invoke, or property or field to access. If the type represented by the current instance has a default member, specify <see cref="F:System.String.Empty" /> to invoke that member. <block subset="none" type="note">For more information on default members, see <see cref="T:System.Reflection.DefaultMemberAttribute" /> .</block></para>
        </param>
        <param name="invokeAttr">
          <para>A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that control the binding process. If zero is specified, <see cref="F:System.Reflection.BindingFlags.Public" /> | <see cref="F:System.Reflection.BindingFlags.Instance" /> is used by default.<SPAN /></para>
        </param>
        <param name="binder">A <see cref="T:System.Reflection.Binder" /> that defines a set of properties, and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <see langword="null" /> to use<see cref="M:System.Type.DefaultBinder" />.</param>
        <param name="target">A <see cref="T:System.Object" /> on which to invoke the member that matches the other specified criteria. If the matching member is <see langword="static" /> , this parameter is ignored.</param>
        <param name="args">An array of objects containing the arguments to pass to the member to be invoked. The elements of this array are of the same number and in the same order by assignment-compatible type as specified by the contract of the member to be bound if and only if <paramref name="nameParameters" /> is <see langword="null" />. If <paramref name="namedParameters" /> is not <see langword="null" />, the order of the elements in <paramref name="args" /> corresponds to the order of the parameters specified in <paramref name="namedParameters" />. Specify an empty array or <see langword="null" /> for a member that takes no parameters.</param>
        <param name="modifiers">
          <para>The only defined value for this parameter is <see langword="null" /> .</para>
        </param>
        <param name="culture">
          <para>The only defined value for this parameter is <see langword="null" /> .</para>
        </param>
        <param name="namedParameters">An array of <see cref="T:System.String" /> objects containing the names of the parameters to which the values in <paramref name="args" /> are passed. These names are processed in a case-sensitive manner and have a one-to-one correspondence with the elements of <paramref name="args" />. Specify an empty array or <see langword="null" /> for a member that takes no parameters. Specify <see langword="null" /> to have this parameter ignored.</param>
        <summary>
          <para> Invokes or
      accesses a member defined on the type represented by the current instance
      that matches the specified binding criteria.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Object" />
containing the return value of the invoked or accessed member. If the member
does not have a return value, returns a <see cref="T:System.Object" /> containing <see cref="T:System.Void" /> .</para>
        </returns>
        <remarks>
          <para>
            <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> calls a constructor or a method , gets or sets a property , gets or sets a field, or gets or sets an element of an array.</para>
          <para> The binder finds all of the matching members. These
   members are found based upon the type of binding specified by <paramref name="invokeAttr" /> . The <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" qualify="true" /> is
   responsible for selecting the method to be invoked. The default binder selects
   the most specific match. The set of members is then filtered by name, number of
   arguments, and a set of search modifiers defined in the binder. After the member is selected, it is invoked or accessed.
   Accessibility is checked at that point. Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</para>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> are used to define which
members to include in the search:</para>
          <list type="bullet">
            <item>
              <term>
      Specify either <see cref="F:System.Reflection.BindingFlags.Instance" /> or <see cref="F:System.Reflection.BindingFlags.Static" />
      to get a return value other than <see langword="null" />.</term>
            </item>
            <item>
              <term>
      Specify <see cref="F:System.Reflection.BindingFlags.Public" /> to include public members in
      the search.</term>
            </item>
            <item>
              <term>
      Specify <see cref="F:System.Reflection.BindingFlags.NonPublic" /> to include non-public members
      (that is, private and protected members) in the search.</term>
            </item>
          </list>
          <para>The following <see cref="T:System.Reflection.BindingFlags" /> values can be used to change how the
search works:</para>
          <list type="bullet">
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.DeclaredOnly" /> to search only the members 
      declared in the type, not members that were simply inherited.</term>
            </item>
            <item>
              <term>
                <see cref="F:System.Reflection.BindingFlags.IgnoreCase" /> to ignore the case of
   <paramref name="name" />.</term>
            </item>
          </list>
          <para>
            <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" />.</block>
          </para>
          <block subset="none" type="behaviors">
            <para>Each parameter in the <paramref name="namedParameters" /> array is assigned the value in the
   corresponding element in the <paramref name="args" /> array. If the length of <paramref name="args" /> is
   greater than the length of <paramref name="namedParameters" />, the remaining argument values
   are passed in order.</para>
            <para>A member will be found only
   if the number of parameters in the member declaration equals the number of
   arguments in the args array (unless default arguments are defined on the
   member). Also, The type of each argument is required to be convertible by
   the binder to the type
   of the parameter. </para>
            <para>It is required that the caller specify values for <paramref name="invokeAttr" /> as
follows:</para>
            <para>
              <list type="table">
                <listheader>
                  <term>Action</term>
                  <description>BindingFlags</description>
                </listheader>
                <item>
                  <term> Invoke a constructor. </term>
                  <description>
                    <see cref="F:System.Reflection.BindingFlags.CreateInstance" />. This
      flag is not valid with the other flags in this table. If this flag is
      specified, <paramref name="name" /> is ignored. </description>
                </item>
                <item>
                  <term> Invoke a method. </term>
                  <description>
                    <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />. This
   flag if not valid with <see cref="F:System.Reflection.BindingFlags.CreateInstance" />, <see cref="F:System.Reflection.BindingFlags.SetField" />, or <see cref="F:System.Reflection.BindingFlags.SetProperty" />. </description>
                </item>
                <item>
                  <term> Define a field value. </term>
                  <description>
                    <see cref="F:System.Reflection.BindingFlags.SetField" />. This
   flag is not valid with <see cref="F:System.Reflection.BindingFlags.CreateInstance" />, <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />, or <see cref="F:System.Reflection.BindingFlags.GetField" />.</description>
                </item>
                <item>
                  <term> Return a field value. </term>
                  <description>
                    <see cref="F:System.Reflection.BindingFlags.GetField" />. This
   flag is not valid with <see cref="F:System.Reflection.BindingFlags.CreateInstance" />, <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />, or <see cref="F:System.Reflection.BindingFlags.SetField" />.</description>
                </item>
                <item>
                  <term> Set a property. </term>
                  <description>
                    <see cref="F:System.Reflection.BindingFlags.SetProperty" />. This
   flag is not valid with <see cref="F:System.Reflection.BindingFlags.CreateInstance" />, <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />, or <see cref="F:System.Reflection.BindingFlags.GetProperty" />.</description>
                </item>
                <item>
                  <term> Get a property.</term>
                  <description>
                    <see cref="F:System.Reflection.BindingFlags.GetProperty" />. This
   flag is not valid with <see cref="F:System.Reflection.BindingFlags.CreateInstance" />, <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />, or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</description>
                </item>
              </list>
            </para>
            <para>
              <block subset="none" type="note">For more information, see <see cref="T:System.Reflection.BindingFlags" /> .</block>
            </para>
          </block>
          <block subset="none" type="usage">
            <para>
              <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> can be used to invoke methods with
   parameters that have default values. To bind to these methods, <see cref="F:System.Reflection.BindingFlags.OptionalParamBinding" /> must be specified. For a parameter that has a
   default value, the caller can supply a value or supply <see cref="F:System.Type.Missing" />
   
   to use the default value.</para>
            <para>
              <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> can be used to set a field to a
particular value by specifying <see cref="F:System.Reflection.BindingFlags.SetField" /> . For example, to set a public instance field named F on class C, where F is a string, the value is set using the following statement:</para>
            <para>
              <c>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{
   "strings new value"}, null, null, null);</c>
            </para>
            <para> A string array F can be initialized as follows:</para>
            <c>
              <para>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{new
      String[]{"a","z","c","d"}, null, null, null);</para>
            </c>
            <para> Use <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> to set the value of an element in an array by specifying the index of the value and the new value for the element as follows:</para>
            <para>
              <c>typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{1,
   "b"}, null, null, null);</c>
            </para>
            <para>The preceding statement changes "z" in array
   F to "b". </para>
          </block>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="name" /> is <see langword="null" />.</para>
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="args" /> has more than one dimension.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> value.</para>
          <para>-or-</para>
          <para>The member to be invoked is a constructor and <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be invoked is a method that is not a type initializer or instance constructor, and <see cref="F:System.Reflection.BindingFlags.InvokeMethod" /> is not specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a field, and neither <see cref="F:System.Reflection.BindingFlags.GetField" /> nor <see cref="F:System.Reflection.BindingFlags.SetField" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>The member to be accessed is a property, and neither <see cref="F:System.Reflection.BindingFlags.GetProperty" /> nor <see cref="F:System.Reflection.BindingFlags.SetProperty" /> is specified in <paramref name="invokeAttr" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.CreateInstance" /> and at least one of <see cref="F:System.Reflection.BindingFlags.InvokeMethod" />, <see cref="F:System.Reflection.BindingFlags.GetField" />, <see cref="F:System.Reflection.BindingFlags.SetField" />, <see cref="F:System.Reflection.BindingFlags.GetProperty" />, or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetField" /> and <see cref="F:System.Reflection.BindingFlags.SetField" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains both <see cref="F:System.Reflection.BindingFlags.GetProperty" /> and <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.InvokeMethod" /> and at least one of <see cref="F:System.Reflection.BindingFlags.SetField" /> or <see cref="F:System.Reflection.BindingFlags.SetProperty" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="invokeAttr" /> contains <see cref="F:System.Reflection.BindingFlags.SetField" /> and <paramref name="args" /> has more than one element.</para>
          <para>-or-</para>
          <para>
            <paramref name="namedParameters" />.Length &gt; <paramref name="args" />.Length .</para>
          <para>-or-</para>
          <para>At least one element in <paramref name="namedParameters" /> is <see langword="null" />.</para>
          <para>-or-</para>
          <para>At least one element in <paramref name="args" /> is not assignment-compatible with the corresponding parameter in <paramref name="namedParameters" />.</para>
        </exception>
        <exception cref="T:System.MissingFieldException">A field or property matching the specified criteria was not found.</exception>
        <exception cref="T:System.MissingMethodException">
          <para>A method matching the specified criteria cannot be found.</para>
          <para>-or-</para>
          <para>The current instance object represents a type that contains open type parameters (that is, </para>
          <see cref="P:System.Type.ContainsGenericParameters" />
          <para> returns </para>
          <see langword="true" />
          <para>).</para>
        </exception>
        <exception cref="T:System.MethodAccessException">The requested member is non-public and the caller does not have the required permission.</exception>
        <exception cref="T:System.Reflection.TargetException">The member matching the specified criteria cannot be invoked on <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The member matching the specified criteria threw an exception.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">More than one member matches the specified criteria.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Requires permission to retrieve information on non-public members of types in loaded assemblies. See <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" />.</permission>
        <example>
          <para>The following example demonstrates the use of <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> to
   construct a <see cref="T:System.String" />, obtain its <see cref="P:System.String.Length" /> property, invoke <see cref="M:System.String.Insert(System.Int32,System.String)" /> on it, and
   then set its value using the <see cref="F:System.String.Empty" /> field.</para>
          <code lang="C#">using System;
using System.Reflection;

class InvokeMemberExample
{
   static void Main(string[] args)
   {
      // Create the parameter arrays that will
      // be passed to InvokeMember.
      char[] cAry = 
      new char[] {'A',' ','s','t','r','i','n','g'};
      object[] oAry = new object[] {cAry, 0, cAry.Length};

      Type t = typeof(string);

      // Invoke the constructor of a string.
      string str =
         (string)t.InvokeMember(null, BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.CreateInstance, null,
         null, oAry, null, null, null);
      Console.WriteLine("The string is \"{0}\".", str);

      // Access a property of the string.
      int i =
         (int) t.InvokeMember("Length", BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.GetProperty, null, 
         str, null, null, null, null);
      Console.WriteLine("The length of the string is {0}.", i);

      // Invoke a method on the string.
      string newStr = "new ";
      object[] oAry2 = new Object[] {2, newStr};
      str = (string) t.InvokeMember("Insert", BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.InvokeMethod, null, str, 
         oAry2, null, null, null);
      Console.WriteLine("The modified string is \"{0}\".", str);

      // Access a field of the string.
      str = (string) t.InvokeMember("Empty", BindingFlags.Static | 
         BindingFlags.Public | BindingFlags.GetField, null, str, 
         null);
      Console.WriteLine("The empty string is \"{0}\".", str);
  
   }
}
</code>
          <para>The output is </para>
          <c>
            <para>The string is "A string". </para>
            <para>The length of the string is 8. </para>
            <para> The modified string is "A new string"</para>
            <para>The empty string is "". </para>
          </c>
        </example>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="ILASM" Value=".property bool IsAbstract { public hidebysig specialname instance bool get_IsAbstract() }" />
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating 
   whether the type represented by the current instance is abstract and is required to be overridden.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property always returns <see langword="true" />. This is because it is not possible to create an instance of a generic type parameter.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Indicates whether the type attribute <see cref="F:System.Reflection.TypeAttributes.AnsiClass" /> is selected for the current type.</para>
        </summary>
        <value>
          <see langword="true" /> if the type attribute <see cref="F:System.Reflection.TypeAttributes.AnsiClass" />  is selected for the current type; otherwise, <see langword="false" />.</value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type, this property applies to the definition of the type. If the current <see cref="T:System.Type" /> represents a type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="ILASM" Value=".property bool IsArray { public hidebysig specialname instance bool get_IsArray() }" />
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether the current <see cref="T:System.Type" /> represents an array.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" /> represents an
   array; otherwise <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>This property returns <see langword="true" /> for an array of objects, but
   not for the <see cref="T:System.Array" />
   type itself, which is a class.</para>
          <para>If the current instance represents a generic type, or a type parameter of a generic type or method, this property returns <see langword="false" />.</para>
        </remarks>
        <example>
          <para>The following example demonstrates using the <see cref="P:System.Type.IsArray" />
property.</para>
          <code lang="C#">using System;
class TestType {
 public static void Main() {
 int [] array = {1,2,3,4};
 Type at = typeof(Array);
 Type t = array.GetType();
 Console.WriteLine("Type is {0}. IsArray? {1}", at, at.IsArray);
 Console.WriteLine("Type is {0}. IsArray? {1}", t, t.IsArray);
 }
}
</code>
          <para>The output is</para>
          <c>
            <para>Type is System.Array. IsArray? False</para>
            <para>Type is System.Int32[]. IsArray? True</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool IsArrayImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>When overridden in a derived class implements the <see cref="P:System.Type.IsArray" /> property returning a
<see cref="T:System.Boolean" /> value that indicates whether
   the type represented by the current instance is an array.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />. </para>
        </returns>
        <remarks>
          <para>An instance of the <see cref="T:System.Array" /> class is required to return <see langword="false" /> because it is an object, not an
   array.<block subset="none" type="behaviors">As described above.</block></para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool IsAssignableFrom(class System.Type c)" />
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">The <see cref="T:System.Type" /> to compare with the current <see cref="T:System.Type" /> . </param>
        <summary>
          <para> Determines whether an instance of the current <see cref="T:System.Type" /> can be assigned
   from an instance of the specified <see cref="T:System.Type" /> .
   </para>
        </summary>
        <returns>
          <para>
            <see langword="false" /> if <paramref name="c" /> is a null reference.</para>
          <para>
            <see langword="true" /> if one or more of the following
statements are true; otherwise <see langword="false" />. </para>
          <list type="bullet">
            <item>
              <term>
      
      If <paramref name="c" /> and the current <see cref="T:System.Type" /> represent the same type.</term>
            </item>
            <item>
              <term>
      
      If the current <see cref="T:System.Type" /> is in the inheritance hierarchy of <paramref name="c" />.</term>
            </item>
            <item>
              <term>
      
      If the current <see cref="T:System.Type" /> is an interface and <paramref name="c" /> supports that
      interface.</term>
            </item>
            <item>
              <term>If <paramref name="c" /> is a generic type parameter and the current instance represents one of the constraints of <paramref name="c" />.</term>
            </item>
          </list>
          <see langword="" />
        </returns>
        <remarks>
          <block subset="none" type="note">
            <para>A generic type definition is not assignable from a closed constructed type.</para>
          </block>
        </remarks>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Type.IsAssignableFrom(System.Type)" />
method using arrays.</para>
          <code lang="C#">using System;
class ArrayTypeTest {
 public static void Main() {
 int i = 1;
 int [] array10 = new int [10];
 int [] array2 = new int[2];
 int [,]array22 = new int[2,2];
 int [,]array24 = new int[2,4];
 int [,,]array333 = new int[3,3,3];
 Type array10Type = array10.GetType();
 Type array2Type = array2.GetType();
 Type array22Type = array22.GetType();
 Type array24Type = array24.GetType();
 Type array333Type = array333.GetType();

 // If X and Y are not both arrays, then false
 Console.WriteLine("int[2] is assignable from int? {0} ", array2Type.IsAssignableFrom(i.GetType()));
 // If X and Y have same type and rank, then true.
 Console.WriteLine("int[2] is assignable from int[10]? {0} ",  array2Type.IsAssignableFrom(array10Type));
 Console.WriteLine("int[2,2] is assignable from int[2,4]? {0}",  array22Type.IsAssignableFrom(array24Type));
 Console.WriteLine("int[2,4] is assignable from int[2,2]? {0}",  array24Type.IsAssignableFrom(array22Type));
 Console.WriteLine("");
 // If X and Y do not have the same rank, then false.
 Console.WriteLine("int[2,2] is assignable from int[10]? {0}",  array22Type.IsAssignableFrom(array10Type));
 Console.WriteLine("int[2,2] is assignable from int[3,3,3]? {0}",  array22Type.IsAssignableFrom(array333Type));
 Console.WriteLine("int[3,3,3] is assignable from int[2,2]? {0}",  array333Type.IsAssignableFrom(array22Type));
 }
}
</code>
          <para>The output is</para>
          <c>
            <para>int[2] is assignable from int? False</para>
            <para>int[2] is assignable from int[10]? True</para>
            <para>int[2,2] is assignable from int[2,4]? True</para>
            <para>int[2,4] is assignable from int[2,2]? True</para>
            <para>int[2,2] is assignable from int[10]? False</para>
            <para>int[2,2] is assignable from int[3,3,3]? False</para>
            <para>int[3,3,3] is assignable from int[2,2]? False</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Indicates whether the type attribute <see cref="F:System.Reflection.TypeAttributes.AutoClass" /> is selected for the current type.</para>
        </summary>
        <value>
          <see langword="true" /> if the type attribute <see cref="F:System.Reflection.TypeAttributes.AutoClass" />  is selected for the current type; otherwise, <see langword="false" />.</value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type, this property applies to the definition of the type. If the current <see cref="T:System.Type" /> represents a type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="ILASM" Value=".property bool IsAutoLayout { public hidebysig specialname instance bool get_IsAutoLayout() }" />
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating
   whether the type layout attribute <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> is specified for the <see cref="T:System.Type" />.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the type
   layout attribute <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> is specified for the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
          <block subset="none" type="note">
            <para>The <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> attribute specifies that the system
      selects the layout the objects of the type. Types marked with this attribute indicate that the
      system will choose the appropriate way to lay out the type; any layout information
      that might have been specified is ignored. </para>
          </block>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="ILASM" Value=".property bool IsByRef { public hidebysig specialname instance bool get_IsByRef() }" />
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value indicating whether the <see cref="T:System.Type" /> is
   passed by reference.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool IsByRefImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" />
property and determines whether the <see cref="T:System.Type" /> is passed by reference.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />. </para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="ILASM" Value=".property bool IsClass { public hidebysig specialname instance bool get_IsClass() }" />
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value that indicates whether the current <see cref="T:System.Type" /> represents a class.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" /> represents a class;
   otherwise <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>Note that this property returns <see langword="true" /> for
<see cref="T:System.Type" /> instances 
   representing <see cref="T:System.Enum" /> and <see cref="T:System.ValueType" /> .</para>
          <para>If the current instance represents a generic type, this property returns <see langword="true" /> if the generic type definition is a class definition (that is, it does not define an interface or a value type).</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool IsCOMObjectImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Reserved.</para>
        </summary>
        <returns>
          <para>
            <see langword="false" />
          </para>
        </returns>
        <remarks>
          <para>This abstract method is required to be present for
      legacy implementations. Conforming implementations are permitted to throw the
   <see cref="T:System.NotSupportedException" />
   as their implementation.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="ILASM" Value=".property bool IsEnum { public hidebysig specialname instance bool get_IsEnum() }" />
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value that indicates whether the current <see cref="T:System.Type" /> represents an enumeration.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" /> represents an
   enumeration; otherwise <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>This property returns <see langword="true" /> for an enumeration, but not
   for the <see cref="T:System.Enum" />
   type itself, which is a class.</para>
          <para>If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
        <example>
          <para>The following example demonstrates using the <see cref="P:System.Type.IsEnum" />
property.</para>
          <code lang="C#">using System;
public enum Color {
Red, Blue, Green
}
class TestType {
 public static void Main() {
 Type colorType = typeof(Color);
 Type enumType = typeof(Enum);
 Console.WriteLine("Color is enum ? {0}", colorType.IsEnum);
 Console.WriteLine("Color is valueType? {0}", colorType.IsValueType);
 Console.WriteLine("Enum is enum Type? {0}", enumType.IsEnum);
 Console.WriteLine("Enum is value? {0}", enumType.IsValueType);
 }
}
</code>
          <para>The output is</para>
          <c>
            <para>Color is enum ? True</para>
            <para>Color is valueType? True</para>
            <para>Enum is enum Type? False</para>
            <para>Enum is value? False</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="ILASM" Value=".property bool IsExplicitLayout { public hidebysig specialname instance bool get_IsExplicitLayout() }" />
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating
   whether the type layout attribute <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> is specified for the <see cref="T:System.Type" />.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the type layout attribute <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> is specified for the current <see cref="T:System.Type" />; otherwise,
<see langword="false" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <block subset="none" type="note">
            <para>Types marked with the <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> attribute cause
      the system to ignore field sequence and to use the explicit layout rules provided,
      in the form of field offsets, overall class size and alignment. </para>
          </block>
          <para>If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Gets a value that indicates whether the current type represents a type parameter of a generic type or method.</para>
        </summary>
        <value>
          <see langword="true" /> if the current object represents a type parameter of a generic type or method; otherwise <see langword="false" />.</value>
        <remarks>
          <para>This property is read-only.</para>
          <para>Use this property to distinguish between type parameters and type arguments. When you call  <see cref="M:System.Type.GetGenericArguments" /> to obtain the type arguments of a generic type, some elements of the array might be specific types (type arguments) and others might be type parameters.<see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" /> for the types and <see langword="true" /> for the type parameters.</para>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property description.</para>
        </remarks>
        <since version=".NET 2.0" />
        <example>
          <para>For an example of using this method, see the example for <see cref="P:System.Type.GenericParameterPosition" />.</para>
        </example>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Gets a value that indicates whether the current type has type arguments, and is therefore a generic type.</para>
        </summary>
        <value>
          <see langword="true" /> if the current type has type arguments; otherwise <see langword="false" />.</value>
        <remarks>
          <para>Use this property to determine whether a <see cref="T:System.Type" /> object represents a generic type. Use the <see cref="P:System.Type.ContainsGenericParameters" /> property to determine whether a <see cref="T:System.Type" /> object represents an open constructed type or a closed constructed type.</para>
          <para>
            <block subset="none" type="note">The  <see cref="P:System.Type.HasGenericArguments" /> property returns <see langword="false" /> if the immediate type is not generic.  </block>
          </para>
          <para>The following table summarizes the invariant conditions for common terms used in generic reflection.</para>
          <para>
            <list type="table">
              <listheader>
                <term>Term</term>
                <description>Invariant</description>
              </listheader>
              <item>
                <term>generic type definition</term>
                <description>
                  <para>The <see cref="P:System.Type.IsGenericTypeDefinition" /> property is <see langword="true" />.</para>
                  <para>Defines a generic type. A constructed type is created by calling the <see cref="M:System.Type.MakeGenericType" /><see langword="(System.Type[])" /> method on a <see cref="T:System.Type" /> object that represents a generic type definition, and specifying an array of type arguments.</para>
                  <para>
                    <see cref="M:System.Type.MakeGenericType" />
                    <see langword="(System.Type[])" /> can be called only on generic type definitions. </para>
                  <para>Any generic type definition is a generic type, but the converse is not true.</para>
                </description>
              </item>
              <item>
                <term>generic type</term>
                <description>
                  <para>The <see cref="P:System.Type.IsGenericType" /> property is <see langword="true" />.</para>
                  <para>Can be a generic type definition, an open constructed type, or a closed constructed type. </para>
                  <para>Note that an array type whose element type is generic is not itself a generic type. The same is true of a <see cref="T:System.Type" /> object representing a pointer to a generic type.</para>
                </description>
              </item>
              <item>
                <term>open constructed type</term>
                <description>
                  <para>The <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</para>
                  <para>It is not possible to create an instance of an open constructed type.</para>
                  <para>Note that not all open constructed types are generic, such as an array type whose element type is a generic type definition.</para>
                </description>
              </item>
              <item>
                <term>closed constructed type</term>
                <description>
                  <para>The <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="false" />.</para>
                  <para>When examined recursively, the type has no unassigned generic parameters. The containing type or method has no generic type parameters, and, recursively, no type arguments have unassigned generic type parameters.</para>
                </description>
              </item>
              <item>
                <term>generic type parameter</term>
                <description>
                  <para>The <see cref="P:System.Type.IsGenericParameter" /> property is <see langword="true" />.</para>
                  <para>In a generic type definition, a placeholder for a type that will be assigned later.</para>
                </description>
              </item>
              <item>
                <term>generic type argument</term>
                <description>
                  <para>Can be any type, including a generic type parameter.</para>
                  <para>Type arguments are specified as an array of <see cref="T:System.Type" /> objects passed to the <see cref="M:System.Type.MakeGenericType" /><see langword="(System.Type[])" /> method when creating a constructed generic type. If instances of the resulting type are to be created, the <see cref="P:System.Type.ContainsGenericParameters" /> property must be <see langword="false" /> for all the type arguments.</para>
                </description>
              </item>
            </list>
          </para>
          <block subset="none" type="behaviors">
            <para>This property is read-only.</para>
          </block>
        </remarks>
        <since version=".NET 2.0" />
        <example>
          <para>For an example of using this method, see the example for <see cref="M:System.Type.MakeGenericType" />.</para>
        </example>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Gets a value that indicates whether the current object represents the definition of a generic type, or whether one or more of its type parameters has been specified.</para>
        </summary>
        <value>
          <see langword="true" /> if the current object represents the definition of a generic type, none of whose type parameters have been bound to specific types; otherwise <see langword="false" />.</value>
        <remarks>
          <para>This property is read-only.</para>
          <para>Use this property to determine whether type arguments have been specified for any of the type parameters of a generic type. If type arguments have been specified (that is, bound to the corresponding type parameters), this property returns <see langword="false" />.</para>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property description.</para>
          <block subset="none" type="note">
            <para>An open generic type can have type parameters even if types have been specified for its type parameters.</para>
          </block>
        </remarks>
        <since version=".NET 2.0" />
        <example>
          <para>For an example of using this method, see the example for <see cref="M:System.Type.MakeGenericType." />.</para>
        </example>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="ILASM" Value=".property bool IsImport { public hidebysig specialname instance bool get_IsImport() }" />
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating whether the <see cref="T:System.Type" /> was imported from another class.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> was imported from another class; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool IsInstanceOfType(object o)" />
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">The object to compare with the current <see cref="T:System.Type" />. </param>
        <summary>
          <para> Determines whether the specified object is an instance
      of the current <see cref="T:System.Type" />.
      </para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if either of the following
   statements is true; otherwise <see langword="false" />.
   </para>
          <list type="bullet">
            <item>
              <term>
      
      If the current <see cref="T:System.Type" /> is in the inheritance hierarchy of <paramref name="o" />.</term>
            </item>
            <item>
              <term>
      
      If the current <see cref="T:System.Type" /> is an interface and <paramref name="o" /> supports that
      interface.</term>
            </item>
          </list>
          <para>If <paramref name="o" /> is a null reference or if the current instance is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" />  returns <see langword="true" />) returns <see langword="false" />.</para>
        </returns>
        <remarks>
          <para>As described above.</para>
          <block subset="none" type="note">
            <para>A constructed type is not an instance of its generic type definition.</para>
          </block>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Type.IsInstanceOfType(System.Object)" />
method.</para>
          <code lang="C#">using System;
public interface IFoo { }
public class MyClass : IFoo {}
public class MyDerivedClass : MyClass {}
class IsInstanceTest {
 public static void Main() {
 Type ifooType=typeof(IFoo);
 MyClass mc = new MyClass();
 Type mcType = mc.GetType();
 MyClass mdc = new MyDerivedClass();
 Type mdcType = mdc.GetType();
 int [] array = new int [10];
 Type arrayType = typeof(Array);
 Console.WriteLine("int[] is instance of Array? {0}", arrayType.IsInstanceOfType(array));
 Console.WriteLine("myclass instance is instance of MyClass? {0}", mcType.IsInstanceOfType(mc));
 Console.WriteLine("myderivedclass instance is instance of MyClass? {0}",  mcType.IsInstanceOfType(mdc));
 Console.WriteLine("myclass instance is instance of IFoo? {0}", ifooType.IsInstanceOfType(mc));
 Console.WriteLine("myderivedclass instance is instance of IFoo? {0}",  ifooType.IsInstanceOfType(mdc));
 }
}
</code>
          <para>The output is </para>
          <c>
            <para>int[] is instance of Array? True</para>
            <para>myclass instance is instance of MyClass? True</para>
            <para>myderivedclass instance is instance of MyClass? True</para>
            <para>myclass instance is instance of IFoo? True</para>
            <para>myderivedclass instance is instance of IFoo? True</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="ILASM" Value=".property bool IsInterface { public hidebysig specialname instance bool get_IsInterface() }" />
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether the  current <see cref="T:System.Type" /> represents an interface.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" />  represents an
   interface; otherwise <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="ILASM" Value=".property bool IsLayoutSequential { public hidebysig specialname instance bool get_IsLayoutSequential() }" />
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating
   whether the type layout attribute <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> is specified for the <see cref="T:System.Type" />.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the type layout attribute
<see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> is specified for the current 
<see cref="T:System.Type" />; otherwise, 
<see langword="false" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <block subset="none" type="note">
            <para> The <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> attribute is used
      to indicate that
      the system is to preserve field order as emitted, but otherwise the specific offsets are calculated based on the type
      of the field; these might be shifted by explicit offset, padding, or alignment information.</para>
          </block>
          <para>If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="ILASM" Value=".property bool IsMarshalByRef { public hidebysig specialname instance bool get_IsMarshalByRef() }" />
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value indicating whether the current type is marshaled by reference.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedAssembly { public hidebysig specialname instance bool get_IsNestedAssembly() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value indicating whether the current <see cref="T:System.Type" /> is nested and visible only within its own assembly.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <para> This property is read-only.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedFamANDAssem { public hidebysig specialname instance bool get_IsNestedFamANDAssem() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating whether the current <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and
   its own assembly.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is nested
   and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <para> This property is read-only.</para>
          <para>A <see cref="T:System.Type" /> object's family is defined as all objects of the exact
   same <see cref="T:System.Type" /> and of its subclasses.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedFamily { public hidebysig specialname instance bool get_IsNestedFamily() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating whether the current <see cref="T:System.Type" /> is nested and visible only within its
   own family.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is nested
   and visible only within its own family; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <para> This property is read-only.</para>
          <para>A <see cref="T:System.Type" /> object's family is defined as all objects of the exact
   same <see cref="T:System.Type" /> and of its subclasses.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedFamORAssem { public hidebysig specialname instance bool get_IsNestedFamORAssem() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating whether the current <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its
   own family or to its own assembly.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is nested
   and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <para> This property is read-only.</para>
          <para>A <see cref="T:System.Type" /> object's family is defined as all objects of the exact
   same <see cref="T:System.Type" /> and of its subclasses.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedPrivate { public hidebysig specialname instance bool get_IsNestedPrivate() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating whether the current <see cref="T:System.Type" /> is nested and declared private.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="ILASM" Value=".property bool IsNestedPublic { public hidebysig specialname instance bool get_IsNestedPublic() }" />
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating 
   whether the current <see cref="T:System.Type" /> is a public nested class.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if
   the class is nested and declared public; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="ILASM" Value=".property bool IsNotPublic { public hidebysig specialname instance bool get_IsNotPublic() }" />
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating whether the top-level <see cref="T:System.Type" /> is not declared public.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the
   top-level <see cref="T:System.Type" /> is not declared public; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="ILASM" Value=".property bool IsPointer { public hidebysig specialname instance bool get_IsPointer() }" />
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether the current <see cref="T:System.Type" /> represents a pointer.</para>
        </summary>
        <value>
          <para>This property is read-only.</para>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" /> represents a
   pointer; otherwise <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents a generic type, or a type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool IsPointerImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the
<see cref="T:System.Type" /> is a pointer.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />. </para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="ILASM" Value=".property bool IsPrimitive { public hidebysig specialname instance bool get_IsPrimitive() }" />
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value indicating whether the current <see cref="T:System.Type" /> is one of the primitive types.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>The primitive types are <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Char" />, <see cref="T:System.Double" />, and <see cref="T:System.Single" />.</para>
          <para>If the current instance represents a generic type, or a type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual abstract bool IsPrimitiveImpl()" />
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the
<see cref="T:System.Type" /> is one of the primitive types.</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />. </para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="behaviors">This method 
      returns <see langword="true" /> if the underlying type of the current instance is
      one of the following: <see cref="T:System.Boolean" />, <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, <see cref="T:System.UInt32" />, <see cref="T:System.Int64" />, <see cref="T:System.UInt64" />, <see cref="T:System.Char" />, <see cref="T:System.Double" />, and <see cref="T:System.Single" />.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="ILASM" Value=".property bool IsPublic { public hidebysig specialname instance bool get_IsPublic() }" />
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating whether the top-level <see cref="T:System.Type" /> is declared public.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the top-level <see cref="T:System.Type" /> is declared public; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property returns <see langword="true" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="ILASM" Value=".property bool IsSealed { public hidebysig specialname instance bool get_IsSealed() }" />
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating whether the current <see cref="T:System.Type" /> is declared sealed.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type, this property returns <see langword="true" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies if it is possible to serialize the <see cref="T:System.Type" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="ILASM" Value=".property bool IsSpecialName { public hidebysig specialname instance bool get_IsSpecialName() }" />
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets a <see cref="T:System.Boolean" /> value indicating whether the current <see cref="T:System.Type" /> has a name that requires special handling.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the <see cref="T:System.Type" /> has a name that requires special handling; otherwise, <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>
            <block subset="none" type="note">Names that begin with or contain an
      underscore character (_) are examples of type names that
      might require special treatment by some tools. </block>
          </para>
          <para>If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool IsSubclassOf(class System.Type c)" />
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">The <see cref="T:System.Type" /> to compare with the current <see cref="T:System.Type" />.</param>
        <summary>
          <para>Determines whether the current <see cref="T:System.Type" /> derives from the
   specified <see cref="T:System.Type" /> .</para>
        </summary>
        <returns>
          <para>
            <see langword="true" /> if <paramref name="c" /> and the current
<see cref="T:System.Type" /> represent 
   classes, and the class represented by the current <see cref="T:System.Type" /> derives from the class represented by
<paramref name="c" />; otherwise <see langword="false" />. Returns <see langword="false" /> if 
<paramref name="c" /> and the current <see cref="T:System.Type" /> represent the same class.</para>
        </returns>
        <remarks>
          <para>Interfaces are not considered.</para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, it derives from its class constraint, or from <see cref="T:System.Object" /> if it has no class constraint.</para>
        </remarks>
        <example>
          <para>The following example demonstrates the <see cref="M:System.Type.IsSubclassOf(System.Type)" />
method.</para>
          <code lang="C#">using System;
public interface IFoo { }
public interface IBar:IFoo{}
public class MyClass : IFoo {}
public class MyDerivedClass : MyClass {}
class IsSubclassTest {
 public static void Main() {
 Type ifooType = typeof(IFoo);
 Type ibarType = typeof(IBar);
 MyClass mc = new MyClass();
 Type mcType = mc.GetType();
 MyClass mdc = new MyDerivedClass();
 Type mdcType = mdc.GetType();
 int [] array = new int [10];
 Type arrayOfIntsType = array.GetType();
 Type arrayType = typeof(Array);
 
 Console.WriteLine("Array is subclass of int[]? {0}", arrayType.IsSubclassOf(arrayOfIntsType));
 Console.WriteLine("int [] is subclass of Array? {0}", arrayOfIntsType.IsSubclassOf(arrayType));
 Console.WriteLine("IFoo is subclass of IBar? {0}", ifooType.IsSubclassOf(ibarType));
 Console.WriteLine("myclass is subclass of MyClass? {0}", mcType.IsSubclassOf(mcType));
 Console.WriteLine("myderivedclass is subclass of MyClass? {0}", mdcType.IsSubclassOf(mcType));
 Console.WriteLine("IBar is subclass of IFoo? {0}", ibarType.IsSubclassOf(ifooType)); 
  }
}
</code>
          <para>The output is </para>
          <c>
            <para>Array is subclass of int[]? False</para>
            <para>int [] is subclass of Array? True</para>
            <para>IFoo is subclass of IBar? False</para>
            <para>myclass is subclass of MyClass? False</para>
            <para>myderivedclass is subclass of MyClass? True</para>
            <para>IBar is subclass of IFoo? False</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Indicates whether the type attribute <see cref="F:System.Reflection.TypeAttributes.UnicodeClass" /> is selected for the current type.</para>
        </summary>
        <value>
          <see langword="true" /> if the type attribute <see cref="F:System.Reflection.TypeAttributes.UnicodeClass" />  is selected for the current type; otherwise, <see langword="false" />.</value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current <see cref="T:System.Type" /> represents a generic type, this property applies to the definition of the type. If the current <see cref="T:System.Type" /> represents a type parameter of a generic type or method, this property always returns <see langword="false" />.</para>
        </remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="ILASM" Value=".property bool IsValueType { public hidebysig specialname instance bool get_IsValueType() }" />
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value that indicates whether the current <see cref="T:System.Type" /> represents a value type.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the current <see cref="T:System.Type" /> represents a value
   type (structure); otherwise <see langword="false" />. </para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>This property returns true for enumerations, but not for
      the <see cref="T:System.Enum" /> type
      itself, which is a class. <block subset="none" type="note">For an example
      that demonstrates this behavior, see <see cref="P:System.Type.IsEnum" />
      .</block></para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns a <see cref="T:System.Type" /> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Type" /> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</para>
        </returns>
        <remarks>
          <para>This method provides a way to generate an array type with any possible element type, including generic types.</para>
        </remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">The number of dimensions for the array.</param>
        <summary>
          <para>Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</para>
        </returns>
        <remarks>
          <para>This method provides a way to generate an array with any possible element type, including generic types.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.IndexOutOfRangeException">
          <para>
            <paramref name="rank" /> is invalid (being less than 1, for example).</para>
        </exception>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a byref parameter.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Type" /> object that represents the current type when passed as a byref parameter.</para>
        </returns>
        <remarks>
          <para>This method provides a way to generate a byref type for any type. </para>
          <para>
            <block subset="none" type="note">Using ilasm syntax, if the current <see cref="T:System.Type" /> object represents <see langword="int32" />, this method returns a <see cref="T:System.Type" /> object representing <see langword="int32&amp;" />.</block>
          </para>
        </remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (Type[] typeArguments);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">To be added.</param>
        <summary>
          <para>Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</para>
          <para>The current type shall be a generic type definition.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type definition.</para>
        </returns>
        <remarks>
          <para>This  method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <see cref="T:System.Type" /> object that represents a particular constructed type. You can use this <see cref="T:System.Type" /> object to create runtime instances of the constructed type.</para>
          <para>The <see cref="T:System.Type" /> object returned by this method is the same as that obtained by calling the <see cref="M:System.Object.GetType" /> method of the resulting constructed type, or the <see cref="M:System.Object.GetType" /> method of any constructed type that was created from the same generic type using the same type arguments.</para>
          <para>
            <block subset="none" type="note">An array type whose element type is a generic type is not itself a generic type. Thus, you cannot call this method to bind an array type. To bind a type argument to this type, call <see cref="M:System.Type.GetElementType" /> to obtain the generic type, then this method to bind the type argument to the generic type, and, finally,  <see cref="M:System.Type.MakeArrayType" /> to create the array type. </block>
          </para>
          <para>For a list of the invariant conditions for terms used in generic reflection, see the <see cref="P:System.Type.IsGenericType" /> property description.</para>
        </remarks>
        <since version=".NET 2.0" />
        <exception cref="T:System.ArgumentException">
          <para>The number of elements in 
<paramref name="typeArguments" /> is not the same as the number of type parameters of the current generic type definition.</para>
          <para>-or-</para>
          <para>An element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type definition.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="typeArguments" /> is <see langword="null" />. </para>
          <para>-or-</para>
          <para>An element of <paramref name="typeArguments" /> is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <para>The current type does not represent the definition of a generic type. That is, <see cref="T:System.Type.IsGenericTypeDefinition" />  returns <see langword="false" />. </para>
        </exception>
        <example>
          <para>The following example uses <see cref="M:System.Type.GetType" /> and <see cref="M:System.Type.MakeGenericType" /> to create a constructed type from the generic <see cref="T:System.Collections.Generic.Dictionary" /> type. The constructed type represents a <see cref="T:System.Collections.Generic.Dictionary" /> of <see langword="Test" /> objects with string keys.   </para>
          <code lang="C#">using System;
using System.Reflection;
using System.Collections.Generic;

public class Test
{
	public static void Main()
	{
		Console.WriteLine("\n--- Create a constructed type from the generic  Dictionary type.");

		// Create a type object representing the generic Dictionary 
		// type.       
		Type generic = Type.GetType("System.Collections.Generic.Dictionary");

		DisplayTypeInfo(generic);

		// Create an array of types to substitute for the type
		// parameters of Dictionary. The key is of type string, and
		// the type to be contained in the Dictionary is Test.
		Type[] typeArgs = { typeof(string), typeof(Test) };
		Type constructed = generic.MakeGenericType(typeArgs);

		DisplayTypeInfo(constructed);

		// Compare the type objects obtained above to type objects
		// obtained using typeof() and GetGenericTypeDefinition().
		Console.WriteLine("\n--- Compare types obtained by different methods:");

		Type t = typeof(Dictionary&lt;string, Test&gt;);

		Console.WriteLine("\tAre the constructed types equal? {0}", t == constructed);
		Console.WriteLine("\tAre the generic types equal? {0}", t.GetGenericTypeDefinition() == generic);
	}

	private static void DisplayTypeInfo(Type t)
	{
		Console.WriteLine("\n{0}", t);
		Console.WriteLine("\tIs this a generic type definition? {0}", t.IsGenericTypeDefinition);
		Console.WriteLine("\tDoes it have generic type arguments? {0}", t.HasGenericArguments);

		Type[] typeArguments = t.GetGenericArguments();

		Console.WriteLine("\tList type arguments ({0}):", typeArguments.Length);
		foreach (Type tParam in typeArguments)
		{
			Console.WriteLine("\t\t{0}", tParam);
		}
	}
}

/* This example produces the following output:

--- Create a constructed type from the generic Dictionary type.

System.Collections.Generic.Dictionary[KeyType,ValueType]
        Is this a generic type definition? True
        Does it have generic type arguments? True
        List type arguments (2):
                K
                V

System.Collections.Generic.Dictionary[System.String, Test]
        Is this a generic type definition? False
        Does it have generic type arguments? True
        List type arguments (2):
                System.String
                Test

--- Compare types obtained by different methods:
        Are the constructed types equal? True
        Are the generic types equal? True
 */
</code>
        </example>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns a <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</para>
        </returns>
        <remarks>
          <para>This method provides a way to generate an unmanaged pointer type for types computed at runtime. </para>
          <para>
            <block subset="none" type="note">Using ilasm syntax, if the current <see cref="T:System.Type" /> object represents <see langword="int32" />, this method returns a <see cref="T:System.Type" /> object representing <see langword="int32*" />.</block>
          </para>
        </remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="ILASM" Value=".field public static initOnly object Missing" />
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberType>Field</MemberType>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Represents a missing value in the <see cref="T:System.Type" /> information.</para>
        </summary>
        <remarks>
          <para>This field is read-only.</para>
          <para>Use the <see langword="Missing" /> 
field for invocation through reflection to ensure that a call will be made
with the default value of a parameter as specified in the metadata. <block subset="none" type="note">If the <see langword="Missing" /> field is specified for a
parameter value and there is no default value for that parameter, a <see cref="T:System.ArgumentException" /> is
thrown.</block></para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <MemberValue>null</MemberValue>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="ILASM" Value=".property class System.Reflection.Module Module { public hidebysig virtual abstract specialname class System.Reflection.Module get_Module() }" />
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets the module in which the current <see cref="T:System.Type" /> is defined.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Reflection.Module" /> that reflects the module in which the current <see cref="T:System.Type" /> is defined.</para>
        </value>
        <remarks>
          <para>If the current instance represents a generic type, this property returns the module in which the type was defined.</para>
          <para>Similarly, if the current instance represents a generic parameter T, this property returns the assembly that contains the generic type that defines T.</para>
          <para>
            <block subset="none" type="behaviors">This property is
      read-only.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="ILASM" Value=".property string Namespace { public hidebysig virtual abstract specialname string get_Namespace() }" />
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the namespace of the <see cref="T:System.Type" />.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.String" /> containing the namespace of the current <see cref="T:System.Type" />.</para>
        </value>
        <remarks>
          <para>If the current instance represents a generic type, this property returns the namespace that contains the generic type definition. Similarly, if the current instance represents a generic parameter T, this property returns the namespace that contains the generic type that defines T.</para>
          <para>
            <block subset="none" type="note">A namespace is a 
      logical design-time naming convenience, used mainly to define scope in an
      application and organize classes and other types in a hierarchical structure.
      From the viewpoint of the system, there are no namespaces.</block>
          </para>
          <para>
            <block subset="none" type="behaviors">This property is 
      read-only.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (Type left, Type right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (Type left, Type right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="ILASM" Value=".property class System.Type ReflectedType { public hidebysig virtual specialname class System.Type get_ReflectedType() }" />
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the type that was used to obtain the current
      instance.</para>
        </summary>
        <value>
          <para>The <see langword="Type" /> object
   through which the current instance was obtained.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>If the current instance represents a generic type, or a type parameter of a generic type or method, this property returns the current instance.</para>
        </remarks>
        <example>
          <para>The following example demonstrates the <see cref="P:System.Type.ReflectedType" /> property. Although the method <paramref name="m" /> is
   declared in <see langword="MyClassA" />, its reflected type is obtained from
<see langword="MyClassB" /> .</para>
          <code lang="C#">using System;
using System.Reflection;
public abstract class ReflectedTypeTest {
    public abstract class MyClassA {
        public abstract int m();
    }
    public abstract class MyClassB : MyClassA {
    }
    public static void Main(string[] args) {
        Console.WriteLine("Reflected type of m is {0}",
            typeof(MyClassB).GetMethod("m").ReflectedType);
    }
}
</code>
          <para>The output is </para>
          <c>
            <para>Reflected type of m is ReflectedTypeTest+MyClassB</para>
          </c>
        </example>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">To be added.</param>
        <param name="throwIfNotFound">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">To be added.</param>
        <param name="rgszNames">To be added.</param>
        <param name="cNames">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="rgDispId">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="ppTInfo">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">To be added.</param>
        <param name="riid">To be added.</param>
        <param name="lcid">To be added.</param>
        <param name="wFlags">To be added.</param>
        <param name="pDispParams">To be added.</param>
        <param name="pVarResult">To be added.</param>
        <param name="pExcepInfo">To be added.</param>
        <param name="puArgErr">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual string ToString()" />
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Returns a <see cref="T:System.String" /> representation of the current <see cref="T:System.Type" />.
   </para>
        </summary>
        <returns>
          <para>Returns <see cref="P:System.Type.FullName" /> .</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">This method
      overrides <see cref="M:System.Object.ToString" />
      .</block>
          </para>
          <para>If the current instance represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly. If the current instance represents an unassigned type parameter of a generic type or method, this method returns the unqualified name of the type parameter.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="ILASM" Value=".property valuetype System.RuntimeTypeHandle TypeHandle { public hidebysig virtual abstract specialname valuetype System.RuntimeTypeHandle get_TypeHandle() }" />
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets the handle for the current <see cref="T:System.Type" />.</para>
        </summary>
        <value>
          <para>The <see cref="T:System.RuntimeTypeHandle" /> for the current <see cref="T:System.Type" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>The <see cref="T:System.RuntimeTypeHandle" /> encapsulates a pointer to an internal data structure that represents the type. This
   handle is unique during the process lifetime. The handle is valid only in
   the application domain in which it was obtained.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="ILASM" Value=".property class System.Reflection.ConstructorInfo TypeInitializer { public hidebysig specialname instance class System.Reflection.ConstructorInfo get_TypeInitializer() }" />
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets the initializer for the<see langword=" " />type
   represented by the current instance.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Reflection.ConstructorInfo" /> containing the name of the static
   constructor for the type represented by the current instance</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>
            <block subset="none" type="note">Type initializers are available through <see cref="M:System.Type.GetMember(System.String)" />,
<see cref="M:System.Type.GetMembers" />, and <see cref="M:System.Type.GetConstructors" />.</block>
          </para>
          <para>If the current instance represents an unassigned type parameter of a generic type or method, this property returns <see langword="null" />.</para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="ILASM" Value=".property class System.Type UnderlyingSystemType { public hidebysig virtual abstract specialname class System.Type get_UnderlyingSystemType() }" />
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Returns the system-supplied type
      that represents the current type.</para>
        </summary>
        <value>
          <para>The underlying system type for the <see cref="T:System.Type" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>
            <block subset="none" type="behaviors">As described 
      above.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>Reflection</ExcludedLibrary>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>
