<?xml version="1.0" encoding="utf-8"?>
<Type Name="GC" FullName="System.GC" FullNameSP="System_GC" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public sealed GC extends System.Object" />
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released. Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</para>
      <para>The garbage collector tracks and reclaims objects allocated in managed memory. Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references. Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory. Alternatively, an application can force garbage collection using the <see cref="M:System.GC.Collect(System.Int32)" /> method.</para>
      <para>Garbage collection consists of the following steps: </para>
      <list type="ordered">
        <item>
          <para>The garbage collector searches for managed objects that are referenced in managed code.</para>
        </item>
        <item>
          <para>The garbage collector tries to finalize objects that are not referenced.</para>
        </item>
        <item>
          <para>The garbage collector frees objects that are not referenced and reclaims their memory.</para>
        </item>
      </list>
      <para>During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code. However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so. The <see cref="M:System.GC.KeepAlive(System.Object)" /> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</para>
      <para>Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections. When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</para>
      <para>In most cases, finalizers are implemented by overriding the <see cref="M:System.Object.Finalize" /> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <see cref="M:System.Object.Finalize" />. In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object. However, the garbage collector is not required to call finalizers in all situations; for example, the <see cref="M:System.GC.SuppressFinalize(System.Object)" /> method explicitly prevents a finalizer from being called. Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</para>
      <para>In scenarios where resources must be released at a specific time, classes can implement the <see cref="T:System.IDisposable" /> interface, which contains the <see cref="M:System.IDisposable.Dispose" /> method that performs resource management and cleanup tasks. Classes that implement <see cref="M:System.IDisposable.Dispose" /> must specify, as part of their class contract, if and when class consumers call the method to clean up the object. The garbage collector does not, by default, call the <see cref="M:System.IDisposable.Dispose" /> method; however, implementations of the <see cref="M:System.IDisposable.Dispose" /> method can call methods in the <see cref="T:System.GC" /> class to customize the finalization behavior of the garbage collector.</para>
      <para>It is recommended, but not required, that garbage collectors support object aging using generations. A generation is a unit of measure of the relative age of objects in memory. The generation number, or age, of an object indicates the generation to which an object belongs. Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle. Objects in the most recent generation are in generation 0.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Controls the system garbage collector, a service that automatically reclaims unused memory.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <see cref="M:System.GC.AddMemoryPressure(System.Int64)" /> method informs the runtime of this additional pressure on system memory.</para>
          <para>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the Dispose or Finalize method. Call the <see cref="M:System.GC.AddMemoryPressure(System.Int64)" /> method after allocating the unmanaged memory, and call the <see cref="M:System.GC.RemoveMemoryPressure(System.Int64)" /> method after releasing it.</para>
          <para>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <see cref="M:System.GC.AddMemoryPressure(System.Int64)" /> and <see cref="M:System.GC.RemoveMemoryPressure(System.Int64)" /> methods to communicate these incremental changes to the runtime.</para>
          <block subset="none" type="note">
            <para>You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</para>
        </summary>
        <param name="bytesAllocated">
          <attribution license="cc4" from="Microsoft" modified="false" />The incremental amount of unmanaged memory that has been allocated. </param>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method cancels a garbage collection notification that was registered by using the <see cref="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" /> method. You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <see cref="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Cancels the registration of a garbage collection notification.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to try to reclaim all memory that is inaccessible. It performs a blocking garbage collection of all generations. </para>
          <para>All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected. Use this method to force the system to try to reclaim the maximum amount of available memory.</para>
          <para>Starting with the net_v451, you can compact the large object heap (LOH) by setting the <see cref="P:System.Runtime.GCSettings.LargeObjectHeapCompactionMode" /> property to <see cref="F:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce" /> before calling the <see cref="M:System.GC.Collect" /> method, as the following example illustrates. </para>
          <para>code reference: System.Runtime.GCSettings#1</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Forces an immediate garbage collection of all generations. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to try to reclaim memory that is inaccessible. However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</para>
          <para>If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation. If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</para>
          <para>Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum valid value of the <paramref name="generation" /> parameter.</para>
          <para>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters. To have the garbage collector reclaim objects based on a <see cref="T:System.GCCollectionMode" /> setting, use the <see cref="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" /> method overload.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Forces an immediate garbage collection from generation 0 through a specified generation.</para>
        </summary>
        <param name="generation">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of the oldest generation that garbage collection can be performed on. </param>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <paramref name="mode" /> parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects. Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</para>
          <para>To adjust the intrusiveness of garbage collection during critical periods in your application, set the <see cref="P:System.Runtime.GCSettings.LatencyMode" /> property.</para>
          <para>The garbage collector does not collect objects with a generation number higher than specified by the <paramref name="generation" /> parameter. Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum valid value of <paramref name="generation" />.</para>
          <para>To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters. </para>
          <para>To have the garbage collector reclaim objects up to a specified generation of objects, use the <see cref="M:System.GC.Collect(System.Int32)" /> method overload. When you specify the maximum generation, all objects are collected.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</para>
        </summary>
        <param name="generation">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of the oldest generation that garbage collection can be performed on. </param>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies the behavior for the garbage collection.</param>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The following table summarizes the interaction of the <paramref name="mode" /> and <paramref name="blocking" /> parameters:</para>
          <list type="table">
            <item>
              <term>
                <para>
                  <paramref name="mode" />
                </para>
              </term>
              <description>
                <para>
                  <paramref name="blocking" /> is true</para>
              </description>
              <description>
                <para>
                  <paramref name="blocking" /> is false</para>
              </description>
            </item>
            <item>
              <term>
                <para>
                  <see cref="F:System.GCCollectionMode.Forced" /> or <see cref="F:System.GCCollectionMode.Default" /></para>
              </term>
              <description>
                <para>A blocking collection is performed as soon as possible. If a background collection is in progress and <paramref name="generation" /> is 0 or 1, the <see cref="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" /> method immediately triggers a blocking collection and returns when the collection is finished. If a background collection is in progress and <paramref name="generation" /> is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</para>
              </description>
              <description>
                <para>A collection is performed as soon as possible. The <see cref="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" /> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed. If a background collection is already in progress, the method returns immediately.</para>
              </description>
            </item>
            <item>
              <term>
                <para>
                  <see cref="F:System.GCCollectionMode.Optimized" />
                </para>
              </term>
              <description>
                <para>A blocking collection may be performed, depending on the state of the garbage collector and the <paramref name="generation" /> parameter. The garbage collector tries to provide optimal performance.</para>
              </description>
              <description>
                <para>A collection may be performed, depending on the state of the garbage collector. The <see cref="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" /> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed. The garbage collector tries to provide optimal performance. If a background collection is already in progress, the method returns immediately.</para>
              </description>
            </item>
          </list>
          <para>If a call to the <see cref="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" /> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <see cref="P:System.Runtime.GCSettings.LargeObjectHeapCompactionMode" /> property to <see cref="F:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce" /> before calling the <see cref="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" /> method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</para>
        </summary>
        <param name="generation">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of the oldest generation that garbage collection can be performed on.</param>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          <attribution license="cc4" from="Microsoft" modified="false" />true to perform a blocking garbage collection; false to perform a background garbage collection where possible.</param>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you implement your own resource management, you might need to force garbage collection periodically by calling the <see cref="M:System.GC.Collect(System.Int32)" /> method. Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently. Save the value returned by <see cref="M:System.GC.CollectionCount(System.Int32)" /> immediately after calling <see cref="M:System.GC.Collect(System.Int32)" />. The next time you need to call <see cref="M:System.GC.Collect(System.Int32)" />, compare the current value returned by <see cref="M:System.GC.CollectionCount(System.Int32)" /> to the saved value. If the two values are equal, no collection has occurred in the interim and it is reasonable to call <see cref="M:System.GC.Collect(System.Int32)" /> again.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the number of times garbage collection has occurred for the specified generation of objects.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of times garbage collection has occurred for the specified generation since the process was started.</para>
        </returns>
        <param name="generation">
          <attribution license="cc4" from="Microsoft" modified="false" />The generation of objects for which the garbage collection count is to be determined. </param>
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to determine the age of an object, and then use that information with the <see cref="M:System.GC.Collect(System.Int32)" /> method to force the garbage collector to collect objects in the same generation. For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the current generation number of the specified object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The current generation number of <paramref name="obj" />.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that generation information is retrieved for. </param>
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the current generation number of the target of a specified weak reference.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The current generation number of the target of <paramref name="wo" />.</para>
        </returns>
        <param name="wo">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the <paramref name="forceFullCollection" /> parameter is true, this method waits a short interval before returning while the system collects garbage and finalizes objects. The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles. The garbage collector does not guarantee that all inaccessible memory is collected.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the number of bytes currently thought to be allocated. A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A number that is the best available approximation of the number of bytes currently allocated in managed memory.</para>
        </returns>
        <param name="forceFullCollection">
          <attribution license="cc4" from="Microsoft" modified="false" />true to indicate that this method can wait for garbage collection to occur before returning; otherwise, false.</param>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void KeepAlive(object obj)" />
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The purpose of the <see cref="M:System.GC.KeepAlive(System.Object)" /> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector. A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</para>
          <para>This method references the <paramref name="obj" /> parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called. Code this method at the end, not the beginning, of the range of instructions where <paramref name="obj" /> must be available.</para>
          <para>The <see cref="M:System.GC.KeepAlive(System.Object)" /> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</para>
        </summary>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to reference. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan. The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <see cref="P:System.GC.MaxGeneration" /> property.</para>
          <para>The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory. Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <see cref="P:System.GC.MaxGeneration" /> property value can grow over time.</para>
          <para>If object aging is implemented, the <see cref="P:System.GC.MaxGeneration" /> property returns the maximum generation number used by the system; otherwise, this property returns zero.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the maximum number of generations that the system currently supports.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can determine whether the runtime is about to induce a full garbage collection and circumvent that collection by inducing a collection yourself (using the <see cref="M:System.GC.Collect" /> method) when conditions are still favorable. For more information about what represents a full garbage collection, see <format type="text/html"><a href="e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Garbage Collection Notifications</a></format>.</para>
          <para>When you register for a garbage collection notification, you can determine whether the event that signals an approaching full garbage collection has been raised by checking the status of the garbage collection notification. This pattern resembles how the operating system monitors for low memory notifications. </para>
          <para>Use the following guidelines for specifying the <paramref name="maxGenerationThreshold" /> and <paramref name="largeObjectHeapThreshold" /> parameters:</para>
          <list type="bullet">
            <item>
              <para>The larger the threshold value, the further away in time the collection will likely occur and the sooner the notification will be raised.</para>
              <para>A larger threshold value provides more opportunities for the runtime to check for an approaching collection. This increases the likelihood that you will be notified. However, you should not set the threshold too high because that results in a longer wait before the runtime induces the next collection. </para>
              <para>When you induce a collection yourself upon notification using a high threshold value, more objects are reclaimed than would be reclaimed by the runtime's next collection.</para>
            </item>
            <item>
              <para>The smaller the threshold value, the greater the likelihood that a collection will occur sooner and the notification will be raised later.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</para>
        </summary>
        <param name="maxGenerationThreshold">
          <attribution license="cc4" from="Microsoft" modified="false" />A number between 1 and 99 that specifies when the notification should be raised based on the objects surviving in generation 2. </param>
        <param name="largeObjectHeapThreshold">
          <attribution license="cc4" from="Microsoft" modified="false" />A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap. </param>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <see cref="M:System.GC.AddMemoryPressure(System.Int64)" /> method informs the runtime of this additional pressure on system memory, and the <see cref="M:System.GC.RemoveMemoryPressure(System.Int64)" /> method informs the runtime that the additional pressure has been released.</para>
          <para>In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the Dispose or Finalize method. Call the <see cref="M:System.GC.AddMemoryPressure(System.Int64)" /> method after allocating the unmanaged memory, and call the <see cref="M:System.GC.RemoveMemoryPressure(System.Int64)" /> method after releasing it.</para>
          <para>In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <see cref="M:System.GC.AddMemoryPressure(System.Int64)" /> and <see cref="M:System.GC.RemoveMemoryPressure(System.Int64)" /> methods to communicate these incremental changes to the runtime.</para>
          <block subset="none" type="note">
            <para>You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</para>
        </summary>
        <param name="bytesAllocated">
          <attribution license="cc4" from="Microsoft" modified="false" />The amount of unmanaged memory that has been released. </param>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void ReRegisterForFinalize(object obj)" />
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> is a <see langword="null" /> reference.</exception>
        <exception cref="T:System.ExecutionEngineException">The caller of this method is not the same as the object passed to this method.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.GC.ReRegisterForFinalize(System.Object)" /> method adds the <paramref name="obj" /> parameter to the list of objects that request finalization before the garbage collector frees the object. The <paramref name="obj" /> parameter must be the caller of this method.</para>
          <para>Calling the <see cref="M:System.GC.ReRegisterForFinalize(System.Object)" /> method does not guarantee that the garbage collector will call an object's finalizer.</para>
          <para>By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <see cref="M:System.GC.SuppressFinalize(System.Object)" /> method.</para>
          <para>A finalizer can use this method to resurrect itself or an object that it references.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</para>
        </summary>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that a finalizer must be called for. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void SuppressFinalize(object obj)" />
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> is a <see langword="null" /> reference.</exception>
        <exception cref="T:System.InvalidOperationException">The caller of this method is not the same as the object passed to this method.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method sets a bit in the object header of <paramref name="obj" />, which the runtime checks when calling finalizers. A finalizer, which is represented by the <see cref="M:System.Object.Finalize" /> method, is used to release unmanaged resources before an object is garbage-collected. If <paramref name="obj" /> does not have a finalizer, the call to the <see cref="M:System.GC.SuppressFinalize(System.Object)" /> method has no effect. </para>
          <para>Objects that implement the <see cref="T:System.IDisposable" /> interface can call this method from the object's <see cref="M:System.IDisposable.Dispose" /> implementation to prevent the garbage collector from calling <see cref="M:System.Object.Finalize" /> on an object that does not require it. Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <see cref="M:System.IDisposable.Dispose" /> implementation. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Requests that the common language runtime not call the finalizer for the specified object. </para>
        </summary>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object whose finalizer must not be executed. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="T:System.GCNotificationStatus" /> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <see cref="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" /> method. You can also use the <see cref="M:System.GC.WaitForFullGCComplete" /> method to determine whether the full garbage collection has completed.</para>
          <para>When the enumeration returns <see cref="F:System.GCNotificationStatus.Succeeded" />, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <see cref="M:System.GC.Collect" /> method. Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</para>
          <para>This method waits indefinitely for a garbage collection notification to be obtained. If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <see cref="M:System.GC.WaitForFullGCApproach(System.Int32)" /> method overload. If you call this method without specifying a time-out, you can call the <see cref="M:System.GC.CancelFullGCNotification" /> method if you are waiting longer than preferred.</para>
          <para>You should follow this method with a call to the <see cref="Overload:System.GC.WaitForFullGCComplete" /> method to make sure that you have had a full garbage collection. Calling this method alone causes indeterminate results. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The status of the registered garbage collection notification.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="T:System.GCNotificationStatus" /> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <see cref="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" /> method. You can also use the <see cref="M:System.GC.WaitForFullGCComplete" /> method to determine whether the full garbage collection has completed.</para>
          <para>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <paramref name="millisecondsTimeout" />. If a garbage collection notification status is not obtained before <paramref name="millisecondsTimeout " />times out, this method returns <see cref="F:System.GCNotificationStatus.NotApplicable" />.</para>
          <para>When the enumeration returns <see cref="F:System.GCNotificationStatus.Succeeded" />, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <see cref="M:System.GC.Collect" /> method. Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</para>
          <para>You can call the <see cref="M:System.GC.CancelFullGCNotification" /> method when you cannot wait for the time-out period to elapse.</para>
          <para>You should follow this method with a call to the <see cref="Overload:System.GC.WaitForFullGCComplete" /> method to make sure that you have had a full garbage collection. Calling this method alone causes indeterminate results.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The status of the registered garbage collection notification.</para>
        </returns>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.</param>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="T:System.GCNotificationStatus" /> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <see cref="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" /> method. You can also use the <see cref="M:System.GC.WaitForFullGCApproach" /> method to determine whether a full garbage collection is imminent.</para>
          <para>When the enumeration returns <see cref="F:System.GCNotificationStatus.Succeeded" />, you can do tasks such as resuming work and obtaining a collection count with the <see cref="M:System.GC.CollectionCount(System.Int32)" /> property. </para>
          <para>This method waits indefinitely for a garbage collection notification to be obtained. If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <see cref="M:System.GC.WaitForFullGCApproach(System.Int32)" /> method overload. If you call this method without specifying a time-out, you can call the <see cref="M:System.GC.CancelFullGCNotification" /> method if you are waiting longer than preferred.</para>
          <para>This method call should be preceded with a call to the <see cref="Overload:System.GC.WaitForFullGCApproach" /> method to make sure that you have had a full garbage collection. Calling this method alone can produce indeterminate results.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The status of the registered garbage collection notification.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="T:System.GCNotificationStatus" /> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <see cref="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" /> method. You can also use the <see cref="M:System.GC.WaitForFullGCApproach" /> method to determine whether a full garbage collection is imminent.</para>
          <para>Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <paramref name="millisecondsTimeout" />. If a garbage collection notification status is not obtained before <paramref name="millisecondsTimeout " />times out, this method returns <see cref="F:System.GCNotificationStatus.NotApplicable" />.</para>
          <para>When the enumeration returns <see cref="F:System.GCNotificationStatus.Succeeded" />, you can do tasks such as resuming work and obtaining a collection count with the <see cref="M:System.GC.CollectionCount(System.Int32)" /> property. </para>
          <para>You can call the <see cref="M:System.GC.CancelFullGCNotification" /> method when you cannot wait for the time-out period to elapse.</para>
          <para>This method call should be preceded with a call to the <see cref="Overload:System.GC.WaitForFullGCApproach" /> method to make sure that you have had a full garbage collection. Calling this method alone can produce indeterminate results. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The status of the registered garbage collection notification.</para>
        </returns>
        <param name="millisecondsTimeout">
          <attribution license="cc4" from="Microsoft" modified="false" />The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.</param>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static void WaitForPendingFinalizers()" />
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements. If an object implements a finalizer and has not disabled finalization by calling <see cref="M:System.GC.SuppressFinalize(System.Object)" />, the object is placed in a list of objects that are marked as ready for finalization. The garbage collector calls the <see cref="M:System.Object.Finalize" /> methods for the objects in this list and removes the entries from the list. This method blocks until all finalizers have run to completion.</para>
          <para>The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate. However, this thread can be interrupted by another thread while the <see cref="M:System.GC.WaitForPendingFinalizers" /> method is in progress. For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>