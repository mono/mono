<?xml version="1.0" encoding="utf-8"?>
<Type Name="String" FullName="System.String" FullNameSP="System_String" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public sealed serializable String extends System.Object implements System.ICloneable, System.IComparable, System.Collections.IEnumerable" />
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>This type is safe for multithreaded operations. </ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <example>
      <para>Example 1</para>
      <para>The following example demonstrates formatting numeric
      data types and inserting literal curly brackets into strings.</para>
      <code lang="C#">using System;
class StringFormatTest {
    public static void Main() {
        decimal dec = 1.99999m;
        double doub = 1.0000000001;

        string somenums = String.Format("Some formatted numbers: dec={0,15:E} doub={1,20}", dec, doub);
        Console.WriteLine(somenums);

        string curlies = "Literal curly brackets: {{ and }} and {{0}}";
        Console.WriteLine(curlies);

        object nullObject = null;
        string embeddedNull = String.Format("A null argument looks like: {0}", nullObject);
        Console.WriteLine(embeddedNull);
    }
}
   </code>
      <para>The output is</para>
      <code>
Some formatted numbers: dec=  1.999990E+000 doub=        1.0000000001
Literal curly brackets: {{ and }} and {{0}}
A null argument looks like: 
 </code>
      <para>Example 2</para>
      <para>The following example demonstrates how formatting works if <see cref="T:System.IFormattable" /> is or is
   not implemented by an argument to the <see cref="M:System.String.Format(System.String,System.Object)" /> method. Note that the format specifier
   is ignored if the argument does not implement <see cref="T:System.IFormattable" />.</para>
      <code lang="C#">using System;
class StringFormatTest {
    public class DefaultFormatEleven {
        public override string ToString() {
            return "11 string";
        }
    }
    public class FormattableEleven:IFormattable {
        // The IFormattable ToString implementation.
        public string ToString(string format, IFormatProvider formatProvider) {
            Console.Write("[IFormattable called] ");
            return 11.ToString(format, formatProvider);
        }
        // Override Object.ToString to show that it is not called.
        public override string ToString() {
            return "Formatted 11 string";
        }
    }

    public static void Main() {
        DefaultFormatEleven def11 = new DefaultFormatEleven ();
         FormattableEleven for11 = new  FormattableEleven();
        string def11string = String.Format("{0}",def11);
        Console.WriteLine(def11string);
        // The format specifier x is ignored.
        def11string = String.Format("{0,15:x}", def11);
        Console.WriteLine(def11string);

        string form11string = String.Format("{0}",for11);
        Console.WriteLine(form11string );
        form11string = String.Format("{0,15:x}",for11);
        Console.WriteLine(form11string);
    }
}
</code>
      <para>The output is</para>
      <code>
11 string
      11 string
[IFormattable called] 11
[IFormattable called]               b
 </code>
      <para>Example 3</para>
      <para>The following example demonstrates searching for an empty string in a non-empty string.</para>
      <code lang="C#">using System;
class EmptyStringSearch {
	public static void Main() 	{
		Console.WriteLine("ABCDEF".IndexOf(""));
		Console.WriteLine("ABCDEF".IndexOf("", 2));
		Console.WriteLine("ABCDEF".IndexOf("", 3, 2));
		Console.WriteLine("ABCDEF".LastIndexOf(""));
		Console.WriteLine("ABCDEF".LastIndexOf("", 1));
		Console.WriteLine("ABCDEF".LastIndexOf("", 4, 2));
	}
}</code>
      <para>The output is</para>
      <code>0
2
3
5
1
4</code>
    </example>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>A string is a sequential collection of Unicode characters that is used to represent text. A <see cref="T:System.String" /> object is a sequential collection of <see cref="T:System.Char" /> objects that represent a string. The value of the <see cref="T:System.String" /> object is the content of the sequential collection, and that value is immutable (that is, it is read-only). For more information about the immutability of strings, see the <format type="text/html"><a href="#Immutability">Immutability and the StringBuilder class</a></format> section later in this topic. The maximum size of a <see cref="T:System.String" /> object in memory is 2 GB, or about 1 billion characters.</para>
      <para>In this section:</para>
      <para>
                    <format type="text/html"><a href="#Instantiation">Instantiating a String object</a></format>
                    <br />
                    <format type="text/html"><a href="#Characters">Char objects and Unicode characters</a></format>
                    <br />
                    <format type="text/html"><a href="#EmbeddedNulls">Strings and embedded null characters</a></format>
                    <br />
                    <format type="text/html"><a href="#Indexes">Strings and indexes</a></format>
                    <br />
                    <format type="text/html"><a href="#Nulls">Null strings and empty strings</a></format>
                    <br />
                    <format type="text/html"><a href="#Immutability">Immutability and the StringBuilder class</a></format>
                    <br />
                    <format type="text/html"><a href="#CultureSensitive">Ordinal vs. culture-sensitive operations</a></format>
                    <br />
                    <format type="text/html"><a href="#Normalization">Normalization</a></format>
                    <br />
                    <format type="text/html"><a href="#ByCategory">String operations by category</a></format>
                    <br />
                </para>
      <format type="text/html">
        <a href="#Instantiation" />
      </format>
      <format type="text/html">
        <h2>Instantiating a String object</h2>
      </format>
      <para>You can instantiate a <see cref="T:System.String" /> object in the following ways:</para>
      <list type="bullet">
        <item>
          <para>By assigning a string literal to a <see cref="T:System.String" /> variable. This is the most commonly used method for creating a string. The following example uses assignment to create several strings. Note that in C#, because the backslash (\) is an escape character, literal backslashes in a string must be escaped or the entire string must be @-quoted. </para>
          <para>code reference: System.String.Class.Instantiate#1</para>
        </item>
        <item>
          <para>By calling a <see cref="T:System.String" /> class constructor. The following example instantiates strings by calling several class constructors. Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters. Visual Basic does not support calls to these constructors. For detailed information about <see cref="T:System.String" /> constructors, see the <see cref="Overload:System.String.#ctor" /> constructor summary.</para>
          <para>code reference: System.String.Class.Instantiate#2</para>
        </item>
        <item>
          <para>By using the string concatenation operator (+ in C# and &amp; or + in Visual Basic) to create a single string from any combination of <see cref="T:System.String" /> instances and string literals. The following example illustrates the use of the string concatenation operator.</para>
          <para>code reference: System.String.Class.Instantiate#3</para>
        </item>
        <item>
          <para>By retrieving a property or calling a method that returns a string. The following example uses the methods of the <see cref="T:System.String" /> class to extract a substring from a larger string.</para>
          <para>code reference: System.String.Class.Instantiate#4</para>
        </item>
        <item>
          <para>By calling a formatting method to convert a value or object to its string representation. The following example uses the <format type="text/html"><a href="87b7d528-73f6-43c6-b71a-f23043039a49">composite formatting</a></format> feature to embed the string representation of two objects into a string.</para>
          <para>code reference: System.String.Class.Instantiate#5</para>
        </item>
      </list>
      <format type="text/html">
        <a href="#Characters" />
      </format>
      <format type="text/html">
        <h2>Char objects and Unicode characters</h2>
      </format>
      <para>Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character. Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <see cref="T:System.Char" /> object. </para>
      <para>A single <see cref="T:System.Char" /> object usually represents a single code point; that is, the numeric value of the <see cref="T:System.Char" /> equals the code point. For example, the code point for the character "a" is U+0061. However, a code point might require more than one encoded element (more than one <see cref="T:System.Char" /> object). The Unicode standard defines three types of characters that correspond to multiple <see cref="T:System.Char" /> objects: graphemes, Unicode supplementary code points, and characters in the supplementary planes.</para>
      <list type="bullet">
        <item>
          <para>A grapheme is represented by a base character followed by one or more combining characters. For example, the character ä is represented by a <see cref="T:System.Char" /> object whose code point is U+0061 followed by a <see cref="T:System.Char" /> object whose code point is U+0308. This character can also be defined by a single <see cref="T:System.Char" /> object that has a code point of U+00E4. As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not. However, if the two strings are normalized, an ordinal comparison also indicates that they are equal. (For more information on normalizing strings, see the <format type="text/html"><a href="#Normalization">Normalization</a></format> section.)</para>
          <para>code reference: System.String.Class#2</para>
        </item>
        <item>
          <para>A Unicode supplementary code point (a surrogate pair) is represented by a <see cref="T:System.Char" /> object whose code point is a high surrogate followed by a <see cref="T:System.Char" /> object whose code point is a low surrogate. The code units of high surrogates range from U+D800 to U+DBFF. The code units of low surrogates range from U+DC00 to U+DFFF. Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes. The following example creates a surrogate character and passes it to the <see cref="M:System.Char.IsSurrogatePair(System.Char,System.Char)" /> method to determine whether it is a surrogate pair.</para>
          <para>code reference: System.String.Class#3</para>
        </item>
      </list>
      <format type="text/html">
        <a href="#EmbeddedNulls" />
      </format>
      <format type="text/html">
        <h2>Strings and embedded null characters</h2>
      </format>
      <para>In the .NET Framework, a <see cref="T:System.String" /> object can include embedded null characters, which count as a part of the string's length. However, in some languages such as C and C++, a null character indicates the end of a string; it is not considered a part of the string and is not counted as part of the string's length. This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <see cref="T:System.String" /> objects:</para>
      <list type="bullet">
        <item>
          <para>The value returned by the strlen or wcslen functions does not necessarily equal <see cref="P:System.String.Length" />.</para>
        </item>
        <item>
          <para>The string created by the strcpy_s or wcscpy_s functions is not necessarily identical to the string created by the <see cref="M:System.String.Copy(System.String)" /> method.</para>
        </item>
      </list>
      <para>You should ensure that native C and C++ code that instantiates <see cref="T:System.String" /> objects, and code that is passed <see cref="T:System.String" /> objects through platform invoke, do not assume that an embedded null character marks the end of the string.</para>
      <para>Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched. Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture. They are considered only for ordinal or case-insensitive ordinal comparisons. On the other hand, embedded null characters are always considered when searching a string with methods such as <see cref="M:System.String.Contains(System.String)" />, <see cref="M:System.String.StartsWith(System.String)" />, and <see cref="M:System.String.IndexOf(System.String)" />.</para>
      <format type="text/html">
        <a href="#Indexes" />
      </format>
      <format type="text/html">
        <h2>Strings and indexes</h2>
      </format>
      <para>An index is the position of a <see cref="T:System.Char" /> object (not a Unicode character) in a <see cref="T:System.String" />. An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero. A number of search methods, such as <see cref="M:System.String.IndexOf(System.Char)" /> and <see cref="M:System.String.LastIndexOf(System.Char)" />, return the index of a character or substring in the string instance.</para>
      <para>The <see cref="P:System.String.Chars(System.Int32)" /> property lets you access individual <see cref="T:System.Char" /> objects by their index position in the string. Because the <see cref="P:System.String.Chars(System.Int32)" /> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <see cref="T:System.Char" /> objects in a string by using code such as the following. This code looks for white space or punctuation characters in a string to determine how many words the string contains.</para>
      <para>code reference: System.String.Class#4</para>
      <para>Because the <see cref="T:System.String" /> class implements the <see cref="T:System.Collections.IEnumerable" /> interface, you can also iterate through the <see cref="T:System.Char" /> objects in a string by using a foreach construct, as the following example shows.</para>
      <para>code reference: System.String.Class#5</para>
      <para>Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <see cref="T:System.Char" /> object. In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs. To work with Unicode characters instead of <see cref="T:System.Char" /> objects, use the <see cref="T:System.Globalization.StringInfo" /> and <see cref="T:System.Globalization.TextElementEnumerator" /> classes. The following example illustrates the difference between code that works with <see cref="T:System.Char" /> objects and code that works with Unicode characters. It compares the number of characters or text elements in each word of a sentence. The string includes two sequences of a base character followed by a combining character. </para>
      <para>code reference: System.String.Class#6</para>
      <para>This example works with text elements by using the <see cref="M:System.Globalization.StringInfo.GetTextElementEnumerator(System.String)" /> method and the <see cref="T:System.Globalization.TextElementEnumerator" />  class to enumerate all the text elements in a string. You can also retrieve an array that contains the starting index of each text element by calling the <see cref="M:System.Globalization.StringInfo.ParseCombiningCharacters(System.String)" /> method. </para>
      <para>For more information about working with units of text rather than individual <see cref="T:System.Char" /> values, see the <see cref="T:System.Globalization.StringInfo" /> class. </para>
      <format type="text/html">
        <a href="#Nulls" />
      </format>
      <format type="text/html">
        <h2>Null strings and empty strings</h2>
      </format>
      <para>A string that has been declared but has not been assigned a value is null. Attempting to call methods on that string throws a <see cref="T:System.NullReferenceException" />. A null string is different from an empty string, which is a string whose value is "" or <see cref="F:System.String.Empty" />. In some cases, passing either a null string or an empty string as an argument in a method call throws an exception. For example, passing a null string to the <see cref="M:System.Int32.Parse(System.String)" /> method throws an <see cref="T:System.ArgumentNullException" />, and passing an empty string throws a <see cref="T:System.FormatException" />. In other cases, a method argument can be either a null string or an empty string. For example, if you are providing an <see cref="T:System.IFormattable" /> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</para>
      <para>The <see cref="T:System.String" /> class includes the following two convenience methods that enable you to test whether a string is null or empty: </para>
      <list type="bullet">
        <item>
          <para>
                                    <see cref="M:System.String.IsNullOrEmpty(System.String)" />, which indicates whether a string is either null or is equal to  <see cref="F:System.String.Empty" />. This method eliminates the need to use code such as the following:</para>
          <para>code reference: System.String.Class.Null#1</para>
        </item>
        <item>
          <para>
                                        <see cref="M:System.String.IsNullOrWhiteSpace(System.String)" />, which indicates whether a string is null, equals <see cref="F:System.String.Empty" />, or consists exclusively of white-space characters. This method eliminates the need to use code such as the following:</para>
          <para>code reference: System.String.Class.Null#2</para>
        </item>
      </list>
      <para>The following example uses the <see cref="M:System.String.IsNullOrEmpty(System.String)" /> method in the <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> implementation of a custom Temperature class. The method supports the "G", "C", "F", and "K" format strings. If an empty format string or a format string whose value is null is passed to the method, its value is changed to the "G" format string.</para>
      <para>code reference: System.String.Class.Null#3</para>
      <format type="text/html">
        <a href="#Immutability" />
      </format>
      <format type="text/html">
        <h2>Immutability and the StringBuilder class</h2>
      </format>
      <para>A <see cref="T:System.String" /> object is called immutable (read-only), because its value cannot be modified after it has been created. Methods that appear to modify a <see cref="T:System.String" /> object actually return a new <see cref="T:System.String" /> object that contains the modification. </para>
      <para>Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty. For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F. Although the code appears to use string concatenation to append a new character to the existing string named str, it actually creates a new <see cref="T:System.String" /> object for each concatenation operation. </para>
      <para>code reference: System.String.Class#15</para>
      <para>You can use the <see cref="T:System.Text.StringBuilder" /> class instead of the <see cref="T:System.String" /> class for operations that make multiple changes to the value of a string. Unlike instances of the <see cref="T:System.String" /> class, <see cref="T:System.Text.StringBuilder" /> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string. When you have finished modifying the value of a <see cref="T:System.Text.StringBuilder" /> object, you can call its <see cref="M:System.Text.StringBuilder.ToString" /> method to convert it to a string. The following example replaces the <see cref="T:System.String" /> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <see cref="T:System.Text.StringBuilder" /> object.</para>
      <para>code reference: System.String.Class#16</para>
      <format type="text/html">
        <a href="#CultureSensitive" />
      </format>
      <format type="text/html">
        <h2>Ordinal vs. culture-sensitive operations</h2>
      </format>
      <para>Members of the <see cref="T:System.String" /> class perform either ordinal or culture-sensitive (linguistic) operations on a <see cref="T:System.String" /> object. An ordinal operation acts on the numeric value of each <see cref="T:System.Char" /> object. A culture-sensitive operation acts on the value of the <see cref="T:System.String" /> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account. Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture. The two kinds of operations can produce very different results when they are performed on the same string.</para>
      <block subset="none" type="note">
        <para>If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison. This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</para>
      </block>
      <block subset="none" type="note">
        <para>Most methods that perform string operations include an overload that has a parameter of type <see cref="T:System.StringComparison" />, which enables you to specify whether the method performs an ordinal or culture-sensitive operation. In general, you should call this overload to make the intent of your method call clear. For best practices and guidance for using ordinal and culture-sensitive operations on strings, see <format type="text/html"><a href="b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Best Practices for Using Strings in the .NET Framework</a></format>.</para>
      </block>
      <para>Operations for <format type="text/html"><a href="#casing">casing</a></format>, <format type="text/html"><a href="#parsing">parsing and formatting</a></format>, <format type="text/html"><a href="#comparison">comparison and sorting</a></format>, and <format type="text/html"><a href="#equality">testing for equality</a></format> can be either ordinal or culture-sensitive. The following sections discuss each category of operation.</para>
      <format type="text/html">
        <a href="#casing" />
      </format>
      <format type="text/html">
        <h2>Casing</h2>
      </format>
      <para>Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase. Often, a casing operation is performed before a string comparison. For example, a string might be converted to uppercase so that it can be compared with another uppercase string. You can convert the characters in a string to lowercase by calling the <see cref="M:System.String.ToLower" /> or <see cref="M:System.String.ToLowerInvariant" /> method, and you can convert them to uppercase by calling the <see cref="M:System.String.ToUpper" /> or <see cref="M:System.String.ToUpperInvariant" /> method. In addition, you can use the <see cref="M:System.Globalization.TextInfo.ToTitleCase(System.String)" /> method to convert a string to title case.</para>
      <para>Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture. Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture. The actual differences in casing are of three kinds: </para>
      <list type="bullet">
        <item>
          <para>Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131). In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE. In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents. </para>
          <para>The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison. (The casing conventions of the invariant culture should have been used.) </para>
          <para>code reference: System.String.Class#17</para>
        </item>
        <item>
          <para>Differences in case mappings between the invariant culture and all other cultures. In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character. For all other cultures, it returns a different character. Some of the affected characters are listed in the following table. </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Character</para>
                </term>
                <description>
                  <para>If changed to</para>
                </description>
                <description>
                  <para>Returns</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>MICRON SIGN (U+00B5)</para>
              </term>
              <description>
                <para>Uppercase</para>
              </description>
              <description>
                <para>GREEK CAPITAL LETTER MU (U+-39C)</para>
              </description>
            </item>
            <item>
              <term>
                <para>LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</para>
              </term>
              <description>
                <para>Lowercase</para>
              </description>
              <description>
                <para>LATIN SMALL LETTER I (U+0069)</para>
              </description>
            </item>
            <item>
              <term>
                <para>LATIN SMALL LETTER DOTLESS I (U+0131)</para>
              </term>
              <description>
                <para>Uppercase</para>
              </description>
              <description>
                <para>LATIN CAPITAL LETTER I (U+0049)</para>
              </description>
            </item>
            <item>
              <term>
                <para>LATIN SMALL LETTER LONG S (U+017F)</para>
              </term>
              <description>
                <para>Uppercase</para>
              </description>
              <description>
                <para>LATIN CAPITAL LETTER S (U+0053)</para>
              </description>
            </item>
            <item>
              <term>
                <para>LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</para>
              </term>
              <description>
                <para>Lowercase</para>
              </description>
              <description>
                <para>LATIN SMALL LETTER DZ WITH CARON (U+01C6)</para>
              </description>
            </item>
            <item>
              <term>
                <para>COMBINING GREEK YPOGEGRAMMENI (U+0345)</para>
              </term>
              <description>
                <para>Uppercase</para>
              </description>
              <description>
                <para>GREEK CAPITAL LETTER IOTA (U+0399)</para>
              </description>
            </item>
          </list>
        </item>
        <item>
          <para>Differences in case mappings of two-letter mixed-case pairs in the ASCII character range. In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair. This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph: </para>
          <list type="bullet">
            <item>
              <para>"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture. </para>
            </item>
            <item>
              <para>"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures. </para>
            </item>
            <item>
              <para>"aA" in the da-DK (Danish (Denmark)) culture. </para>
            </item>
            <item>
              <para>"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture. </para>
            </item>
            <item>
              <para>"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture. </para>
            </item>
            <item>
              <para>"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture. </para>
            </item>
          </list>
          <para>However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers. </para>
        </item>
      </list>
      <para>The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</para>
      <para>code reference: System.String.Class#7</para>
      <format type="text/html">
        <a href="#parsing" />
      </format>
      <format type="text/html">
        <h2>Parsing and formatting</h2>
      </format>
      <para>Formatting and parsing are inverse operations. Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time. Both formatting and parsing rules are dependent on cultural conventions. The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string. Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</para>
      <para>code reference: System.String.Class#8</para>
      <para>Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation. </para>
      <para>code reference: System.String.Class#9</para>
      <format type="text/html">
        <a href="#comparison" />
      </format>
      <format type="text/html">
        <h2>String comparison and sorting</h2>
      </format>
      <para>Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other. For example, the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method compares two strings based on the <see cref="T:System.StringComparison" /> parameter. If the parameter value is <see cref="F:System.StringComparison.CurrentCulture" />, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <see cref="F:System.StringComparison.Ordinal" />, the method performs an ordinal comparison. Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</para>
      <para>code reference: System.String.Class#10</para>
      <para>The .NET Framework supports word, string, and ordinal sort rules: </para>
      <list type="bullet">
        <item>
          <para>A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them. For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list. For a list of the <see cref="T:System.String" /> methods that compare two strings using word sort rules, see the <format type="text/html"><a href="#ByCategory">String operations by category</a></format> section. </para>
        </item>
        <item>
          <para>A string sort also performs a culture-sensitive comparison. It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters. Two strings can be compared using string sort rules by calling the <see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.String)" /> method overloads that have an <paramref name="options" /> parameter that is supplied a value of <see cref="F:System.Globalization.CompareOptions.StringSort" />. Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.</para>
        </item>
        <item>
          <para>An ordinal sort compares strings based on the numeric value of each <see cref="T:System.Char" /> object in the string. An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points. However, if case is not important, you can specify an ordinal comparison that ignores case. This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result. For a list of the <see cref="T:System.String" /> methods that compare two strings using ordinal sort rules, see the <format type="text/html"><a href="#ByCategory">String operations by category</a></format> section.</para>
        </item>
      </list>
      <para>A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <see cref="T:System.Globalization.CultureInfo" /> object, including the invariant culture that is specified by the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" /> property. The implicit culture is the current culture, which is specified by the <see cref="P:System.Threading.Thread.CurrentCulture" /> and <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> properties. There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <see cref="M:System.Char.IsLetter(System.Char)" /> property returns true) across cultures. You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <see cref="T:System.Globalization.CultureInfo" /> object to a string comparison method such as <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />. You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <see cref="F:System.StringComparison.CurrentCulture" />, <see cref="F:System.StringComparison.CurrentCultureIgnoreCase" />, or any member of the <see cref="T:System.Globalization.CompareOptions" /> enumeration other than <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> to an appropriate overload of the <see cref="M:System.String.Compare(System.String,System.String)" /> method. A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not. An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</para>
      <para>Use the following general guidelines to choose an appropriate sorting or string comparison method: </para>
      <list type="bullet">
        <item>
          <para>If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture. If the user's culture changes, the order of sorted strings will also change accordingly. For example, a thesaurus application should always sort words based on the user's culture. </para>
        </item>
        <item>
          <para>If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <see cref="T:System.Globalization.CultureInfo" /> object that represents that culture to a comparison method. For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language. </para>
        </item>
        <item>
          <para>If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison. For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</para>
        </item>
        <item>
          <para>For a comparison that involves a security decision (such as whether a user name is valid), you should always perform an ordinal test for equality by calling an overload of the <see cref="M:System.String.Equals(System.String)" /> method. </para>
        </item>
      </list>
      <block subset="none" type="note">
        <para>The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework. In the net_v45 running on the win8 operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard. On other operating systems, it conforms to the Unicode 5.0 standard.</para>
      </block>
      <para>For more information about word, string, and ordinal sort rules, see the <see cref="T:System.Globalization.CompareOptions" /> topic. For additional recommendations on when to use each rule, see <format type="text/html"><a href="b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Best Practices for Using Strings in the .NET Framework</a></format>. </para>
      <para>Ordinarily, you do not call string comparison methods such as <see cref="M:System.String.Compare(System.String,System.String)" /> directly to determine the sort order of strings. Instead, comparison methods are called by sorting methods such as <see cref="M:System.Array.Sort(System.Array)" /> or <see cref="M:System.Collections.Generic.List`1.Sort" />. The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method. Note that each type of sort produces a unique ordering of strings in its array.</para>
      <para>code reference: System.String.Class#12</para>
      <block subset="none" type="note">
        <para>If your primary purpose in comparing strings is to determine whether they are equal, you should call the <see cref="M:System.String.Equals(System.Object)" /> method. Typically, you should use <see cref="M:System.String.Equals(System.Object)" /> to perform an ordinal comparison. The <see cref="M:System.String.Compare(System.String,System.String)" /> method is intended primarily to sort strings.</para>
      </block>
      <para>String search methods, such as <see cref="M:System.String.StartsWith(System.String)" /> and <see cref="M:System.String.IndexOf(System.Char)" />, also can perform culture-sensitive or ordinal string comparisons. The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <see cref="M:System.String.IndexOf(System.Char)" /> method. A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ". Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <see cref="F:System.String.Empty" /> and finds a match at the beginning of the string. An ordinal search, on the other hand, does not find a match in either case.</para>
      <para>code reference: System.String.Class#13</para>
      <format type="text/html">
        <a href="#equality" />
      </format>
      <format type="text/html">
        <h2>Testing for equality</h2>
      </format>
      <para>Use the <see cref="M:System.String.Compare(System.String,System.String)" /> method to determine the relationship of two strings in the sort order. Typically, this is a culture-sensitive operation. In contrast, call the <see cref="M:System.String.Equals(System.String)" /> method to test for equality. Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</para>
      <block subset="none" type="note">
        <para>It is possible to test for equality by calling the <see cref="M:System.String.Compare(System.String,System.String)" /> method and determining whether the return value is zero. However, this practice is not recommended. To determine whether two strings are equal, you should call one of the overloads of the <see cref="M:System.String.Equals(System.String)" /> method. The preferred overload to call is either the instance <see cref="M:System.String.Equals(System.String,System.StringComparison)" /> method or the static <see cref="M:System.String.Equals(System.String,System.String,System.StringComparison)" /> method, because both methods include a <see cref="T:System.StringComparison" /> parameter that explicitly specifies the type of comparison.</para>
      </block>
      <para>The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead. In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://". However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I". As a result, file system access is inadvertently permitted. On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</para>
      <para>code reference: System.String.Class#11</para>
      <format type="text/html">
        <a href="#Normalization" />
      </format>
      <format type="text/html">
        <h2>Normalization</h2>
      </format>
      <para>Some Unicode characters have multiple representations. For example, any of the following code points can represent the letter "ắ": </para>
      <list type="bullet">
        <item>
          <para>U+1EAF</para>
        </item>
        <item>
          <para>U+0103 U+0301</para>
        </item>
        <item>
          <para>U+0061 U+0306 U+0301</para>
        </item>
      </list>
      <para> Multiple representations for a single character complicate searching, sorting, matching, and other string operations. </para>
      <para>The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations. Normalization can use several algorithms, called normalization forms, that follow different rules. The .NET Framework supports Unicode normalization forms C, D, KC, and KD. When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison. </para>
      <para>An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <see cref="T:System.Char" /> objects in each string. The <see cref="T:System.String" /> class includes a number of methods that can perform an ordinal comparison, including the following: </para>
      <list type="bullet">
        <item>
          <para>Any overload of the <see cref="M:System.String.Compare(System.String,System.String)" />, <see cref="M:System.String.Equals(System.Object)" />, <see cref="M:System.String.StartsWith(System.String)" />,  <see cref="M:System.String.EndsWith(System.String)" />, <see cref="M:System.String.IndexOf(System.String)" />, and <see cref="M:System.String.LastIndexOf(System.String)" /> methods that includes a <see cref="T:System.StringComparison" /> parameter. The method performs an ordinal comparison if you supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for this parameter. </para>
        </item>
        <item>
          <para>The overloads of the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method. </para>
        </item>
        <item>
          <para>Methods that use ordinal comparison by default, such as <see cref="M:System.String.Contains(System.String)" />, <see cref="M:System.String.Replace(System.String,System.String)" />, and <see cref="M:System.String.Split(System.Char[])" />. </para>
        </item>
        <item>
          <para>Methods that search for a <see cref="T:System.Char" /> value or for the elements in a <see cref="T:System.Char" /> array in a string instance. Such methods include <see cref="M:System.String.IndexOf(System.Char)" /> and <see cref="M:System.String.Split(System.Char[])" />.  </para>
        </item>
      </list>
      <para>You can determine whether a string is normalized to normalization form C by calling the <see cref="M:System.String.IsNormalized" /> method, or you can call the <see cref="M:System.String.IsNormalized(System.Text.NormalizationForm)" /> method to determine whether a string is normalized to a specified normalization form. You can also call the <see cref="M:System.String.Normalize" /> method to convert a string to normalization form C, or you can call the <see cref="M:System.String.Normalize(System.Text.NormalizationForm)" /> method to convert a string to a specified normalization form. For step-by-step information about normalizing and comparing strings, see the <see cref="M:System.String.Normalize" /> and <see cref="M:System.String.Normalize(System.Text.NormalizationForm)" /> methods. </para>
      <para>The following simple example illustrates string normalization. It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings. It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form. In each case, the second test for equality shows that the strings are equal.</para>
      <para>code reference: System.String.Class#14</para>
      <para>For more information about normalization and normalization forms, see <see cref="T:System.Text.NormalizationForm" />, as well as <see cref="http://unicode.org/reports/tr15/">Unicode Standard Annex #15: Unicode Normalization Forms</see> and the <see cref="http://www.unicode.org/faq/normalization.html">Normalization FAQ</see> on the unicode.org website. </para>
      <format type="text/html">
        <a href="#ByCategory" />
      </format>
      <format type="text/html">
        <h2>String operations by category</h2>
      </format>
      <para>The <see cref="T:System.String" /> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</para>
      <format type="text/html">
        <h2>Comparing strings</h2>
      </format>
      <para>You can compare strings to determine their relative position in the sort order by using the following <see cref="T:System.String" /> methods:</para>
      <list type="bullet">
        <item>
          <para>
                                            <see cref="M:System.String.Compare(System.String,System.String)" /> returns an integer that indicates the relationship of one string to a second string in the sort order.</para>
        </item>
        <item>
          <para>
                                                <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</para>
        </item>
        <item>
          <para>
                                                    <see cref="M:System.String.CompareTo(System.String)" /> returns an integer that indicates the relationship of the current string instance to a second string in the sort order. The <see cref="M:System.String.CompareTo(System.String)" /> method provides the <see cref="T:System.IComparable" /> and <see cref="T:System.IComparable`1" /> implementations for the <see cref="T:System.String" /> class. </para>
        </item>
      </list>
      <format type="text/html">
        <h2>Testing strings for equality</h2>
      </format>
      <para>You call the <see cref="M:System.String.Equals(System.String)" /> method to determine whether two strings are equal. The instance <see cref="M:System.String.Equals(System.String,System.String,System.StringComparison)" /> and the static <see cref="M:System.String.Equals(System.String,System.StringComparison)" /> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored. Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</para>
      <format type="text/html">
        <h2>Finding characters in a string</h2>
      </format>
      <para>The <see cref="T:System.String" /> class includes two kinds of search methods: </para>
      <list type="bullet">
        <item>
          <para>Methods that return a <see cref="T:System.Boolean" /> value to indicate whether a particular substring is present in a string instance. These include the <see cref="M:System.String.Contains(System.String)" />, <see cref="M:System.String.EndsWith(System.String)" />, and <see cref="M:System.String.StartsWith(System.String)" /> methods.</para>
        </item>
        <item>
          <para>Methods that indicate the starting position of a substring in a string instance. These include the <see cref="M:System.String.IndexOf(System.String)" />, <see cref="M:System.String.IndexOfAny(System.Char[])" />, <see cref="M:System.String.LastIndexOf(System.String)" />, and <see cref="M:System.String.LastIndexOfAny(System.Char[])" /> methods.</para>
        </item>
      </list>
      <block subset="none" type="note">
        <para>If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions. For more information, see <format type="text/html"><a href="521b3f6d-f869-42e1-93e5-158c54a6895d">.NET Framework Regular Expressions</a></format>.</para>
      </block>
      <format type="text/html">
        <h2>Modifying a string</h2>
      </format>
      <para>The <see cref="T:System.String" /> class includes the following methods that appear to modify the value of a string:</para>
      <list type="bullet">
        <item>
          <para>
                                                        <see cref="M:System.String.Insert(System.Int32,System.String)" /> inserts a string into the current <see cref="T:System.String" /> instance.</para>
        </item>
        <item>
          <para>
                                                            <see cref="M:System.String.PadLeft(System.Int32)" /> inserts one or more occurrences of a specified character at the beginning of a string.</para>
        </item>
        <item>
          <para>
                                                                <see cref="M:System.String.PadRight(System.Int32)" /> inserts one or more occurrences of a specified character at the beginning of a string.</para>
        </item>
        <item>
          <para>
                                                                    <see cref="M:System.String.Remove(System.Int32)" /> deletes a substring from the current <see cref="T:System.String" /> instance.</para>
        </item>
        <item>
          <para>
                                                                        <see cref="M:System.String.Replace(System.Char,System.Char)" /> replaces a substring with another substring in the current <see cref="T:System.String" /> instance.</para>
        </item>
        <item>
          <para>
                                                                            <see cref="M:System.String.ToLower" /> and <see cref="M:System.String.ToLowerInvariant" /> convert all the characters in a string to lowercase.</para>
        </item>
        <item>
          <para>
                                                                                <see cref="M:System.String.ToUpper" /> and <see cref="M:System.String.ToUpperInvariant" /> convert all the characters in a string to uppercase.</para>
        </item>
        <item>
          <para>
                                                                                    <see cref="M:System.String.Trim" /> removes all occurrences of a character from the beginning and end of a string.</para>
        </item>
        <item>
          <para>
                                                                                        <see cref="M:System.String.TrimEnd(System.Char[])" /> removes all occurrences of a character from the end of a string.</para>
        </item>
        <item>
          <para>
                                                                                            <see cref="M:System.String.TrimStart(System.Char[])" /> removes all occurrences of a character from the beginning of a string.</para>
        </item>
      </list>
      <block subset="none" type="note">
        <para>All string modification methods return a new <see cref="T:System.String" /> object. They do not modify the value of the current instance.</para>
      </block>
      <format type="text/html">
        <h2>Extracting substrings from a string</h2>
      </format>
      <para>The <see cref="M:System.String.Split(System.Char[])" /> method separates a single string into multiple strings. Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</para>
      <format type="text/html">
        <h2>Combining strings</h2>
      </format>
      <para>The following <see cref="T:System.String" /> methods can be used for string concatenation:</para>
      <list type="bullet">
        <item>
          <para>
                                                                                                <see cref="M:System.String.Concat(System.String[])" /> combines one or more substrings into a single string.</para>
        </item>
        <item>
          <para>
                                                                                                    <see cref="M:System.String.Join(System.String,System.String[])" /> concatenates one or more substrings into a single element and adds a separator between each substring.</para>
        </item>
      </list>
      <format type="text/html">
        <h2>Formatting values</h2>
      </format>
      <para>The <see cref="Overload:System.String.Format" /> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value. The <see cref="Overload:System.String.Format" /> method is often used to do the following: </para>
      <list type="bullet">
        <item>
          <para>To embed the string representation of a numeric value in a string.</para>
        </item>
        <item>
          <para>To embed the string representation of a date and time value in a string.</para>
        </item>
        <item>
          <para>To embed the string representation of an enumeration value in a string.</para>
        </item>
        <item>
          <para>To embed the string representation of some object that supports the <see cref="T:System.IFormattable" /> interface in a string.</para>
        </item>
        <item>
          <para>To right-justify or left-justify a substring in a field within a larger string.</para>
        </item>
      </list>
      <para>For detailed information about formatting operations and examples, see the <see cref="Overload:System.String.Format" /> overload summary.</para>
      <format type="text/html">
        <h2>Copying a string</h2>
      </format>
      <para>You can call the following <see cref="T:System.String" /> methods to make a copy of a string:</para>
      <list type="bullet">
        <item>
          <para>
                                                                                                        <see cref="M:System.String.Clone" /> returns a reference to an existing <see cref="T:System.String" /> object.</para>
        </item>
        <item>
          <para>
                                                                                                            <see cref="M:System.String.Copy(System.String)" /> creates a copy of an existing string.</para>
        </item>
        <item>
          <para>
                                                                                                                <see cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" /> copies a portion of a string to a character array.</para>
        </item>
      </list>
      <format type="text/html">
        <h2>Normalizing a string</h2>
      </format>
      <para>In Unicode, a single character can have multiple code points. Normalization converts these equivalent characters into the same binary representation. The <see cref="M:System.String.Normalize" /> method performs the normalization, and the <see cref="M:System.String.IsNormalized" /> method determines whether a string is normalized.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Represents text as a series of Unicode characters.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Char* value)" />
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue />
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other String constructor overloads, see the <see cref="Overload:System.String.#ctor" /> constructor summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to a null-terminated array of Unicode characters. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Char[] value)" />
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other String constructor overloads, see the <see cref="Overload:System.String.#ctor" /> constructor summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of Unicode characters. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other String constructor overloads, see the <see cref="Overload:System.String.#ctor" /> constructor summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a pointer to an array of 8-bit signed integers.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to a null-terminated array of 8-bit signed integers. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(valuetype System.Char c, int32 count)" />
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.</exception>
        <example>
          <para>The following example demonstrates using this constructor.</para>
          <code lang="C#">using System;

public class StringExample {
 public static void Main() {
 
 string s = new String('a', 10);

 Console.WriteLine(s);            
 }
}
   </code>
          <para>The output is</para>
          <para>
            <c>aaaaaaaaaa</c>
          </para>
        </example>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of times <paramref name="c" /> occurs. </param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other String constructor overloads, see the <see cref="Overload:System.String.#ctor" /> constructor summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified Unicode character repeated a specified number of times.</para>
        </summary>
        <param name="c">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode character. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of times <paramref name="c" /> occurs. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Char* value, int32 startIndex, int32 length)" />
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue />
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</para>
          <para> -or-</para>
          <para>
            <paramref name="value" /> is a null pointer and <paramref name="length" /> is not zero.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other String constructor overloads, see the <see cref="Overload:System.String.#ctor" /> constructor summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to an array of Unicode characters. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting position within <paramref name="value" />. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters within <paramref name="value" /> to use. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Char[] value, int32 startIndex, int32 length)" />
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</para>
          <para> -or-</para>
          <para>The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the number of elements in <paramref name="value" /> .</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other String constructor overloads, see the <see cref="Overload:System.String.#ctor" /> constructor summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of Unicode characters. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting position within <paramref name="value" />. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters within <paramref name="value" /> to use. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other String constructor overloads, see the <see cref="Overload:System.String.#ctor" /> constructor summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to an array of 8-bit signed integers. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting position within <paramref name="value" />. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters within <paramref name="value" /> to use. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.SByte* value, int32 startIndex, int32 length, class System.Text.Encoding enc)" />
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue />
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="value" /> is a null pointer and <paramref name="length" /> is not zero.</para>
        </exception>
        <param name="enc">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that specifies how the array referenced by <paramref name="value" /> is encoded. If <paramref name="enc" /> is null, ANSI encoding is assumed.</param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other String constructor overloads, see the <see cref="Overload:System.String.#ctor" /> constructor summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <see cref="T:System.Text.Encoding" /> object.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to an array of 8-bit signed integers. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting position within <paramref name="value" />. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters within <paramref name="value" /> to use. </param>
        <param name="enc">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that specifies how the array referenced by <paramref name="value" /> is encoded. If <paramref name="enc" /> is null, ANSI encoding is assumed.</param>
      </Docs>
      <Excluded>1</Excluded>
      <ExcludedLibrary>RuntimeInfrastructure</ExcludedLibrary>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="ILASM" Value=".property valuetype System.Char Chars[int32 index] { public hidebysig specialname instance valuetype System.Char get_Chars(int32 index) }" />
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
          <para> Gets the character at a specified position in the current
      instance.</para>
        </summary>
        <value>
          <para>A Unicode character at the location index in the current instance.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>
            <paramref name="index" /> is the position of a character within a
   string. The first character in the string is at index 0. The length of a string
   is the number of characters it is made up of. The last accessible <paramref name="index" />
   of a string instance is its length
   - 1.</para>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> is greater than or equal to the length of the current instance or less than zero.</exception>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual object Clone()" />
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The return value is not an independent copy of this instance; it is simply another view of the same data. Use the <see cref="M:System.String.Copy(System.String)" /> or <see cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" /> method to create a separate <see cref="T:System.String" /> object with the same value as this instance.</para>
          <para>Because the <see cref="M:System.String.Clone" /> method simply returns the existing string instance, there is little reason to call it directly. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a reference to this instance of <see cref="T:System.String" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This instance of <see cref="T:System.String" />.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 Compare(string strA, string strB)" />
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</para>
          <para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="T:System.Globalization.CompareOptions" />.</para>
          <block subset="none" type="note">
            <para>When comparing strings, you should call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see <format type="text/html"><a href="b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Best Practices for Using Strings in the .NET Framework</a></format>.</para>
          </block>
          <para>One or both comparands can be null. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
          <para>The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.</para>
          <para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</para>
          <para>code reference: System.String.Compare#10</para>
          <para>Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:</para>
          <para>code reference: System.String.Compare#11</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value </para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                        <paramref name="strA" /> is less than <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                            <paramref name="strA" /> equals <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                <paramref name="strA" /> is greater than <paramref name="strB" />. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to compare. </param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to compare. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 Compare(string strA, string strB, bool ignoreCase)" />
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <example>
          <para>The following example demonstrates comparing strings with and without case 
      sensitivity.</para>
          <code lang="C#">using System;
public class StringCompareExample {
 public static void Main() {
 string strA = "A STRING";
 string strB = "a string";
 int first = String.Compare( strA, strB, true );
 int second = String.Compare( strA, strB, false );
 Console.WriteLine( "When 'A STRING' is compared to 'a string' in a case-insensitive manner, the return value is {0}.", first );
 Console.WriteLine( "When 'A STRING' is compared to 'a string' in a case-sensitive manner, the return value is {0}.", second );
 }
}
   </code>
          <para>The output is</para>
          <c>
            <para>When 'A STRING' is compared to 'a string' in a case-insensitive manner, the
         return value is 0.</para>
            <para>When 'A STRING' is compared to 'a string' in a case-sensitive manner, the
         return value is 1.</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</para>
          <para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="T:System.Globalization.CompareOptions" />.</para>
          <block subset="none" type="note">
            <para>When comparing strings, you should call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see <format type="text/html"><a href="b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Best Practices for Using Strings in the .NET Framework</a></format>.</para>
          </block>
          <para>One or both comparands can be null. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
          <para>The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.</para>
          <para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</para>
          <para>code reference: System.String.Compare#12</para>
          <para>Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:</para>
          <para>code reference: System.String.Compare#13</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value </para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                    <paramref name="strA" /> is less than <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                        <paramref name="strA" /> equals <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                            <paramref name="strA" /> is greater than <paramref name="strB" />. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to compare. </param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to compare. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                                                                        true to ignore case during the comparison; otherwise, false.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="comparisonType" /> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</para>
          <para>One or both comparands can be null. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
          <para>The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater. The return value is the result of the last comparison performed.</para>
          <para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</para>
          <para>code reference: System.String.Compare#16</para>
          <para>Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:</para>
          <para>code reference: System.String.Compare#17</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value </para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                            <paramref name="strA" /> is less than <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                                <paramref name="strA" /> equals <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                                    <paramref name="strA" /> is greater than <paramref name="strB" />. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to compare.</param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to compare. </param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies the rules to use in the comparison. </param>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The comparison uses the <paramref name="culture" /> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</para>
          <para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="T:System.Globalization.CompareOptions" />.</para>
          <para>One or both comparands can be null. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
          <para>The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.</para>
          <para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</para>
          <para>code reference: System.String.Compare#14</para>
          <para>Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:</para>
          <para>code reference: System.String.Compare#15</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value </para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                <paramref name="strA" /> is less than <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                    <paramref name="strA" /> equals <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                        <paramref name="strA" /> is greater than <paramref name="strB" />. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to compare. </param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to compare. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                                                                                    true to ignore case during the comparison; otherwise, false. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that supplies culture-specific comparison information. </param>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The comparison uses the <paramref name="culture" /> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters. For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</para>
          <block subset="none" type="note">
            <para>The <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method is designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero). To determine whether two strings are equivalent, call the <see cref="Overload:System.String.Equals" /> method.</para>
          </block>
          <para>The comparison can be further specified by the <paramref name="options" /> parameter, which consists of one or more members of the <see cref="T:System.Globalization.CompareOptions" /> enumeration. However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <see cref="F:System.Globalization.CompareOptions.Ordinal" /> and <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> values have no effect. </para>
          <para>Either or both comparands can be null. By definition, any string, including <see cref="F:System.String.Empty" />, compares greater than a null reference, and two null references compare equal to each other.</para>
          <para>The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that indicates the lexical relationship between <paramref name="strA" /> and <paramref name="strB" />, as shown in the following table</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value</para>
                </term>
                <description>
                  <para>Condition</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero</para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                    <paramref name="strA" /> is less than <paramref name="strB" />.</para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero</para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                        <paramref name="strA" /> equals <paramref name="strB" />.</para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero</para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                            <paramref name="strA" /> is greater than <paramref name="strB" />.</para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to compare.  </param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to compare.</param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />The culture that supplies culture-specific comparison information.</param>
        <param name="options">
          <attribution license="cc4" from="Microsoft" modified="false" />Options to use when performing the comparison (such as ignoring case or symbols).  </param>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length)" />
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>The sum of <paramref name="indexA" /> and <paramref name="length" /> is greater than <paramref name="strA" /> .Length .</para>
          <para> -or-</para>
          <para>The sum of <paramref name="indexB" /> and <paramref name="length" /> is greater than <paramref name="strB" /> .Length .</para>
          <para> -or-</para>
          <para>
            <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</para>
        </exception>
        <example>
          <para>The following example demonstrates comparing substrings.</para>
          <code lang="C#">using System;
public class StringCompareExample {
 public static void Main() {
 string strA = "A string";
 string strB = "B ring";
 int first = String.Compare( strA, 4, strB, 2, 3 );
 int second = String.Compare( strA, 3, strB, 3, 3 );
 Console.WriteLine( "When the substring 'rin' of 'A string' is compared to the substring 'rin' of 'B ring', the return value is {0}.", first );
 Console.WriteLine( "When the substring 'tri' of 'A string' is compared to the substring 'ing' of 'B ring', the return value is {0}.", second );
 }
}
   </code>
          <para>The output is</para>
          <c>
            <para>When the substring 'rin' of 'A string' is compared to the substring 'rin' of
         'B ring', the return value is 0.</para>
            <para>When the substring 'tri' of 'A string' is compared to the substring 'ing' of
         'B ring', the return value is 1.</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The substrings to compare start in <paramref name="strA" /> at <paramref name="indexA" /> and in <paramref name="strB" /> at <paramref name="indexB" />. Both <paramref name="indexA" /> and <paramref name="indexB" /> are zero-based; that is, the first character in <paramref name="strA" /> and <paramref name="strB" /> is at position zero. The length of the first substring is equal to the length of <paramref name="strA" /> minus <paramref name="indexA" /> plus one. The length of the second substring is equal to the length of <paramref name="strB" /> minus <paramref name="indexB" /> plus one. </para>
          <para>The number of characters to compare is the lesser of the lengths of the two substrings, and <paramref name="length" />. The <paramref name="indexA" />, <paramref name="indexB" />, and <paramref name="length" /> parameters must be nonnegative.</para>
          <para>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</para>
          <para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="T:System.Globalization.CompareOptions" />.</para>
          <block subset="none" type="note">
            <para>When comparing strings, you should call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see <format type="text/html"><a href="b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Best Practices for Using Strings in the .NET Framework</a></format>.</para>
          </block>
          <para>One or both comparands can be null. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
          <para>The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.</para>
          <para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</para>
          <para>code reference: System.String.Compare#2</para>
          <para>Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:</para>
          <para>code reference: System.String.Compare#3</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares substrings of two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer indicating the lexical relationship between the two comparands.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value </para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>The substrings are equal, or <paramref name="length" /> is zero. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to use in the comparison. </param>
        <param name="indexA">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the substring within <paramref name="strA" />. </param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to use in the comparison. </param>
        <param name="indexB">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the substring within <paramref name="strB" />. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of characters in the substrings to compare. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase)" />
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="indexA" /> is greater than <paramref name="strA" /> .Length</para>
          <para> -or-</para>
          <para>
            <paramref name="indexB" /> is greater than <paramref name="strB" /> .Length</para>
          <para> -or-</para>
          <para>
            <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</para>
        </exception>
        <example>
          <para>The following example demonstrates comparing substrings with and without case 
      sensitivity.</para>
          <code lang="C#">using System;
public class StringCompareExample {
 public static void Main() {
 string strA = "STRING A";
 string strB = "string b";
 int first = String.Compare( strA, strB, true );
 int second = String.Compare( strA, 0, strB, 0, 4, true );
 int third = String.Compare( strA, 0, strB, 0, 4, false );
 Console.WriteLine( "When the string 'STRING A' is compared to the string 'string b' in a case-insensitive manner, the return value is {0}.", first );
 Console.WriteLine( "When the substring 'STRI' of 'STRING A' is compared to the substring 'stri' of 'string b' in a case-insensitive manner, the return value is {0}.", second );
 Console.WriteLine( "When the substring 'STRI' of 'STRING A' is compared to the substring 'stri' of 'string b' in a case-sensitive manner, the return value is {0}.", third );
 }
}
   </code>
          <para>The output is</para>
          <c>
            <para>When the string 'STRING A' is compared to the string 'string b' in a
         case-insensitive manner, the return value is -1.</para>
            <para>When the substring 'STRI' of 'STRING A' is compared to the substring 'stri'
         of 'string b' in a case-insensitive manner, the return value is 0.</para>
            <para>When the substring 'STRI' of 'STRING A' is compared to the substring 'stri'
         of 'string b' in a case-sensitive manner, the return value is 1.</para>
          </c>
        </example>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                        true to ignore case during the comparison; otherwise, false.</param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The substrings to compare start in <paramref name="strA" /> at <paramref name="indexA" />, and in <paramref name="strB" /> at <paramref name="indexB" />. Both <paramref name="indexA" /> and <paramref name="indexB" /> are zero-based; that is, the first character in <paramref name="strA" /> and <paramref name="strB" /> is at position zero. The length of the first substring is equal to the length of <paramref name="strA" /> minus <paramref name="indexA" /> plus one. The length of the second substring is equal to the length of <paramref name="strB" /> minus <paramref name="indexB" /> plus one.</para>
          <para>The number of characters to compare is the lesser of the lengths of the two substrings, and <paramref name="length" />. The <paramref name="indexA" />, <paramref name="indexB" />, and <paramref name="length" /> parameters must be nonnegative.</para>
          <para>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</para>
          <para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="T:System.Globalization.CompareOptions" />.</para>
          <block subset="none" type="note">
            <para>When comparing strings, you should call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see <format type="text/html"><a href="b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Best Practices for Using Strings in the .NET Framework</a></format>.</para>
          </block>
          <para>One or both comparands can be null. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
          <para>The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.</para>
          <para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</para>
          <para>code reference: System.String.Compare#4</para>
          <para>The path name needs to be compared in an invariant manner. The correct code to do this is as follows.</para>
          <para>code reference: System.String.Compare#5</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value</para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>The substrings are equal, or <paramref name="length" /> is zero. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to use in the comparison. </param>
        <param name="indexA">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the substring within <paramref name="strA" />. </param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to use in the comparison. </param>
        <param name="indexB">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the substring within <paramref name="strB" />. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of characters in the substrings to compare. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                        true to ignore case during the comparison; otherwise, false.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The substrings to compare start in <paramref name="strA" /> at <paramref name="indexA" /> and in <paramref name="strB" /> at <paramref name="indexB" />. Both <paramref name="indexA" /> and <paramref name="indexB" /> are zero-based; that is, the first character in <paramref name="strA" /> and <paramref name="strB" /> is at position zero, not position one. The length of the first substring is equal to the length of <paramref name="strA" /> minus <paramref name="indexA" /> plus one. The length of the second substring is equal to the length of <paramref name="strB" /> minus <paramref name="indexB" /> plus one.</para>
          <para>The number of characters to compare is the lesser of the lengths of the two substrings, and <paramref name="length" />. The <paramref name="indexA" />, <paramref name="indexB" />, and <paramref name="length" /> parameters must be nonnegative.</para>
          <para>The <paramref name="comparisonType" /> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</para>
          <para>One or both comparands can be null. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
          <para>The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater. The return value is the result of the last comparison performed.</para>
          <para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</para>
          <para>code reference: System.String.Compare#8</para>
          <para>Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:</para>
          <para>code reference: System.String.Compare#9</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares substrings of two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value </para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>The substring in the <paramref name="strA" /> parameter is less than the substring in the <paramref name="strB" /> parameter.</para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>The substrings are equal, or the <paramref name="length" /> parameter is zero. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to use in the comparison. </param>
        <param name="indexA">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the substring within <paramref name="strA" />. </param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to use in the comparison.</param>
        <param name="indexB">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the substring within <paramref name="strB" />. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of characters in the substrings to compare. </param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies the rules to use in the comparison. </param>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The substrings to compare start in <paramref name="strA" /> at <paramref name="indexA" />, and in <paramref name="strB" /> at <paramref name="indexB" />. Both <paramref name="indexA" /> and <paramref name="indexB" /> are zero-based; that is, the first character in <paramref name="strA" /> and <paramref name="strB" /> is at position zero, not position one. The length of the first substring is equal to the length of <paramref name="strA" /> minus <paramref name="indexA" /> plus one. The length of the second substring is equal to the length of <paramref name="strB" /> minus <paramref name="indexB" /> plus one. </para>
          <para>The number of characters to compare is the lesser of the lengths of the two substrings, and <paramref name="length" />. The <paramref name="indexA" />, <paramref name="indexB" />, and <paramref name="length" /> parameters must be nonnegative.</para>
          <para>The comparison uses the <paramref name="culture" /> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</para>
          <para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="T:System.Globalization.CompareOptions" />.</para>
          <para>One or both comparands can be null. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
          <para>The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.</para>
          <para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</para>
          <para>code reference: System.String.Compare#6</para>
          <para>Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:</para>
          <para>code reference: System.String.Compare#7</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An integer that indicates the lexical relationship between the two comparands.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value </para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>The substrings are equal, or <paramref name="length" /> is zero. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to use in the comparison. </param>
        <param name="indexA">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the substring within <paramref name="strA" />. </param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to use in the comparison. </param>
        <param name="indexB">
          <attribution license="cc4" from="Microsoft" modified="false" />The position of the substring within <paramref name="strB" />. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of characters in the substrings to compare. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                                    true to ignore case during the comparison; otherwise, false. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that supplies culture-specific comparison information. </param>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The substrings to compare start in <paramref name="strA" /> at position <paramref name="indexA" /> and in <paramref name="strB" /> at position <paramref name="indexB" />. The length of the first substring is the length of <paramref name="strA" /> minus <paramref name="indexA" />. The length of the second substring is the length of <paramref name="strB" /> minus <paramref name="indexB" />.</para>
          <para>The number of characters to compare is the lesser of the lengths of the two substrings, and <paramref name="length" />. The <paramref name="indexA" />, <paramref name="indexB" />, and <paramref name="length" /> parameters must be nonnegative.</para>
          <para>The comparison uses the <paramref name="culture" /> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters. For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</para>
          <block subset="none" type="note">
            <para>The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method is designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero). To determine whether two strings are equivalent, call the <see cref="Overload:System.String.Equals" /> method.</para>
          </block>
          <para>One or both of <paramref name="strA" /> and <paramref name="strB" /> can be null. By definition, any string, including <see cref="F:System.String.Empty" />, compares greater than a null reference, and two null references compare equal to each other.</para>
          <para>The comparison can be further specified by the <paramref name="options" /> parameter, which consists of one or more members of the <see cref="T:System.Globalization.CompareOptions" /> enumeration. However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <see cref="F:System.Globalization.CompareOptions.Ordinal" /> and <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> values have no effect. </para>
          <para>The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater. The return value is the result of the last comparison performed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares substrings of two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value</para>
                </term>
                <description>
                  <para>Condition</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero</para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />.</para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero</para>
              </term>
              <description>
                <para>The substrings are equal or <paramref name="length" /> is zero.</para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero</para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />.</para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to use in the comparison.   </param>
        <param name="indexA">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting position of the substring within <paramref name="strA" />.</param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to use in the comparison.</param>
        <param name="indexB">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting position of the substring within <paramref name="strB" />.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of characters in the substrings to compare.</param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that supplies culture-specific comparison information.</param>
        <param name="options">
          <attribution license="cc4" from="Microsoft" modified="false" />Options to use when performing the comparison (such as ignoring case or symbols).  </param>
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 CompareOrdinal(string strA, string strB)" />
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method performs a case-sensitive comparison using ordinal sort rules. For more information about word, string, and ordinal sorts, see <see cref="T:System.Globalization.CompareOptions" />. To perform a case-insensitive comparison using ordinal sort rules, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method with a <see cref="T:System.StringComparison" /> value of <see cref="F:System.StringComparison.OrdinalIgnoreCase" />.</para>
          <para>Because <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> is a static method, <paramref name="strA" /> and <paramref name="strB" /> can be null. If both values are null, the method returns 0 (zero), which indicates that <paramref name="strA" /> and <paramref name="strB" /> are equal. If only one of the values is null, the method considers the non-null value to be greater. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An integer that indicates the lexical relationship between the two comparands.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value</para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                                                <paramref name="strA" /> is less than <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                                                    <paramref name="strA" /> and <paramref name="strB" /> are equal. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>
                                                                                                                                                                                                                                                                                                                                                        <paramref name="strA" /> is greater than <paramref name="strB" />. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to compare. </param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to compare. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length)" />
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="indexA" /> is greater than <paramref name="strA" /> .Length</para>
          <para> -or-</para>
          <para>
            <paramref name="indexB" /> is greater than <paramref name="strB" /> .Length</para>
          <para> -or-</para>
          <para>
            <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" />is negative.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="indexA" />, <paramref name="indexB" />, and <paramref name="length" /> parameters must be nonnegative.</para>
          <para>The number of characters compared is the lesser of the length of <paramref name="strA" /> less <paramref name="indexA" />, the length of <paramref name="strB" /> less <paramref name="indexB" />, and <paramref name="length" />.</para>
          <para>This method performs a case-sensitive comparison using ordinal sort rules. For more information about word, string, and ordinal sorts, see <see cref="T:System.Globalization.CompareOptions" />. To perform a case-insensitive comparison using ordinal sort rules, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method with a <see cref="T:System.StringComparison" /> value of <see cref="F:System.StringComparison.OrdinalIgnoreCase" />.</para>
          <para>Because <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> is a static method, <paramref name="strA" /> and <paramref name="strB" /> can be null. If both values are null, the method returns 0 (zero), which indicates that <paramref name="strA" /> and <paramref name="strB" /> are equal. If only one of the values is null, the method considers the non-null value to be greater. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares substrings of two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each substring. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value</para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>The substrings are equal, or <paramref name="length" /> is zero. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strA">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to use in the comparison. </param>
        <param name="indexA">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the substring in <paramref name="strA" />. </param>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to use in the comparison. </param>
        <param name="indexB">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting index of the substring in <paramref name="strB" />. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of characters in the substrings to compare. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual int32 CompareTo(object value)" />
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> is not a <see cref="T:System.String" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                    <paramref name="value" /> must be a <see cref="T:System.String" /> object.</para>
          <block subset="none" type="note">
            <para>The <see cref="M:System.String.CompareTo(System.Object)" /> method was designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent. To determine whether two strings are equivalent, call the <see cref="Overload:System.String.Equals" /> method.</para>
          </block>
          <para>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture. For more information about word, string, and ordinal sorts, see <see cref="T:System.Globalization.CompareOptions" />.</para>
          <para>For more information about the behavior of this method, see the Remarks section of the <see cref="M:System.String.Compare(System.String,System.String)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value </para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>This instance precedes <paramref name="value" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>This instance has the same position in the sort order as <paramref name="value" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>This instance follows <paramref name="value" />.</para>
                <para>-or- </para>
                <para>
                                                                                                                                                                                                                                                                                                                                                    <paramref name="value" /> is null. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that evaluates to a <see cref="T:System.String" />. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture. For more information about word, string, and ordinal sorts, see <see cref="T:System.Globalization.CompareOptions" />.</para>
          <block subset="none" type="note">
            <para>The <see cref="M:System.String.CompareTo(System.Object)" /> method was designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent. To determine whether two strings are equivalent, call the <see cref="Overload:System.String.Equals" /> method.</para>
          </block>
          <para>For more information about the behavior of this method, see the Remarks section of the <see cref="M:System.String.Compare(System.String,System.String)" /> method.</para>
          <para>This method implements the <see cref="T:System.IComparable`1" /> interface and performs slightly better than the <see cref="M:System.String.CompareTo(System.Object)" /> method, because it does not have to determine whether the <paramref name="value" /> argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <see cref="T:System.Object" /> to a <see cref="T:System.String" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Compares this instance with a specified <see cref="T:System.String" /> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.String" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Value </para>
                </term>
                <description>
                  <para>Condition </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>Less than zero </para>
              </term>
              <description>
                <para>This instance precedes <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Zero </para>
              </term>
              <description>
                <para>This instance has the same position in the sort order as <paramref name="strB" />. </para>
              </description>
            </item>
            <item>
              <term>
                <para>Greater than zero </para>
              </term>
              <description>
                <para>This instance follows <paramref name="strB" />.</para>
                <para>-or- </para>
                <para>
                                                                                                                                                                                                                                                                                                                                                            <paramref name="strB" /> is null. </para>
              </description>
            </item>
          </list>
        </returns>
        <param name="strB">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to compare with this instance. </param>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method concatenates each object in <paramref name="values" />; it does not add any delimiters. To specify a delimiter between each member of <paramref name="values" />, call the <see cref="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" /> method.</para>
          <para>An <see cref="F:System.String.Empty" /> string is used in place of any null argument.</para>
          <para>
                                                                                                                                                                                                                                                                                                                                        <see cref="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" /> is a convenience method that lets you concatenate each element in an IEnumerable(Of String) collection without first converting the elements to a string array. It is particularly useful with Language-Integrated Query (LINQ) query expressions. The following example passes a List(Of String) object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M"). The IEnumerable(Of String) collection that is returned by the <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" /> method is passed to the <see cref="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" /> method to display the result as a single string. </para>
          <para>code reference: System.String.Concat#3</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The concatenated strings in <paramref name="values" />.</para>
        </returns>
        <param name="values">
          <attribution license="cc4" from="Microsoft" modified="false" />A collection object that implements <see cref="T:System.Collections.Generic.IEnumerable`1" /> and whose generic type argument is <see cref="T:System.String" />.</param>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.Concat(System.Object)" /> method represents <paramref name="arg0" /> as a string by calling its parameterless ToString method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates the string  representation of a specified object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The string representation of the value of <paramref name="arg0" />, or <see cref="F:System.String.Empty" /> if <paramref name="arg0" /> is null.</para>
        </returns>
        <param name="arg0">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to represent, or null. </param>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Concat(class System.Object[] args)" />
      <MemberSignature Language="C#" Value="public static string Concat (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> is a null reference.</exception>
        <example>
          <para>The following example demonstrates concatenating an array of objects.</para>
          <code lang="C#">using System;
public class StringConcatExample {
 public static void Main() {
 string str = String.Concat( 'c', 32, "String" );
 Console.WriteLine( "The concatenated Object array is: {0}", str );
 }
}
   </code>
          <para>The output is</para>
          <para>
            <c>The
      concatenated Object array is: c32String</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method concatenates each object in <paramref name="args" /> by calling the parameterless ToString method of that object; it does not add any delimiters.</para>
          <para>
                                                                                                                                                                                                                                                                                                                                                <see cref="F:System.String.Empty" /> is used in place of any null object in the array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the string representations of the elements in a specified <see cref="T:System.Object" /> array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The concatenated string representations of the values of the elements in <paramref name="args" />.</para>
        </returns>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An object array that contains the elements to concatenate. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Concat(class System.String[] values)" />
      <MemberSignature Language="C#" Value="public static string Concat (string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> is a null reference.</exception>
        <example>
          <para>The following example demonstrates concatenating an array of strings.</para>
          <code lang="C#">using System;
public class StringConcatExample {
 public static void Main() {
 string str = String.Concat( "one", "two", "three", "four", "five" );
 Console.WriteLine( "The concatenated String array is: {0}", str );
 }
}
   </code>
          <para>The output is</para>
          <para>
            <c>The
      concatenated String array is: onetwothreefourfive</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method concatenates each object in <paramref name="values" />; it does not add any delimiters.</para>
          <para>An <see cref="F:System.String.Empty" /> string is used in place of any null object in the array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the elements of a specified <see cref="T:System.String" /> array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The concatenated elements of <paramref name="values" />.</para>
        </returns>
        <param name="values">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of string instances. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Concat(object arg0, object arg1)" />
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <example>
          <para>The following example demonstrates concatenating two objects.</para>
          <code lang="C#">using System;
public class StringConcatExample {
 public static void Main() {
 string str = String.Concat( 'c', 32 );
 Console.WriteLine( "The concatenated Objects are: {0}", str );
 }
}
   </code>
          <para>The output is</para>
          <para>
            <c>The
      concatenated Objects are: c32</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method concatenates <paramref name="arg0" /> and <paramref name="arg1" />by calling the parameterless ToString method of <paramref name="arg0" /> and <paramref name="arg1" />; it does not add any delimiters.</para>
          <para>
                                                                                                                                                                                                                                                                                                                                            <see cref="F:System.String.Empty" /> is used in place of any null argument.</para>
          <para>If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the string representations of two specified objects.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The concatenated string representations of the values of <paramref name="arg0" /> and <paramref name="arg1" />.</para>
        </returns>
        <param name="arg0">
          <attribution license="cc4" from="Microsoft" modified="false" />The first object to concatenate. </param>
        <param name="arg1">
          <attribution license="cc4" from="Microsoft" modified="false" />The second object to concatenate. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Concat(string str0, string str1)" />
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <example>
          <para>The following example demonstrates concatenating two strings.</para>
          <code lang="C#">using System;
public class StringConcatExample {
 public static void Main() {
 string str = String.Concat( "one", "two" );
 Console.WriteLine( "The concatenated strings are: {0}", str );
 }
}
   </code>
          <para>The output is</para>
          <para>
            <c>The
      concatenated strings are: onetwo</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method concatenates <paramref name="str0" /> and <paramref name="str1" />; it does not add any delimiters.</para>
          <para>An <see cref="F:System.String.Empty" /> string is used in place of any null argument.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates two specified instances of <see cref="T:System.String" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The concatenation of <paramref name="str0" /> and <paramref name="str1" />.</para>
        </returns>
        <param name="str0">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to concatenate. </param>
        <param name="str1">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to concatenate. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Concat(object arg0, object arg1, object arg2)" />
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <example>
          <para>The following example demonstrates concatenating three objects.</para>
          <code lang="C#">using System;
public class StringConcatExample {
 public static void Main() {
 string str = String.Concat( 'c', 32, "String" );
 Console.WriteLine( "The concatenated Objects are: {0}", str );
 }
}
   </code>
          <para>The output is</para>
          <para>
            <c>The
      concatenated Objects are: c32String</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method concatenates <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" /> by calling the parameterless ToString method of each object; it does not add any delimiters.</para>
          <para>
                                                                                                                                                                                                                                                                                                                                            <see cref="F:System.String.Empty" /> is used in place of any null argument.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the string representations of three specified objects.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The concatenated string representations of the values of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</para>
        </returns>
        <param name="arg0">
          <attribution license="cc4" from="Microsoft" modified="false" />The first object to concatenate. </param>
        <param name="arg1">
          <attribution license="cc4" from="Microsoft" modified="false" />The second object to concatenate. </param>
        <param name="arg2">
          <attribution license="cc4" from="Microsoft" modified="false" />The third object to concatenate. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Concat(string str0, string str1, string str2)" />
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <example>
          <para>The following example demonstrates concatenating three strings.</para>
          <code lang="C#">using System;
public class StringConcatExample {
 public static void Main() {
 string str = String.Concat( "one", "two", "three" );
 Console.WriteLine( "The concatenated strings are: {0}", str );
 }
}
   </code>
          <para>The output is</para>
          <para>
            <c>The
      concatenated strings are: onetwothree</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method concatenates <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />; it does not add any delimiters.</para>
          <para>An <see cref="F:System.String.Empty" /> string is used in place of any null argument.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates three specified instances of <see cref="T:System.String" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The concatenation of <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />.</para>
        </returns>
        <param name="str0">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to concatenate. </param>
        <param name="str1">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to concatenate. </param>
        <param name="str2">
          <attribution license="cc4" from="Microsoft" modified="false" />The third string to concatenate. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method concatenates each object in the parameter list by calling its parameterless ToString method; it does not add any delimiters.</para>
          <para>
                                                                                                                                                                                                                                                                                                                                            <see cref="F:System.String.Empty" /> is used in place of any null argument.</para>
          <block subset="none" type="note">
            <para>The last parameter of the  <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> method is an optional comma-delimited list of one or more additional objects to concatenate.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The concatenated string representation of each value in the parameter list.</para>
        </returns>
        <param name="arg0">
          <attribution license="cc4" from="Microsoft" modified="false" />The first object to concatenate. </param>
        <param name="arg1">
          <attribution license="cc4" from="Microsoft" modified="false" />The second object to concatenate. </param>
        <param name="arg2">
          <attribution license="cc4" from="Microsoft" modified="false" />The third object to concatenate. </param>
        <param name="arg3">
          <attribution license="cc4" from="Microsoft" modified="false" />The fourth object to concatenate.</param>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method concatenates <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, and <paramref name="str3" />; it does not add any delimiters.</para>
          <para>An <see cref="F:System.String.Empty" /> string is used in place of any null object in the array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates four specified instances of <see cref="T:System.String" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The concatenation of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, and <paramref name="str3" />.</para>
        </returns>
        <param name="str0">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to concatenate. </param>
        <param name="str1">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to concatenate. </param>
        <param name="str2">
          <attribution license="cc4" from="Microsoft" modified="false" />The third string to concatenate. </param>
        <param name="str3">
          <attribution license="cc4" from="Microsoft" modified="false" />The fourth string to concatenate. </param>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The method concatenates each object in <paramref name="values" />; it does not add any delimiters.</para>
          <para>An <see cref="F:System.String.Empty" /> string is used in place of any null argument.</para>
          <para>
                                                                                                                                                                                                                                                                                                                                            <see cref="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" /> is a convenience method that lets you concatenate each element in an <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection without first converting the elements to strings. It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates. The string representation of each object in the <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection is derived by calling that object's ToString method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the members of an <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementation.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The concatenated members in <paramref name="values" />.</para>
        </returns>
        <param name="values">
          <attribution license="cc4" from="Microsoft" modified="false" />A collection object that implements the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the members of <paramref name="values" />.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method performs an ordinal (case-sensitive and culture-insensitive) comparison. The search begins at the first character position of this string and continues through the last character position.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a value indicating whether a specified substring occurs within this string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                        true if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Copy(string str)" />
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> is a null reference.</exception>
        <example>
          <para>The following example demonstrates copying strings.</para>
          <code lang="C#">using System;
public class StringCopyExample {
 public static void Main() {
 string strA = "string";
 Console.WriteLine( "The initial string, strA, is '{0}'.", strA );
 string strB = String.Copy( strA );
 strA = strA.ToUpper();
 Console.WriteLine( "The copied string, strB, before strA.ToUpper, is '{0}'.", strB );
 Console.WriteLine( "The initial string after StringCopy and ToUpper, is '{0}'.", strA );
 Console.WriteLine( "The copied string, strB, after strA.ToUpper, is '{0}'.", strB );
 }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The initial string, strA, is 'string'.</para>
            <para>The copied string, strB, before strA.ToUpper, is 'string'.</para>
            <para>The initial string after StringCopy and ToUpper, is 'STRING'.</para>
            <para>The copied string, strB, after strA.ToUpper, is 'string'.</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.Copy(System.String)" /> method returns a <see cref="T:System.String" /> object that has the same value as the original string but represents a different object reference. It differs from an assignment operation, which assigns an existing string reference to an additional object variable. The example illustrates the difference. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a new instance of <see cref="T:System.String" /> with the same value as a specified <see cref="T:System.String" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new string with the same value as <paramref name="str" />.</para>
        </returns>
        <param name="str">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to copy. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, class System.Char[] destination, int32 destinationIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> is a null reference.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" /> is negative </para>
          <para>-or- </para>
          <para>
            <paramref name="count" /> is greater than the length of the substring from <paramref name="startIndex" /> to the end of the current instance </para>
          <para>-or- </para>
          <para>
            <paramref name="count" /> is greater than the length of the subarray from <paramref name="destinationIndex" /> to the end of <paramref name="destination" /></para>
        </exception>
        <example>
          <para>The following example demonstrates copying characters from a string to a 
      Unicode character array.</para>
          <code lang="C#">using System;
public class StringCopyToExample {
 public static void Main() {
 string str = "this is the new string";
 Char[] cAry = {'t','h','e',' ','o','l','d'};
 Console.WriteLine( "The initial string is '{0}'", str );
 Console.Write( "The initial character array is: '" );
 foreach( Char c in cAry)
 Console.Write( c );
 Console.WriteLine( "'" );
 str.CopyTo( 12, cAry, 4, 3 );
 Console.Write( "The character array after CopyTo is: '" );
 foreach( Char c in cAry)
 Console.Write( c );
 Console.WriteLine("'");
 }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The initial string is 'this is the new string'</para>
            <para>The initial character array is: 'the old'</para>
            <para>The character array after CopyTo is: 'the new'</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method copies <paramref name="count" /> characters from the <paramref name="sourceIndex" /> position of this instance to the <paramref name="destinationIndex" /> position of <paramref name="destination" /> character array. This method does not resize the <paramref name="destination" /> character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <see cref="T:System.ArgumentOutOfRangeException" />. </para>
          <para>
                                                                                                                                                                                                                                                                                                                                                                        <paramref name="sourceIndex" /> and <paramref name="destinationIndex" /> are zero-based.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</para>
        </summary>
        <param name="sourceIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first character in this instance to copy. </param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of Unicode characters to which characters in this instance are copied. </param>
        <param name="destinationIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The index in <paramref name="destination" /> at which the copy operation begins. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters in this instance to copy to <paramref name="destination" />. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="ILASM" Value=".field public static initOnly string Empty" />
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The value of this field is the zero-length string, "".</para>
          <para>In application code, this field is most commonly used in assignments to initialize a string variable to an empty string. To test whether the value of a string is either null or <see cref="F:System.String.Empty" />, use the <see cref="M:System.String.IsNullOrEmpty(System.String)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Represents the empty string. This field is read-only.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance bool EndsWith(string value)" />
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference.</exception>
        <example>
          <para>The following example demonstrates determining whether the current instance 
      ends with a specified string.</para>
          <code lang="C#">using System;
public class StringEndsWithExample {
 public static void Main() {
 string str = "One string to compare";
 Console.WriteLine( "The given string is '{0}'", str );
 Console.Write( "The given string ends with 'compare'? " );
 Console.WriteLine( str.EndsWith( "compare" ) );
 Console.Write( "The given string ends with 'Compare'? " );
 Console.WriteLine( str.EndsWith( "Compare" ) );
 }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The given string is 'One string to compare'</para>
            <para>The given string ends with 'compare'? True</para>
            <para>The given string ends with 'Compare'? False</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method compares <paramref name="value" /> to the substring at the end of this instance that is the same length as <paramref name="value" />, and returns an indication whether they are equal. To be equal, <paramref name="value" /> must be a reference to this same instance or match the end of this instance.</para>
          <para>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the end of this string instance matches the specified string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                true if <paramref name="value" /> matches the end of this instance; otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to compare to the substring at the end of this instance. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> method compares the <paramref name="value" /> parameter to the substring at the end of this string and returns a value that indicates whether they are equal. To be equal, <paramref name="value" /> must be a reference to this same string, must be the empty string (""), or must match the end of this string. The type of comparison performed by the <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> method depends on the value of the <paramref name="comparisonType" /> parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                            true if the <paramref name="value" /> parameter matches the end of this string; otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to compare to the substring at the end of this instance. </param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that determines how this string and <paramref name="value" /> are compared. </param>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method compares the <paramref name="value" /> parameter to the substring at the end of this string that is the same length as <paramref name="value" />, and returns a value that indicates whether they are equal. To be equal, <paramref name="value" /> must be a reference to this same instance or match the end of this string.</para>
          <para>This method performs a word (culture-sensitive) comparison using the specified casing and culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the end of this string instance matches the specified string when compared using the specified culture.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                        true if the <paramref name="value" /> parameter matches the end of this string; otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to compare to the substring at the end of this instance. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                                                                                                                                                        true to ignore case during the comparison; otherwise, false.</param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />Cultural information that determines how this instance and <paramref name="value" /> are compared. If <paramref name="culture" /> is null, the current culture is used.</param>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool Equals(object obj)" />
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.NullReferenceException">The current instance is a null reference.</exception>
        <example>
          <para>The following example demonstrates checking to see if an object is equal to 
      the current instance.</para>
          <code lang="C#">using System;
public class StringEqualsExample {
 public static void Main() {
 string str = "A string";
 Console.WriteLine( "The given string is '{0}'", str );
 Console.Write( "The given string is equal to 'A string'? " );
 Console.WriteLine( str.Equals( "A string" ) );
 Console.Write( "The given string is equal to 'A String'? " );
 Console.WriteLine( str.Equals( "A String" ) );
 }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The given string is 'A string'</para>
            <para>The given string is equal to 'A string'? True</para>
            <para>The given string is equal to 'A String'? False</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether this instance and a specified object, which must also be a <see cref="T:System.String" /> object, have the same value.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                true if <paramref name="obj" /> is a <see cref="T:System.String" /> and its value is the same as this instance; otherwise, false.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to compare to this instance. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether this instance and another specified <see cref="T:System.String" /> object have the same value.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                true if the value of the <paramref name="value" /> parameter is the same as this instance; otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to compare to this instance. </param>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static bool Equals(string a, string b)" />
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <example>
          <para>The following example demonstrates checking to see if two strings are 
      equal.</para>
          <code lang="C#">using System;
public class StringEqualsExample {
 public static void Main() {
 string strA = "A string";
 string strB = "a string";
 string strC = "a string";
 Console.Write( "The string '{0}' is equal to the string '{1}'? ", strA, strB );
 Console.WriteLine( String.Equals( strA, strB ) );
 Console.Write( "The string '{0}' is equal to the string '{1}'? ", strC, strB );
 Console.WriteLine( String.Equals( strC, strB ) );
 }
}
   </code>
          <para>The output is</para>
          <c>
            <para>The string 'A string' is equal to the string 'a string'? False</para>
            <para>The string 'a string' is equal to the string 'a string'? True</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether two specified <see cref="T:System.String" /> objects have the same value.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                true if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, false. If both <paramref name="a" /> and <paramref name="b" /> are null, the method returns true.</para>
        </returns>
        <param name="a">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to compare, or null. </param>
        <param name="b">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to compare, or null. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="comparisonType" /> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether this string and a specified <see cref="T:System.String" /> object have the same value. A parameter specifies the culture, case, and sort rules used in the comparison.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                    true if the value of the <paramref name="value" /> parameter is the same as this string; otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to compare to this instance.</param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies how the strings will be compared. </param>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="comparisonType" /> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether two specified <see cref="T:System.String" /> objects have the same value. A parameter specifies the culture, case, and sort rules used in the comparison.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                true if the value of the <paramref name="a" /> parameter is equal to the value of the <paramref name="b" /> parameter; otherwise, false.</para>
        </returns>
        <param name="a">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to compare, or null. </param>
        <param name="b">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to compare, or null. </param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies the rules for the comparison. </param>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Format(string format, object arg0)" />
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format " /> is a null reference.</exception>
        <exception cref="T:System.FormatException">
          <para>The format specification in <paramref name="format" /> is invalid.</para>
          <para> -or-</para>
          <para>The number indicating an argument to be formatted is less than zero, or greater than or equal to the number of provided objects to be formatted (1).</para>
        </exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.Format(System.String,System.Object)" /> method.</para>
          <code lang="C#">
using System;
public class StringFormat {
 public static void Main() {
 Console.WriteLine(String.Format("The high temperature today was {0:###} degrees.", 88));
 Console.WriteLine("The museum had {0,-6} visitors today.", 88);
 }
}
</code>
          <para>The output is</para>
          <code>
The high temperature today was 88 degrees.
The museum had 88     visitors today.
</code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other overloads of the Format method, see the <see cref="Overload:System.String.Format" /> overload summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces one or more format items in a specified string with the string representation of a specified object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A copy of <paramref name="format" /> in which any format items are replaced by the string representation of <paramref name="arg0" />.</para>
        </returns>
        <param name="format">
          <attribution license="cc4" from="Microsoft" modified="false" />A <format type="text/html"><a href="87b7d528-73f6-43c6-b71a-f23043039a49">composite format string</a></format>. </param>
        <param name="arg0">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to format. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Format(string format, class System.Object[] args)" />
      <MemberSignature Language="C#" Value="public static string Format (string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> or <paramref name="args " />is a null reference.</exception>
        <exception cref="T:System.FormatException">
          <para>
            <paramref name="format" /> is invalid.</para>
          <para> -or-</para>
          <para>The number indicating an argument to be formatted is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</para>
        </exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.Format(System.String,System.Object)" /> method.</para>
          <code lang="C#">
using System;
public class StringFormat {
   public static void Main() {
      Console.WriteLine( String.Format("The winning numbers were {0:000} {1:000} {2:000} {3:000} {4:000} today.", 5, 10, 11, 37, 42) );
      Console.WriteLine( "The winning numbers were {0, -6}{1, -6}{2, -6}{3, -6}{4, -6} today.", 5, 10, 11, 37, 42 );
 }
}
</code>
          <para>The output is</para>
          <code>
The winning numbers were 005 010 011 037 042 today.
The winning numbers were 5     10    11    37    42     today.
</code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other overloads of the Format method, see the <see cref="Overload:System.String.Format" /> overload summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</para>
        </returns>
        <param name="format">
          <attribution license="cc4" from="Microsoft" modified="false" />A <format type="text/html"><a href="87b7d528-73f6-43c6-b71a-f23043039a49">composite format string</a></format>.</param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An object array that contains zero or more objects to format. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Format(class System.IFormatProvider provider, string format, class System.Object[] args)" />
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> or <paramref name="args" /> is a null reference.</exception>
        <exception cref="T:System.FormatException">
          <para>
            <paramref name="format" /> is invalid.</para>
          <para>-or-</para>
          <para>The number indicating an argument to be formatted (<paramref name="N" />) is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other overloads of the Format method, see the <see cref="Overload:System.String.Format" /> overload summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the format items in a specified string with the string representations of corresponding objects in a specified array. A parameter supplies culture-specific formatting information.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that supplies culture-specific formatting information. </param>
        <param name="format">
          <attribution license="cc4" from="Microsoft" modified="false" />A <format type="text/html"><a href="87b7d528-73f6-43c6-b71a-f23043039a49">composite format string</a></format>. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An object array that contains zero or more objects to format. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Format(string format, object arg0, object arg1)" />
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is a null reference.</exception>
        <exception cref="T:System.FormatException">
          <para>
            <paramref name="format" /> is invalid.</para>
          <para> -or-</para>
          <para>The number indicating an argument to be formatted is less than zero, or greater than or equal to the number of provided objects to be formatted (2).</para>
        </exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.Format(System.String,System.Object)" /> method.</para>
          <code lang="C#">using System;
public class StringFormat {
  public static void Main() {
  Console.WriteLine( String.Format("The temperature today oscillated between {0:####} and {1:####} degrees.", 78, 100) );
  Console.WriteLine( String.Format("The temperature today oscillated between {0:0000} and {1:0000} degrees.", 78, 100) );
  Console.WriteLine( "The temperature today oscillated between {0, -4} and {1, -4} degrees.", 78, 100 );
   }
}
</code>
          <para>The output is</para>
          <code>
The temperature today oscillated between 78 and 100 degrees.
The temperature today oscillated between 0078 and 0100 degrees.
The temperature today oscillated between 78   and 100  degrees.
</code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other overloads of the Format method, see the <see cref="Overload:System.String.Format" /> overload summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the format items in a specified string with the string representation of two specified objects.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</para>
        </returns>
        <param name="format">
          <attribution license="cc4" from="Microsoft" modified="false" />A <format type="text/html"><a href="87b7d528-73f6-43c6-b71a-f23043039a49">composite format string</a></format>. </param>
        <param name="arg0">
          <attribution license="cc4" from="Microsoft" modified="false" />The first object to format. </param>
        <param name="arg1">
          <attribution license="cc4" from="Microsoft" modified="false" />The second object to format. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Format(string format, object arg0, object arg1, object arg2)" />
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is a null reference.</exception>
        <exception cref="T:System.FormatException">
          <para>
            <paramref name="format" /> is invalid.</para>
          <para> -or-</para>
          <para>The number indicating an argument to be formatted is less than zero, or greater than or equal to the number of provided objects to be formatted (3).</para>
        </exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.Format(System.String,System.Object)" /> method.</para>
          <code lang="C#">
using System;
public class StringFormat {
   public static void Main() {
      Console.WriteLine(String.Format("The temperature today oscillated between {0:###} and {1:###} degrees. The average temperature  was {2:000} degrees.", 78, 100, 91));
      Console.WriteLine("The temperature today oscillated between {0, 4} and {1, 4} degrees. The average temperature was {2, 4}  degrees.", 78, 100, 91);
   }
}
</code>
          <para>The output is</para>
          <code>
The temperature today oscillated between 78 and 100 degrees. The average temperature was 091 degrees.
The temperature today oscillated between   78 and  100 degrees. The average temperature was   91 degrees.</code>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>For examples and comprehensive usage information about this and other overloads of the Format method, see the <see cref="Overload:System.String.Format" /> overload summary. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Replaces the format items in a specified string with the string representation of three specified objects.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</para>
        </returns>
        <param name="format">
          <attribution license="cc4" from="Microsoft" modified="false" />A <format type="text/html"><a href="87b7d528-73f6-43c6-b71a-f23043039a49">composite format string</a></format>.</param>
        <param name="arg0">
          <attribution license="cc4" from="Microsoft" modified="false" />The first object to format. </param>
        <param name="arg1">
          <attribution license="cc4" from="Microsoft" modified="false" />The second object to format. </param>
        <param name="arg2">
          <attribution license="cc4" from="Microsoft" modified="false" />The third object to format. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator()" />
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method enables you to iterate the individual characters in a string. For example, the Visual Basic For Each and C# foreach statements invoke this method to return a <see cref="T:System.CharEnumerator" /> object that can provide read-only access to the characters in this string instance. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves an object that can iterate through the individual characters in this string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An enumerator object.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetHashCode()" />
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The behavior of <see cref="M:System.String.GetHashCode" /> is dependent on its implementation, which might change from one version of the common language runtime to another. A reason why this might happen is to improve the performance of <see cref="M:System.String.GetHashCode" />. </para>
          <block subset="none" type="note">
            <para>If two string objects are equal, the <see cref="M:System.String.GetHashCode" /> method returns identical values. However, there is not a unique hash code value for each unique string value. Different strings can return the same hash code. </para>
            <para>The hash code itself is not guaranteed to be stable. Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework. In some cases, they can even differ by application domain. </para>
            <para>As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted. </para>
            <para>Finally, do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash. For cryptographic hashes, use a class derived from the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> or <see cref="T:System.Security.Cryptography.KeyedHashAlgorithm" /> class.</para>
            <para>For more information about hash codes, see <see cref="M:System.Object.GetHashCode" />.</para>
          </block>
          <para>In desktop apps, you can use the <format type="text/html"><a href="c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; element</a></format> to generate unique hash codes on a per application domain basis. This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables. The following example shows how to use the <format type="text/html"><a href="c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; element</a></format>. It defines a DisplayString class that includes a private string constant, s, whose value is "This is a string." It also includes a ShowStringHashCode method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</para>
          <para>code reference: System.String.GetHashCode#2</para>
          <para>When you run the example without supplying a configuration file, it displays output similar to the following. Note that the hash codes for the string are identical in the two application domains. </para>
          <code>
                                                                                                                                                                                                                                                                                                                                                                                                                                                            String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC
                                                                                                                                                                                                                                                                                                                                                                                                                                                            String 'This is a string.' in domain 'NewDomain': 941BCEAC
                                                                                                                                                                                                                                                                                                                                                                                                                                                        </code>
          <para>However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain. </para>
          <code>
                                                                                                                                                                                                                                                                                                                                                                                                                                                            &lt;?xml version ="1.0"?&gt;
                                                                                                                                                                                                                                                                                                                                                                                                                                                            &lt;configuration&gt;
                                                                                                                                                                                                                                                                                                                                                                                                                                                               &lt;runtime&gt;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  &lt;UseRandomizedStringHashAlgorithm enabled="1" /&gt;
                                                                                                                                                                                                                                                                                                                                                                                                                                                               &lt;/runtime&gt;
                                                                                                                                                                                                                                                                                                                                                                                                                                                            &lt;/configuration&gt;
                                                                                                                                                                                                                                                                                                                                                                                                                                                        </code>
          <para>When the configuration file is present, the example displays the following output: </para>
          <code>
                                                                                                                                                                                                                                                                                                                                                                                                                                                            String 'This is a string.' in domain 'PerDomain.exe': 5435776D
                                                                                                                                                                                                                                                                                                                                                                                                                                                            String 'This is a string.' in domain 'NewDomain': 75CC8236
                                                                                                                                                                                                                                                                                                                                                                                                                                                        </code>
          <block subset="none" type="note">
            <para>Hash codes are used to insert and retrieve keyed objects from hash tables efficiently. However, hash codes do not uniquely identify strings. Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings. In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain. Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary. </para>
          </block>
          <para>For additional information about the use of hash codes and the GetHashCode method, see <see cref="M:System.Object.GetHashCode" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the hash code for this string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer hash code.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the <see cref="T:System.TypeCode" /> for class <see cref="T:System.String" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The enumerated constant, <see cref="F:System.TypeCode.String" />.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 IndexOf(valuetype System.Char value)" />
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode character to seek. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 IndexOf(string value)" />
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference.</exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.IndexOf(System.Char)" /> 
method.</para>
          <code lang="C#">using System;
public class StringIndexOf {
 public static void Main() {
 String str = "This is the string";
 Console.WriteLine( "Searching for the index of \"is\" yields {0,2}.", str.IndexOf( "is" ) );
 Console.WriteLine( "Searching for the index of \"Is\" yields {0,2}.", str.IndexOf( "Is" ) );
 Console.WriteLine( "Searching for the index of \"\" yields {0,2}.", str.IndexOf( "" ) );
 }
}
</code>
          <para>The output is</para>
          <c>
            <para>Searching for the index of "is" yields 2.</para>
            <para>Searching for the index of "Is" yields -1.</para>
            <para>Searching for the index of "" yields 0.</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero.</para>
          <para>This method performs a word (case-sensitive and culture-sensitive) search using the current culture. The search begins at the first character position of this instance and continues until the last character position.</para>
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String)" /> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance. In the following example, the <see cref="M:System.String.IndexOf(System.String)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings. Only one of the strings contains a soft hyphen. In each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <paramref name="value" />. When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</para>
          <para>code reference: System.String.IndexOf#21</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence of the specified string in this instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 IndexOf(valuetype System.Char value, int32 startIndex)" />
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.IndexOf(System.Char)" /> 
method.</para>
          <code lang="C#">using System;
public class StringIndexOf {
 public static void Main() {
 String str = "This is the string";
 Console.WriteLine( "Searching for the index of 'h' starting from index 0 yields {0}.", str.IndexOf( 'h', 0 ) );
 Console.WriteLine( "Searching for the index of 'h' starting from index 10 yields {0}.", str.IndexOf( 'h', 10 ) );
 }
}
</code>
          <para>The output is</para>
          <c>
            <para>Searching for the index of 'h' starting from index 0 yields 1.</para>
            <para>Searching for the index of 'h' starting from index 10 yields -1.</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from 0. The <paramref name="startIndex" /> parameter can range from 0 to the length of the string instance. If <paramref name="startIndex" /> equals the length of the string instance, the method returns -1.</para>
          <para>The search ranges from <paramref name="startIndex" /> to the end of the string.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence of the specified Unicode character in this string. The search starts at a specified character position.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode character to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex)" />
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is greater than the length of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from 0. The <paramref name="startIndex" /> parameter can range from 0 to the length of the string instance. If <paramref name="startIndex" /> equals the length of the string instance, the method returns -1.</para>
          <para>This method performs a word (case-sensitive and culture-sensitive) search using the current culture. The search begins at the <paramref name="startIndex" /> character position of this instance and continues until the last character position.</para>
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins. In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings. Only one of the strings contains the required substring. In both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</para>
          <para>code reference: System.String.IndexOf#22</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence of the specified string in this instance. The search starts at a specified character position.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero.</para>
          <para>The <paramref name="comparisonType" /> parameter specifies to search for the <paramref name="value" /> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object. A parameter specifies the type of search to use for the specified string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies the rules for the search. </param>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 IndexOf(valuetype System.Char value, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="count" /> is negative</para>
          <para> -or-</para>
          <para>
            <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The search begins at <paramref name="startIndex" /> and continues to <paramref name="startIndex" /> + <paramref name="count" /> -1. The character at <paramref name="startIndex" /> + <paramref name="count" /> is not included in the search.</para>
          <para>Index numbering starts from 0 (zero). The <paramref name="startIndex" /> parameter can range from 0 to the length of the string instance.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence of the specified character in this instance. The search starts at a specified character position and examines a specified number of character positions.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode character to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of character positions to examine. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="count" /> is negative</para>
          <para> -or-</para>
          <para>
            <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from 0 (zero). The <paramref name="startIndex" /> parameter can range from 0 to the length of the string instance.</para>
          <para>This method performs a word (case-sensitive and culture-sensitive) search using the current culture. The search begins at <paramref name="startIndex" /> and continues to <paramref name="startIndex" /> + <paramref name="count" /> -1. The character at <paramref name="startIndex" /> + <paramref name="count" /> is not included in the search.</para>
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins. In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings. Only one of the strings contains the required substring. In both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</para>
          <para>code reference: System.String.IndexOf#23</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence of the specified string in this instance. The search starts at a specified character position and examines a specified number of character positions.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of character positions to examine. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from 0. The <paramref name="startIndex" /> parameter can range from 0 to the length of the string instance. If <paramref name="startIndex" /> equals the length of the string instance, the method returns -1.</para>
          <para>The <paramref name="comparisonType" /> parameter specifies to search for the <paramref name="value" /> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object. Parameters specify the starting search position in the current string and the type of search to use for the specified string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. </param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies the rules for the search. </param>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from 0 (zero). The <paramref name="startIndex" /> parameter can range from 0 to the length of the string instance.</para>
          <para>The search begins at <paramref name="startIndex" /> and continues to <paramref name="startIndex" /> + <paramref name="count" /> -1. The character at <paramref name="startIndex" /> + <paramref name="count" /> is not included in the search.</para>
          <para>The <paramref name="comparisonType" /> parameter specifies to search for the <paramref name="value" /> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object. Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of character positions to examine. </param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies the rules for the search. </param>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 IndexOfAny(class System.Char[] anyOf)" />
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is a null reference.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero.</para>
          <para>The search for <paramref name="anyOf" /> is case-sensitive.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</para>
        </returns>
        <param name="anyOf">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode character array containing one or more characters to seek. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 IndexOfAny(class System.Char[] anyOf, int32 startIndex)" />
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is a null reference.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is greater than the length of the current instance</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero. The <paramref name="startIndex" /> parameter can range from 0 to one less than the length of the string instance.</para>
          <para>The search ranges from <paramref name="startIndex" /> to the end of the string.</para>
          <para>The search for <paramref name="anyOf" /> is case-sensitive.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters. The search starts at a specified character position.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</para>
        </returns>
        <param name="anyOf">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode character array containing one or more characters to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 IndexOfAny(class System.Char[] anyOf, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is a null reference.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="count" /> is negative.</para>
          <para>-or-</para>
          <para>
            <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of the current instance. </para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The search begins at <paramref name="startIndex" /> and continues to <paramref name="startIndex" /> + <paramref name="count" /> -1. The character at <paramref name="startIndex" /> + <paramref name="count" /> is not included in the search.</para>
          <para>Index numbering starts from zero. The <paramref name="startIndex" /> parameter can range from 0 to one less than the length of the string instance.</para>
          <para>The search for <paramref name="anyOf" /> is case-sensitive.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters. The search starts at a specified character position and examines a specified number of character positions.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</para>
        </returns>
        <param name="anyOf">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode character array containing one or more characters to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of character positions to examine. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string Insert(int32 startIndex, string value)" />
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is greater than the length of the current instance. </para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="startIndex" /> is equal to the length of this instance, <paramref name="value" /> is appended to the end of this instance.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which <paramref name="value" /> is inserted into the current instance.</para>
          </block>
          <para>For example, the return value of "abc".Insert(2, "XYZ") is "abXYZc".</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string in which a specified string is inserted at a specified index position in this instance. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new string that is equivalent to this instance, but with <paramref name="value" /> inserted at position <paramref name="startIndex" />.</para>
        </returns>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index position of the insertion. </param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to insert. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Intern(string str)" />
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> is a null reference. </exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.Intern(System.String)" /> method.</para>
          <code lang="C#">using System;
using System.Text;
public class StringExample {
 public static void Main() {

     String s1 = "MyTest"; 
        String s2 = new StringBuilder().Append("My").Append("Test").ToString(); 
        String s3 = String.Intern(s2);

        Console.WriteLine(Object.ReferenceEquals(s1, s2));    //different
        Console.WriteLine(Object.ReferenceEquals(s1, s3));    //the same
    }
}
</code>
          <para>The output is</para>
          <c>
            <para>False</para>
            <para>True</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program. Consequently, an instance of a literal string with a particular value only exists once in the system.</para>
          <para>For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</para>
          <para>The <see cref="M:System.String.Intern(System.String)" /> method uses the intern pool to search for a string equal to the value of <paramref name="str" />. If such a string exists, its reference in the intern pool is returned. If the string does not exist, a reference to <paramref name="str" /> is added to the intern pool, then that reference is returned.</para>
          <para>In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program. The <see cref="T:System.Text.StringBuilder" /> class generates a new string object that has the same value as s1. A reference to that string is assigned to s2. The <see cref="M:System.String.Intern(System.String)" /> method searches for a string that has the same value as s2. Because such a string exists, the method returns the same reference that is assigned to s1. That reference is then assigned to s3. References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</para>
          <para>code reference: System.String.Intern#1</para>
          <para>Compare this method to the <see cref="M:System.String.IsInterned(System.String)" /> method.</para>
          <format type="text/html">
            <h2>Version Considerations</h2>
          </format>
          <para>In the net_v35SP1_long, the <see cref="M:System.String.Intern(System.String)" /> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string. In the following example, the variable str1 is assigned a reference to <see cref="F:System.String.Empty" />, and the variable str2 is assigned the reference to <see cref="F:System.String.Empty" /> that is returned by calling the <see cref="M:System.String.Intern(System.String)" /> method after converting a <see cref="T:System.Text.StringBuilder" /> object whose value is <see cref="F:System.String.Empty" /> to a string. Then the references contained in str1 and str2 are compared for equality.</para>
          <para>code reference: System.String.Intern#2</para>
          <para>In the net_v10_short, net_v11_short, and net_v35SP1_short, str1 and str2 are equal. In the net_v20SP1_long and net_v30_long, str1 and str2 are not equal.</para>
          <format type="text/html">
            <h2>Performance Considerations</h2>
          </format>
          <para>If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects. First, the memory allocated for interned <see cref="T:System.String" /> objects is not likely be released until the common language runtime (CLR) terminates. The reason is that the CLR's reference to the interned <see cref="T:System.String" /> object can persist after your application, or even your application domain, terminates. Second, to intern a string, you must first create the string. The memory used by the <see cref="T:System.String" /> object must still be allocated, even though the memory will eventually be garbage collected. </para>
          <para>The .NET Framework version 2.0 introduces the <see cref="F:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning" /> enumeration member. The <see cref="F:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning" /> member marks an assembly as not requiring string-literal interning. You can apply <see cref="F:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning" /> to an assembly using the <see cref="T:System.Runtime.CompilerServices.CompilationRelaxationsAttribute" /> attribute. Also, when you use the <format type="text/html"><a href="44bf97aa-a9a4-4eba-9a0d-cfaa6fc53a66">Native Image Generator (Ngen.exe)</a></format> to compile an assembly in advance of run time, strings are not interned across modules. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the system's reference to the specified <see cref="T:System.String" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The system's reference to <paramref name="str" />, if it is interned; otherwise, a new reference to a string with the value of <paramref name="str" />.</para>
        </returns>
        <param name="str">
          <attribution license="cc4" from="Microsoft" modified="false" />A string to search for in the intern pool. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string IsInterned(string str)" />
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> is a null reference. </exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.IsInterned(System.String)" />
method.</para>
          <code lang="C#">using System;
using System.Text;

public class StringExample {
    public static void Main() {

        String s1 = new StringBuilder().Append("My").Append("Test").ToString(); 

        Console.WriteLine(String.IsInterned(s1) != null);
    }
}
</code>
          <para>The output is</para>
          <para>
            <c>True</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <see cref="T:System.String" /> you add programmatically by calling the <see cref="M:System.String.Intern(System.String)" /> method. </para>
          <para>The intern pool conserves string storage. If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <see cref="T:System.String" /> that have identical values.</para>
          <para>This method looks up <paramref name="str" /> in the intern pool. If <paramref name="str" /> has already been interned, a reference to that instance is returned; otherwise, null is returned.</para>
          <para>Compare this method to the <see cref="M:System.String.Intern(System.String)" /> method.</para>
          <para>This method does not return a Boolean value. If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</para>
          <para>code reference: System.String.IsInterned#1</para>
          <block subset="none" type="note">
            <para>Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the <format type="text/html"><a href="44bf97aa-a9a4-4eba-9a0d-cfaa6fc53a66">Native Image Generator (Ngen.exe)</a></format> to install an assembly to the native image cache on a local computer. For more information, see Performance Considerations in the Remarks section for the <see cref="M:System.String.Intern(System.String)" /> property.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves a reference to a specified <see cref="T:System.String" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A reference to <paramref name="str" /> if it is in the common language runtime intern pool; otherwise, null.</para>
        </returns>
        <param name="str">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to search for in the intern pool. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</para>
          <para>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework currently supports normalization forms C, D, KC, and KD.</para>
          <para>For a description of supported Unicode normalization forms, see <see cref="T:System.Text.NormalizationForm" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether this string is in Unicode normalization form C.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        true if this string is in normalization form C; otherwise, false.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</para>
          <para>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework currently supports normalization forms C, D, KC, and KD.</para>
          <para>For a description of supported Unicode normalization forms, see <see cref="T:System.Text.NormalizationForm" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether this string is in the specified Unicode normalization form.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        true if this string is in the normalization form specified by the <paramref name="normalizationForm" /> parameter; otherwise, false.</para>
        </returns>
        <param name="normalizationForm">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode normalization form. </param>
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <see cref="M:System.String.IsNullOrEmpty(System.String)" /> is a convenience method that enables you to simultaneously test whether a <see cref="T:System.String" /> is null or its value is <see cref="F:System.String.Empty" />. It is equivalent to the following code:</para>
          <para>code reference: System.String.IsNullOrEmpty#1</para>
          <para>You can use the <see cref="M:System.String.IsNullOrWhiteSpace(System.String)" /> method to test whether a string is null, its value is <see cref="F:System.String.Empty" />,  or it consists only of white-space characters. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether the specified string is null or an <see cref="F:System.String.Empty" /> string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        true if the <paramref name="value" /> parameter is null or an empty string (""); otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to test. </param>
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <see cref="M:System.String.IsNullOrWhiteSpace(System.String)" /> is a convenience method that is similar to the following  code, except that it offers superior performance:</para>
          <para>code reference: System.String.IsNullOrWhitespace#2</para>
          <para>White-space characters are defined by the Unicode standard. The <see cref="M:System.String.IsNullOrWhiteSpace(System.String)" /> method interprets any character that returns a value of true when it is passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method as a white-space character.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether a specified string is null, empty, or consists only of white-space characters.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            true if the <paramref name="value" /> parameter is null or <see cref="F:System.String.Empty" />, or if <paramref name="value" /> consists exclusively of white-space characters. </para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to test.</param>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="separator" /> is null, an empty string (<see cref="F:System.String.Empty" />) is used instead. If any member of <paramref name="values" /> is null, an empty string is used instead.</para>
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <see cref="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" /> is a convenience method that lets you concatenate each element in an IEnumerable(Of String) collection without first converting the elements to a string array. It is particularly useful with Language-Integrated Query (LINQ) query expressions. The following example passes a List(Of String) object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M"). The IEnumerable(Of String) collection returned by the <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" /> method is passed to the <see cref="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" /> method to display the result as a single string. </para>
          <para>code reference: System.String.Join#4</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />, using the specified separator between each member.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string. If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to use as a separator. <paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</param>
        <param name="values">
          <attribution license="cc4" from="Microsoft" modified="false" />A collection that contains the strings to concatenate.</param>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="separator" /> is null or if any element of <paramref name="values" /> other than the first element is null, an empty string (<see cref="F:System.String.Empty" />) is used instead. See the Notes for Callers section if the first element of <paramref name="values" /> is null.</para>
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <see cref="M:System.String.Join(System.String,System.Object[])" /> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings. The string representation of each object in the array is derived by calling that object's ToString method. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the elements of an object array, using the specified separator between each element.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> string. If <paramref name="values" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to use as a separator. <paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</param>
        <param name="values">
          <attribution license="cc4" from="Microsoft" modified="false" />An array that contains the elements to concatenate.</param>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Join(string separator, class System.String[] value)" />
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference. </exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.Join(System.String,System.String[])" /> method.</para>
          <code lang="C#">using System;
public class StringJoin {
 public static void Main() {
 String[] strAry = { "Red" , "Green" , "Blue" };
 Console.WriteLine( String.Join( " :: ", strAry ) );
 }
}
</code>
          <para>The output is</para>
          <para>
            <c>Red :: Green
   :: Blue</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For example, if <paramref name="separator" /> is ", " and the elements of <paramref name="value" /> are "apple", "orange", "grape", and "pear", Join(separator, value) returns "apple, orange, grape, pear".</para>
          <para>If <paramref name="separator" /> is null, an empty string (<see cref="F:System.String.Empty" />) is used instead. If any element in <paramref name="value" /> is null, an empty string is used instead.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates all the elements of a string array, using the specified separator between each element. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that consists of the elements in <paramref name="value" /> delimited by the <paramref name="separator" /> string. If <paramref name="value" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to use as a separator. <paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />An array that contains the elements to concatenate. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static string Join(string separator, class System.String[] value, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> plus <paramref name="count" /> is greater than the number of elements in <paramref name="value" />.</exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.Join(System.String,System.String[])" /> method.</para>
          <code lang="C#">using System;
public class StringJoin {
 public static void Main() {
 String[] strAry = { "Red" , "Green" , "Blue" };
 Console.WriteLine( String.Join( " :: ", strAry, 1, 2 ) );
 }
}
</code>
          <para>The output is</para>
          <para>
            <c>Green ::
   Blue</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For example, if <paramref name="separator" /> is ", " and the elements of <paramref name="value" /> are "apple", "orange", "grape", and "pear", Join(separator, value, 1, 2) returns "orange, grape".</para>
          <para>If <paramref name="separator" /> is null, an empty string (<see cref="F:System.String.Empty" />) is used instead. If any element in <paramref name="value" /> is null, an empty string is used instead.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the specified elements of a string array, using the specified separator between each element. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that consists of the strings in <paramref name="value" /> delimited by the <paramref name="separator" /> string. </para>
          <para>-or-</para>
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <see cref="F:System.String.Empty" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or <paramref name="separator" /> and all the elements of <paramref name="value" /> are <see cref="F:System.String.Empty" />.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to use as a separator. <paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</param>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />An array that contains the elements to concatenate. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The first element in <paramref name="value" /> to use. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of elements of <paramref name="value" /> to use. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="separator" /> is null, an empty string (<see cref="F:System.String.Empty" />) is used instead. If any member of <paramref name="values" /> is null, an empty string is used instead.</para>
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <see cref="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" /> is a convenience method that lets you concatenate each member of an <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection without first converting them to strings. The string representation of each object in the <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection is derived by calling that object's ToString method. </para>
          <para>This method is particular useful with Language-Integrated Query (LINQ) query expressions. For example, the following code defines a very simple Animal class that contains the name of an animal and the order to which it belongs. It then defines a <see cref="T:System.Collections.Generic.List`1" /> object that contains a number of Animal objects. The <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" /> extension method is called to extract the Animal objects whose Order property equals "Rodent". The result is passed to the <see cref="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" /> method.</para>
          <para>code reference: System.String.Join#5</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Concatenates the members of a collection, using the specified separator between each member.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string. If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to use as a separator. <paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</param>
        <param name="values">
          <attribution license="cc4" from="Microsoft" modified="false" />A collection that contains the objects to concatenate.</param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the members of <paramref name="values" />.</typeparam>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 LastIndexOf(valuetype System.Char value)" />
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <see cref="P:System.String.Length" /> - 1.</para>
          <para>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either <paramref name="value" /> is found or the first character position has been examined. The search is case-sensitive.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The Unicode character to seek. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 LastIndexOf(string value)" />
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <see cref="P:System.String.Length" /> - 1.</para>
          <para>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <paramref name="value" /> is found or the first character position has been examined.</para>
          <para>This method performs a word (case-sensitive and culture-sensitive) search using the current culture. </para>
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String)" /> method always returns <see cref="P:System.String.Length" /> – 1, which represents the last index position in the current instance. In the following example, the <see cref="M:System.String.LastIndexOf(System.String)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings. Only one of the strings contains a soft hyphen. In each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <paramref name="value" />. When searching for a soft hyphen only, the method returns 6 and 5. These values correspond to the index of the last character in the two strings.</para>
          <para>code reference: System.String.LastIndexOf#21</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index position of the last occurrence of a specified string within this instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 LastIndexOf(valuetype System.Char value, int32 startIndex)" />
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</exception>
        <example>
          <para>The following example demonstrates the <see cref="M:System.String.LastIndexOf(System.Char)" /> 
method.</para>
          <code lang="C#">using System;
public class StringLastIndexOfTest {
   public static void Main() {
      String str = "aa bb cc dd";
      
      Console.WriteLine( str.LastIndexOf('d', 8) );
      Console.WriteLine( str.LastIndexOf('b', 8) );
   }
}
</code>
          <para>The output is</para>
          <c>
            <para>-1</para>
            <para>4</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <see cref="P:System.String.Length" /> - 1.This method begins searching at the <paramref name="startIndex" /> character position of this instance and proceeds backward toward the beginning of the current instance until either <paramref name="value" /> is found or the first character position has been examined. For example, if <paramref name="startIndex" /> is <see cref="P:System.String.Length" /> - 1, the method searches every character from the last character in the string to the beginning. The search is case-sensitive.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The Unicode character to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting position of the search. The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex)" />
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference. <paramref name="" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than zero or greater than or equal to the length of the current instance. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <see cref="P:System.String.Length" /> - 1.</para>
          <para>The search begins at the <paramref name="startIndex" /> character position of this instance and proceeds backward toward the beginning until either <paramref name="value" /> is found or the first character position has been examined. For example, if <paramref name="startIndex" /> is <see cref="P:System.String.Length" /> - 1, the method searches every character from the last character in the string to the beginning. </para>
          <para>This method performs a word (case-sensitive and culture-sensitive) search using the current culture. </para>
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins. In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32)" /> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string. Because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n". When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of <paramref name="startIndex" />.</para>
          <para>code reference: System.String.LastIndexOf#22</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <see cref="P:System.String.Length" /> - 1.</para>
          <para>The <paramref name="comparisonType" /> parameter specifies to search for the <paramref name="value" /> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</para>
          <para>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <paramref name="value" /> is found or the first character position has been examined.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object. A parameter specifies the type of search to use for the specified string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies the rules for the search. </param>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 LastIndexOf(valuetype System.Char value, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</para>
          <para> -or-</para>
          <para>
            <paramref name="startIndex" /> - <paramref name="count" /> is less than -1.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <see cref="P:System.String.Length" /> - 1.</para>
          <para>This method begins searching at the <paramref name="startIndex" /> character position and proceeds backward toward the beginning of this instance until either <paramref name="value" /> is found or <paramref name="count" /> character positions have been examined. For example, if <paramref name="startIndex" /> is <see cref="P:System.String.Length" /> - 1, the method searches backward <paramref name="count" /> characters from the last character in the string. The search is case-sensitive.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The Unicode character to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting position of the search. The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of character positions to examine. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value " />is a null reference.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</para>
          <para> -or-</para>
          <para>
            <paramref name="startIndex" /> - <paramref name="count" /> is smaller than -1.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <see cref="P:System.String.Length" /> - 1.</para>
          <para>The search begins at the <paramref name="startIndex" /> character position of this instance and proceeds backward toward the beginning until either <paramref name="value" /> is found or <paramref name="count" /> character positions have been examined. For example, if <paramref name="startIndex" /> is <see cref="P:System.String.Length" /> - 1, the method searches backward <paramref name="count" /> characters from the last character in the string. </para>
          <para>This method performs a word (case-sensitive and culture-sensitive) search using the current culture. </para>
          <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins. In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" /> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings. Only one of the strings contains the required substring. In both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</para>
          <para>code reference: System.String.LastIndexOf#23</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of character positions to examine. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <see cref="P:System.String.Length" /> - 1.</para>
          <para>The search begins at the <paramref name="startIndex" /> character position and proceeds backward until either <paramref name="value" /> is found or the first character position has been examined. For example, if <paramref name="startIndex" /> is <see cref="P:System.String.Length" /> - 1, the method searches every character from the last character in the string to the beginning. </para>
          <para>The <paramref name="comparisonType" /> parameter specifies to search for the <paramref name="value" /> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object. The search starts at a specified character position and proceeds backward toward the beginning of the string. A parameter specifies the type of comparison to perform when searching for the specified string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies the rules for the search. </param>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <see cref="P:System.String.Length" /> - 1.</para>
          <para>The search begins at the <paramref name="startIndex" /> character position and proceeds backward until either <paramref name="value" /> is found or <paramref name="count" /> character positions have been examined. For example, if <paramref name="startIndex" /> is <see cref="P:System.String.Length" /> - 1, the method searches backward <paramref name="count" /> characters from the last character in the string. </para>
          <para>The <paramref name="comparisonType" /> parameter specifies to search for the <paramref name="value" /> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</para>
          <para />
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions. A parameter specifies the type of comparison to perform when searching for the specified string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />. If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of character positions to examine. </param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that specifies the rules for the search. </param>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 LastIndexOfAny(class System.Char[] anyOf)" />
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is a null reference. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero.</para>
          <para>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in <paramref name="anyOf" /> is found or the first character position has been examined. The search is case-sensitive.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</para>
        </returns>
        <param name="anyOf">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode character array containing one or more characters to seek. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 LastIndexOfAny(class System.Char[] anyOf, int32 startIndex)" />
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is a null reference.<paramref name="" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> is less than zero or greater than or equal to the length of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero.</para>
          <para>This method begins searching at the <paramref name="startIndex" /> character position of this instance and proceeds backward toward the beginning until either a character in <paramref name="anyOf" /> is found or the first character position has been examined. The search is case-sensitive.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array. The search starts at a specified character position and proceeds backward toward the beginning of the string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</para>
        </returns>
        <param name="anyOf">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode character array containing one or more characters to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance int32 LastIndexOfAny(class System.Char[] anyOf, int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is a null reference.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</para>
          <para> -or-</para>
          <para>
            <paramref name="startIndex" /> - <paramref name="count" /> is smaller than -1.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Index numbering starts from zero.</para>
          <para>This method begins searching at the <paramref name="startIndex" /> character position of this instance and proceeds backward toward the beginning until either a character in <paramref name="anyOf" /> is found or <paramref name="count" /> character positions have been examined. The search is case-sensitive.</para>
          <para>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" /> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</para>
        </returns>
        <param name="anyOf">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode character array containing one or more characters to seek. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The search starting position. The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of character positions to examine. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="ILASM" Value=".property int32 Length { public hidebysig specialname instance int32 get_Length() }" />
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Int32" /> containing the number of characters in the current instance.</para>
        </value>
        <example>
          <para>The following example demonstrates the <see cref="P:System.String.Length" /> property.</para>
          <code lang="C#">using System;
public class StringLengthExample {
 public static void Main() {
 string str = "STRING";
 Console.WriteLine( "The length of string {0} is {1}", str, str.Length );
 }
}
</code>
          <para>The output is</para>
          <para>
            <c>The length
   of string STRING is 6</c>
          </para>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.String.Length" /> property returns the number of <see cref="T:System.Char" /> objects in this instance, not the number of Unicode characters. The reason is that a Unicode character might be represented by more than one <see cref="T:System.Char" />. Use the <see cref="T:System.Globalization.StringInfo" /> class to work with each Unicode character instead of each <see cref="T:System.Char" />.</para>
          <para>In some languages, such as C and C++, a null character indicates the end of a string. In the .NET Framework, a null character can be embedded in a string. When a string includes one or more null characters, they are included in the length of the total string. For example, in the following string, the substrings "abc" and "def" are separated by a null character. The <see cref="P:System.String.Length" /> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</para>
          <para>code reference: System.String.Class#1</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the number of characters in the current <see cref="T:System.String" /> object.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. For example, any of the following code points can represent the letter "ắ": </para>
          <list type="bullet">
            <item>
              <para>U+1EAF</para>
            </item>
            <item>
              <para>U+0103 U+0301</para>
            </item>
            <item>
              <para>U+0061 U+0306 U+0301</para>
            </item>
          </list>
          <para>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</para>
          <para>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework supports the four normalization forms (C, D, KC, and KD) that are defined by the Unicode standard. When two strings are represented in the same normalization form, they can be compared by using ordinal comparison. </para>
          <para>To normalize and compare two strings, do the following: </para>
          <list type="ordered">
            <item>
              <para>Obtain the strings to be compared from an input source, such as a file or a user input device. </para>
            </item>
            <item>
              <para>Call the <see cref="M:System.String.Normalize" /> method to normalize the strings to normalization form C. </para>
            </item>
            <item>
              <para>To compare two strings, call a method that supports ordinal string comparison, such as the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method, and supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> as the <see cref="T:System.StringComparison" /> argument. To sort an array of normalized strings, pass a <paramref name="comparer" /> value of <see cref="P:System.StringComparer.Ordinal" /> or <see cref="P:System.StringComparer.OrdinalIgnoreCase" /> to an appropriate overload of <see cref="M:System.Array.Sort(System.Array)" />. </para>
            </item>
            <item>
              <para>Emit the strings in the sorted output based on the order indicated by the previous step. </para>
            </item>
          </list>
          <para>For a description of supported Unicode normalization forms, see <see cref="T:System.Text.NormalizationForm" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</para>
          <para>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework supports the four normalization forms (C, D, KC, and KD) that are defined by the Unicode standard. When two strings are represented in the same normalization form, they can be compared by using ordinal comparison. </para>
          <para>To normalize and compare two strings, do the following: </para>
          <list type="ordered">
            <item>
              <para>Obtain the strings to be compared from an input source, such as a file or a user input device. </para>
            </item>
            <item>
              <para>Call the <see cref="M:System.String.Normalize(System.Text.NormalizationForm)" /> method to normalize the strings to a specified normalization form. </para>
            </item>
            <item>
              <para>To compare two strings, call a method that supports ordinal string comparison, such as the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method, and supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> as the <see cref="T:System.StringComparison" /> argument. To sort an array of normalized strings, pass a <paramref name="comparer" /> value of <see cref="P:System.StringComparer.Ordinal" /> or <see cref="P:System.StringComparer.OrdinalIgnoreCase" /> to an appropriate overload of <see cref="M:System.Array.Sort(System.Array)" />. </para>
            </item>
            <item>
              <para>Emit the strings in the sorted output based on the order indicated by the previous step. </para>
            </item>
          </list>
          <para>For a description of supported Unicode normalization forms, see <see cref="T:System.Text.NormalizationForm" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <paramref name="normalizationForm" /> parameter.</para>
        </returns>
        <param name="normalizationForm">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode normalization form. </param>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static specialname bool op_Equality(string a, string b)" />
      <MemberSignature Language="C#" Value="public static bool op_Equality (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <altmember cref="M:System.String.Equals(System.Object)" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.op_Equality(System.String,System.String)" /> method defines the operation of the equality operator for the <see cref="T:System.String" /> class. The operator, in turn, calls the static <see cref="M:System.String.Equals(System.String,System.String)" /> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison. </para>
          <block subset="none" type="note">
            <para>The Visual Basic compiler does not resolve the equality operator as a call to the <see cref="M:System.String.op_Equality(System.String,System.String)" /> method. Instead, the equality operator wraps a call to the <see cref="M:Microsoft.VisualBasic.CompilerServices.Operators.CompareString(System.String,System.String,System.Boolean)" /> method.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether two specified strings have the same value.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        true if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, false.</para>
        </returns>
        <param name="a">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to compare, or null. </param>
        <param name="b">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to compare, or null. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static specialname bool op_Inequality(string a, string b)" />
      <MemberSignature Language="C#" Value="public static bool op_Inequality (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <altmember cref="M:System.String.Equals(System.Object)" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.op_Inequality(System.String,System.String)" /> method defines the operation of the inequality operator for the <see cref="T:System.String" /> class.</para>
          <para>This operator is implemented using the <see cref="M:System.String.Equals(System.Object)" /> method, which means the comparands are tested for a combination of reference and value equality. This operator performs an ordinal comparison.</para>
          <block subset="none" type="note">
            <para>   The Visual Basic compiler does not resolve the inequality operator as a call to the <see cref="M:System.String.op_Inequality(System.String,System.String)" /> method. Instead, the inequality operator wraps a call to the <see cref="M:Microsoft.VisualBasic.CompilerServices.Operators.CompareString(System.String,System.String,System.Boolean)" /> method.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether two specified strings have different values.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        true if the value of <paramref name="a" /> is different from the value of <paramref name="b" />; otherwise, false.</para>
        </returns>
        <param name="a">
          <attribution license="cc4" from="Microsoft" modified="false" />The first string to compare, or null. </param>
        <param name="b">
          <attribution license="cc4" from="Microsoft" modified="false" />The second string to compare, or null. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string PadLeft(int32 totalWidth)" />
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="totalWidth " /> is less than zero.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A Unicode space is defined as hexadecimal 0x0020. </para>
          <para>The <see cref="M:System.String.PadLeft(System.Int32)" /> method pads the beginning of the returned string. This means that, when used with right-to-left languages, it pads the right portion of the string.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string that is padded with leading white space so that its total length is <paramref name="totalWidth" /> characters.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <paramref name="totalWidth" />. However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance. If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</para>
        </returns>
        <param name="totalWidth">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, valuetype System.Char paddingChar)" />
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="totalWidth" /> is less than zero.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.PadLeft(System.Int32,System.Char)" /> method pads the beginning of the returned string. This means that, when used with right-to-left languages, it pads the right portion of the string.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string that is padded with leading <paramref name="paddingChar" /> characters so that its total length is <paramref name="totalWidth" /> characters.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />. However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance. If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</para>
        </returns>
        <param name="totalWidth">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </param>
        <param name="paddingChar">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode padding character. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string PadRight(int32 totalWidth)" />
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="totalWidth " />is less than zero.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A Unicode space is defined as hexadecimal 0x0020.</para>
          <para>The <see cref="M:System.String.PadRight(System.Int32)" /> method pads the end of the returned string. This means that, when used with right-to-left languages, it pads the left portion of the string.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string that is padded with trailing white space so that its total length is <paramref name="totalWidth" /> characters.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <paramref name="totalWidth" />. However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance. If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</para>
        </returns>
        <param name="totalWidth">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string PadRight(int32 totalWidth, valuetype System.Char paddingChar)" />
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="totalWidth" /> is less than zero.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.PadRight(System.Int32,System.Char)" /> method pads the end of the returned string. This means that, when used with right-to-left languages, it pads the left portion of the string.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string that is padded with trailing <paramref name="paddingChar" /> characters so that its total length is <paramref name="totalWidth" /> characters.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.  However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance. If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</para>
        </returns>
        <param name="totalWidth">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </param>
        <param name="paddingChar">
          <attribution license="cc4" from="Microsoft" modified="false" />A Unicode padding character. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In the dnprdnshort, strings are zero-based. The value of the <paramref name="startIndex" /> parameter can range from zero to one less than the length of the string instance.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all characters from position <paramref name="startIndex" /> to the end of the original string have been removed.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new string that is equivalent to this string except for the removed characters.</para>
        </returns>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based position to begin deleting characters. </param>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count)" />
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</para>
          <para> -or-</para>
          <para>
            <paramref name="startIndex" /> plus <paramref name="count" /> is greater than the length of the current instance.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In the dnprdnshort, strings are zero-based. The value of the <paramref name="startIndex" /> parameter can range from zero to one less than the length of the string instance.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which the number of characters specified by the <paramref name="count" /> parameter have been removed. The characters are removed at the position specified by <paramref name="startIndex" />.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new string that is equivalent to this instance except for the removed characters.</para>
        </returns>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based position to begin deleting characters. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters to delete. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string Replace(valuetype System.Char oldChar, valuetype System.Char newChar)" />
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <paramref name="oldChar" />.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all occurrences of <paramref name="oldChar" /> are replaced by <paramref name="newChar" />.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that is equivalent to this instance except that all instances of <paramref name="oldChar" /> are replaced with <paramref name="newChar" />. If <paramref name="oldChar" /> is not found in the current instance, the method returns the current instance unchanged. </para>
        </returns>
        <param name="oldChar">
          <attribution license="cc4" from="Microsoft" modified="false" />The Unicode character to be replaced. </param>
        <param name="newChar">
          <attribution license="cc4" from="Microsoft" modified="false" />The Unicode character to replace all occurrences of <paramref name="oldChar" />. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string Replace(string oldValue, string newValue)" />
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="newValue" /> is null, all occurrences of <paramref name="oldValue" /> are removed.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all occurrences of <paramref name="oldValue" /> are replaced by <paramref name="newValue" />.</para>
          </block>
          <para>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <paramref name="oldValue" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />. If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged. </para>
        </returns>
        <param name="oldValue">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to be replaced. </param>
        <param name="newValue">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to replace all occurrences of <paramref name="oldValue" />. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.String[] Split(class System.Char[] separator)" />
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Delimiter characters are not included in the elements of the returned array. </para>
          <para>If this instance does not contain any of the characters in <paramref name="separator" />, the returned array consists of a single element that contains this instance. </para>
          <para>If the <paramref name="separator" /> parameter is null or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return true if they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method. </para>
          <para>Each element of <paramref name="separator" /> defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <see cref="F:System.String.Empty" />. The following table provides examples.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>String value</para>
                </term>
                <description>
                  <para>Separator </para>
                </description>
                <description>
                  <para>Returned array</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>"42, 12, 19" </para>
              </term>
              <description>
                <para>new Char[] {',', ' '} (C#)</para>
                <para>Char() = {","c, " "c}) (Visual Basic)</para>
              </description>
              <description>
                <para>{"42", "", "12", "", "19"} </para>
              </description>
            </item>
            <item>
              <term>
                <para>"42..12..19" </para>
              </term>
              <description>
                <para>new Char[] {'.'} (C#)</para>
                <para>Char() = {"."c} (Visual Basic)</para>
              </description>
              <description>
                <para>{"42", "", "12", "", "19"} </para>
              </description>
            </item>
            <item>
              <term>
                <para>"Banana" </para>
              </term>
              <description>
                <para>new Char[] {'.'} (C#) </para>
                <para>Char() = {"."c} (Visual Basic)</para>
              </description>
              <description>
                <para>{"Banana"} </para>
              </description>
            </item>
            <item>
              <term>
                <para>"Darb\nSmarba" (C#)</para>
                <para>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</para>
              </term>
              <description>
                <para>new Char[] {} (C#)</para>
                <para>Char() = {} (Visual Basic)</para>
              </description>
              <description>
                <para>{"Darb", "Smarba"} </para>
              </description>
            </item>
            <item>
              <term>
                <para>"Darb\nSmarba" (C#)</para>
                <para>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</para>
              </term>
              <description>
                <para>null (C#)</para>
                <para>Nothing (Visual Basic)</para>
              </description>
              <description>
                <para>{"Darb", "Smarba"} </para>
              </description>
            </item>
          </list>
          <format type="text/html">
            <h2>Performance Considerations</h2>
          </format>
          <para>The <see cref="Overload:System.String.Split" /> methods allocate memory for the returned array object and a <see cref="T:System.String" /> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method, and optionally the <see cref="Overload:System.String.Compare" /> method, to locate a substring within a string. </para>
          <para>If you are splitting a string at a separator character, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate the first character of the separator string. Then use the <see cref="Overload:System.String.Compare" /> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</para>
          <para>In addition, if the same set of characters is used to split strings in multiple <see cref="Overload:System.String.Split" /> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a string array that contains the substrings in this instance that are delimited by elements of a specified Unicode character array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array whose elements contain the substrings in this instance that are delimited by one or more characters in <paramref name="separator" />. For more information, see the Remarks section.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of Unicode characters that delimit the substrings in this instance, an empty array that contains no delimiters, or null. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.String[] Split(class System.Char[] separator, int32 count)" />
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is negative.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Delimiter characters are not included in the elements of the returned array. </para>
          <para>If this instance does not contain any of the characters in <paramref name="separator" />, the returned array consists of a single element that contains this instance. If <paramref name="count" /> is zero, an empty array is returned.</para>
          <para>If the <paramref name="separator" /> parameter is null or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return true if they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method.</para>
          <para>Each element of <paramref name="separator" /> defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <see cref="F:System.String.Empty" />. </para>
          <para>If there are more than <paramref name="count" /> substrings in this instance, the first <paramref name="count" /> minus 1 substrings are returned in the first <paramref name="count" /> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</para>
          <para>If <paramref name="count" /> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</para>
          <para>The following table provides examples. </para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>String value </para>
                </term>
                <description>
                  <para>Separator  </para>
                </description>
                <description>
                  <para>Count</para>
                </description>
                <description>
                  <para>Returned array</para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>"42, 12, 19" </para>
              </term>
              <description>
                <para>new Char[] {',', ' '} (C#)</para>
                <para>Char() = {","c, " "c} (Visual Basic) </para>
              </description>
              <description>
                <para>2</para>
              </description>
              <description>
                <para>{"42", " 12, 19"} </para>
              </description>
            </item>
            <item>
              <term>
                <para>"42..12..19" </para>
              </term>
              <description>
                <para>new Char[] {'.'} (C#)</para>
                <para>Char() = {"."c} (Visual Basic)</para>
              </description>
              <description>
                <para>4</para>
              </description>
              <description>
                <para>{"42", "", "12", ".19"} </para>
              </description>
            </item>
            <item>
              <term>
                <para>"Banana" </para>
              </term>
              <description>
                <para>new Char[] {'.'} (C#)</para>
                <para>Char() = {"."c} (Visual Basic)</para>
              </description>
              <description>
                <para>2</para>
              </description>
              <description>
                <para>{"Banana"} </para>
              </description>
            </item>
            <item>
              <term>
                <para>"Darb\nSmarba" (C#)</para>
                <para>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</para>
              </term>
              <description>
                <para>new Char[] {} (C#)</para>
                <para>Char() = {} (Visual Basic) </para>
              </description>
              <description>
                <para>1</para>
              </description>
              <description>
                <para>{"Darb\nSmarba"} (C#)</para>
                <para>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</para>
              </description>
            </item>
            <item>
              <term>
                <para>"Darb\nSmarba" (C#)</para>
                <para>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</para>
              </term>
              <description>
                <para>new Char[] null (C#)</para>
                <para>Char() = Nothing</para>
              </description>
              <description>
                <para>2</para>
              </description>
              <description>
                <para>{"Darb", "Smarba"} </para>
              </description>
            </item>
            <item>
              <term>
                <para>"Darb\nSmarba" (C#)</para>
                <para>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</para>
              </term>
              <description>
                <para>new Char[] null (C#)</para>
                <para>Char() = Nothing</para>
              </description>
              <description>
                <para>100</para>
              </description>
              <description>
                <para>{"Darb", "Smarba"} </para>
              </description>
            </item>
          </list>
          <format type="text/html">
            <h2>Performance Considerations</h2>
          </format>
          <para>The <see cref="Overload:System.String.Split" /> methods allocate memory for the returned array object and a <see cref="T:System.String" /> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method, and optionally the <see cref="Overload:System.String.Compare" /> method, to locate a substring within a string. </para>
          <para>If you are splitting a string at a separator character, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate the first character of the separator string. Then use the <see cref="Overload:System.String.Compare" /> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</para>
          <para>In addition, if the same set of characters is used to split strings in multiple <see cref="Overload:System.String.Split" /> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a string array that contains the substrings in this instance that are delimited by elements of a specified Unicode character array. A parameter specifies the maximum number of substrings to return.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array whose elements contain the substrings in this instance that are delimited by one or more characters in <paramref name="separator" />. For more information, see the Remarks section.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of Unicode characters that delimit the substrings in this instance, an empty array that contains no delimiters, or null. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of substrings to return. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Delimiter characters are not included in the elements of the returned array. </para>
          <para>If this instance does not contain any of the characters in <paramref name="separator" />, the returned array consists of a single element that contains this instance. If the <paramref name="separator" /> parameter is null or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return true if they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method. However, if the <paramref name="separator" /> parameter in the call to this method overload is null, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the null. The following example shows several ways to unambiguously identify this overload.</para>
          <para>code reference: System.String.Split#5</para>
          <para>Each element of <paramref name="separator" /> defines a separate delimiter character. If the <paramref name="options" /> parameter is <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> and the length of this instance is zero, an empty array is returned.</para>
          <para>If the <paramref name="options" /> parameter is <see cref="F:System.StringSplitOptions.None" />, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <see cref="F:System.String.Empty" />. </para>
          <format type="text/html">
            <h2>Performance Considerations</h2>
          </format>
          <para>The <see cref="Overload:System.String.Split" /> methods allocate memory for the returned array object and a <see cref="T:System.String" /> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method, and optionally the <see cref="Overload:System.String.Compare" /> method, to locate a substring within a string. </para>
          <para>If you are splitting a string at a separator character, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate the first character of the separator string. Then use the <see cref="Overload:System.String.Compare" /> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</para>
          <para>In addition, if the same set of characters is used to split strings in multiple <see cref="Overload:System.String.Split" /> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a string array that contains the substrings in this string that are delimited by elements of a specified Unicode character array. A parameter specifies whether to return empty array elements.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />. For more information, see the Remarks section.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of Unicode characters that delimit the substrings in this string, an empty array that contains no delimiters, or null. </param>
        <param name="options">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned. </param>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <format type="text/html">
            <h2>Return value details</h2>
          </format>
          <para>Delimiter strings are not included in the elements of the returned array. </para>
          <para>If this instance does not contain any of the strings in <paramref name="separator" />, the returned array consists of a single element that contains this instance. If the <paramref name="separator" /> parameter is null or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return true if they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method. However, if the <paramref name="separator" /> parameter in the call to this method overload is null, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the null. The following example shows several ways to unambiguously identify this overload.</para>
          <para>code reference: System.String.Split#6</para>
          <para>If the <paramref name="options" /> parameter is <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> and the length of this instance is zero, an empty array is returned.</para>
          <para>Each element of <paramref name="separator" /> defines a separate delimiter that consists of one or more characters. If the <paramref name="options" /> parameter is <see cref="F:System.StringSplitOptions.None" />, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <see cref="F:System.String.Empty" />. </para>
          <format type="text/html">
            <h2>The separator array</h2>
          </format>
          <para>If any of the elements in <paramref name="separator" /> consists of more than a single character, only the first character of that element is considered a delimiter, and any subsequent characters are ignored. For example, if one of the elements in <paramref name="separator" /> is "10", attempting to split the string "This10is10a10string." returns the following four-element array: { "This", "0is", "0a", "0string." }. </para>
          <format type="text/html">
            <h2>Comparison details</h2>
          </format>
          <para>The <see cref="M:System.String.Split(System.String[],System.StringSplitOptions)" /> method extracts the substrings in this string that are delimited by one or more of the strings in the <paramref name="separator" /> parameter, and returns those substrings as elements of an array. </para>
          <para>The <see cref="Overload:System.String.Split" /> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules. For more information about word, string, and ordinal sorts, see the <see cref="T:System.Globalization.CompareOptions" /> enumeration. </para>
          <para>The <see cref="M:System.String.Split(System.String[],System.StringSplitOptions)" /> method ignores any element of <paramref name="separator" /> whose value is null or the empty string ("").</para>
          <para>To avoid ambiguous results when strings in <paramref name="separator" /> have characters in common, the <see cref="Overload:System.String.Split" /> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in <paramref name="separator" /> that is equal to a delimiter in the instance. The order in which substrings are encountered in the instance takes precedence over the order of elements in <paramref name="separator" />.</para>
          <para>For example, consider an instance whose value is "abcdef". If the first element in <paramref name="separator" /> was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f". This is because the substring in the instance, "bcde", is encountered and matches an element in <paramref name="separator" /> before the substring "f" is encountered.</para>
          <para>However, if the first element of <paramref name="separator" /> was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef". This is because "bcd" is the first delimiter in <paramref name="separator" /> that matches a delimiter in the instance. If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def". </para>
          <format type="text/html">
            <h2>Performance considerations</h2>
          </format>
          <para>The <see cref="Overload:System.String.Split" /> methods allocate memory for the returned array object and a <see cref="T:System.String" /> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method, and optionally the <see cref="Overload:System.String.Compare" /> method, to locate a substring within a string. </para>
          <para>If you are splitting a string at a separator character, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate the first character of the separator string. Then use the <see cref="Overload:System.String.Compare" /> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</para>
          <para>In addition, if the same set of characters is used to split strings in multiple <see cref="Overload:System.String.Split" /> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a string array that contains the substrings in this string that are delimited by elements of a specified string array. A parameter specifies whether to return empty array elements.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />. For more information, see the Remarks section.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of single-character strings that delimit the substrings in this string, an empty array that contains no delimiters, or null. </param>
        <param name="options">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned. </param>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Delimiter characters are not included in the elements of the returned array. </para>
          <para>If this instance does not contain any of the characters in <paramref name="separator" />, or the <paramref name="count" /> parameter is 1, the returned array consists of a single element that contains this instance. If the <paramref name="separator" /> parameter is null or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return true if they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method. However, if the <paramref name="separator" /> parameter in the call to this method overload is null, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the null. The following example shows several ways to unambiguously identify this overload. </para>
          <para>code reference: System.String.Split#3</para>
          <para>If the <paramref name="count" /> parameter is zero, or the <paramref name="options" /> parameter is <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> and the length of this instance is zero, an empty array is returned.</para>
          <para>Each element of <paramref name="separator" /> defines a separate delimiter character. If the <paramref name="options" /> parameter is <see cref="F:System.StringSplitOptions.None" />, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <see cref="F:System.String.Empty" />. </para>
          <para>If there are more than <paramref name="count" /> substrings in this instance, the first <paramref name="count" /> minus 1 substrings are returned in the first <paramref name="count" /> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</para>
          <para>If <paramref name="count" /> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</para>
          <format type="text/html">
            <h2>Performance Considerations</h2>
          </format>
          <para>The <see cref="Overload:System.String.Split" /> methods allocate memory for the returned array object and a <see cref="T:System.String" /> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method, and optionally the <see cref="Overload:System.String.Compare" /> method, to locate a substring within a string. </para>
          <para>If you are splitting a string at a separator character, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate the first character of the separator string. Then use the <see cref="Overload:System.String.Compare" /> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</para>
          <para>In addition, if the same set of characters is used to split strings in multiple <see cref="Overload:System.String.Split" /> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a string array that contains the substrings in this string that are delimited by elements of a specified Unicode character array. Parameters specify the maximum number of substrings to return and whether to return empty array elements.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />. For more information, see the Remarks section.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of Unicode characters that delimit the substrings in this string, an empty array that contains no delimiters, or null. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of substrings to return. </param>
        <param name="options">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned. </param>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <format type="text/html">
            <h2>Return value details</h2>
          </format>
          <para>Delimiter strings are not included in the elements of the returned array. </para>
          <para>If this instance does not contain any of the strings in <paramref name="separator" />, or the <paramref name="count" /> parameter is 1, the returned array consists of a single element that contains this instance. If the <paramref name="separator" /> parameter is null or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return true if they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method. However, if the <paramref name="separator" /> parameter in the call to this method overload is null, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the null. The following example shows several ways to unambiguously identify this overload.</para>
          <para>code reference: System.String.Split#4</para>
          <para>If the <paramref name="count" /> parameter is zero, or the <paramref name="options" /> parameter is <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> and the length of this instance is zero, an empty array is returned.</para>
          <para>Each element of <paramref name="separator" /> defines a separate delimiter that consists of one or more characters. If the <paramref name="options" /> parameter is <see cref="F:System.StringSplitOptions.None" />, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <see cref="F:System.String.Empty" />. </para>
          <para>If there are more than <paramref name="count" /> substrings in this instance, the first <paramref name="count" /> minus 1 substrings are returned in the first <paramref name="count" /> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</para>
          <para>If <paramref name="count" /> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</para>
          <format type="text/html">
            <h2>The separator array</h2>
          </format>
          <para>If any of the elements in <paramref name="separator" /> consists of more than a single character, only the first character of that element is considered a delimiter, and any subsequent characters are ignored. For example, if one of the elements in <paramref name="separator" /> is "10", attempting to split the string "This10is10a10string." returns the following four-element array: { "This", "0is", "0a", "0string." }. </para>
          <format type="text/html">
            <h2>Comparison details</h2>
          </format>
          <para>The <see cref="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" /> method extracts the substrings in this string that are delimited by one or more of the strings in the <paramref name="separator" /> parameter, and returns those substrings as elements of an array. </para>
          <para>The <see cref="Overload:System.String.Split" /> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules. For more information about word, string, and ordinal sorts, see the <see cref="T:System.Globalization.CompareOptions" /> enumeration. </para>
          <para>The <see cref="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" /> method ignores any element of <paramref name="separator" /> whose value is null or the empty string ("").</para>
          <para>To avoid ambiguous results when strings in <paramref name="separator" /> have characters in common, the <see cref="Overload:System.String.Split" /> method proceeds from the beginning to the end of the value of the instance, and matches the first element in <paramref name="separator" /> that is equal to a delimiter in the instance. The order in which substrings are encountered in the instance takes precedence over the order of elements in <paramref name="separator" />.</para>
          <para>For example, consider an instance whose value is "abcdef". If the first element in <paramref name="separator" /> was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f". This is because the substring in the instance, "bcde", is encountered and matches an element in <paramref name="separator" /> before the substring "f" is encountered.</para>
          <para>However, if the first element of <paramref name="separator" /> was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef". This is because "bcd" is the first delimiter in <paramref name="separator" /> that matches a delimiter in the instance. If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def". </para>
          <format type="text/html">
            <h2>Performance considerations</h2>
          </format>
          <para>The <see cref="Overload:System.String.Split" /> methods allocate memory for the returned array object and a <see cref="T:System.String" /> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method, and optionally the <see cref="Overload:System.String.Compare" /> method, to locate a substring within a string. </para>
          <para>If you are splitting a string at a separator character, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <see cref="Overload:System.String.IndexOf" /> or <see cref="Overload:System.String.IndexOfAny" /> method to locate the first character of the separator string. Then use the <see cref="Overload:System.String.Compare" /> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</para>
          <para>In addition, if the same set of characters is used to split strings in multiple <see cref="Overload:System.String.Split" /> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a string array that contains the substrings in this string that are delimited by elements of a specified string array. Parameters specify the maximum number of substrings to return and whether to return empty array elements.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />. For more information, see the Remarks section.</para>
        </returns>
        <param name="separator">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of single-character strings that delimit the substrings in this string, an empty array that contains no delimiters, or null. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of substrings to return. </param>
        <param name="options">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned. </param>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance bool StartsWith(string value)" />
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is a null reference. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method compares <paramref name="value" /> to the substring at the beginning of this instance that is the same length as <paramref name="value" />, and returns an indication whether they are equal. To be equal, <paramref name="value" /> must be an empty string (<see cref="F:System.String.Empty" />), must be a reference to this same instance, or must match the beginning of this instance.</para>
          <para>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the beginning of this string instance matches the specified string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        true if <paramref name="value" /> matches the beginning of this string; otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to compare. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> method compares the <paramref name="value" /> parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal. To be equal, <paramref name="value" /> must be a reference to this same string, must be the empty string (""), or must match the beginning of this string. The type of comparison performed by the <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> method depends on the value of the <paramref name="comparisonType" /> parameter. The comparison can use the conventions of the current culture (<see cref="F:System.StringComparison.CurrentCulture" /> and <see cref="F:System.StringComparison.CurrentCultureIgnoreCase" />) or the invariant culture (<see cref="F:System.StringComparison.InvariantCulture" /> and <see cref="F:System.StringComparison.InvariantCultureIgnoreCase" />), or it can consist of a character-by-character comparison of code points (<see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />). The comparison can also be case-sensitive (<see cref="F:System.StringComparison.CurrentCulture" />, <see cref="F:System.StringComparison.InvariantCulture" />, or <see cref="F:System.StringComparison.Ordinal" />), or it can ignore case (<see cref="F:System.StringComparison.CurrentCultureIgnoreCase" />, <see cref="F:System.StringComparison.InvariantCultureIgnoreCase" />, <see cref="F:System.StringComparison.OrdinalIgnoreCase" />).</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    true if this instance begins with <paramref name="value" />; otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to compare. </param>
        <param name="comparisonType">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the enumeration values that determines how this string and <paramref name="value" /> are compared. </param>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method compares the <paramref name="value" /> parameter to the substring at the beginning of this string that is the same length as <paramref name="value" />, and returns a value that indicates whether they are equal. To be equal, <paramref name="value" /> must be an empty string (<see cref="F:System.String.Empty" />), must be a reference to this same instance, or must match the beginning of this instance.</para>
          <para>This method performs a comparison using the specified casing and culture.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                true if the <paramref name="value" /> parameter matches the beginning of this string; otherwise, false.</para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The string to compare. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                true to ignore case during the comparison; otherwise, false.</param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />Cultural information that determines how this string and <paramref name="value" /> are compared. If <paramref name="culture" /> is null, the current culture is used.</param>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string Substring(int32 startIndex)" />
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The index is zero-based.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string that begins at the <paramref name="startIndex" /> position in the current string.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves a substring from this instance. The substring starts at a specified character position and continues to the end of the string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that is equivalent to the substring that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance.</para>
        </returns>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based starting character position of a substring in this instance. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length)" />
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="length" /> is greater than the length of the current instance.</para>
          <para> -or-</para>
          <para>
            <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <paramref name="startIndex" /> is zero-based.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string with <paramref name="length" /> characters starting from the <paramref name="startIndex" /> position in the current string.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that is equivalent to the substring of length <paramref name="length" /> that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance and <paramref name="length" /> is zero.</para>
        </returns>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based starting character position of a substring in this instance. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters in the substring. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>This method is implemented to support the <see cref="T:System.Collections.Generics.IEnumerable&lt;System.Char&gt; " /> interface.</para>
        </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.Collections.IEnumerable" /> interface. For more information, see the <see cref="M:System.Collections.IEnumerable.GetEnumerator" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an enumerator that iterates through the current <see cref="T:System.String" /> object. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An enumerator that can be used to iterate through the current string.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToBoolean(System.String)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            true if the value of the current string is <see cref="F:System.Boolean.TrueString" />; false if the value of the current string is <see cref="F:System.Boolean.FalseString" />.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />This parameter is ignored.</param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToByte(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToChar(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The character at index 0 in the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToDateTime(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToDecimal(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToDouble(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToInt16(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToInt32(System.String,System.IFormatProvider)" /> method.</para>
          <para />
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToInt64(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToSByte(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToSingle(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type targetType, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type targetType, class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="targetType">To be added.</param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information.</param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToUInt16(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToUInt32(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This member is an explicit interface member implementation. It can be used only when the <see cref="T:System.String" /> instance is cast to an <see cref="T:System.IConvertible" /> interface. The recommended alternative is to call the <see cref="M:System.Convert.ToUInt64(System.String,System.IFormatProvider)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The converted value of the current <see cref="T:System.String" /> object.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides culture-specific formatting information. </param>
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Char[] ToCharArray()" />
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the characters in this instance to a Unicode character array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A Unicode character array whose elements are the individual characters of this instance. If this instance is an empty string, the returned array is empty and has a zero length.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance class System.Char[] ToCharArray(int32 startIndex, int32 length)" />
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="startIndex" /> or <paramref name="length" /> is less than zero. </para>
          <para> -or- </para>
          <para>
            <paramref name="startIndex" /> plus <paramref name="length" /> is greater than the length of the current instance. </para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="startIndex" /> parameter is zero-based. That is, the index of the first character in the string instance is zero.</para>
          <para>If <paramref name="length" /> is zero, the returned array is empty and has a zero length. If this instance is null or an empty string (""), the returned array is empty and has a zero length.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the characters in a specified substring in this instance to a Unicode character array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A Unicode character array whose elements are the <paramref name="length" /> number of characters in this instance starting from character position <paramref name="startIndex" />.</para>
        </returns>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The starting position of a substring in this instance. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The length of the substring in this instance. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string ToLower()" />
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method takes into account the casing rules of the current culture.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</para>
          </block>
          <format type="text/html">
            <h2>Security Considerations</h2>
          </format>
          <para>The casing operation that results from calling the <see cref="M:System.String.ToLower" /> method takes the casing conventions of the current culture into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <see cref="M:System.String.ToLowerInvariant" /> or <see cref="M:System.String.ToUpperInvariant" /> methods. This produces the same result in every culture (unlike the <see cref="M:System.String.ToLower" /> method) and performs more efficiently.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a copy of this string converted to lowercase.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string in lowercase.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The casing rules of the culture specified by the <paramref name="culture" /> parameter determine the way the case of the string is changed. </para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</para>
          </block>
          <format type="text/html">
            <h2>Security Considerations</h2>
          </format>
          <para>If you pass the <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> method a <see cref="T:System.Globalization.CultureInfo" /> object other than <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />, the casing operation will take culture-specific rules into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <see cref="M:System.String.ToLowerInvariant" /> or <see cref="M:System.String.ToUpperInvariant" /> method. This produces the same result in every culture and performs more efficiently.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The lowercase equivalent of the current string.</para>
        </returns>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that supplies culture-specific casing rules. </param>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The invariant culture represents a culture that is culture-insensitive. It is associated with the English language but not with a specific country or region. For more information, see <format type="text/html"><a href="3f64ca8a-5349-4b46-b10a-1bff5b86b88b">Using the InvariantCulture Property</a></format>.</para>
          <para>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <see cref="M:System.String.ToLowerInvariant" /> method. The <see cref="M:System.String.ToLowerInvariant" /> method is equivalent to ToLower(CultureInfo.InvariantCulture). The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</para>
          </block>
          <format type="text/html">
            <h2>Security Considerations</h2>
          </format>
          <para>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <see cref="M:System.String.ToLowerInvariant" /> or <see cref="M:System.String.ToUpperInvariant" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a copy of this <see cref="T:System.String" /> object converted to lowercase using the casing rules of the invariant culture.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The lowercase equivalent of the current string.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual string ToString()" />
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <para>
            <block subset="none" type="note"> This method
      overrides <see cref="M:System.Object.ToString" />.</block>
          </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The current string.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="ILASM" Value=".method public final hidebysig virtual string ToString(class System.IFormatProvider provider)" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                <paramref name="provider" /> is reserved, and does not currently participate in this operation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The current string.</para>
        </returns>
        <param name="provider">
          <attribution license="cc4" from="Microsoft" modified="false" />(Reserved) An object that supplies culture-specific formatting information. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string ToUpper()" />
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent. If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</para>
          </block>
          <para>The <see cref="M:System.String.ToUpper" /> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison. A better method to perform case-insensitive comparison is to call a string comparison method that has a <see cref="T:System.StringComparison" /> parameter whose value you set to <see cref="F:System.StringComparison.CurrentCultureIgnoreCase" /> for a culture-sensitive, case-insensitive comparison.</para>
          <format type="text/html">
            <h2>Security Considerations</h2>
          </format>
          <para>The casing operation that results from calling the <see cref="M:System.String.ToUpper" /> method takes the casing conventions of the current culture into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <see cref="M:System.String.ToLowerInvariant" /> or <see cref="M:System.String.ToUpperInvariant" /> method. This produces the same result in every culture (unlike the <see cref="M:System.String.ToUpper" /> method) and performs more efficiently.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a copy of this string converted to uppercase.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The uppercase equivalent of the current string.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The casing rules of the culture specified by the <paramref name="culture" /> parameter determine the way the case of a string is changed. </para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</para>
          </block>
          <format type="text/html">
            <h2>Security Considerations</h2>
          </format>
          <para>If you pass the <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> method a <see cref="T:System.Globalization.CultureInfo" /> object other than <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />, the casing operation will take culture-specific rules into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <see cref="M:System.String.ToLowerInvariant" /> or <see cref="M:System.String.ToUpperInvariant" /> method. This produces the same result in every culture and performs more efficiently.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The uppercase equivalent of the current string.</para>
        </returns>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that supplies culture-specific casing rules. </param>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The invariant culture represents a culture that is culture-insensitive. It is associated with the English language but not with a specific country or region. For more information, see <format type="text/html"><a href="3f64ca8a-5349-4b46-b10a-1bff5b86b88b">Using the InvariantCulture Property</a></format>.</para>
          <para>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <see cref="M:System.String.ToUpperInvariant" /> method. The <see cref="M:System.String.ToUpperInvariant" /> method is equivalent to ToUpper(CultureInfo.InvariantCulture). The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</para>
          </block>
          <format type="text/html">
            <h2>Security Considerations</h2>
          </format>
          <para>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <see cref="M:System.String.ToLowerInvariant" /> or <see cref="M:System.String.ToUpperInvariant" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a copy of this <see cref="T:System.String" /> object converted to uppercase using the casing rules of the invariant culture.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The uppercase equivalent of the current string.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string Trim()" />
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.Trim" /> method removes from the current string all leading and trailing white-space characters. Each leading and trailing trim operation stops when a non-white-space character is encountered. For example, if the current string is "   abc   xyz   ", the <see cref="M:System.String.Trim" /> method returns "abc   xyz".</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</para>
          </block>
          <para>If the current string equals <see cref="F:System.String.Empty" /> or all the characters in the current instance consist of white-space characters, the method returns <see cref="F:System.String.Empty" />.</para>
          <para>White-space characters are defined by the Unicode standard. The <see cref="M:System.String.Trim" /> method removes any leading and trailing characters that produce a return value of true when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes all leading and trailing white-space characters from the current <see cref="T:System.String" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The string that remains after all white-space characters are removed from the start and end of the current string.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string Trim(class System.Char[] trimChars)" />
      <MemberSignature Language="C#" Value="public string Trim (char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.Trim(System.Char[])" /> method removes from the current string all leading and trailing characters that are in the <paramref name="trimChars" /> parameter. Each leading and trailing trim operation stops when a character that is not in <paramref name="trimChars" /> is encountered. For example, if the current string is "123abc456xyz789" and <paramref name="trimChars" /> contains the digits from "1" through "9", the <see cref="M:System.String.Trim(System.Char[])" /> method returns "abc456xyz".</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all leading and trailing <paramref name="trimChars" /> characters found in the current instance are removed.</para>
          </block>
          <para>If the current string equals <see cref="F:System.String.Empty" /> or all the characters in the current instance consist of characters in the <paramref name="trimChars" /> array, the method returns <see cref="F:System.String.Empty" />.</para>
          <para>If <paramref name="trimChars" /> is null or an empty array, this method removes any leading or trailing characters that result in the method returning true when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method,</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes all leading and trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the start and end of the current string. If <paramref name="trimChars" /> is null or an empty array, white-space characters are removed instead.</para>
        </returns>
        <param name="trimChars">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of Unicode characters to remove, or null. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string TrimEnd(class System.Char[] trimChars)" />
      <MemberSignature Language="C#" Value="public string TrimEnd (char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.TrimEnd(System.Char[])" /> method removes from the current string all trailing characters that are in the <paramref name="trimChars" /> parameter. The trim operation stops when the first character that is not in <paramref name="trimChars" /> is encountered at the end of the string. For example, if the current string is "123abc456xyz789" and <paramref name="trimChars" /> contains the digits from "1" through "9", the <see cref="M:System.String.TrimEnd(System.Char[])" /> method returns "123abc456xyz".</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all trailing characters found in <paramref name="trimChars" /> are removed from the current string.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes all trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the end of the current string. If <paramref name="trimChars" /> is null or an empty array, Unicode white-space characters are removed instead.</para>
        </returns>
        <param name="trimChars">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of Unicode characters to remove, or null. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance string TrimStart(class System.Char[] trimChars)" />
      <MemberSignature Language="C#" Value="public string TrimStart (char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.String.TrimStart(System.Char[])" /> method removes from the current string all leading characters that are in the <paramref name="trimChars" /> parameter. The trim operation stops when a character that is not in <paramref name="trimChars" /> is encountered. For example, if the current string is "123abc456xyz789" and <paramref name="trimChars" /> contains the digits from "1" through "9", the <see cref="M:System.String.TrimStart(System.Char[])" /> method returns "abc456xyz789".</para>
          <block subset="none" type="note">
            <para>This method does not modify the value of the current instance. Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Removes all leading occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The string that remains after all occurrences of characters in the <paramref name="trimChars" /> parameter are removed from the start of the current string. If <paramref name="trimChars" /> is null or an empty array, white-space characters are removed instead.</para>
        </returns>
        <param name="trimChars">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of Unicode characters to remove, or null. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>