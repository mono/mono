<?xml version="1.0" encoding="utf-8"?>
<Type Name="Marshal" FullName="System.Runtime.InteropServices.Marshal">
  <TypeSignature Maintainer="auto" Language="C#" Value="public static class Marshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Marshal extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadSafetyStatement>Gtk# is thread aware, but not thread safe; See the &lt;link location="node:gtk-sharp/programming/threads"&gt;Gtk# Thread Programming&lt;/link&gt; for details.</ThreadSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The static methods defined on the <see cref="T:System.Runtime.InteropServices.Marshal" /> class are essential to working with unmanaged code. Most methods defined in this class are typically used by developers who want to provide a bridge between the managed and unmanaged programming models. For example, the <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" /> method copies ANSI characters from a specified string (in the managed heap) to a buffer in the unmanaged heap. It also allocates the target heap of the right size.</para>
      <para>The common language runtime provides specific marshaling capabilities. For details on marshaling behavior, see <format type="text/html"><a href="115f7a2f-d422-4605-ab36-13a8dd28142a">Interop Marshaling</a></format>.</para>
      <para>The Read and Write methods in the <see cref="T:System.Runtime.InteropServices.Marshal" /> class support both aligned and unaligned access.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Provides a collection of methods for allocating unmanaged memory, copying unmanaged memory blocks, and converting managed to unmanaged types, as well as other miscellaneous methods used when interacting with unmanaged code.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName="AddRef">
      <MemberSignature Language="C#" Value="public static int AddRef (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddRef(native int pUnk) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly. In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually. After calling <see cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />, you must decrement the reference count by using a method such as <see cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />. Do not rely on the return value of <see cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />, as it can sometimes be unstable.</para>
          <para>You can call <see cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />, <see cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />, or <see cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" /> to obtain an <see cref="T:System.IntPtr" /> value that represents an <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> interface pointer. You can also use these methods and the <see cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" /> method on managed objects to obtain the COM interfaces represented by the managed object's COM callable wrapper. If you are not familiar with the details of this wrapper type, see <format type="text/html"><a href="D04BE3B5-27B9-4F5B-8469-A44149FABF78">[&lt;topic://cpconcomcallablewrapper&gt;]</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Increments the reference count on the specified interface.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The new value of the reference count on the <paramref name="pUnk" /> parameter.</para>
        </returns>
        <param name="pUnk">
          <attribution license="cc4" from="Microsoft" modified="false" />The interface reference count to increment.</param>
      </Docs>
    </Member>
    <Member MemberName="AllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr AllocCoTaskMem (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocCoTaskMem(int32 cb) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /> is one of two memory allocation API methods in the <see cref="T:System.Runtime.InteropServices.Marshal" /> class. (<see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> is the other.) The initial memory content returned is undefined, and the allocated memory can be larger than the requested number of bytes. This method exposes the COM <see cref="http://go.microsoft.com/fwlink/?LinkId=148626">CoTaskMemAlloc</see> function, which is referred to as the COM task memory allocator.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates a block of memory of specified size from the COM task memory allocator.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An integer representing the address of the block of memory allocated. This memory must be released with <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</para>
        </returns>
        <param name="cb">
          <attribution license="cc4" from="Microsoft" modified="false" />The size of the block of memory to be allocated.</param>
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(int32 cb) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> is one of two memory allocation methods in the <see cref="T:System.Runtime.InteropServices.Marshal" /> class. (<see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /> is the other.) This method exposes the Win32 <see cref="http://go.microsoft.com/fwlink/?LinkId=148628">LocalAlloc</see> function from Kernel32.dll.</para>
          <para>When <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)" /> calls LocalAlloc, it passes a LMEM_FIXED flag, which causes the allocated memory to be locked in place. Also, the allocated memory is not zero-filled.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates memory from the unmanaged memory of the process by using the specified number of bytes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A pointer to the newly allocated memory. This memory must be released using the <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> method.</para>
        </returns>
        <param name="cb">
          <attribution license="cc4" from="Microsoft" modified="false" />The required number of bytes in memory.</param>
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(native int cb) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /> is one of two memory allocation methods in the <see cref="T:System.Runtime.InteropServices.Marshal" /> class. (<see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /> is the other.) This method exposes the Win32 <see cref="http://go.microsoft.com/fwlink/?LinkID=148628">LocalAlloc</see> function from Kernel32.dll.</para>
          <para>When <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)" /> calls LocalAlloc, it passes a LMEM_FIXED flag, which causes the allocated memory to be locked in place. Also, the allocated memory is not zero-filled.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates memory from the unmanaged memory of the process by using the pointer to the specified number of bytes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A pointer to the newly allocated memory. This memory must be released using the <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> method.</para>
        </returns>
        <param name="cb">
          <attribution license="cc4" from="Microsoft" modified="false" />The required number of bytes in memory.</param>
      </Docs>
    </Member>
    <Member MemberName="BindToMoniker">
      <MemberSignature Language="C#" Value="public static object BindToMoniker (string monikerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object BindToMoniker(string monikerName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="monikerName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)" /> exposes the COM BindToMoniker method, which produces an object that you can cast to any COM interface you require. This method provides the same functionality as the GetObject method in Visual Basic 6.0 and vbprvblong.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an interface pointer identified by the specified moniker.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object containing a reference to the interface pointer identified by the <paramref name="monikerName" /> parameter. A moniker is a name, and in this case, the moniker is defined by an interface.</para>
        </returns>
        <param name="monikerName">
          <attribution license="cc4" from="Microsoft" modified="false" />The moniker corresponding to the desired interface pointer.</param>
      </Docs>
    </Member>
    <Member MemberName="ChangeWrapperHandleStrength">
      <MemberSignature Language="C#" Value="public static void ChangeWrapperHandleStrength (object otp, bool fIsWeak);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangeWrapperHandleStrength(object otp, bool fIsWeak) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otp" Type="System.Object" />
        <Parameter Name="fIsWeak" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)" /> is used for object pooling functionality and should never be called by user code directly.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Changes the strength of an object's <format type="text/html"><a href="d04be3b5-27b9-4f5b-8469-a44149fabf78">COM Callable Wrapper</a></format> (CCW) handle.</para>
        </summary>
        <param name="otp">
          <attribution license="cc4" from="Microsoft" modified="false" />The object whose CCW holds a reference counted handle. The handle is strong if the reference count on the CCW is greater than zero; otherwise, it is weak.</param>
        <param name="fIsWeak">
          <attribution license="cc4" from="Microsoft" modified="false" />true to change the strength of the handle on the <paramref name="otp" /> parameter to weak, regardless of its reference count; false to reset the handle strength on <paramref name="otp" /> to be reference counted.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (byte[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(unsigned int8[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from a one-dimensional, managed 8-bit unsigned integer array to an unmanaged memory pointer.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional array to copy from.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the source array where copying should start.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy to.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (char[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(char[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from a one-dimensional, managed character array to an unmanaged memory pointer.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional array to copy from.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the source array where copying should start.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy to.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (double[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from a one-dimensional, managed double-precision floating-point number array to an unmanaged memory pointer.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional array to copy from.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the source array where copying should start.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy to.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (short[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int16[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from a one-dimensional, managed 16-bit signed integer array to an unmanaged memory pointer.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional array to copy from.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the source array where copying should start.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy to.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (int[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from a one-dimensional, managed 32-bit signed integer array to an unmanaged memory pointer.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional array to copy from.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the source array where copying should start.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy to.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (long[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from a one-dimensional, managed 64-bit signed integer array to an unmanaged memory pointer.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional array to copy from.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the source array where copying should start.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy to.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, byte[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, unsigned int8[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unmanaged, C-style arrays do not contain bounds information, which prevents the <paramref name="startIndex" /> and <paramref name="length" /> parameters from being validated. Thus, the unmanaged data corresponding to the <paramref name="source" /> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from an unmanaged memory pointer to a managed 8-bit unsigned integer array.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy from.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The array to copy to.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the destination array where copying should start.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, char[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, char[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unmanaged, C-style arrays do not contain bounds information, which prevents the <paramref name="startIndex" /> and <paramref name="length" /> parameters from being validated. Thus, the unmanaged data corresponding to the <paramref name="source" /> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from an unmanaged memory pointer to a managed character array.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy from.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The array to copy to.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the destination array where copying should start.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, double[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unmanaged, C-style arrays do not contain bounds information, which prevents the <paramref name="startIndex" /> and <paramref name="length" /> parameters from being validated. Thus, the unmanaged data corresponding to the <paramref name="source" /> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from an unmanaged memory pointer to a managed double-precision floating-point number array.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy from.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The array to copy to.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the destination array where copying should start.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, short[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int16[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unmanaged, C-style arrays do not contain bounds information, which prevents the <paramref name="startIndex" /> and <paramref name="length" /> parameters from being validated. Thus, the unmanaged data corresponding to the <paramref name="source" /> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from an unmanaged memory pointer to a managed 16-bit signed integer array.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy from.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The array to copy to.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the destination array where copying should start.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, int[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unmanaged, C-style arrays do not contain bounds information, which prevents the <paramref name="startIndex" /> and <paramref name="length" /> parameters from being validated. Thus, the unmanaged data corresponding to the <paramref name="source" /> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from an unmanaged memory pointer to a managed 32-bit signed integer array.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy from.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The array to copy to.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the destination array where copying should start.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, long[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unmanaged, C-style arrays do not contain bounds information, which prevents the <paramref name="startIndex" /> and <paramref name="length" /> parameters from being validated. Thus, the unmanaged data corresponding to the <paramref name="source" /> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from an unmanaged memory pointer to a managed 64-bit signed integer array.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy from.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The array to copy to.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the destination array where copying should start.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, IntPtr[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, native int[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unmanaged, C-style arrays do not contain bounds information, which prevents the <paramref name="startIndex" /> and <paramref name="length" /> parameters from being validated. Therefore, the unmanaged data that corresponds to the <paramref name="source" /> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling the <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from an unmanaged memory pointer to a managed <see cref="T:System.IntPtr" /> array.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy from. </param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The array to copy to.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the destination array where copying should start.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, float[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Unmanaged, C-style arrays do not contain bounds information, which prevents the <paramref name="startIndex" /> and <paramref name="length" /> parameters from being validated. Thus, the unmanaged data corresponding to the <paramref name="source" /> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from an unmanaged memory pointer to a managed single-precision floating-point number array.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy from. </param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The array to copy to. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the destination array where copying should start. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy. </param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method to copy a subset of a one-dimensional managed <see cref="T:System.IntPtr" /> array to an unmanaged C-style array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from a one-dimensional, managed <see cref="T:System.IntPtr" /> array to an unmanaged memory pointer.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional array to copy from.</param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the source array where copying should start.</param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy to.</param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (float[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies data from a one-dimensional, managed single-precision floating-point number array to an unmanaged memory pointer.</para>
        </summary>
        <param name="source">
          <attribution license="cc4" from="Microsoft" modified="false" />The one-dimensional array to copy from. </param>
        <param name="startIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based index in the source array where copying should start. </param>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The memory pointer to copy to. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of array elements to copy. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject (IntPtr pOuter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject(native int pOuter, object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)" /> method aggregates the inner managed pointer of a managed object with the specified outer pointer, and then returns an inner <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> pointer of the managed object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Aggregates a managed object with the specified COM object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The inner IUnknown pointer of the managed object.</para>
        </returns>
        <param name="pOuter">
          <attribution license="cc4" from="Microsoft" modified="false" />The outer IUnknown pointer.</param>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />An object to aggregate.</param>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject&lt;T&gt; (IntPtr pOuter, T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject&lt;T&gt;(native int pOuter, !!T o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="pOuter">To be added.</param>
        <param name="o">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType">
      <MemberSignature Language="C#" Value="public static object CreateWrapperOfType (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateWrapperOfType(object o, class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)" /> converts one COM class type, typically the generic __ComObject type, to another COM class type. The input COM object, represented by parameter <paramref name="o" />, is a <format type="text/html"><a href="7e542583-1e31-4e10-b523-8cf2f29cb4a4">Runtime Callable Wrapper</a></format> (RCW).</para>
          <para>Both the <paramref name="t" /> and <paramref name="o" /> parameters must be classes whose signatures are attributed with <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />. The <format type="text/html"><a href="ec0a8d63-11b3-4acd-b398-da1e37e97382">Tlbimp.exe (Type Library Importer)</a></format> tool applies this attribute for you when it imports a type library. If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</para>
          <para>Tlbimp.exe imports a COM <format type="text/html"><a href="333d0904-ffa2-4d25-878d-7422bcd40582">coclass</a></format> as a managed class and an interface. The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class". For example, a coclass called MyCoclass becomes a coclass interface called MyCoclass and a managed class called MyCoclassClass. Since <paramref name="t" /> must be a class, not an interface, be sure to specify the managed class (MyCoclassClass) and not the coclass interface.</para>
          <block subset="none" type="note">
            <para>You lose the identity of the input COM object because a new RCW instance wraps the <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> pointer exposed by the original RCW.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Wraps the specified COM object in an object of the specified type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The newly wrapped object that is an instance of the desired type.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to be wrapped. </param>
        <param name="t">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of wrapper to create. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType&lt;T,TWrapper&gt;">
      <MemberSignature Language="C#" Value="public static TWrapper CreateWrapperOfType&lt;T,TWrapper&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TWrapper CreateWrapperOfType&lt;T, TWrapper&gt;(!!T o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TWrapper</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TWrapper" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TWrapper">To be added.</typeparam>
        <param name="o">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure">
      <MemberSignature Language="C#" Value="public static void DestroyStructure (IntPtr ptr, Type structuretype);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure(native int ptr, class System.Type structuretype) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structuretype" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method to free reference-type fields, such as strings, of an unmanaged structure. Unlike its fields, a structure can be a value type or a reference type. Value-type structures that contain value-type fields (all blittable) have no references whose memory must be freed. The <see cref="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" /> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> calls the COM <see cref="http://go.microsoft.com/fwlink/?LinkId=148633">SysFreeString</see> function, which, in turn, frees an allocated string.</para>
          <para>In addition to <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />, the <see cref="T:System.Runtime.InteropServices.Marshal" /> class provides two other memory-deallocation methods: <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees all substructures that the specified unmanaged memory block points to.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to an unmanaged block of memory. </param>
        <param name="structuretype">
          <attribution license="cc4" from="Microsoft" modified="false" />Type of a formatted class. This provides the layout information necessary to delete the buffer in the <paramref name="ptr" /> parameter.</param>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DestroyStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method to free reference type fields, such as strings, of an unmanaged structure. Unlike its fields, a structure can be a value type or a reference type. Value type structures that contain value type fields (all blittable) have no references whose memory must be freed. The <see cref="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" /> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> calls the COM <see cref="http://go.microsoft.com/fwlink/?LinkId=148633">SysFreeString</see> function, which, in turn, frees an allocated string.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>[Supported in the .NET Framework 4.5.1 only] </para>
          <para>Frees all substructures of a specified type that the specified unmanaged memory block points to. </para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to an unmanaged block of memory. </param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the formatted structure. This provides the layout information necessary to delete the buffer in the <paramref name="ptr" /> parameter. </typeparam>
      </Docs>
    </Member>
    <Member MemberName="FinalReleaseComObject">
      <MemberSignature Language="C#" Value="public static int FinalReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FinalReleaseComObject(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" /> method releases the managed reference to a COM object. Calling this method is equivalent to calling the <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" /> method in a loop until it returns 0 (zero).</para>
          <para>When the reference count on the COM object becomes 0, the COM object is usually freed, although this depends on the COM object's implementation and is beyond the control of the runtime. However, the RCW can still exist, waiting to be garbage-collected.</para>
          <para>The COM object cannot be used after it has been separated from its underlying RCW. If you try to call a method on the RCW after its reference count becomes 0, a <see cref="T:System.Runtime.InteropServices.InvalidComObjectException" /> will be thrown.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases all references to a <format type="text/html"><a href="7e542583-1e31-4e10-b523-8cf2f29cb4a4">Runtime Callable Wrapper</a></format> (RCW) by setting its reference count to 0.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The new value of the reference count of the RCW associated with the <paramref name="o" /><legacyItalic> </legacyItalic>parameter, which is 0 (zero) if the release is successful.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The RCW to be released.</param>
      </Docs>
    </Member>
    <Member MemberName="FreeBSTR">
      <MemberSignature Language="C#" Value="public static void FreeBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeBSTR(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Like <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />, you can use this method to deallocate memory. <see cref="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" /> calls the COM <see cref="http://go.microsoft.com/fwlink/?LinkID=148633">SysFreeString</see> function, which frees memory allocated by any of the following unmanaged methods: SysAllocString, SysAllocStringByteLen, SysAllocStringLen, SysReAllocString, SysReAllocStringLen. You can call unmanaged methods such as these with platform invoke. For details, see <format type="text/html"><a href="ECA7606E-EBFB-4F47-B8D9-289903FDC045">[&lt;topic://cpconconsumingunmanageddllfunctions&gt;]</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees a BSTR using the COM <see cref="http://go.microsoft.com/fwlink/?LinkID=148633">SysFreeString</see> function.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the BSTR to be freed. </param>
      </Docs>
    </Member>
    <Member MemberName="FreeCoTaskMem">
      <MemberSignature Language="C#" Value="public static void FreeCoTaskMem (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeCoTaskMem(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /> to free any memory allocated by <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />, <see cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />, or any equivalent unmanaged method. If the <paramref name="ptr" /> parameter is null, the method does nothing.</para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /> exposes the COM <see cref="http://go.microsoft.com/fwlink/?LinkId=148638">CoTaskMemFree</see> function, which frees all bytes so that you can no longer use the memory that the <paramref name="ptr" /> parameter points to.</para>
          <para>In addition to <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />, the <see cref="T:System.Runtime.InteropServices.Marshal" /> class provides two other memory-deallocation methods: <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees a block of memory allocated by the unmanaged COM task memory allocator.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the memory to be freed. </param>
      </Docs>
    </Member>
    <Member MemberName="FreeHGlobal">
      <MemberSignature Language="C#" Value="public static void FreeHGlobal (IntPtr hglobal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeHGlobal(native int hglobal) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hglobal" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> to free any memory from the global heap allocated by <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />, <see cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />, or any equivalent unmanaged API method. If the <paramref name="hglobal" /> parameter is <see cref="F:System.IntPtr.Zero" /> the method does nothing.</para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> exposes the <see cref="http://go.microsoft.com/fwlink/?LinkId=148640">LocalFree</see> function from Kernel32.DLL, which frees all bytes so that you can no longer use the memory pointed to by <paramref name="hglobal" />.</para>
          <para>In addition to <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />, the <see cref="T:System.Runtime.InteropServices.Marshal" /> class provides two other memory-deallocation API methods: <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees memory previously allocated from the unmanaged memory of the process.</para>
        </summary>
        <param name="hglobal">
          <attribution license="cc4" from="Microsoft" modified="false" />The handle returned by the original matching call to <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />. </param>
      </Docs>
    </Member>
    <Member MemberName="GenerateGuidForType">
      <MemberSignature Language="C#" Value="public static Guid GenerateGuidForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GenerateGuidForType(class System.Type type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the type has a GUID in the metadata, it is returned. Otherwise, a GUID is automatically generated. You can use this method to programmatically determine the COM GUID for any managed type, including COM-invisible types. Class interfaces are the only exception because they do not correspond to a managed type. <see cref="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)" /> provides the same functionality as the <see cref="P:System.Type.GUID" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the globally unique identifier (GUID) for the specified type, or generates a GUID using the algorithm used by the Type Library Exporter (Tlbexp.exe).</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An identifier for the specified type.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The type to generate a GUID for. </param>
      </Docs>
    </Member>
    <Member MemberName="GenerateProgIdForType">
      <MemberSignature Language="C#" Value="public static string GenerateProgIdForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateProgIdForType(class System.Type type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the type has a ProgID in the metadata, that ProgID is returned. Otherwise, a ProgID is generated based on the fully qualified name of the type.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a programmatic identifier (ProgID) for the specified type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The ProgID of the specified type.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The type to get a ProgID for. </param>
      </Docs>
    </Member>
    <Member MemberName="GetActiveObject">
      <MemberSignature Language="C#" Value="public static object GetActiveObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetActiveObject(string progID) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)" /> exposes the COM <format type="text/html"><a href="a276e30c-6a7f-4cde-9639-21a9f5170b62">GetActiveObject</a></format> function from OLEAUT32.DLL; however, the latter expects a class identifier (CLSID) instead of the programmatic identifier (<paramref name="ProgID" />) expected by this method. To obtain a running instance of a COM object without a registered <paramref name="ProgID" />, use platform invoke to define the COM <format type="text/html"><a href="a276e30c-6a7f-4cde-9639-21a9f5170b62">GetActiveObject</a></format> function. For a description of platform invoke, see <format type="text/html"><a href="ECA7606E-EBFB-4F47-B8D9-289903FDC045">[&lt;topic://cpconconsumingunmanageddllfunctions&gt;]</a></format>.</para>
          <format type="text/html">
            <h2>ProgID and CLSID</h2>
          </format>
          <para>Keys in the HKEY_CLASSES_ROOT subtree of the registry contain a variety of subkey types. Most of the subkeys are ProgIDs, which map a user-friendly string to a CLSID. Applications often use these human-readable strings instead of the numeric CLSIDs. Often, a component has a version-independent ProgID that is mapped to the latest version of the component that is installed on the system.</para>
          <para>Applications and components primarily use ProgIDs to retrieve their corresponding CLSIDs. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Obtains a running instance of the specified object from the running object table (ROT).</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The object that was requested; otherwise null. You can cast this object to any COM interface that it supports.</para>
        </returns>
        <param name="progID">
          <attribution license="cc4" from="Microsoft" modified="false" />The programmatic identifier (ProgID) of the object that was requested.</param>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method returns an interface pointer that represents the requested interface on the specified object. It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer. Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned. Always use <see cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" /> to decrement the reference count once you have finished with the pointer. You must adhere to the rules defined by COM when using raw COM interface pointers.</para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" /> is useful when calling a method that exposes a COM object parameter as an <see cref="T:System.IntPtr" /> type, or with custom marshaling. Although less common, you can use this method on a managed object to obtain a pointer to the object's COM callable wrapper. For example, you can use <see cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" /> on a managed object that is exported to COM to obtain an interface pointer for <see cref="T:System.Runtime.InteropServices.UCOMIConnectionPointContainer" />. You cannot obtain a pointer to a class interface since a class interface lacks the corresponding type to pass to the second parameter (<paramref name="t" />). Instead, use <see cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" /> to invoke the members on the default interface of the COM callable wrapper, which is usually an auto-dispatch class interface.</para>
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" /> method overload allows query interface customization by default. To specify whether to apply query interface customization, use the <see cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)" /> method overload. </para>
          <para>For additional information, see the <format type="text/html"><a href="d04be3b5-27b9-4f5b-8469-a44149fabf78">COM Callable Wrapper</a></format>, <format type="text/html"><a href="7e542583-1e31-4e10-b523-8cf2f29cb4a4">Runtime Callable Wrapper</a></format>, and <format type="text/html"><a href="733c0dd2-12e5-46e6-8de1-39d5b25df024">Introducing the Class Interface</a></format> topics.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a pointer to an <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> interface that represents the specified interface on the specified object. Custom query interface access is enabled by default.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The interface pointer that represents the specified interface for the object.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that provides the interface. </param>
        <param name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of interface that is requested. </param>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject&lt;T,TInterface&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject&lt;T,TInterface&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject&lt;T, TInterface&gt;(!!T o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TInterface" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TInterface">To be added.</typeparam>
        <param name="o">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObjectInContext (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObjectInContext(object o, class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is the same as <see cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" /> except that it returns null if the caller is not in the same context as the object. It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an interface pointer that represents the specified interface for an object, if the caller is in the same context as that object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The interface pointer specified by <paramref name="t" /> that represents the interface for the specified object, or null if the caller is not in the same context as the object.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that provides the interface.</param>
        <param name="t">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of interface that is requested.</param>
      </Docs>
    </Member>
    <Member MemberName="GetComObjectData">
      <MemberSignature Language="C#" Value="public static object GetComObjectData (object obj, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetComObjectData(object obj, object key) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>All COM objects wrapped in a <format type="text/html"><a href="7e542583-1e31-4e10-b523-8cf2f29cb4a4">Runtime Callable Wrapper</a></format> have an associated hash table, which <see cref="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" /> retrieves. <see cref="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" /> adds data to the hash table. You should never have to call either method from your code.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves data that is referenced by the specified key from the specified COM object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The data represented by the <paramref name="key" /> parameter in the internal hash table of the <paramref name="obj" /> parameter.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The COM object that contains the data that you want.</param>
        <param name="key">
          <attribution license="cc4" from="Microsoft" modified="false" />The key in the internal hash table of <paramref name="obj" /> to retrieve the data from.</param>
      </Docs>
    </Member>
    <Member MemberName="GetComSlotForMethodInfo">
      <MemberSignature Language="C#" Value="public static int GetComSlotForMethodInfo (System.Reflection.MemberInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetComSlotForMethodInfo(class System.Reflection.MemberInfo m) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The zero-based slot number returned by this method accounts for three <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> and possibly four <format type="text/html"><a href="ebbff4bc-36b2-4861-9efa-ffa45e013eb5">IDispatch</a></format> methods, making the value of the first available slot either 3 or 7. <see cref="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" /> provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />.</para>
          <para>You can use this method to retrieve slot numbers for members of interfaces that are not visible from COM and for members of private interfaces. The slot numbers returned correspond to the v-table numbers that would be reserved if the type was exposed to COM. COM-invisible members actually occupy a slot in an exposed v-table, even though the COM client cannot use the slot. You cannot use <see cref="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" /> on a class interface by passing <see cref="T:System.Reflection.MemberInfo" /> from a class. For additional information, see <format type="text/html"><a href="733c0dd2-12e5-46e6-8de1-39d5b25df024">Introducing the Class Interface</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the virtual function table (v-table or VTBL) slot for a specified <see cref="T:System.Reflection.MemberInfo" /> type when that type is exposed to COM.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The VTBL slot <paramref name="m" /> identifier when it is exposed to COM.</para>
        </returns>
        <param name="m">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that represents an interface method.</param>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer">
      <MemberSignature Language="C#" Value="public static Delegate GetDelegateForFunctionPointer (IntPtr ptr, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate GetDelegateForFunctionPointer(native int ptr, class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In versions 1.0 and 1.1 of the .NET Framework, it was possible to pass a delegate representing a managed method to unmanaged code as a function pointer, allowing the unmanaged code to call the managed method through the function pointer. It was also possible for the unmanaged code to pass that function pointer back to the managed code, and the pointer was resolved properly to the underlying managed method.</para>
          <para>In the .NET Framework 2.0 and later versions, you can use the <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" /> methods to marshal delegates in both directions. With <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" />, <paramref name="ptr" /> is imported as a <see cref="T:System.IntPtr" />. A <see cref="T:System.IntPtr" /> can be obtained for a managed delegate by calling <see cref="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" /> and passed as a parameter; it can then be called from inside the unmanaged method. Note that the parameter marshaler can also marshal function pointers to delegates in the .NET Framework 2.0 and later versions.</para>
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" /> method has the following restrictions:</para>
          <list type="bullet">
            <item>
              <para>Generics are not supported in interop scenarios.</para>
            </item>
            <item>
              <para>You cannot pass an invalid function pointer to this method.</para>
            </item>
            <item>
              <para>You can use this method only for pure unmanaged function pointers.</para>
            </item>
            <item>
              <para>You cannot use this method with function pointers obtained through C++ or from the <see cref="M:System.RuntimeMethodHandle.GetFunctionPointer" /> method.</para>
            </item>
            <item>
              <para>You cannot use this method to create a delegate from a function pointer to another managed delegate.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts an unmanaged function pointer to a delegate.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A delegate instance that can be cast to the appropriate delegate type.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The unmanaged function pointer to be converted.</param>
        <param name="t">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the delegate to be returned.</param>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt;(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use the <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)" /> methods to marshal delegates in both directions. </para>
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)" /> method has the following restrictions:</para>
          <list type="bullet">
            <item>
              <para>You cannot pass an invalid function pointer to this method.</para>
            </item>
            <item>
              <para>You can use this method only for pure unmanaged function pointers.</para>
            </item>
            <item>
              <para>You cannot use this method with function pointers obtained through C++ or from the <see cref="M:System.RuntimeMethodHandle.GetFunctionPointer" /> method.</para>
            </item>
            <item>
              <para>You cannot use this method to create a delegate from a function pointer to another managed delegate.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>[Supported in the .NET Framework 4.5.1 only] </para>
          <para>Converts an unmanaged function pointer to a delegate of a specified type. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A instance of the specified delegate type.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The unmanaged function pointer to convert. </param>
        <typeparam name="TDelegate">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the delegate to return. </typeparam>
      </Docs>
    </Member>
    <Member MemberName="GetEndComSlot">
      <MemberSignature Language="C#" Value="public static int GetEndComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEndComSlot(class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method returns the zero-based, v-table number for an interface or a class. When used on a class, the slot number returned refers to the class interface for the class. If the class interface is auto-dual, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients. You can use <see cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" /> in conjunction with <see cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" /> to pass slots within a specified range. For additional information, see <format type="text/html"><a href="733c0dd2-12e5-46e6-8de1-39d5b25df024">Introducing the Class Interface</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the last slot in the virtual function table (v-table or VTBL) of a type when exposed to COM.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The last VTBL slot of the interface when exposed to COM. If the <paramref name="t" /> parameter is a class, the returned VTBL slot is the last slot in the interface that is generated from the class.</para>
        </returns>
        <param name="t">
          <attribution license="cc4" from="Microsoft" modified="false" />A type that represents an interface or class.</param>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionCode">
      <MemberSignature Language="C#" Value="public static int GetExceptionCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetExceptionCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetExceptionCode" /> is exposed for compiler support of structured exception handling (SEH) only. If this method is called before an exception is thrown, it returns 0x0.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves a code that identifies the type of the exception that occurred.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The type of the exception.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="Overload:System.Runtime.InteropServices.Marshal.GetExceptionForHR" /> method to get an <see cref="T:System.Exception" /> based on an HRESULT without having to call the <see cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" /> method and catch the exception.</para>
          <para>The current <format type="text/html"><a href="4dda6909-2d9a-4727-ae0c-b5f90dcfa447">IErrorInfo</a></format> interface is used to construct the exception.</para>
          <para>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <format type="text/html"><a href="610b364b-2761-429d-9c4a-afbc3e66f1b9">How to: Map HRESULTs and Exceptions</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the specified HRESULT error code to a corresponding <see cref="T:System.Exception" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that represents the converted HRESULT.</para>
        </returns>
        <param name="errorCode">
          <attribution license="cc4" from="Microsoft" modified="false" />The HRESULT to be converted.</param>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="Overload:System.Runtime.InteropServices.Marshal.GetExceptionForHR" /> method to get an <see cref="T:System.Exception" /> based on an HRESULT without having to call the <see cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" /> method and catch the exception (thus avoiding the corresponding performance overhead). The <paramref name="errorInfo" /> parameter supplies additional information about the error, such as its textual description and the globally unique identifier (GUID) for the interface that defined the error.</para>
          <para>Use this method overload if you have custom error information that you have to supply in the conversion.</para>
          <para>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <format type="text/html"><a href="610b364b-2761-429d-9c4a-afbc3e66f1b9">How to: Map HRESULTs and Exceptions</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the specified HRESULT error code to a corresponding <see cref="T:System.Exception" /> object, with additional error information passed in an <format type="text/html"><a href="4dda6909-2d9a-4727-ae0c-b5f90dcfa447">IErrorInfo</a></format> interface for the exception object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that represents the converted HRESULT and information obtained from <paramref name="errorInfo" />.</para>
        </returns>
        <param name="errorCode">
          <attribution license="cc4" from="Microsoft" modified="false" />The HRESULT to be converted.</param>
        <param name="errorInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the IErrorInfo interface that provides more information about the error. You can specify IntPtr(0) to use the current IErrorInfo interface, or IntPtr(-1) to ignore the current IErrorInfo interface and construct the exception just from the error code. </param>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionPointers">
      <MemberSignature Language="C#" Value="public static IntPtr GetExceptionPointers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetExceptionPointers() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers" /> is exposed for compiler support of structured exception handling (SEH) only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves a computer-independent description of an exception, and information about the state that existed for the thread when the exception occurred.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A pointer to an <see cref="http://go.microsoft.com/fwlink/?LinkId=148648">EXCEPTION_POINTERS</see> structure.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate(class System.Delegate d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The delegate <paramref name="d" /> is converted to a function pointer that can be passed to unmanaged code using the <format type="text/html"><a href="e212594b-1827-4d07-9527-7d412b300df8">__stdcall</a></format> calling convention.</para>
          <para>You must manually keep the delegate from being collected by the garbage collector from managed code. The garbage collector does not track references to unmanaged code.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts a delegate into a function pointer that is callable from unmanaged code.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate. </para>
        </returns>
        <param name="d">
          <attribution license="cc4" from="Microsoft" modified="false" />The delegate to be passed to unmanaged code.</param>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate&lt;TDelegate&gt; (TDelegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate&lt;TDelegate&gt;(!!TDelegate d) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="d" Type="TDelegate" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">To be added.</typeparam>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHINSTANCE">
      <MemberSignature Language="C#" Value="public static IntPtr GetHINSTANCE (System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHINSTANCE(class System.Reflection.Module m) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When dynamic or in-memory, modules do not have an HINSTANCE.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the instance handle (HINSTANCE) for the specified module.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The HINSTANCE for <paramref name="m" />; or -1 if the module does not have an HINSTANCE.</para>
        </returns>
        <param name="m">
          <attribution license="cc4" from="Microsoft" modified="false" />The module whose HINSTANCE is desired.</param>
      </Docs>
    </Member>
    <Member MemberName="GetHRForException">
      <MemberSignature Language="C#" Value="public static int GetHRForException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForException(class System.Exception e) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" /> also sets up an <format type="text/html"><a href="4dda6909-2d9a-4727-ae0c-b5f90dcfa447">IErrorInfo</a></format> interface for the exception that can be obtained by calling the COM GetErrorInfoNEEDGUID function. You can use this function to return an HRESULT value on a managed class implementation of a COM interface where you apply the <see cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />. Have the attributed method catch all exceptions and use <see cref="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" /> to return the appropriate HRESULT value. Allowing an exception to propagate outside the method produces incorrect behavior. (In fact, the common language runtime fails to pass an exception to a COM client that calls such a method through a v-table.)</para>
          <para>Note that the <see cref="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" /> method sets the IErrorInfo of the current thread. This can cause unexpected results for methods like the <see cref="Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR" /> methods that default to using the IErrorInfo of the current thread if it is set.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts the specified exception to an HRESULT.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The HRESULT mapped to the supplied exception.</para>
        </returns>
        <param name="e">
          <attribution license="cc4" from="Microsoft" modified="false" />The exception to convert to an HRESULT.</param>
      </Docs>
    </Member>
    <Member MemberName="GetHRForLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetHRForLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForLastWin32Error() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The target function must have had the setLastError metadata flag set. For example, the SetLastError field of the <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> must be true. The process for setting this flag depends on the source language used: C# and C++ are false by default, but the Declare statement in Visual Basic is true.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the HRESULT corresponding to the last error incurred by Win32 code executed using <see cref="T:System.Runtime.InteropServices.Marshal" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The HRESULT corresponding to the last Win32 error code.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObject(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In managed code, you seldom work directly with the IDispatch interface. However, <see cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" /> is useful when calling a method that exposes a COM object parameter as an <see cref="T:System.IntPtr" /> type, or with custom marshaling. Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned. Always use <see cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" /> to decrement the reference count once you have finished with the pointer.</para>
          <para>You can also use this method on a managed object to obtain an interface pointer to the COM callable wrapper for the object. For additional information, see <format type="text/html"><a href="D04BE3B5-27B9-4F5B-8469-A44149FABF78">[&lt;topic://cpconcomcallablewrapper&gt;]</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an <format type="text/html"><a href="ebbff4bc-36b2-4861-9efa-ffa45e013eb5">IDispatch</a></format> interface from a managed object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The IDispatch pointer for the <paramref name="o" /> parameter.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object whose IDispatch interface is requested.</param>
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObjectInContext(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is the same as <see cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" /> except that it returns null if the caller is not in the same context as the object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an <format type="text/html"><a href="ebbff4bc-36b2-4861-9efa-ffa45e013eb5">IDispatch</a></format> interface pointer from a managed object, if the caller is in the same context as that object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The IDispatch interface pointer for the specified object, or null if the caller is not in the same context as the specified object.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object whose IDispatch interface is requested.</param>
      </Docs>
    </Member>
    <Member MemberName="GetITypeInfoForType">
      <MemberSignature Language="C#" Value="public static IntPtr GetITypeInfoForType (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetITypeInfoForType(class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method returns a pointer to an ITypeInfo implementation that is based on the original type. Calling an object with <see cref="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" /> causes the reference count to increment on the interface pointer before the pointer is returned. Always use <see cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" /> to decrement the reference count once you have finished with the pointer. You can apply the <see cref="T:System.Runtime.InteropServices.MarshalAsAttribute" /> to replace standard interop marshaling behavior with this custom marshaler.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> interface from a managed type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A pointer to the ITypeInfo interface for the <paramref name="t" /> parameter.</para>
        </returns>
        <param name="t">
          <attribution license="cc4" from="Microsoft" modified="false" />The type whose ITypeInfo interface is being requested.</param>
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObject(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In managed code, you seldom work directly with the IUnknown interface. However, <see cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" /> is useful when calling a method that exposes a COM object parameter as an <see cref="T:System.IntPtr" /> type, or with custom marshaling. Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned. Always use <see cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" /> to decrement the reference count once you have finished with the pointer. This method provides the opposite functionality of the <see cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" /> method.</para>
          <para>You can also use this method on a managed object to obtain an interface pointer to the <format type="text/html"><a href="d04be3b5-27b9-4f5b-8469-a44149fabf78">COM Callable Wrapper</a></format> for the object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> interface from a managed object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The IUnknown pointer for the <paramref name="o" /> parameter.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object whose IUnknown interface is requested.</param>
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObjectInContext(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is the same as <see cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" /> except that it returns null if the caller is not in the same context as the object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> interface from a managed object, if the caller is in the same context as that object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The IUnknown pointer for the specified object, or null if the caller is not in the same context as the specified object.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object whose IUnknown interface is requested.</param>
      </Docs>
    </Member>
    <Member MemberName="GetLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetLastWin32Error() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> exposes the Win32 <see cref="http://go.microsoft.com/fwlink/?LinkId=148657">GetLastError</see> function from Kernel32.DLL. This method exists because it is not safe to make a direct platform invoke call to GetLastError to obtain this information. If you want to access this error code, you must call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> instead of writing your own platform invoke definition for GetLastError and calling it. The common language runtime can make internal calls to APIs that overwrite the GetLastError maintained by the operating system.</para>
          <para>You can use this method to obtain error codes only if you apply the <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> to the method signature and set the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> field to true. The process for this varies depending upon the source language used: C# and C++ are false by default, but the Declare statement in Visual Basic is true.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the error code returned by the last unmanaged function that was called using platform invoke that has the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> flag set.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The last error code set by a call to the Win32 <see cref="http://go.microsoft.com/fwlink/?LinkId=148656">SetLastError</see> function.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetManagedThunkForUnmanagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetManagedThunkForUnmanagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetManagedThunkForUnmanagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" /> is exposed for compiler support only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a pointer to a runtime-generated function that marshals a call from managed to unmanaged code.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A pointer to the function that will marshal a call from the <paramref name="pfnMethodToWrap" /> parameter to unmanaged code.</para>
        </returns>
        <param name="pfnMethodToWrap">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the method to marshal.</param>
        <param name="pbSignature">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the method signature.</param>
        <param name="cbSignature">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes in <paramref name="pbSignature" />.</param>
      </Docs>
    </Member>
    <Member MemberName="GetMethodInfoForComSlot">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo GetMethodInfoForComSlot (Type t, int slot, ref System.Runtime.InteropServices.ComMemberType memberType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo GetMethodInfoForComSlot(class System.Type t, int32 slot, valuetype System.Runtime.InteropServices.ComMemberType memberType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="slot" Type="System.Int32" />
        <Parameter Name="memberType" Type="System.Runtime.InteropServices.ComMemberType&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="t">To be added: an object of type 'Type'</param>
        <param name="slot">To be added: an object of type 'int'</param>
        <param name="memberType">To be added: an object of type 'ComMemberType&amp;'</param>
        <summary>To be added</summary>
        <returns>To be added: an object of type 'Reflection.MemberInfo'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject (object obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject(object obj, native int pDstNativeVariant) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="pDstNativeVariant" /> parameter must point to sufficient memory to store the resulting VARIANT. Also, the implementation of this method calls <format type="text/html"><a href="96aeb671-5528-4d3c-8e70-313716550b42">VariantInit</a></format> on the raw memory that the <paramref name="pDstNativeVariant" /> parameter points to.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts an object to a COM VARIANT.</para>
        </summary>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The object for which to get a COM VARIANT.</param>
        <param name="pDstNativeVariant">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to receive the VARIANT that corresponds to the <paramref name="obj" /> parameter.</param>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject&lt;T&gt; (T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject&lt;T&gt;(!!T obj, native int pDstNativeVariant) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="obj">To be added.</param>
        <param name="pDstNativeVariant">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetObjectForIUnknown (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForIUnknown(native int pUnk) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method wraps IUnknown in a managed object. This has the effect of incrementing the reference count of the COM component. The reference count will be decremented when the runtime performs garbage collection on the managed object that represents the COM object.</para>
          <para>The <paramref name="pUnk" /> parameter represents an IUnknown interface pointer; however, because all COM interfaces derive directly or indirectly from IUnknown, you can pass any COM interface to this method. The object returned by <see cref="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" /> is a <format type="text/html"><a href="7e542583-1e31-4e10-b523-8cf2f29cb4a4">Runtime Callable Wrapper</a></format>, which the common language runtime manages as it does any other managed object. The type of this wrapper is often a generic System.__ComObject type, which is a hidden type used when the wrapper type is ambiguous. You can still make late-bound calls to such a generic type as long as the COM object implements the <format type="text/html"><a href="ebbff4bc-36b2-4861-9efa-ffa45e013eb5">IDispatch</a></format> interface. Likewise, you can cast the returned object to an appropriate COM interface.</para>
          <para>For an object to be wrapped with a specific managed class type (and not a generic wrapper type), you must adhere to the following requirements: </para>
          <list type="bullet">
            <item>
              <para>Implement the <see cref="http://go.microsoft.com/fwlink/?LinkID=148012">IProvideClassInfo</see> interface for the COM object.</para>
            </item>
            <item>
              <para>Register the containing assembly with the <format type="text/html"><a href="e190e342-36ef-4651-a0b4-0e8c2c0281cb">Assembly Registration Tool (Regasm.exe)</a></format>.</para>
            </item>
          </list>
          <para>Alternatively, you can avoid these requirements and still get an object that is wrapped with a specific managed class type by using the <see cref="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an instance of a type that represents a COM object by a pointer to its <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> interface.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that represents the specified unmanaged COM object.</para>
        </returns>
        <param name="pUnk">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the IUnknown interface. </param>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant">
      <MemberSignature Language="C#" Value="public static object GetObjectForNativeVariant (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForNativeVariant(native int pSrcNativeVariant) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" /> returns a managed object that corresponds to a raw pointer to an unmanaged VARIANT type. The interop marshaler performs the identical transformation when exposing a VARIANT type to managed code.</para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" /> provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />.</para>
          <para>When the VARIANT type is VT_ERROR, <see cref="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" /> returns an object of type Int32 instead of UInt32.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts a COM VARIANT to an object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that corresponds to the <paramref name="pSrcNativeVariant" /> parameter.</para>
        </returns>
        <param name="pSrcNativeVariant">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to a COM VARIANT.</param>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetObjectForNativeVariant&lt;T&gt; (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetObjectForNativeVariant&lt;T&gt;(native int pSrcNativeVariant) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)" /> returns a managed object of type <paramref name="T" /> that corresponds to a raw pointer to an unmanaged VARIANT type. The interop marshaler performs the identical transformation when exposing a VARIANT type to managed code. </para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)" /> provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>[Supported in the .NET Framework 4.5.1 only] </para>
          <para>Converts a COM VARIANT to an object of a specified type. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object of the specified type that corresponds to the <paramref name="pSrcNativeVariant" /> parameter. </para>
        </returns>
        <param name="pSrcNativeVariant">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to a COM VARIANT. </param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type to which to convert the COM VARIANT. </typeparam>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants">
      <MemberSignature Language="C#" Value="public static object[] GetObjectsForNativeVariants (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object[] GetObjectsForNativeVariants(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)" /> returns an array of managed objects that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types. The interop marshaler performs the identical transformation when exposing a VARIANT type to managed code. The method returns an empty array when the <paramref name="cVars" /> parameter is 0.</para>
          <para>The object array (the return value) gets garbage collected as usual. The unmanaged input array or individual VARIANTs in the input array are not freed. Therefore it is your responsibility to free them as appropriate.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts an array of COM <see cref="http://go.microsoft.com/fwlink/?LinkId=148670">VARIANTs</see> to an array of objects. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object array that corresponds to <paramref name="aSrcNativeVariant" />.</para>
        </returns>
        <param name="aSrcNativeVariant">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the first element of an array of COM VARIANTs.</param>
        <param name="cVars">
          <attribution license="cc4" from="Microsoft" modified="false" />The count of COM VARIANTs in <paramref name="aSrcNativeVariant" />.</param>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetObjectsForNativeVariants&lt;T&gt; (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] GetObjectsForNativeVariants&lt;T&gt;(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)" /> returns an array of <paramref name="T" /> that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types. The interop marshaler performs the identical transformation when exposing a VARIANT type to managed code. The method returns an empty array when the <paramref name="cVars" /> parameter is 0.</para>
          <para>The returned array is garbage-collected as usual. The unmanaged input array or individual VARIANTs in the input array are not freed. Therefore, it is your responsibility to free them as appropriate. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>[Supported in the .NET Framework 4.5.1 only] </para>
          <para>Converts an array of COM VARIANTs to an array of a specified type. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of <paramref name="T" /> objects that corresponds to <paramref name="aSrcNativeVariant" />. </para>
        </returns>
        <param name="aSrcNativeVariant">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the first element of an array of COM VARIANTs. </param>
        <param name="cVars">
          <attribution license="cc4" from="Microsoft" modified="false" />The count of COM VARIANTs in <paramref name="aSrcNativeVariant" />. </param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the array to return. </typeparam>
      </Docs>
    </Member>
    <Member MemberName="GetStartComSlot">
      <MemberSignature Language="C#" Value="public static int GetStartComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetStartComSlot(class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method returns the zero-based v-table number for an interface or a class. When used on a class, the slot number that is returned refers to the class interface for the class. If the class interface is auto-dispatch, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients. You can use <see cref="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" /> in conjunction with <see cref="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" /> to pass slots within a specified range. For additional information, see <format type="text/html"><a href="733c0dd2-12e5-46e6-8de1-39d5b25df024">Introducing the Class Interface</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the first slot in the virtual function table (v-table or VTBL) that contains user-defined methods.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The first VTBL slot that contains user-defined methods. The first slot is 3 if the interface is based on <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see>, and 7 if the interface is based on <format type="text/html"><a href="ebbff4bc-36b2-4861-9efa-ffa45e013eb5">IDispatch</a></format>.</para>
        </returns>
        <param name="t">
          <attribution license="cc4" from="Microsoft" modified="false" />A type that represents an interface.</param>
      </Docs>
    </Member>
    <Member MemberName="GetThreadFromFiberCookie">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread GetThreadFromFiberCookie (int cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Thread GetThreadFromFiberCookie(int32 cookie) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Fiber cookies are opaque tokens that are used by the host when alerting the common language runtime to its fiber-scheduling decisions. They consist of a stack and register context.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts a fiber cookie into the corresponding <see cref="T:System.Threading.Thread" /> instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A thread that corresponds to the <paramref name="cookie" /> parameter.</para>
        </returns>
        <param name="cookie">
          <attribution license="cc4" from="Microsoft" modified="false" />An integer that represents a fiber cookie.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypedObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetTypedObjectForIUnknown (IntPtr pUnk, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetTypedObjectForIUnknown(native int pUnk, class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="t" /> parameter must be either a COM-imported type or a subtype of a COM-imported type. In addition, <paramref name="t" /> must be a type whose metadata was imported by the <format type="text/html"><a href="ec0a8d63-11b3-4acd-b398-da1e37e97382">Tlbimp.exe (Type Library Importer)</a></format> tool. This type must be a class and not an associated coclass interface, which carries the name of the COM class. For example, if Tlbimp.exe imports Myclass as a class called MyclassClass and as a coclass interface called Myclass, you must use MyclassClass (not Myclass) with this method. For additional information about imported classes and coclass interfaces, see <format type="text/html"><a href="CB1EE67D-8EF0-4E40-B2A5-13714B9F33C3">[&lt;topic://cpcontlbimptypeconversion&gt;]</a></format>.</para>
          <para>If an object has already been obtained for the <paramref name="pUnk" /> parameter, <paramref name="t" /> is ignored and the existing object is returned. <paramref name="pUnk" /> represents an <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> interface pointer; however, because all COM interfaces derive directly or indirectly from IUnknown, you can pass any COM interface to this method. The object returned by <see cref="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" /> is a <format type="text/html"><a href="7e542583-1e31-4e10-b523-8cf2f29cb4a4">Runtime Callable Wrapper</a></format> (RCW), which the common language runtime manages as it does any other managed object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns a managed object of a specified type that represents a COM object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance of the class corresponding to the <see cref="T:System.Type" /> object that represents the requested unmanaged COM object.</para>
        </returns>
        <param name="pUnk">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the IUnknown interface of the unmanaged object.</param>
        <param name="t">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the requested managed class.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeForITypeInfo">
      <MemberSignature Language="C#" Value="public static Type GetTypeForITypeInfo (IntPtr piTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeForITypeInfo(native int piTypeInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="piTypeInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" /> returns a <see cref="T:System.Type" /> instance that is based on the original type. You can apply the <see cref="T:System.Runtime.InteropServices.MarshalAsAttribute" /> to replace standard interop marshaling behavior with this custom marshaler. The <format type="text/html"><a href="ec0a8d63-11b3-4acd-b398-da1e37e97382">Tlbimp.exe (Type Library Importer)</a></format> tool uses the custom marshaler to translate ITypeInfo parameters to <see cref="T:System.Type" /> parameters. However, if you obtain an ITypeInfo interface by some means other than Tlbimp.exe, you can use <see cref="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" /> to manually perform the same translation.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts an unmanaged <format type="text/html"><a href="f3356463-3373-4279-bae1-953378aa2680">ITypeInfo</a></format> object into a managed <see cref="T:System.Type" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A managed type that represents the unmanaged ITypeInfo object.</para>
        </returns>
        <param name="piTypeInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />The ITypeInfo interface to marshal. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Runtime.InteropServices.ComTypes.ITypeInfo" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can also retrieve the name of the type represented by an ITypeInfo by calling the <see cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" /> method and passing -1 for its first parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the name of the type represented by an <format type="text/html"><a href="f3356463-3373-4279-bae1-953378aa2680">ITypeInfo</a></format> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The name of the type that the <paramref name="typeInfo" /> parameter points to.</para>
        </returns>
        <param name="typeInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that represents an ITypeInfo pointer.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.UCOMITypeInfo pTI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.UCOMITypeInfo pTI) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTI" Type="System.Runtime.InteropServices.UCOMITypeInfo" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can also retrieve the name of the type represented by an ITypeInfo object by calling the <see cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" /> method and passing -1 for its first parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the name of the type represented by an <format type="text/html"><a href="f3356463-3373-4279-bae1-953378aa2680">ITypeInfo</a></format> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The name of the type that the <paramref name="pTI" /> parameter points to.</para>
        </returns>
        <param name="pTI">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that represents an ITypeInfo pointer. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" /> extracts the LIBID directly from an existing type library. This action differs from that of the <see cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" /> method, which calculates what the LIBID should be based on the current assembly.</para>
          <para>For more information about library identifiers, see <format type="text/html"><a href="3fffd8db-240f-4fde-a558-a5bcc01e1a86">Exported Assembly Conversion</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the library identifier (LIBID) of a type library.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The LIBID of the specified type library.</para>
        </returns>
        <param name="typelib">
          <attribution license="cc4" from="Microsoft" modified="false" />The type library whose LIBID is to be retrieved.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" /> extracts the LIBID directly from an existing type library. This action differs from that of the <see cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" /> method, which calculates what the LIBID should be based on the current assembly.</para>
          <para>For more information about library identifiers, see <format type="text/html"><a href="3fffd8db-240f-4fde-a558-a5bcc01e1a86">Exported Assembly Conversion</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the library identifier (LIBID) of a type library.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The LIBID of the type library that the <paramref name="pTLB" /> parameter points to.</para>
        </returns>
        <param name="pTLB">
          <attribution license="cc4" from="Microsoft" modified="false" />The type library whose LIBID is to be retrieved. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuidForAssembly">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuidForAssembly (System.Reflection.Assembly asm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuidForAssembly(class System.Reflection.Assembly asm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asm" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When assemblies are exported to type libraries, the type library is assigned a LIBID. You can set the LIBID explicitly by applying the <see cref="T:System.Runtime.InteropServices.GuidAttribute" /> at the assembly level, or it can be generated automatically. The <format type="text/html"><a href="ec0a8d63-11b3-4acd-b398-da1e37e97382">Tlbimp.exe (Type Library Importer)</a></format> tool calculates a LIBID value based on the identity of the assembly. <see cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" /> returns the LIBID that is associated with the <see cref="T:System.Runtime.InteropServices.GuidAttribute" />, if the attribute is applied. Otherwise, <see cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" /> returns the calculated value. Alternatively, you can use the <see cref="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" /> method to extract the actual LIBID from an existing type library.</para>
          <para>See the <format type="text/html"><a href="3fffd8db-240f-4fde-a558-a5bcc01e1a86">Exported Assembly Conversion</a></format> topic for more information about library identifiers.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the library identifier (LIBID) that is assigned to a type library when it was exported from the specified assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The LIBID that is assigned to a type library when it is exported from the specified assembly.</para>
        </returns>
        <param name="asm">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly from which the type library was exported.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the LCID of a type library.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The LCID of the type library that the <paramref name="typelib" /> parameter points to.</para>
        </returns>
        <param name="typelib">
          <attribution license="cc4" from="Microsoft" modified="false" />The type library whose LCID is to be retrieved.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the LCID of a type library.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The LCID of the type library that the <paramref name="pTLB" /> parameter points to.</para>
        </returns>
        <param name="pTLB">
          <attribution license="cc4" from="Microsoft" modified="false" />The type library whose LCID is to be retrieved.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library. The name is not a file name.</para>
          <para>You can also retrieve the type library name by calling the <see cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" /> method and passing -1 for its first parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the name of a type library.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The name of the type library that the <paramref name="typelib" /> parameter points to.</para>
        </returns>
        <param name="typelib">
          <attribution license="cc4" from="Microsoft" modified="false" />The type library whose name is to be retrieved.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library. The name is not a file name.</para>
          <para>You can also retrieve the type library name by calling the <see cref="M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)" /> method and passing -1 for its first parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Retrieves the name of a type library.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The name of the type library that the <paramref name="pTLB" /> parameter points to.</para>
        </returns>
        <param name="pTLB">
          <attribution license="cc4" from="Microsoft" modified="false" />The type library whose name is to be retrieved.</param>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibVersionForAssembly">
      <MemberSignature Language="C#" Value="public static void GetTypeLibVersionForAssembly (System.Reflection.Assembly inputAssembly, out int majorVersion, out int minorVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetTypeLibVersionForAssembly(class System.Reflection.Assembly inputAssembly, int32 majorVersion, int32 minorVersion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="majorVersion" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="minorVersion" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="inputAssembly">To be added.</param>
        <param name="majorVersion">To be added.</param>
        <param name="minorVersion">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
      </Docs>
    </Member>
    <Member MemberName="GetUniqueObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetUniqueObjectForIUnknown (IntPtr unknown);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUniqueObjectForIUnknown(native int unknown) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unknown" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)" /> method ensures that you receive a unique RCW, because it does not match an IUnknown pointer to an existing object. Use this method when you have to create a unique RCW that is not impacted by other code that calls the <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates a unique <format type="text/html"><a href="7e542583-1e31-4e10-b523-8cf2f29cb4a4">Runtime Callable Wrapper</a></format> (RCW) object for a given <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> interface.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A unique RCW for the specified IUnknown interface.</para>
        </returns>
        <param name="unknown">
          <attribution license="cc4" from="Microsoft" modified="false" />A managed pointer to an IUnknown interface.</param>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedThunkForManagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetUnmanagedThunkForManagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetUnmanagedThunkForManagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" /> is exposed for compiler support only.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a pointer to a runtime-generated function that marshals a call from unmanaged to managed code.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A pointer to a function that will marshal a call from <paramref name="pfnMethodToWrap" /> to managed code.</para>
        </returns>
        <param name="pfnMethodToWrap">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the method to marshal.</param>
        <param name="pbSignature">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the method signature.</param>
        <param name="cbSignature">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes in <paramref name="pbSignature" />.</param>
      </Docs>
    </Member>
    <Member MemberName="IsComObject">
      <MemberSignature Language="C#" Value="public static bool IsComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComObject(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)" /> returns true if the class type of the instance is attributed with <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> or if it derives directly or indirectly from a class attributed with <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />. The <format type="text/html"><a href="ec0a8d63-11b3-4acd-b398-da1e37e97382">Tlbimp.exe (Type Library Importer)</a></format> tool applies this attribute for you when it imports a type library.</para>
          <para>Two other methods also determine whether a specified object represents a COM object, but the requirements for returning true differ from this method's requirements. <see cref="P:System.Type.IsImport" /> returns true if the class (or interface) is attributed with <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> directly; it does not return true for derived types. <see cref="M:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType(System.Type)" /> returns true if the type is attributed with <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> or derives from a type with the same GUID.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether a specified object represents a COM object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the <paramref name="o" /> parameter is a COM type; otherwise, false.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to check.</param>
      </Docs>
    </Member>
    <Member MemberName="IsTypeVisibleFromCom">
      <MemberSignature Language="C#" Value="public static bool IsTypeVisibleFromCom (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTypeVisibleFromCom(class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)" /> enables you to check for COM visibility in one step. Types that are not visible cannot be used from COM. A type is visible if it is public and not hidden with the <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether a type is visible to COM clients.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the type is visible to COM; otherwise, false.</para>
        </returns>
        <param name="t">
          <attribution license="cc4" from="Microsoft" modified="false" />The type to check for COM visibility.</param>
      </Docs>
    </Member>
    <Member MemberName="NumParamBytes">
      <MemberSignature Language="C#" Value="public static int NumParamBytes (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NumParamBytes(class System.Reflection.MethodInfo m) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)" /> method returns the stack size (in bytes) needed to represent the parameters of a method signature in unmanaged memory.</para>
          <para>Note that the return value of this method is platform-dependent. For example, a signature with a single integer parameter returns a value of 4 on 32-bit platforms and a value of 8 on 64-bit platforms.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Calculates the number of bytes in unmanaged memory that are required to hold the parameters for the specified method.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes required to represent the method parameters in unmanaged memory.</para>
        </returns>
        <param name="m">
          <attribution license="cc4" from="Microsoft" modified="false" />The method to be checked.</param>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf (Type t, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf(class System.Type t, string fieldName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" /> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout. Marshaling the structure can transform the layout and alter the offset. The <paramref name="t" /> parameter can be a value type or a formatted reference type (with either a sequential or explicit layout). You can obtain the size of the entire layout by using the <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" /> method. For additional information, see <format type="text/html"><a href="4d9a876c-e05a-40ba-bd85-bd22877f984a">Default Marshaling for Value Types</a></format>.</para>
          <block subset="none" type="note">
            <para>Beginning with the .NET Framework version 2.0, <see cref="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" /> may expose private fields.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the field offset of the unmanaged form of the managed class.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The offset, in bytes, for the <paramref name="fieldName" /> parameter within the specified class that is declared by platform invoke.</para>
        </returns>
        <param name="t">
          <attribution license="cc4" from="Microsoft" modified="false" />A value type or formatted reference type that specifies the managed class. You must apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> to the class.</param>
        <param name="fieldName">
          <attribution license="cc4" from="Microsoft" modified="false" />The field within the <paramref name="t" /> parameter.</param>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf&lt;T&gt; (string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf&lt;T&gt;(string fieldName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)" /> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout. Marshaling the structure can transform the layout and alter the offset. The <paramref name="T" /> generic type parameter can be a value type or a formatted reference type (with either a sequential or explicit layout). You can obtain the size of the entire layout by using the <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" /> method. For additional information, see <format type="text/html"><a href="4d9a876c-e05a-40ba-bd85-bd22877f984a">Default Marshaling for Value Types</a></format>.</para>
          <block subset="none" type="note">
            <para>Beginning with the .NET Framework version 2.0, <see cref="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" /> may expose private fields.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>[Supported in the .NET Framework 4.5.1 only] </para>
          <para>Returns the field offset of the unmanaged form of a specified managed class.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The offset, in bytes, for the <paramref name="fieldName" /> parameter within the specified class that is declared by platform invoke. </para>
        </returns>
        <param name="fieldName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the field in the <paramref name="T" /> type. </param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />A managed value type or formatted reference type. You must apply the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> attribute to the class. </typeparam>
      </Docs>
    </Member>
    <Member MemberName="Prelink">
      <MemberSignature Language="C#" Value="public static void Prelink (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Prelink(class System.Reflection.MethodInfo m) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Setup tasks provide early initialization and are performed automatically when the target method is invoked. First-time tasks include the following:</para>
          <list type="bullet">
            <item>
              <para>Verifying that the platform invoke metadata is correctly formatted.</para>
            </item>
            <item>
              <para>Verifying that all the managed types are valid parameters of platform invoke functions.</para>
            </item>
            <item>
              <para>Locating and loading the unmanaged DLL into the process.</para>
            </item>
            <item>
              <para>Locating the entry point in the process.</para>
            </item>
          </list>
          <para>Calling <see cref="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" /> on a method outside of platform invoke has no effect. To execute setup tasks on all platform invoke methods in a type, use <see cref="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Executes one-time method setup tasks without calling the method.</para>
        </summary>
        <param name="m">
          <attribution license="cc4" from="Microsoft" modified="false" />The method to be checked.</param>
      </Docs>
    </Member>
    <Member MemberName="PrelinkAll">
      <MemberSignature Language="C#" Value="public static void PrelinkAll (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrelinkAll(class System.Type c) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" /> method invokes <see cref="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" /> on every method for a given type. <see cref="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" /> executes one-time method setup tasks without calling each method. You can use <see cref="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" /> only for platform invoke calls.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Performs a pre-link check for all methods on a class.</para>
        </summary>
        <param name="c">
          <attribution license="cc4" from="Microsoft" modified="false" />The class whose methods are to be checked.</param>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" /> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. This method provides the opposite functionality of the <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies all characters up to the first null character from an unmanaged ANSI string to a managed <see cref="T:System.String" />, and widens each ANSI character to Unicode.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A managed string that holds a copy of the unmanaged ANSI string. If <paramref name="ptr" /> is null, the method returns a null string.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the first character of the unmanaged string.</param>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr, int32 len) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" /> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. This method provides the opposite functionality of the <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates a managed <see cref="T:System.String" />, copies a specified number of characters from an unmanaged ANSI string into it, and widens each ANSI character to Unicode.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A managed string that holds a copy of the native ANSI string if the value of the <paramref name="ptr" /> parameter is not null; otherwise, this method returns null.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the first character of the unmanaged string.</param>
        <param name="len">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte count of the input string to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the current platform is Unicode, each ANSI character is widened to a Unicode character and this method calls <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />. Otherwise, this method calls <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />.</para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" /> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)" /> provides the opposite functionality of the <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from a string stored in unmanaged memory into it.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not null; otherwise, this method returns null.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />For Unicode platforms, the address of the first Unicode character.</param>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr, int32 len) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>On Unicode platforms, this method calls <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />; on ANSI platforms, it calls <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />. No transformations are done before these methods are called.</para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" /> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)" /> provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates a managed <see cref="T:System.String" /> and copies the specified number of characters from a string stored in unmanaged memory into it.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A managed string that holds a copy of the native string if the value of the <paramref name="ptr" /> parameter is not null; otherwise, this method returns null.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />For Unicode platforms, the address of the first Unicode character.</param>
        <param name="len">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringBSTR">
      <MemberSignature Language="C#" Value="public static string PtrToStringBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringBSTR(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Call this method only on strings that were allocated with the unmanaged <format type="text/html"><a href="9e0437a2-9b4a-4576-88b0-5cb9d08ca29b">SysAllocString</a></format> and <format type="text/html"><a href="f98bff39-bc5f-4a81-85d7-d5228e20fbc8">SysAllocStringLen</a></format> functions.</para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" /> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. This method provides the opposite functionality of the <see cref="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates a managed <see cref="T:System.String" /> and copies a <format type="text/html"><a href="1b2d7d2c-47af-4389-a6b6-b01b7e915228">BSTR</a></format> string stored in unmanaged memory into it.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not null; otherwise, this method returns null.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the first character of the unmanaged string.</param>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" /> is useful for custom marshaling or for use when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. This method provides the opposite functionality of the <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates a managed <see cref="T:System.String" /> and copies all characters up to the first null character from an unmanaged Unicode string into it.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not null; otherwise, this method returns null.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the first character of the unmanaged string.</param>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr, int32 len) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" /> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. This method provides the opposite functionality of the <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" /> and <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates a managed <see cref="T:System.String" /> and copies a specified number of characters from an unmanaged Unicode string into it.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A managed string that holds a copy of the unmanaged string if the value of the <paramref name="ptr" /> parameter is not null; otherwise, this method returns null.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the first character of the unmanaged string.</param>
        <param name="len">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of Unicode characters to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static void PtrToStructure (IntPtr ptr, object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure(native int ptr, object structure) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)" /> is often necessary in COM interop and platform invoke when structure parameters are represented as an <see cref="T:System.IntPtr" /> value. You cannot use this overload method with value types.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Marshals data from an unmanaged block of memory to a managed object.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to an unmanaged block of memory.</param>
        <param name="structure">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to which the data is to be copied. This must be an instance of a formatted class.</param>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static object PtrToStructure (IntPtr ptr, Type structureType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object PtrToStructure(native int ptr, class System.Type structureType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structureType" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)" /> is often necessary in COM interop and platform invoke when structure parameters are represented as an <see cref="T:System.IntPtr" /> value. You can pass a value type to this overload method. In this case, the returned object is a boxed instance.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Marshals data from an unmanaged block of memory to a newly allocated managed object of the specified type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A managed object containing the data pointed to by the <paramref name="ptr" /> parameter.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to an unmanaged block of memory.</param>
        <param name="structureType">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of object to be created. This object must represent a formatted class or a structure.</param>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PtrToStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T PtrToStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)" /> is often necessary in COM interop and platform invoke when structure parameters are represented as <see cref="T:System.IntPtr" /> values. You can pass a value type to this method overload. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>[Supported in the .NET Framework 4.5.1 only] </para>
          <para>Marshals data from an unmanaged block of memory to a newly allocated managed object of the type specified by a generic type parameter. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A managed object that contains the data that the <paramref name="ptr" /> parameter points to. </para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to an unmanaged block of memory. </param>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the object to which the data is to be copied. This must be a formatted class or a structure. </typeparam>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PtrToStructure&lt;T&gt; (IntPtr ptr, T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure&lt;T&gt;(native int ptr, !!T structure) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="ptr">To be added.</param>
        <param name="structure">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryInterface">
      <MemberSignature Language="C#" Value="public static int QueryInterface (IntPtr pUnk, ref Guid iid, out IntPtr ppv);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 QueryInterface(native int pUnk, valuetype System.Guid iid, native int ppv) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="iid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="ppv" Type="System.IntPtr&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pUnk">To be added: an object of type 'IntPtr'</param>
        <param name="iid">To be added: an object of type 'Guid&amp;'</param>
        <param name="ppv">To be added: an object of type 'IntPtr&amp;'</param>
        <summary>To be added</summary>
        <returns>To be added: an object of type 'int'</returns>
        <remarks>To be added</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" /> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a single byte from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The byte read from unmanaged memory.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory from which to read.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr, int32 ofs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" /> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a single byte at a given offset (or index) from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The byte read from unmanaged memory at the given offset.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory from which to read.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(object ptr, int32 ofs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" /> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a single byte at a given offset (or index) from unmanaged memory. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The byte read from unmanaged memory at the given offset.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the source object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)" /> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style Int16 array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a 16-bit signed integer from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The 16-bit signed integer read from unmanaged memory.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory from which to read.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr, int32 ofs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)" /> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a 16-bit signed integer at a given offset from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The 16-bit signed integer read from unmanaged memory at the given offset.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory from which to read.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(object ptr, int32 ofs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)" /> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a 16-bit signed integer at a given offset from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The 16-bit signed integer read from unmanaged memory at the given offset.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the source object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" /> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style Int32 array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a 32-bit signed integer from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The 32-bit signed integer read from unmanaged memory.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory from which to read.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr, int32 ofs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" /> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a 32-bit signed integer at a given offset from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The 32-bit signed integer read from unmanaged memory.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory from which to read.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(object ptr, int32 ofs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" /> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a 32-bit signed integer at a given offset from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The 32-bit signed integer read from unmanaged memory at the given offset.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the source object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)" /> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style Int64 array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a 64-bit signed integer from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The 64-bit signed integer read from unmanaged memory.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory from which to read.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr, int32 ofs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)" /> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a 64-bit signed integer at a given offset from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The 64-bit signed integer read from unmanaged memory at the given offset.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory from which to read.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(object ptr, int32 ofs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)" /> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a 64-bit signed integer at a given offset from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The 64-bit signed integer read from unmanaged memory at the given offset.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the source object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" /> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style IntPtr array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a processor native-sized integer from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The integer read from unmanaged memory. A 32 bit integer is returned on 32 bit machines and a 64 bit integer is returned on 64 bit machines.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory from which to read.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr, int32 ofs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" /> enables direct interaction with an unmanaged C-style IntPtr array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a processor native sized integer at a given offset from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The integer read from unmanaged memory at the given offset.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory from which to read.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(object ptr, int32 ofs) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" /> enables direct interaction with an unmanaged C-style IntPtr array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before reading its element values.</para>
          <para>Reading from unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a processor native sized integer from unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The integer read from unmanaged memory at the given offset.</para>
        </returns>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the source object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before reading.</param>
      </Docs>
    </Member>
    <Member MemberName="ReAllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocCoTaskMem (IntPtr pv, int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocCoTaskMem(native int pv, int32 cb) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" /> is one of two memory reallocation methods in the <see cref="T:System.Runtime.InteropServices.Marshal" /> class. (<see cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" /> is the other.) The beginning of the reallocated memory content is the same as the original content; however, the entire memory block can be in a different location. This method exposes the COM <see cref="http://go.microsoft.com/fwlink/?LinkId=148778">CoTaskMemRealloc</see> function, which is referred to as the COM task memory allocator.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Resizes a block of memory previously allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An integer representing the address of the reallocated block of memory. This memory must be released with <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</para>
        </returns>
        <param name="pv">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to memory allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</param>
        <param name="cb">
          <attribution license="cc4" from="Microsoft" modified="false" />The new size of the allocated block.</param>
      </Docs>
    </Member>
    <Member MemberName="ReAllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocHGlobal (IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocHGlobal(native int pv, native int cb) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" /> is one of two memory reallocation API methods in the <see cref="T:System.Runtime.InteropServices.Marshal" /> class. (<see cref="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" /> is the other.) </para>
          <para>This method exposes the Win32 <see cref="http://go.microsoft.com/fwlink/?LinkId=148780">GlobalReAlloc</see> function from Kernel32.dll. The returned pointer can differ from the original. If it is different, the contents of the original memory block have been copied to the new block, and the original memory block has been freed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Resizes a block of memory previously allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A pointer to the reallocated memory. This memory must be released using <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</para>
        </returns>
        <param name="pv">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to memory allocated with <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</param>
        <param name="cb">
          <attribution license="cc4" from="Microsoft" modified="false" />The new size of the allocated block. This is not a pointer; it is the byte count you are requesting, cast to type <see cref="T:System.IntPtr" />. If you pass a pointer, it is treated as a size.</param>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public static int Release (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Release(native int pUnk) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly. Use this value only for testing purposes. In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually. Only programs that call <see cref="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" /> should call <see cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />. Calling <see cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" /> after the reference count has reached zero causes undefined behavior.</para>
          <para>You can call <see cref="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />, <see cref="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />, or <see cref="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" /> to obtain an <see cref="T:System.IntPtr" /> value that represents a <see cref="http://go.microsoft.com/fwlink/?LinkId=148003">IUnknown</see> interface pointer to release. You can also use these methods and the <see cref="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" /> method on managed objects to release the COM interfaces represented by the managed object's <format type="text/html"><a href="d04be3b5-27b9-4f5b-8469-a44149fabf78">COM Callable Wrapper</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Decrements the reference count on the specified interface.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The new value of the reference count on the interface specified by the <paramref name="pUnk" /> parameter.</para>
        </returns>
        <param name="pUnk">
          <attribution license="cc4" from="Microsoft" modified="false" />The interface to release.</param>
      </Docs>
    </Member>
    <Member MemberName="ReleaseComObject">
      <MemberSignature Language="C#" Value="public static int ReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReleaseComObject(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is used to explicitly control the lifetime of a COM object used from managed code. You should use this method to free the underlying COM object that holds references to resources in a timely manner or when objects must be freed in a specific order.</para>
          <para>Every time a COM interface pointer enters the common language runtime (CLR), it is wrapped in an RCW.</para>
          <para>The RCW has a reference count that is incremented every time a COM interface pointer is mapped to it. The <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" /> method decrements the reference count of an RCW. When the reference count reaches zero, the runtime releases all its references on the unmanaged COM object, and throws a <see cref="T:System.NullReferenceException" /> if you attempt to use the object further. If the same COM interface is passed more than one time from unmanaged to managed code, the reference count on the wrapper is incremented every time, and calling <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" /> returns the number of remaining references.</para>
          <para>This method enables you to force an RCW reference count release so that it occurs precisely when you want it to. However, improper use of <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" /> may cause your application to fail, or may cause an access violation.</para>
          <para>Consider a scenario in which managed code in an application domain is holding onto an RCW that represents a COM component. If you call the <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" /> method on the RCW, the managed code will be unable to access the RCW and will raise an <see cref="T:System.Runtime.InteropServices.InvalidComObjectException" /> exception.</para>
          <para>A more serious error may occur if a call to the RCW is executing when the RCW is released. In this case, there is a good chance that the thread making the call will cause an access violation. However, process memory may become corrupted, and the process may continue to run until it fails for reasons that are very difficult to debug.</para>
          <para>This risk is compounded when the COM component that is being used is a singleton, for the following reason: The CLR activates COM components by calling the COM <see cref="http://go.microsoft.com/fwlink/?LinkID=142894">CoCreateInstance</see> function, which returns the same interface pointer every time it is called for singleton COM components. Thus, separate and independent pieces of managed code in an application domain can be using the same RCW for a singleton COM component, and if either one calls the <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" /> method on the COM component, the other will be broken.</para>
          <para>Therefore, use the <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" /> only if it is absolutely required. If you want to call this method to ensure that a COM component is released at a determined time, consider using the <see cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" /> method instead. <see cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" /> will release the underlying COM component regardless of how many times it has re-entered the CLR. The internal reference count of the RCW is incremented by one every time the COM component re-enters the CLR. Therefore, you could call the <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" /> method in a loop until the value returned is zero. This achieves the same result as the <see cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Decrements the reference count of the specified <format type="text/html"><a href="7e542583-1e31-4e10-b523-8cf2f29cb4a4">Runtime Callable Wrapper</a></format> (RCW) associated with the specified COM object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The new value of the reference count of the RCW associated with <paramref name="o" />. This value is typically zero since the RCW keeps just one reference to the wrapped COM object regardless of the number of managed clients calling it.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The COM object to release.</param>
      </Docs>
    </Member>
    <Member MemberName="ReleaseThreadCache">
      <MemberSignature Language="C#" Value="public static void ReleaseThreadCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReleaseThreadCache() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the thread cache.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToBSTR (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToBSTR(class System.Security.SecureString s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /> method is useful for custom marshaling or when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the BSTR when finished by calling the <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates a <format type="text/html"><a href="1b2d7d2c-47af-4389-a6b6-b01b7e915228">BSTR</a></format> and copies the contents of a managed <see cref="T:System.Security.SecureString" /> object into it.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The managed object to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemAnsi(class System.Security.SecureString s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> method is useful for custom marshaling or when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)" />. The characters of the string are copied as ANSI characters.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object to a block of memory allocated from the unmanaged COM task allocator.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The managed object to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemUnicode(class System.Security.SecureString s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> method is useful for custom marshaling or when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)" /> method. The characters of the string are copied as Unicode characters.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object to a block of memory allocated from the unmanaged COM task allocator.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The address, in unmanaged memory, where the <paramref name="s" /> parameter was copied to, or 0 if a null object was supplied.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The managed object to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocAnsi(class System.Security.SecureString s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> method is useful for custom marshaling or when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the contents of a managed <see cref="T:System.Security.SecureString" /> into unmanaged memory, converting into ANSI format as it copies.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The address, in unmanaged memory, to where the <paramref name="s" /> parameter was copied, or 0 if a null object was supplied.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The managed object to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocUnicode(class System.Security.SecureString s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> method is useful for custom marshaling or for use when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the contents of a managed <see cref="T:System.Security.SecureString" /> object into unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The address, in unmanaged memory, where <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is a <see cref="T:System.Security.SecureString" /> object whose length is 0.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The managed object to copy.</param>
      </Docs>
    </Member>
    <Member MemberName="SetComObjectData">
      <MemberSignature Language="C#" Value="public static bool SetComObjectData (object obj, object key, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetComObjectData(object obj, object key, object data) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>All COM objects wrapped in a <format type="text/html"><a href="7e542583-1e31-4e10-b523-8cf2f29cb4a4">Runtime Callable Wrapper</a></format> (RCW) have an associated hash table, to which <see cref="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" /> adds data. <see cref="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" /> retrieves data from the hash table. You should never have to call either method from your code.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets data referenced by the specified key in the specified COM object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the data was set successfully; otherwise, false.</para>
        </returns>
        <param name="obj">
          <attribution license="cc4" from="Microsoft" modified="false" />The COM object in which to store the data.</param>
        <param name="key">
          <attribution license="cc4" from="Microsoft" modified="false" />The key in the internal hash table of the COM object in which to store the data.</param>
        <param name="data">
          <attribution license="cc4" from="Microsoft" modified="false" />The data to set.</param>
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(object structure) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method accepts an instance of a structure, which can be a reference type or a boxed value type. The layout must be sequential or explicit.</para>
          <para>The size returned is the size of the unmanaged object. The unmanaged and managed sizes of an object can differ. For character types, the size is affected by the <see cref="T:System.Runtime.InteropServices.CharSet" /> value applied to that class.</para>
          <para>You can use the <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" /> method to determine how much unmanaged memory to allocate using the <see cref="Overload:System.Runtime.InteropServices.Marshal.AllocHGlobal" /> and <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /> methods.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the unmanaged size of an object in bytes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The size of the specified object in unmanaged code.</para>
        </returns>
        <param name="structure">
          <attribution license="cc4" from="Microsoft" modified="false" />The object whose size is to be returned.</param>
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(class System.Type t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method when you do not have a structure. The layout must be sequential or explicit.</para>
          <para>The size returned is the size of the unmanaged type. The unmanaged and managed sizes of an object can differ. For character types, the size is affected by the <see cref="T:System.Runtime.InteropServices.CharSet" /> value applied to that class.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the size of an unmanaged type in bytes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The size of the specified type in unmanaged code.</para>
        </returns>
        <param name="t">
          <attribution license="cc4" from="Microsoft" modified="false" />The type whose size is to be returned.</param>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You can use this method when you do not have a structure. The layout must be sequential or explicit.</para>
          <para>The size returned is the size of the unmanaged type. The unmanaged and managed sizes of an object can differ. For character types, the size is affected by the <see cref="T:System.Runtime.InteropServices.CharSet" /> value applied to that class. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>[Supported in the .NET Framework 4.5.1 only] </para>
          <para>Returns the size of an unmanaged type in bytes. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The size, in bytes, of the type that is specified by the <paramref name="T" /> generic type parameter. </para>
        </returns>
        <typeparam name="T">
          <attribution license="cc4" from="Microsoft" modified="false" />The type whose size is to be returned. </typeparam>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; (T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;(!!T structure) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="structure">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr StringToBSTR (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToBSTR(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" /> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the BSTR when finished by calling <see cref="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />. This method provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allocates a <format type="text/html"><a href="1b2d7d2c-47af-4389-a6b6-b01b7e915228">BSTR</a></format> and copies the contents of a managed <see cref="T:System.String" /> into it.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An unmanaged pointer to the BSTR, or 0 if <paramref name="s" /> is null.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The managed string to be copied.</param>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAnsi(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" /> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />. This method provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />. The characters of the string are copied as ANSI characters.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An integer representing a pointer to the block of memory allocated for the string, or 0 if <paramref name="s" /> is null.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />A managed string to be copied.</param>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAuto(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" /> is useful for custom marshaling or for use when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />. This method provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />.</para>
          <para>The characters of the string are copied as either ANSI or Unicode characters, depending on the operating system where the code is executing. On Windows 98, the characters are copied as ANSI characters. On Windows NT 4.0, Windows 2000, Windows XP, and the Windows Server 2003 family, the characters are copied as Unicode characters.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The allocated memory block, or 0 if <paramref name="s" /> is null.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />A managed string to be copied.</param>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUni(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" /> is useful for custom marshaling or for use when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />. This method provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />. The characters of the string are copied as Unicode characters.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the contents of a managed <see cref="T:System.String" /> to a block of memory allocated from the unmanaged COM task allocator.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An integer representing a pointer to the block of memory allocated for the string, or 0 if s is null.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />A managed string to be copied.</param>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAnsi(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" /> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />. <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" /> provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />.</para>
          <para>This method copies embedded null characters, and includes a terminating null character. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory, converting into ANSI format as it copies.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The address, in unmanaged memory, to where <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is null.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />A managed string to be copied.</param>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAuto(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" /> is useful for custom marshaling or for use when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />. This method provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />.</para>
          <para>This method copies embedded null characters, and includes a terminating null character. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory, converting into ANSI format if required.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The address, in unmanaged memory, to where the string was copied, or 0 if <paramref name="s" /> is null.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />A managed string to be copied.</param>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalUni(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" /> is useful for custom marshaling or for use when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />. This method provides the opposite functionality of <see cref="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />.</para>
          <para>This method copies embedded null characters, and includes a terminating null character. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Copies the contents of a managed <see cref="T:System.String" /> into unmanaged memory.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The address, in unmanaged memory, to where the <paramref name="s" /> was copied, or 0 if <paramref name="s" /> is null.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />A managed string to be copied.</param>
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr">
      <MemberSignature Language="C#" Value="public static void StructureToPtr (object structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr(object structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If <paramref name="structure" /> is a value type, it can be boxed or unboxed. If it is boxed, it is unboxed before copying. </para>
          <para>A formatted class is a reference type whose layout is specified by the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> attribute, as either <see cref="F:System.Runtime.InteropServices.LayoutKind.Explicit" /> or <see cref="F:System.Runtime.InteropServices.LayoutKind.Sequential" />. </para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" /> copies the contents of <paramref name="structure" /> to the pre-allocated block of memory that the <paramref name="ptr" /> parameter points to. If <paramref name="structure" /> contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <see cref="T:System.Object" />), the managed objects are kept alive with reference counts. All other reference types (for example, strings and arrays) are marshaled to copies. To release these managed or unmanaged objects, you must call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> method before you free the memory block. </para>
          <para>If you use the <see cref="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" /> method to copy a different instance to the memory block at a later time, specify true for <paramref name="fDeleteOld" /> to remove reference counts for reference types in the previous instance. Otherwise, the managed reference types and unmanaged copies are effectively leaked. </para>
          <para>The overall pattern for using <see cref="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" /> is as follows:</para>
          <list type="ordered">
            <item>
              <para>On the first call to the <see cref="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" /> method after a memory block has been allocated, <paramref name="fDeleteOld" /> must be false, because there are no contents to clear. </para>
              <block subset="none" type="note">
                <para>Specify true for <paramref name="fDeleteOld" /> only if the block contains valid data. </para>
              </block>
            </item>
            <item>
              <para>If you copy a different instance to the memory block, and the object contains reference types, <paramref name="fDeleteOld" /> must be true to free reference types in the old contents. </para>
            </item>
            <item>
              <para>If the object contains reference types, you must call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> method before you free the memory block. </para>
            </item>
          </list>
          <block subset="none" type="note">
            <para>To pin an existing structure instead of copying it, use the <see cref="T:System.Runtime.InteropServices.GCHandle" /> type to create a pinned handle for the structure. For details on how to pin, see <format type="text/html"><a href="0059F576-E460-4E70-B257-668870E420B8">Copying and Pinning</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Marshals data from a managed object to an unmanaged block of memory.</para>
        </summary>
        <param name="structure">
          <attribution license="cc4" from="Microsoft" modified="false" />A managed object that holds the data to be marshaled. This object must be a structure or an instance of a formatted class. </param>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to an unmanaged block of memory, which must be allocated before this method is called.</param>
        <param name="fDeleteOld">
          <attribution license="cc4" from="Microsoft" modified="false" />true to call the <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> method on the <paramref name="ptr" /> parameter before this method copies the data. The block must contain valid data. Note that passing false when the memory block already contains data can lead to a memory leak.</param>
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StructureToPtr&lt;T&gt; (T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr&lt;T&gt;(!!T structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="structure">To be added.</param>
        <param name="ptr">To be added.</param>
        <param name="fDeleteOld">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemDefaultCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemDefaultCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemDefaultCharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <MemberValue>1</MemberValue>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Represents the default character size on the system; the default is 2 for Unicode systems and 1 for ANSI systems. This field is read-only.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SystemMaxDBCSCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemMaxDBCSCharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <MemberValue>2</MemberValue>
      <Docs>
        <remarks>To be added</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Represents the maximum size of a double byte character set (DBCS) size, in bytes, for the current operating system. This field is read-only.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method creates an exception object for the specified failure HRESULT. If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</para>
          <para>Note that the <see cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" /> method returns an exception based on the <format type="text/html"><a href="4dda6909-2d9a-4727-ae0c-b5f90dcfa447">IErrorInfo</a></format> of the current thread if one is set. When this happens, the <paramref name="errorCode" /> parameter is ignored.</para>
          <para>Some failure HRESULTs map to defined exceptions, whereas others do not. If the HRESULT maps to a defined exception, <see cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" /> creates an instance of the exception and throws it. Otherwise, it creates an instance of <see cref="T:System.Runtime.InteropServices.COMException" />, initializes the error code field with the HRESULT, and throws that exception. When <see cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" /> is invoked, it attempts to retrieve extra information regarding the error by using the unmanaged <format type="text/html"><a href="03317526-8c4f-4173-bc10-110c8112676a">GetErrorInfo</a></format> function.</para>
          <para>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <format type="text/html"><a href="610b364b-2761-429d-9c4a-afbc3e66f1b9">How to: Map HRESULTs and Exceptions</a></format>.</para>
          <para>Occasionally, <see cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" /> might return an exception from a previous COM call. In this case, you can use the following workaround and pass IntPtr(-1) as the second parameter (errorInfo):</para>
          <code>[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
public static void ThrowExceptionForHR(int errorCode,IntPtr errorInfo)</code>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Throws an exception with a specific failure HRESULT value.</para>
        </summary>
        <param name="errorCode">
          <attribution license="cc4" from="Microsoft" modified="false" />The HRESULT corresponding to the desired exception.</param>
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method creates an exception object for the specified failure HRESULT. If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</para>
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" /> method releases the <paramref name="errorInfo" /> parameter, decreasing the COM reference count of the IErrorInfo interface.</para>
          <para>Note that the <see cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" /> method returns an exception based on the <format type="text/html"><a href="4dda6909-2d9a-4727-ae0c-b5f90dcfa447">IErrorInfo</a></format> interface of the current thread if one is set. When this happens, the <paramref name="errorCode" /> parameter is ignored.</para>
          <para>Some failure HRESULTs map to defined exceptions, whereas others do not. If the HRESULT maps to a defined exception, <see cref="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" /> creates an instance of the exception and throws it. Otherwise, it creates an instance of <see cref="T:System.Runtime.InteropServices.COMException" />, initializes the error code field with the HRESULT, and throws that exception. The <paramref name="errorInfo" /> parameter is used to retrieve extra information regarding the error.</para>
          <para>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <format type="text/html"><a href="610b364b-2761-429d-9c4a-afbc3e66f1b9">How to: Map HRESULTs and Exceptions</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Throws an exception with a specific failure HRESULT, based on the specified <format type="text/html"><a href="4dda6909-2d9a-4727-ae0c-b5f90dcfa447">IErrorInfo</a></format> interface.</para>
        </summary>
        <param name="errorCode">
          <attribution license="cc4" from="Microsoft" modified="false" />The HRESULT corresponding to the desired exception.</param>
        <param name="errorInfo">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the IErrorInfo interface that provides more information about the error. You can specify IntPtr(0) to use the current IErrorInfo interface, or IntPtr(-1) to ignore the current IErrorInfo interface and construct the exception just from the error code.</param>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement(class System.Array arr, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The array must be pinned using a <see cref="T:System.Runtime.InteropServices.GCHandle" /> before it is passed to this method. For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the address of the element at the specified index inside the specified array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The address of <paramref name="index" /> inside <paramref name="arr" />.</para>
        </returns>
        <param name="arr">
          <attribution license="cc4" from="Microsoft" modified="false" />The array that contains the desired element.</param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index in the <paramref name="arr" /> parameter of the desired element.</param>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement&lt;T&gt; (T[] arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement&lt;T&gt;(!!T[] arr, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arr" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="arr">To be added.</param>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, unsigned int8 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" /> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a single byte value to unmanaged memory.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory to write to.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" /> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a single byte value to unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory to write to.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (object ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(object ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" /> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a single byte value to unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the target object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, char val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" /> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a character as a 16-bit integer value to unmanaged memory.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory to write to.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int16 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" /> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 16-bit integer value to unmanaged memory.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory to write to.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, char val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" /> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in the native heap to write to.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, int16 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" /> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 16-bit signed integer value into unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory to write to.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(object ptr, int32 ofs, char val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" /> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the target object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(object ptr, int32 ofs, int16 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" /> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the target object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing. </param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" /> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 32-bit signed integer value to unmanaged memory.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory to write to.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 ofs, int32 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" /> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 32-bit signed integer value into unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory to write to.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (object ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(object ptr, int32 ofs, int32 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" /> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 32-bit signed integer value to unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the target object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int64 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" /> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 64-bit signed integer value to unmanaged memory.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory to write to.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int32 ofs, int64 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" /> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory to write.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (object ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(object ptr, int32 ofs, int64 val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" /> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the target object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, native int val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" /> enables direct interaction with an unmanaged C-style IntPtr array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a processor native sized integer value into unmanaged memory.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The address in unmanaged memory to write to.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, int32 ofs, native int val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method writes a 32 bit integer on 32 bit systems, and a 64 bit integer on 64 bit systems.</para>
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" /> enables direct interaction with an unmanaged C-style IntPtr array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a processor native-sized integer value to unmanaged memory at a specified offset.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory to write to.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (object ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(object ptr, int32 ofs, native int val) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" /> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <see cref="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />) to a separate managed array before setting its element values.</para>
          <para>Writing to unaligned memory locations is supported.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a processor native sized integer value to unmanaged memory.</para>
        </summary>
        <param name="ptr">
          <attribution license="cc4" from="Microsoft" modified="false" />The base address in unmanaged memory of the target object.</param>
        <param name="ofs">
          <attribution license="cc4" from="Microsoft" modified="false" />An additional byte offset, which is added to the <paramref name="ptr" /> parameter before writing.</param>
        <param name="val">
          <attribution license="cc4" from="Microsoft" modified="false" />The value to write.</param>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeBSTR">
      <MemberSignature Language="C#" Value="public static void ZeroFreeBSTR (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeBSTR(native int s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)" /> method first sets the contents of the BSTR to zero, and then frees the BSTR.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees a <format type="text/html"><a href="1b2d7d2c-47af-4389-a6b6-b01b7e915228">BSTR</a></format> pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /> method.</para>
        </summary>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the BSTR to free.</param>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemAnsi(native int s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)" /> method first zeros out and then frees unmanaged memory that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> method.</para>
        </summary>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the unmanaged string to free.</param>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUnicode(native int s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)" /> method first zeros out and then frees unmanaged memory that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> method.</para>
        </summary>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the unmanaged string to free.</param>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocAnsi(native int s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)" /> method first zeros out and then frees unmanaged memory that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> method.</para>
        </summary>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the unmanaged string to free.</param>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocUnicode(native int s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)" /> method first zeros out and then frees unmanaged memory that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> method.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Frees an unmanaged string pointer that was allocated using the <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> method.</para>
        </summary>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The address of the unmanaged string to free.</param>
      </Docs>
    </Member>
  </Members>
</Type>