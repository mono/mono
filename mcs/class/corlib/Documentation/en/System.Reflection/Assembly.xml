<?xml version="1.0" encoding="utf-8"?>
<Type Name="Assembly" FullName="System.Reflection.Assembly" FullNameSP="System_Reflection_Assembly" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public serializable Assembly extends System.Object" />
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <MemberOfLibrary>RuntimeInfrastructure</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>This type is safe for multithreaded operations. </ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Use the <see cref="T:System.Reflection.Assembly" /> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</para>
      <para>To get an array of <see cref="T:System.Reflection.Assembly" /> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <see cref="M:System.AppDomain.GetAssemblies" /> method.</para>
      <para>To load assemblies dynamically, the <see cref="T:System.Reflection.Assembly" /> class provides the following static methods (Shared methods in Visual Basic). Assemblies are loaded into the application domain where the load operation occurs.</para>
      <list type="bullet">
        <item>
          <para>The recommended way to load assemblies is to use the <see cref="Overload:System.AppDomain.Load" /> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"). The search for the assembly follows the rules described in <format type="text/html"><a href="772ac6f4-64d2-4cfb-92fd-58096dcd6c34">How the Runtime Locates Assemblies</a></format>.</para>
        </item>
        <item>
          <para>The <see cref="Overload:System.Reflection.Assembly.ReflectionOnlyLoad" /> and <see cref="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" /> methods enable you to load an assembly for reflection, but not for execution. For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</para>
        </item>
        <item>
          <para>The <see cref="Overload:System.Reflection.Assembly.LoadFile" /> and <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> methods are provided for rare scenarios in which an assembly must be identified by path. </para>
        </item>
      </list>
      <para>To get an <see cref="T:System.Reflection.Assembly" /> object for the currently executing assembly, use the <see cref="M:System.Reflection.Assembly.GetExecutingAssembly" /> method. </para>
      <para>Many members of the <see cref="T:System.Reflection.Assembly" /> class provide information about an assembly. For example:</para>
      <list type="bullet">
        <item>
          <para>The <see cref="M:System.Reflection.Assembly.GetName" /> method returns an <see cref="T:System.Reflection.AssemblyName" /> object that provides access to the parts of the assembly display name. </para>
        </item>
        <item>
          <para>The <see cref="Overload:System.Reflection.Assembly.GetCustomAttributes" /> method lists the attributes applied to the assembly. </para>
        </item>
        <item>
          <para>The <see cref="Overload:System.Reflection.Assembly.GetFiles" /> method provides access to the files in the assembly manifest. </para>
        </item>
        <item>
          <para>The <see cref="M:System.Reflection.Assembly.GetManifestResourceNames" /> method provides the names of the resources in the assembly manifest.</para>
        </item>
      </list>
      <para>The <see cref="M:System.Reflection.Assembly.GetTypes" /> method lists all the types in the assembly. The <see cref="M:System.Reflection.Assembly.GetExportedTypes" /> method lists the types that are visible to callers outside the assembly. The <see cref="Overload:System.Reflection.Assembly.GetType" /> method can be used to search for a particular type in the assembly. The <see cref="Overload:System.Reflection.Assembly.CreateInstance" /> method can be used to search for and create instances of types in the assembly. </para>
      <para>For more information on assemblies, see <format type="text/html"><a href="433b04ae-4ba8-4849-9dbd-79194f240346">Application Domains and Assemblies</a></format>.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This constructor is invoked by derived classes during the construction of <see cref="T:System.Reflection.Assembly" /> objects.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Reflection.Assembly" /> class.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>Absolute path from which the assembly was originally loaded.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To get the absolute path to the loaded manifest-containing file, use the <see cref="P:System.Reflection.Assembly.Location" /> property instead.</para>
          <para>If the assembly was loaded as a byte array, using an overload of the <see cref="Overload:System.Reflection.Assembly.Load" /> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the location of the assembly as specified originally, for example, in an <see cref="T:System.Reflection.AssemblyName" /> object.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="ILASM" Value=".method public hidebysig instance object CreateInstance(string typeName)" />
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> is the empty string ("") or "\0anything".</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> is <see langword="null" />.</exception>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance of the specified type created with the default constructor; or null if <paramref name="typeName" /> is not found. The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to Public or Instance. </para>
        </returns>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="P:System.Type.FullName" /> of the type to locate. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance of the specified type created with the default constructor; or null if <paramref name="typeName" /> is not found. The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to Public or Instance.</para>
        </returns>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="P:System.Type.FullName" /> of the type to locate. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />true to ignore the case of the type name; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="activationAttributes" /> parameter is related to client-activated objects; see <format type="text/html"><a href="4a791494-c18a-4711-a5c1-4ab0e49a8f1a">Client Activation</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An instance of the specified type, or null if <paramref name="typeName" /> is not found. The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</para>
        </returns>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="P:System.Type.FullName" /> of the type to locate. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />true to ignore the case of the type name; otherwise, false. </param>
        <param name="bindingAttr">
          <attribution license="cc4" from="Microsoft" modified="false" />A bitmask that affects the way in which the search is conducted. The value is a combination of bit flags from <see cref="T:System.Reflection.BindingFlags" />. </param>
        <param name="binder">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection. If <paramref name="binder" /> is null, the default binder is used. </param>
        <param name="args">
          <attribution license="cc4" from="Microsoft" modified="false" />An array that contains the arguments to be passed to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to be invoked. If the default constructor is desired, <paramref name="args" /> must be an empty array or null. </param>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />An instance of CultureInfo used to govern the coercion of types. If this is null, the CultureInfo for the current thread is used. (This is necessary to convert a String that represents 1000 to a Double value, for example, since 1000 is represented differently by different cultures.) </param>
        <param name="activationAttributes">
          <attribution license="cc4" from="Microsoft" modified="false" />An array of one or more attributes that can participate in activation. Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object. The <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> specifies the URL that is required to activate a remote object.  </param>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The format of the returned string is: </para>
          <para>&lt;FullTypeName&gt;, &lt;AssemblyDisplayName&gt; </para>
          <para>See <see cref="T:System.Reflection.AssemblyName" /> for a description of the format of the display name of an assembly.</para>
          <para>To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.  For information about qualified assembly names, see <see cref="P:System.Type.AssemblyQualifiedName" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Creates the name of a type qualified by the display name of its assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The full name of the type qualified by the display name of the assembly.</para>
        </returns>
        <param name="assemblyName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of an assembly. </param>
        <param name="typeName">
          <attribution license="cc4" from="Microsoft" modified="false" />The full name of a type. </param>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a collection that contains this assembly's custom attributes.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a collection of the types defined in this assembly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <value>
          <see cref="T:System.Reflection.MethodInfo" /> object for the Entry Point in the assembly if it exists.</value>
        <remarks>If there isn't an entry point in the assembly, the object is null.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the entry point of this assembly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether this assembly and the specified object are equal.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="o" /> is equal to this instance; otherwise, false.</para>
        </returns>
        <param name="o">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to compare with this instance. </param>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the URI, including escape characters, that represents the codebase.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the evidence for this assembly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a collection of the public types defined in this assembly that are visible outside the assembly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="ILASM" Value=".property string FullName { public hidebysig virtual specialname string get_FullName() }" />
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.String" /> containing the full name of the assembly.</para>
        </value>
        <example>
          <para> The following example demonstrates using
      the <see cref="P:System.Reflection.Assembly.FullName" /> property to get the full name of an assembly compiled into a file named
      "HelloWorld". </para>
          <code lang="C#">using System;
using System.Reflection;

public class AssemblyExample {
 public static void Main() {

 Assembly a = Assembly.Load("helloworld");
 Console.WriteLine(a.FullName);
 } 
}
   </code>
          <para>The output is</para>
          <c>
            <para>HelloWorld, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>See <see cref="T:System.Reflection.AssemblyName" /> for a description of the format of the display name of an assembly.</para>
          <block subset="none" type="note">
            <para>Writing your own code to parse display names is not recommended. Instead, pass the display name to the <see cref="M:System.Reflection.AssemblyName.#ctor(System.String)" /> constructor, which parses it and populates the appropriate fields of the new <see cref="T:System.Reflection.AssemblyName" />.</para>
          </block>
          <para>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. However, it is not included in the string returned by the <see cref="P:System.Reflection.Assembly.FullName" /> property, for compatibility reasons. See <see cref="P:System.Reflection.AssemblyName.ProcessorArchitecture" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the display name of the assembly.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In order to call this method, you must have a <see cref="T:System.Type" /> object, which means that the assembly in which the class is defined must already be loaded.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the currently loaded assembly in which the specified class is defined.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly in which the specified class is defined.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />An object representing a class in the assembly that will be returned. </param>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the method that calls the <see cref="M:System.Reflection.Assembly.GetCallingAssembly" /> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <see cref="M:System.Reflection.Assembly.GetCallingAssembly" /> may differ unexpectedly. For example, consider the following methods and assemblies:</para>
          <list type="bullet">
            <item>
              <para>Method M1 in assembly A1 calls <see cref="M:System.Reflection.Assembly.GetCallingAssembly" />. </para>
            </item>
            <item>
              <para>Method M2 in assembly A2 calls M1. </para>
            </item>
            <item>
              <para>Method M3 in assembly A3 calls M2. </para>
            </item>
          </list>
          <para>When M1 is not inlined, <see cref="M:System.Reflection.Assembly.GetCallingAssembly" /> returns A2. When M1 is inlined, <see cref="M:System.Reflection.Assembly.GetCallingAssembly" /> returns A3. Similarly, when M2 is not inlined, <see cref="M:System.Reflection.Assembly.GetCallingAssembly" /> returns A2. When M2 is inlined, <see cref="M:System.Reflection.Assembly.GetCallingAssembly" /> returns A3. </para>
          <para>This effect also occurs when M1 executes as a tail call from M2, or when M2 executes as a tail call from M3. You can prevent the JIT compiler from inlining the method that calls <see cref="M:System.Reflection.Assembly.GetCallingAssembly" />, by applying the <see cref="T:System.Runtime.CompilerServices.MethodImplAttribute" /> attribute with the <see cref="F:System.Runtime.CompilerServices.MethodImplOptions.NoInlining" /> flag, but there is no similar mechanism for preventing tail calls. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the <see cref="T:System.Reflection.Assembly" /> of the method that invoked the currently executing method.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The Assembly object of the method that invoked the currently executing method.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method implements the corresponding <see cref="T:System.Reflection.ICustomAttributeProvider" /> interface method. Therefore, the <paramref name="inherit" /> parameter must be specified even though it is ignored.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 2.0, this method returns security attributes if they are stored in the new metadata format. Assemblies compiled with version 2.0 use this format. Dynamic assemblies and assemblies compiled with earlier versions of the .NET Framework use the old XML format. See <format type="text/html"><a href="9eeddee8-ca89-4440-b84b-fd613f590cd5">Emitting Declarative Security Attributes</a></format>.</para>
          </block>
          <para>A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present. Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded. Some of the resulting bits cannot be accessed using existing reflection APIs.</para>
          <para>The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Pseudo-Attribute </para>
                </term>
                <description>
                  <para>Metadata Bits </para>
                </description>
                <description>
                  <para>Reflection Accessor </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>DllImportAttribute </para>
              </term>
              <description>
                <para>CorPInvokeMap </para>
                <para>DLL name </para>
              </description>
              <description>
                <para>No accessor for PInvokeMap for ordinary method/global method attributes.</para>
                <para>No accessor for DLL name. </para>
              </description>
            </item>
            <item>
              <term>
                <para>GuidAttribute </para>
              </term>
              <description>
                <para>Stored as a real custom attribute. </para>
              </description>
              <description>
                <para>Accessed as a real custom attribute. </para>
              </description>
            </item>
            <item>
              <term>
                <para>ComImportAttribute </para>
              </term>
              <description>
                <para>CorTypeAttr.tdImport </para>
              </description>
              <description>
                <para>Type.Attributes.Import </para>
              </description>
            </item>
            <item>
              <term>
                <para>SerializableAttribute </para>
              </term>
              <description>
                <para>CorTypeAttr.tdSerializable </para>
              </description>
              <description>
                <para>Type.Attributes.Serializable </para>
              </description>
            </item>
            <item>
              <term>
                <para>NonSerializedAttribute </para>
              </term>
              <description>
                <para>CorFieldAttr.fdNotSerialized </para>
              </description>
              <description>
                <para>FieldInfo.Attributes.NotSerialized </para>
              </description>
            </item>
            <item>
              <term>
                <para>MethodImplAttribute </para>
              </term>
              <description>
                <para>CorMethodImpl </para>
              </description>
              <description>
                <para>MethodInfo.GetMethodImplementationFlags() </para>
                <para>ConstructorInfo.GetMethodImplementationFlags() </para>
              </description>
            </item>
            <item>
              <term>
                <para>MarshalAsAttribute </para>
              </term>
              <description>
                <para>Various bits. </para>
              </description>
              <description>
                <para>No accessor. </para>
              </description>
            </item>
            <item>
              <term>
                <para>PreserveSigAttribute </para>
              </term>
              <description>
                <para>CorMethodImpl.miOLE </para>
              </description>
              <description>
                <para>MethodInfo.GetMethodImplementationFlags().OLE </para>
                <para>ConstructorInfo.GetMethodImplementationFlags().OLE </para>
              </description>
            </item>
            <item>
              <term>
                <para>InAttribute </para>
              </term>
              <description>
                <para>CorParamAttr.pdIn </para>
              </description>
              <description>
                <para>ParameterInfo.Attributes.In </para>
              </description>
            </item>
            <item>
              <term>
                <para>OutAttribute </para>
              </term>
              <description>
                <para>CorParamAttr.pdOut </para>
              </description>
              <description>
                <para>ParameterInfo.Attributes.Out </para>
              </description>
            </item>
            <item>
              <term>
                <para>StructLayoutAttribute </para>
              </term>
              <description>
                <para>CorTypeAttr.tdLayoutSequential </para>
                <para>CorTypeAttr.tdExplicitLayout </para>
                <para>CorTypeAttr.tdAnsiClass </para>
                <para>CorTypeAttr.tdUnicodeClass </para>
                <para>CorTypeAttr.tdAutoClass </para>
                <para>Class packing. </para>
              </description>
              <description>
                <para>Type.Attributes.LayoutSequential </para>
                <para>Type.Attributes.ExplicitLayout </para>
                <para>Type.Attributes.AnsiClass </para>
                <para>Type.Attributes.UnicodeClass </para>
                <para>Type.Attributes.AutoClass </para>
                <para>No accessor. </para>
              </description>
            </item>
            <item>
              <term>
                <para>FieldOffsetAttribute </para>
              </term>
              <description>
                <para>Field offset. </para>
              </description>
              <description>
                <para>No accessor. </para>
              </description>
            </item>
            <item>
              <term>
                <para>AssemblyLoadAttribute </para>
              </term>
              <description>
                <para>CorAssemblyFlags </para>
              </description>
              <description>
                <para>No accessor or enumerator. </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets all the custom attributes for this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array that contains the custom attributes for this assembly.</para>
        </returns>
        <param name="inherit">
          <attribution license="cc4" from="Microsoft" modified="false" />This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />. </param>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method implements the corresponding <see cref="T:System.Reflection.ICustomAttributeProvider" /> interface method. Therefore, the <paramref name="inherit" /> parameter must be specified even though it is ignored.</para>
          <block subset="none" type="note">
            <para>In the .NET Framework version 2.0, this method returns security attributes if they are stored in the new metadata format. Assemblies compiled with version 2.0 use this format. Dynamic assemblies and assemblies compiled with earlier versions of the .NET Framework use the old XML format. See <format type="text/html"><a href="9eeddee8-ca89-4440-b84b-fd613f590cd5">Emitting Declarative Security Attributes</a></format>.</para>
          </block>
          <para>A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present. Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded. Some of the resulting bits cannot be accessed using existing reflection APIs.</para>
          <para>The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</para>
          <list type="table">
            <listheader>
              <item>
                <term>
                  <para>Pseudo-Attribute </para>
                </term>
                <description>
                  <para>Metadata Bits </para>
                </description>
                <description>
                  <para>Reflection Accessor </para>
                </description>
              </item>
            </listheader>
            <item>
              <term>
                <para>DllImportAttribute </para>
              </term>
              <description>
                <para>CorPInvokeMap </para>
                <para>DLL name </para>
              </description>
              <description>
                <para>No accessor for PInvokeMap for ordinary method/global method attributes.</para>
                <para>No accessor for DLL name. </para>
              </description>
            </item>
            <item>
              <term>
                <para>GuidAttribute </para>
              </term>
              <description>
                <para>Stored as a real custom attribute. </para>
              </description>
              <description>
                <para>Accessed as a real custom attribute. </para>
              </description>
            </item>
            <item>
              <term>
                <para>ComImportAttribute </para>
              </term>
              <description>
                <para>CorTypeAttr.tdImport </para>
              </description>
              <description>
                <para>Type.Attributes.Import </para>
              </description>
            </item>
            <item>
              <term>
                <para>SerializableAttribute </para>
              </term>
              <description>
                <para>CorTypeAttr.tdSerializable </para>
              </description>
              <description>
                <para>Type.Attributes.Serializable </para>
              </description>
            </item>
            <item>
              <term>
                <para>NonSerializedAttribute </para>
              </term>
              <description>
                <para>CorFieldAttr.fdNotSerialized </para>
              </description>
              <description>
                <para>FieldInfo.Attributes.NotSerialized </para>
              </description>
            </item>
            <item>
              <term>
                <para>MethodImplAttribute </para>
              </term>
              <description>
                <para>CorMethodImpl </para>
              </description>
              <description>
                <para>MethodInfo.GetMethodImplementationFlags() </para>
                <para>ConstructorInfo.GetMethodImplementationFlags() </para>
              </description>
            </item>
            <item>
              <term>
                <para>MarshalAsAttribute </para>
              </term>
              <description>
                <para>Various bits. </para>
              </description>
              <description>
                <para>No accessor. </para>
              </description>
            </item>
            <item>
              <term>
                <para>PreserveSigAttribute </para>
              </term>
              <description>
                <para>CorMethodImpl.miOLE </para>
              </description>
              <description>
                <para>MethodInfo.GetMethodImplementationFlags().OLE </para>
                <para>ConstructorInfo.GetMethodImplementationFlags().OLE </para>
              </description>
            </item>
            <item>
              <term>
                <para>InAttribute </para>
              </term>
              <description>
                <para>CorParamAttr.pdIn </para>
              </description>
              <description>
                <para>ParameterInfo.Attributes.In </para>
              </description>
            </item>
            <item>
              <term>
                <para>OutAttribute </para>
              </term>
              <description>
                <para>CorParamAttr.pdOut </para>
              </description>
              <description>
                <para>ParameterInfo.Attributes.Out </para>
              </description>
            </item>
            <item>
              <term>
                <para>StructLayoutAttribute </para>
              </term>
              <description>
                <para>CorTypeAttr.tdLayoutSequential </para>
                <para>CorTypeAttr.tdExplicitLayout </para>
                <para>CorTypeAttr.tdAnsiClass </para>
                <para>CorTypeAttr.tdUnicodeClass </para>
                <para>CorTypeAttr.tdAutoClass </para>
                <para>Class packing. </para>
              </description>
              <description>
                <para>Type.Attributes.LayoutSequential </para>
                <para>Type.Attributes.ExplicitLayout </para>
                <para>Type.Attributes.AnsiClass </para>
                <para>Type.Attributes.UnicodeClass </para>
                <para>Type.Attributes.AutoClass </para>
                <para>No accessor. </para>
              </description>
            </item>
            <item>
              <term>
                <para>FieldOffsetAttribute </para>
              </term>
              <description>
                <para>Field offset. </para>
              </description>
              <description>
                <para>No accessor. </para>
              </description>
            </item>
            <item>
              <term>
                <para>AssemblyLoadAttribute </para>
              </term>
              <description>
                <para>CorAssemblyFlags </para>
              </description>
              <description>
                <para>No accessor or enumerator. </para>
              </description>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the custom attributes for this assembly as specified by type.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array that contains the custom attributes for this assembly as specified by <paramref name="attributeType" />.</para>
        </returns>
        <param name="attributeType">
          <attribution license="cc4" from="Microsoft" modified="false" />The type for which the custom attributes are to be returned. </param>
        <param name="inherit">
          <attribution license="cc4" from="Microsoft" modified="false" />This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />. </param>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context. Methods like <see cref="Overload:System.Attribute.GetCustomAttributes" /> and <see cref="Overload:System.Reflection.Assembly.GetCustomAttributes" /> cannot be used in such cases, because they create instances of the attributes. Code in the reflection-only context cannot be executed. For more information and for example code, see the <see cref="T:System.Reflection.CustomAttributeData" /> class.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns information about the attributes that have been applied to the current <see cref="T:System.Reflection.Assembly" />, expressed as <see cref="T:System.Reflection.CustomAttributeData" /> objects.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current assembly.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Reflection.Assembly.GetEntryAssembly" /> method can return null when a managed assembly has been loaded from an unmanaged application. For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <see cref="M:System.Reflection.Assembly.GetEntryAssembly" /> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the process executable in the default application domain. In other application domains, this is the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly that is the process executable in the default application domain, or the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />. Can return null when called from unmanaged code.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To get the assembly that contains the method that called the currently executing code, use <see cref="M:System.Reflection.Assembly.GetCallingAssembly" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the assembly that contains the code that is currently executing.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly that contains the code that is currently executing. </para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The only types visible outside an assembly are public types and public types nested within other public types.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the public types defined in this assembly that are visible outside the assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array that represents the types defined in this assembly that are visible outside the assembly.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method works on both public and private resource files.</para>
          <para>The <paramref name="name" /> should not include the path to the file.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.IO.FileStream" /> for the specified file in the file table of the manifest of this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A stream that contains the specified file, or null if the file is not found.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the specified file. Do not include the path to the file.</param>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method works on public and private resource files.</para>
          <para>This overload is equivalent to calling the <see cref="M:System.Reflection.Assembly.GetFiles(System.Boolean)" /> overload and specifying false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the files in the file table of an assembly manifest.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of streams that contain the files.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method works on public and private resource files.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of streams that contain the files.</para>
        </returns>
        <param name="getResourceModules">
          <attribution license="cc4" from="Microsoft" modified="false" />true to include resource modules; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the hash code for this instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A 32-bit signed integer hash code.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets all the loaded modules that are part of this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of modules.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of modules.</para>
        </returns>
        <param name="getResourceModules">
          <attribution license="cc4" from="Microsoft" modified="false" />true to include resource modules; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Resource information is returned only if the resource is visible to the caller, or the caller has <see cref="T:System.Security.Permissions.ReflectionPermission" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns information about how the given resource has been persisted.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that is populated with information about the resource's topology, or null if the resource is not found.</para>
        </returns>
        <param name="resourceName">
          <attribution license="cc4" from="Microsoft" modified="false" />The case-sensitive name of the resource. </param>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Resource information is returned only if the resource is visible to the caller, or the caller has <see cref="T:System.Security.Permissions.ReflectionPermission" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the names of all the resources in this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array that contains the names of all the resources.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time. For more information about manifest resources, see <see cref="http://go.microsoft.com/fwlink/?LinkId=204554">Microsoft .NET Framework Resource Basics</see> in the MSDN Library.</para>
          <para>Resource information is returned only if the resource is visible to the caller, or the caller has <see cref="T:System.Security.Permissions.ReflectionPermission" />.</para>
          <block subset="none" type="note">
            <para>This method returns null if a private resource in another assembly is accessed and the caller does not have <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> flag.</para>
          </block>
          <para>If the assembly manifest lists a resource file, <see cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" /> returns a <see cref="T:System.IO.Stream" /> object even if the resource file cannot be found on disk at the time. If the resource file is not found, passing the resulting <see cref="T:System.IO.Stream" /> object to the <see cref="T:System.Resources.ResourceReader" /> constructor causes an <see cref="T:System.ArgumentException" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the specified manifest resource from this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The manifest resource; or null if no resources were specified during compilation or if the resource is not visible to the caller.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The case-sensitive name of the manifest resource being requested. </param>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For example, if the full name specified for <paramref name="type" /> is "MyNameSpace.MyClasses" and <paramref name="name" /> is "Net", this method overload searches for a resource named "MyNameSpace.Net".</para>
          <para>A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time. For more information about manifest resources, see <see cref="http://go.microsoft.com/fwlink/?LinkId=204554">Microsoft .NET Framework Resource Basics</see> in the MSDN Library.</para>
          <para>Resource information is returned only if the resource is visible to the caller, or the caller has <see cref="T:System.Security.Permissions.ReflectionPermission" />.</para>
          <block subset="none" type="note">
            <para>This method returns null if a private resource in another assembly is accessed and the caller does not have <see cref="T:System.Security.Permissions.ReflectionPermission" /> with the <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> flag.</para>
          </block>
          <para>If the assembly manifest lists a resource file, <see cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" /> returns a <see cref="T:System.IO.Stream" /> object even if the resource file cannot be found on disk at the time. If the resource file is not found, passing the resulting <see cref="T:System.IO.Stream" /> object to the <see cref="T:System.Resources.ResourceReader" /> constructor causes an <see cref="T:System.ArgumentException" />. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The manifest resource; or null if no resources were specified during compilation or if the resource is not visible to the caller.</para>
        </returns>
        <param name="type">
          <attribution license="cc4" from="Microsoft" modified="false" />The type whose namespace is used to scope the manifest resource name. </param>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The case-sensitive name of the manifest resource being requested. </param>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method works on file names.</para>
          <para>Classes in the Reflection.Emit namespace emit the scope name for a dynamic module. The scope name can be determined by the <see cref="P:System.Reflection.Module.ScopeName" /> property. Pass the kind of module you want to Assembly.GetModule. For example, if you want the module that contains the assembly manifest, pass the scope name of the module to GetModule. Otherwise, pass the file name of the module. Assemblies loaded by one of the Load methods that have a byte[] parameter have only one module, and that is the manifest module. Always seek these modules using the scope name.</para>
          <para>A type can be retrieved from a specific module using <see cref="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />. Calling Module.GetType on the module containing the manifest will not initiate a search of the entire assembly. To retrieve a type from an assembly, regardless of which module it is in, you must call <see cref="M:System.Reflection.Assembly.GetType(System.String)" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the specified module in this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The module being requested, or null if the module is not found.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the module being requested. </param>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method works on public and private resource files.</para>
          <block subset="none" type="note">
            <para>Modules must be emitted with file name extensions.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets all the modules that are part of this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of modules.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method works on public and private resource files.</para>
          <block subset="none" type="note">
            <para>Modules must be emitted with file name extensions.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets all the modules that are part of this assembly, specifying whether to include resource modules.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of modules.</para>
        </returns>
        <param name="getResourceModules">
          <attribution license="cc4" from="Microsoft" modified="false" />true to include resource modules; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that contains the fully parsed display name for this assembly.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly, setting the codebase as specified by <paramref name="copiedName" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that contains the fully parsed display name for this assembly.</para>
        </returns>
        <param name="copiedName">
          <attribution license="cc4" from="Microsoft" modified="false" />true to set the <see cref="P:System.Reflection.Assembly.CodeBase" /> to the location of the assembly after it was shadow copied; false to set <see cref="P:System.Reflection.Assembly.CodeBase" /> to the original location. </param>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets serialization information with all of the data needed to reinstantiate this assembly.</para>
        </summary>
        <param name="info">
          <attribution license="cc4" from="Microsoft" modified="false" />The object to be populated with serialization information. </param>
        <param name="context">
          <attribution license="cc4" from="Microsoft" modified="false" />The destination context of the serialization. </param>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>Starting with the net_v40_long, the <see cref="P:System.Reflection.AssemblyName.HashAlgorithm" /> property of an <see cref="T:System.Reflection.AssemblyName" /> object that is returned by this method is <see cref="F:System.Configuration.Assemblies.AssemblyHashAlgorithm.None" /> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <see cref="T:System.Configuration.Assemblies.AssemblyHashAlgorithm" /> enumeration. In previous versions of the .NET Framework, the <see cref="P:System.Reflection.AssemblyName.HashAlgorithm" /> property returned <see cref="F:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1" /> in this situation. </para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Reflection.AssemblyName" /> objects for all the assemblies referenced by this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</para>
          <para>Call this method to use your current assembly version.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the satellite assembly for the specified culture.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The specified satellite assembly.</para>
        </returns>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />The specified culture. </param>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</para>
          <para>Call the <see cref="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" /> overload to use your current assembly version.</para>
          <para>If <paramref name="version" /> is null, the current assembly version is used if both the resource and main assemblies are signed. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the specified version of the satellite assembly for the specified culture.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The specified satellite assembly.</para>
        </returns>
        <param name="culture">
          <attribution license="cc4" from="Microsoft" modified="false" />The specified culture. </param>
        <param name="version">
          <attribution license="cc4" from="Microsoft" modified="false" />The version of the satellite assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Type GetType(string name)" />
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is equal to <see cref="F:System.String.Empty" /> or starts with the null character ('\0').</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method only searches the current assembly instance. The <paramref name="name" /> parameter includes the namespace but not the assembly. To search other assemblies for a type, use the <see cref="M:System.Type.GetType(System.String)" /> method overload, which can optionally include an assembly display name as part of the type name.</para>
          <block subset="none" type="note">
            <para>If the type has been forwarded to another assembly, it is still returned by this method. For information on type forwarding, see <format type="text/html"><a href="51f8ffa3-c253-4201-a3d3-c4fad85ae097">Type Forwarding in the Common Language Runtime</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that represents the specified class, or null if the class is not found.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The full name of the type. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method only searches the current assembly instance. The <paramref name="name" /> parameter includes the namespace but not the assembly. To search other assemblies for a type, use the <see cref="M:System.Type.GetType(System.String)" /> method overload, which can optionally include an assembly display name as part of the type name.</para>
          <block subset="none" type="note">
            <para>If the type has been forwarded to another assembly, it is still returned by this method. For information on type forwarding, see <format type="text/html"><a href="51f8ffa3-c253-4201-a3d3-c4fad85ae097">Type Forwarding in the Common Language Runtime</a></format>.</para>
          </block>
          <para>The <paramref name="throwOnError" /> parameter only affects what happens when the type is not found. It does not affect any other exceptions that might be thrown. In particular, if the type is found but cannot be loaded, <see cref="T:System.TypeLoadException" /> can be thrown even if <paramref name="throwOnError" /> is false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that represents the specified class.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The full name of the type. </param>
        <param name="throwOnError">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw an exception if the type is not found; false to return null. </param>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method only searches the current assembly instance. The <paramref name="name" /> parameter includes the namespace but not the assembly. To search other assemblies for a type, use the <see cref="M:System.Type.GetType(System.String)" /> method overload, which can optionally include an assembly display name as part of the type name.</para>
          <block subset="none" type="note">
            <para>If the type has been forwarded to another assembly, it is still returned by this method. For information on type forwarding, see <format type="text/html"><a href="51f8ffa3-c253-4201-a3d3-c4fad85ae097">Type Forwarding in the Common Language Runtime</a></format>.</para>
          </block>
          <para>The <paramref name="throwOnError" /> parameter only affects what happens when the type is not found. It does not affect any other exceptions that might be thrown. In particular, if the type is found but cannot be loaded, <see cref="T:System.TypeLoadException" /> can be thrown even if <paramref name="throwOnError" /> is false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that represents the specified class.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The full name of the type. </param>
        <param name="throwOnError">
          <attribution license="cc4" from="Microsoft" modified="false" />true to throw an exception if the type is not found; false to return null. </param>
        <param name="ignoreCase">
          <attribution license="cc4" from="Microsoft" modified="false" />true to ignore the case of the type name; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Type[] GetTypes()" />
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The returned array includes nested types.</para>
          <para>If the <see cref="M:System.Reflection.Assembly.GetTypes" /> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <see cref="T:System.Reflection.ReflectionTypeLoadException" /> is thrown. For example, this can happen if the first assembly was loaded with the <see cref="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" /> or <see cref="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" /> methods, and the second assembly was not loaded. It can also happen with assemblies loaded using the <see cref="M:System.Reflection.Assembly.Load(System.String)" /> and <see cref="M:System.Reflection.Assembly.LoadFile(System.String)" /> methods if the second assembly cannot be located when the <see cref="M:System.Reflection.Assembly.GetTypes" /> method is called. </para>
          <block subset="none" type="note">
            <para>If a type has been forwarded to another assembly, it is not included in the returned array. For information on type forwarding, see <format type="text/html"><a href="51f8ffa3-c253-4201-a3d3-c4fad85ae097">Type Forwarding in the Common Language Runtime</a></format>.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the types defined in this assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array that contains all the types that are defined in this assembly.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>Boolean value whether the assembly was loaded from the GAC.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the assembly was loaded from the global assembly cache.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the host context with which the assembly was loaded.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>Version of the CLR stored in the assembly.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For example, the value for the .NET Framework version 1.1 would be v1.1.4322. The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322. </para>
          <para>By default, <see cref="P:System.Reflection.Assembly.ImageRuntimeVersion" /> is set to the version of the CLR used to build the assembly. However, it might have been set to another value at compile time. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>In the .NET Framework version 2.0, this method returns true if the assembly has security attributes stored in the new metadata format. Assemblies compiled with version 2.0 use this format. Dynamic assemblies and assemblies compiled with earlier versions of the .NET Framework use the old XML format. See Emitting Declarative Security Attributes.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether or not a specified attribute has been applied to the assembly.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the attribute has been applied to the assembly; otherwise, false.</para>
        </returns>
        <param name="attributeType">
          <attribution license="cc4" from="Microsoft" modified="false" />The type of the attribute to be checked for this assembly. </param>
        <param name="inherit">
          <attribution license="cc4" from="Microsoft" modified="false" />This argument is ignored for objects of this type. </param>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Dynamic assemblies are represented by the derived class <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</para>
          <para>When a dynamic assembly is saved to disk, the saved assembly is not dynamic. If the saved assembly is loaded into another application domain or process, the <see cref="P:System.Reflection.Assembly.IsDynamic" /> property returns false. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates whether the current assembly is loaded with full trust.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly. To load an assembly from a byte array with the trust level of the application domain, use the <see cref="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" /> method overload. For more information about the use of evidence with overloads of the <see cref="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" /> method that take byte arrays, see the <see cref="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" /> method overload. </para>
          <para>Reflecting on C++ executable files might throw a <see cref="T:System.BadImageFormatException" />. This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file. To preserve the .reloc address for your C++ executable file, specify /fixed:no when you are linking.</para>
          <para>Note that this method overload always creates a new <see cref="T:System.Reflection.Assembly" /> object with its own mapping.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly. The assembly is loaded into the application domain of the caller.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="rawAssembly">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array that is a COFF-based image containing an emitted assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.IO.FileLoadException" /> is thrown if <paramref name="assemblyRef" /> specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token. The loader does not continue probing for other assemblies that match the simple name. </para>
          <block subset="none" type="note">
            <para>Do not use an <see cref="T:System.Reflection.AssemblyName" /> with only the <see cref="P:System.Reflection.AssemblyName.CodeBase" /> property set. The <see cref="P:System.Reflection.AssemblyName.CodeBase" /> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <see cref="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" /> method. Instead, the assembly is loaded using load-from rules. For information about the disadvantages of using the load-from context, see the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method overload or <format type="text/html"><a href="68d1c539-6a47-4614-ab59-4b071c9d4b4c">Best Practices for Assembly Loading</a></format>.</para>
          </block>
          <para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
          <list type="bullet">
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with no <see cref="T:System.Security.Policy.Evidence" /> parameter, the assembly is loaded with the evidence that the loader supplies.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with an <see cref="T:System.Security.Policy.Evidence" /> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method supersede pieces of evidence supplied by the loader.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload with a Byte[] parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly. This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</para>
              <block subset="none" type="note">
                <para>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload with a Byte[] parameter to load a COFF image, evidence is combined. Zone, Url and Site are inherited from the calling assembly, and Hash and StrongName are taken from the COFF assembly.</para>
              </block>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with a Byte[] parameter and <see cref="T:System.Security.Policy.Evidence" /> to load a COFF image, only the supplied evidence is used. Evidence of the calling assembly and evidence of the COFF image is ignored.</para>
            </item>
          </list>
          <para>Reflecting on C++ executable files might throw a <see cref="T:System.BadImageFormatException" />. This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file. To preserve the .reloc address for your C++ executable file, specify /fixed:no when you are linking.</para>
          <block subset="none" type="note">
            <para>If both the <see cref="P:System.Reflection.AssemblyName.Name" /> property and the <see cref="P:System.Reflection.AssemblyName.CodeBase" /> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <see cref="P:System.Reflection.Assembly.FullName" /> property). If the file is not found, <see cref="P:System.Reflection.AssemblyName.CodeBase" /> is used to search for the assembly. If the assembly is found using <see cref="P:System.Reflection.AssemblyName.CodeBase" />, the display name is matched against the assembly. If the match fails, a <see cref="T:System.IO.FileLoadException" /> is thrown.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyRef">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that describes the assembly to be loaded. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Reflection.Assembly Load(string assemblyString)" />
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> is equal to <see cref="F:System.String.Empty" /> or starts with the null character ('\0').</exception>
        <exception cref="T:System.IO.FileNotFoundException">The <see cref="T:System.Reflection.Assembly" /> identified by <paramref name="assemblyString" /> was not found.</exception>
        <exception cref="T:System.BadImageFormatException">The <see cref="T:System.Reflection.Assembly" /> identified by <paramref name="assemblyString" /> is not a valid assembly. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.IO.FileLoadException" /> is thrown if <paramref name="assemblyString" /> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token. The loader does not continue probing for other assemblies that match the simple name. </para>
          <para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
          <list type="bullet">
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with no <see cref="T:System.Security.Policy.Evidence" /> parameter, the assembly is loaded with the evidence that the loader supplies.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with an <see cref="T:System.Security.Policy.Evidence" /> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method supersede pieces of evidence supplied by the loader.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload with a Byte[] parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly. This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</para>
              <block subset="none" type="note">
                <para>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload with a Byte[] parameter to load a COFF image, evidence is combined. Zone, Url and Site are inherited from the calling assembly, and Hash and StrongName are taken from the COFF assembly.</para>
              </block>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with a Byte[] parameter and <see cref="T:System.Security.Policy.Evidence" /> to load a COFF image, only the supplied evidence is used. Evidence of the calling assembly and evidence of the COFF image is ignored.</para>
            </item>
          </list>
          <para>Reflecting on C++ executable files might throw a <see cref="T:System.BadImageFormatException" />. This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file. To preserve the .reloc address for your C++ executable file, specify /fixed:no when you are linking.</para>
          <para>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, "ProcessorArchitecture=msil". However, the recommended way to specify an assembly name is to create an <see cref="T:System.Reflection.AssemblyName" /> object and pass it to an appropriate overload of the <see cref="Overload:System.Reflection.Assembly.Load" /> method. See <see cref="P:System.Reflection.AssemblyName.ProcessorArchitecture" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly given the long form of its name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyString">
          <attribution license="cc4" from="Microsoft" modified="false" />The long form of the assembly name. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly. To load an assembly from a byte array with the trust level of the application domain, use the <see cref="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" /> method overload. For more information about the use of evidence with overloads of the <see cref="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" /> method that take byte arrays, see the <see cref="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" /> method overload.</para>
          <para>Reflecting on C++ executable files might throw a <see cref="T:System.BadImageFormatException" />. This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file. To preserve the .reloc address for your C++ executable file, specify /fixed:no when you are linking.</para>
          <para>Note that this method overload always creates a new <see cref="T:System.Reflection.Assembly" /> object with its own mapping.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly. The assembly is loaded into the application domain of the caller.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="rawAssembly">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array that is a COFF-based image containing an emitted assembly. </param>
        <param name="rawSymbolStore">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array that contains the raw bytes representing the symbols for the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.IO.FileLoadException" /> is thrown if <paramref name="assemblyRef" /> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token. The loader does not continue probing for other assemblies that match the simple name. </para>
          <block subset="none" type="note">
            <para>Do not use an <see cref="T:System.Reflection.AssemblyName" /> with only the <see cref="P:System.Reflection.AssemblyName.CodeBase" /> property set. The <see cref="P:System.Reflection.AssemblyName.CodeBase" /> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <see cref="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" /> method. Instead, the assembly is loaded using load-from rules. For information about the disadvantages of using the load-from context, see the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method overload or <format type="text/html"><a href="68d1c539-6a47-4614-ab59-4b071c9d4b4c">Best Practices for Assembly Loading</a></format>.</para>
          </block>
          <para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
          <list type="bullet">
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with no <see cref="T:System.Security.Policy.Evidence" /> parameter, the assembly is loaded with the evidence that the loader supplies.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with an <see cref="T:System.Security.Policy.Evidence" /> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method supersede pieces of evidence supplied by the loader.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload with a Byte[] parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly. This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</para>
              <block subset="none" type="note">
                <para>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload with a Byte[] parameter to load a COFF image, evidence is combined. Zone, Url and Site are inherited from the calling assembly, and Hash and StrongName are taken from the COFF assembly.</para>
              </block>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with a Byte[] parameter and <see cref="T:System.Security.Policy.Evidence" /> to load a COFF image, only the supplied evidence is used. Evidence of the calling assembly and evidence of the COFF image is ignored.</para>
            </item>
          </list>
          <para>Reflecting on C++ executable files might throw a <see cref="T:System.BadImageFormatException" />. This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file. To preserve the .reloc address for your C++ executable file, specify /fixed:no when you are linking.</para>
          <block subset="none" type="note">
            <para>If both the <see cref="P:System.Reflection.AssemblyName.Name" /> property and the <see cref="P:System.Reflection.AssemblyName.CodeBase" /> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <see cref="P:System.Reflection.Assembly.FullName" /> property). If the file is not found, <see cref="P:System.Reflection.AssemblyName.CodeBase" /> is used to search for the assembly. If the assembly is found using <see cref="P:System.Reflection.AssemblyName.CodeBase" />, the display name is matched against the assembly. If the match fails, a <see cref="T:System.IO.FileLoadException" /> is thrown.</para>
          </block>
          <para>If you call the <see cref="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" /> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <see cref="T:System.IO.FileLoadException" /> because the equality and integrity of the different evidence specifications cannot be determined. The evidence that first succeeds is the evidence that is used. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />. The assembly is loaded into the domain of the caller using the supplied evidence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyRef">
          <attribution license="cc4" from="Microsoft" modified="false" />The object that describes the assembly to be loaded. </param>
        <param name="assemblySecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.IO.FileLoadException" /> is thrown if <paramref name="assemblyString" /> specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token. The loader does not continue probing for other assemblies that match the simple name. </para>
          <para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
          <list type="bullet">
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with no <see cref="T:System.Security.Policy.Evidence" /> parameter, the assembly is loaded with the evidence that the loader supplies.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with an <see cref="T:System.Security.Policy.Evidence" /> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method supersede pieces of evidence supplied by the loader.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload with a Byte[] parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly. This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</para>
              <block subset="none" type="note">
                <para>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload with a Byte[] parameter to load a COFF image, evidence is combined. Zone, Url and Site are inherited from the calling assembly, and Hash and StrongName are taken from the COFF assembly.</para>
              </block>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with a Byte[] parameter and <see cref="T:System.Security.Policy.Evidence" /> to load a COFF image, only the supplied evidence is used. Evidence of the calling assembly and evidence of the COFF image is ignored.</para>
            </item>
          </list>
          <para>Reflecting on C++ executable files might throw a <see cref="T:System.BadImageFormatException" />. This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file. To preserve the .reloc address for your C++ executable file, specify /fixed:no when you are linking.</para>
          <para>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <see cref="T:System.IO.FileLoadException" /> because the equality and integrity of the different evidence specifications cannot be determined. The evidence that first succeeds is the evidence that is used. </para>
          <para>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, "ProcessorArchitecture=msil". However, the recommended way to specify an assembly name is to create an <see cref="T:System.Reflection.AssemblyName" /> object and pass it to an appropriate overload of the <see cref="Overload:System.Reflection.Assembly.Load" /> method. See <see cref="P:System.Reflection.AssemblyName.ProcessorArchitecture" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyString">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. </param>
        <param name="assemblySecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly is loaded into the domain of the caller using the supplied evidence. The raw bytes representing the symbols for the assembly are also loaded.</para>
          <para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
          <list type="bullet">
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with no <see cref="T:System.Security.Policy.Evidence" /> parameter, the assembly is loaded with the evidence that the loader supplies.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with an <see cref="T:System.Security.Policy.Evidence" /> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method supersede pieces of evidence supplied by the loader.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload with a Byte[] parameter to load a COFF image, evidence is inherited from the calling assembly. This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases. </para>
              <block subset="none" type="note">
                <para>In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload with a Byte[] parameter to load a COFF image, evidence is combined. Zone, Url and Site are inherited from the calling assembly, and Hash and StrongName are taken from the COFF assembly.</para>
              </block>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method with a Byte[] parameter and <see cref="T:System.Security.Policy.Evidence" /> to load a COFF image, only the supplied evidence is used. Evidence of the calling assembly and evidence of the COFF image are ignored.</para>
            </item>
          </list>
          <para>Reflecting on C++ executable files might throw a <see cref="T:System.BadImageFormatException" />. This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file. To preserve the .reloc address for your C++ executable file, specify /fixed:no when you are linking.</para>
          <para>If you call the <see cref="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" /> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <see cref="T:System.IO.FileLoadException" /> because the equality and integrity of the different evidence specifications cannot be determined. The evidence that first succeeds is the evidence that is used. </para>
          <para>Note that this method overload always creates a new <see cref="T:System.Reflection.Assembly" /> object with its own mapping.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly. The assembly is loaded into the application domain of the caller.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="rawAssembly">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array that is a COFF-based image containing an emitted assembly. </param>
        <param name="rawSymbolStore">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array that contains the raw bytes representing the symbols for the assembly. </param>
        <param name="securityEvidence">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The assembly is loaded into the application domain of the caller using the specified source for the security context. If <paramref name="rawSymbolStore" /> was specified, the raw bytes that represent the symbols for the assembly are also loaded.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context. The assembly is loaded into the application domain of the caller.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="rawAssembly">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array that is a COFF-based image containing an emitted assembly. </param>
        <param name="rawSymbolStore">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array that contains the raw bytes representing the symbols for the assembly. </param>
        <param name="securityContextSource">
          <attribution license="cc4" from="Microsoft" modified="false" />The source of the security context. </param>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="M:System.Reflection.Assembly.LoadFile(System.String)" /> method to load and examine assemblies that have the same identity, but are located in different paths. <see cref="M:System.Reflection.Assembly.LoadFile(System.String)" /> does not load files into the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> context, and does not resolve dependencies using the load path, as the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method does. <see cref="M:System.Reflection.Assembly.LoadFile(System.String)" /> is useful in this limited scenario because <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the contents of an assembly file on the specified path.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />The path of the file to load. </param>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use the <see cref="M:System.Reflection.Assembly.LoadFile(System.String)" /> method to load and examine assemblies that have the same identity, but are located in different paths. <see cref="M:System.Reflection.Assembly.LoadFile(System.String)" /> does not load files into the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> context, and does not resolve dependencies using the load path, as the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method does. <see cref="M:System.Reflection.Assembly.LoadFile(System.String)" /> is useful in this limited scenario because <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />The path of the assembly file. </param>
        <param name="securityEvidence">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="assemblyFile" /> parameter must refer to a URI without escape characters. This method supplies escape characters for all invalid characters in the URI.</para>
          <block subset="none" type="note">
            <para>File transfer protocol (FTP) is not supported. If the URI supplied for <paramref name="assemblyFile" /> is an FTP address, the assembly is not loaded. No exception is thrown.</para>
          </block>
          <para>
            <paramref name="assemblyFile" /> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</para>
          <para>Assemblies can be loaded into one of three contexts, or can be loaded without context:</para>
          <list type="bullet">
            <item>
              <para>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <see cref="P:System.AppDomainSetup.ApplicationBase" /> and <see cref="P:System.AppDomainSetup.PrivateBinPath" /> of the application domain. Most overloads of the <see cref="Overload:System.Reflection.Assembly.Load" /> method load assemblies into this context.</para>
            </item>
            <item>
              <para>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing. <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, <see cref="Overload:System.AppDomain.CreateInstanceFrom" />, and <see cref="Overload:System.AppDomain.ExecuteAssembly" /> are examples of methods that load by path. </para>
            </item>
            <item>
              <para>The reflection-only context contains assemblies loaded with the <see cref="Overload:System.Reflection.Assembly.ReflectionOnlyLoad" /> and <see cref="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" /> methods; code in these contexts cannot be executed.</para>
            </item>
            <item>
              <para>If the user generated or found the assembly, it is not in any context. This applies to assemblies loaded using overloads of the <see cref="Overload:System.Reflection.Assembly.Load" /> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk. </para>
            </item>
          </list>
          <para>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context. </para>
          <para>The <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> method has the following disadvantages. Consider using <see cref="Overload:System.Reflection.Assembly.Load" /> instead.</para>
          <list type="bullet">
            <item>
              <para>If an assembly with the same identity is already loaded, <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> returns the loaded assembly even if a different path was specified. </para>
            </item>
            <item>
              <para>If an assembly is loaded with <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails. This can occur when an assembly is de-serialized. </para>
            </item>
            <item>
              <para>If an assembly is loaded with <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, and the probing path includes an assembly with the same identity but a different location, an <see cref="T:System.InvalidCastException" />, <see cref="T:System.MissingMethodException" />, or other unexpected behavior can occur. </para>
            </item>
            <item>
              <para>
                <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> demands <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />, or <see cref="T:System.Net.WebPermission" />, on the specified path.</para>
            </item>
            <item>
              <para>If a native image exists for <paramref name="assemblyFile" />, it is not used. The assembly cannot be loaded as domain neutral.</para>
            </item>
            <item>
              <para>In the .NET Framework version 1.0 and 1.1, policy is not applied.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly given its file name or path.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name or path of the file that contains the manifest of the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="assemblyFile" /> parameter must refer to a URI without escape characters. This method supplies escape characters for all invalid characters in the URI.</para>
          <block subset="none" type="note">
            <para>File transfer protocol (FTP) is not supported. If the URI supplied for <paramref name="assemblyFile" /> is an FTP address, the assembly is not loaded. No exception is thrown.</para>
          </block>
          <para>
            <paramref name="assemblyFile" /> may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</para>
          <para>Assemblies can be loaded into one of three contexts, or can be loaded without context:</para>
          <list type="bullet">
            <item>
              <para>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <see cref="P:System.AppDomainSetup.ApplicationBase" /> and <see cref="P:System.AppDomainSetup.PrivateBinPath" /> of the application domain. Most overloads of the <see cref="Overload:System.Reflection.Assembly.Load" /> method load assemblies into this context.</para>
            </item>
            <item>
              <para>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing. <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, <see cref="Overload:System.AppDomain.CreateInstanceFrom" />, and <see cref="Overload:System.AppDomain.ExecuteAssembly" /> are examples of methods that load by path. </para>
            </item>
            <item>
              <para>The reflection-only context contains assemblies loaded with the <see cref="Overload:System.Reflection.Assembly.ReflectionOnlyLoad" /> and <see cref="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" /> methods; code in these contexts cannot be executed.</para>
            </item>
            <item>
              <para>If the user generated or found the assembly, it is not in any context. This applies to assemblies loaded using overloads of the <see cref="Overload:System.Reflection.Assembly.Load" /> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk. </para>
            </item>
          </list>
          <para>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context. </para>
          <para>The <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> method has the following disadvantages. Consider using <see cref="Overload:System.Reflection.Assembly.Load" /> instead.</para>
          <list type="bullet">
            <item>
              <para>If an assembly with the same identity is already loaded, <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> returns the loaded assembly even if a different path was specified. </para>
            </item>
            <item>
              <para>If an assembly is loaded with <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails. This can occur when an assembly is deserialized. </para>
            </item>
            <item>
              <para>If an assembly is loaded with <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, and the probing path includes an assembly with the same identity but a different location, an <see cref="T:System.InvalidCastException" />, <see cref="T:System.MissingMethodException" />, or other unexpected behavior can occur. </para>
            </item>
            <item>
              <para>
                <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> demands <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />, or <see cref="T:System.Net.WebPermission" />, on the specified path.</para>
            </item>
            <item>
              <para>If a native image exists for <paramref name="assemblyFile" />, it is not used. The assembly cannot be loaded as domain neutral.</para>
            </item>
            <item>
              <para>In the .NET Framework version 1.0 and 1.1, policy is not applied.</para>
            </item>
          </list>
          <para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
          <list type="bullet">
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method with no <see cref="T:System.Security.Policy.Evidence" /> parameter, the assembly is loaded with the evidence that the loader supplies.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method with an <see cref="T:System.Security.Policy.Evidence" /> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method supersede pieces of evidence supplied by the loader.</para>
            </item>
            <item>
              <para>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <see cref="T:System.IO.FileLoadException" /> because the equality and integrity of the different evidence specifications cannot be determined. The evidence that first succeeds is the evidence that is used. </para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method with a Byte[] parameter to load a common object file format (COFF) image, evidence is combined. Zone, Url and Site are inherited from the calling assembly, and Hash and StrongName are taken from the COFF assembly.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method with a Byte[] parameter and <see cref="T:System.Security.Policy.Evidence" /> to load a COFF image, only the supplied evidence is used. Evidence of the calling assembly and evidence of the COFF image is ignored.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly given its file name or path and supplying security evidence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name or path of the file that contains the manifest of the assembly. </param>
        <param name="securityEvidence">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="assemblyFile" /> parameter must refer to a URI without escape characters. This method supplies escape characters for all invalid characters in the URI.</para>
          <block subset="none" type="note">
            <para>File transfer protocol (FTP) is not supported. If the URI supplied for <paramref name="assemblyFile" /> is an FTP address, the assembly is not loaded. No exception is thrown.</para>
          </block>
          <para>
            <paramref name="assemblyFile" /> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</para>
          <para>Assemblies can be loaded into one of three contexts, or can be loaded without context:</para>
          <list type="bullet">
            <item>
              <para>The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <see cref="P:System.AppDomainSetup.ApplicationBase" /> and <see cref="P:System.AppDomainSetup.PrivateBinPath" /> of the application domain. Most overloads of the <see cref="Overload:System.Reflection.Assembly.Load" /> method load assemblies into this context.</para>
            </item>
            <item>
              <para>The load-from context contains assemblies for which the user provided a path that is not included in probing. <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, <see cref="Overload:System.AppDomain.CreateInstanceFrom" />, and <see cref="Overload:System.AppDomain.ExecuteAssembly" /> are examples of methods that load by path. </para>
            </item>
            <item>
              <para>The reflection-only context contains assemblies loaded with the <see cref="Overload:System.Reflection.Assembly.ReflectionOnlyLoad" /> and <see cref="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" /> methods; code in these contexts cannot be executed.</para>
            </item>
            <item>
              <para>If the user generated or found the assembly, it is not in any context. This applies to assemblies loaded using overloads of the <see cref="Overload:System.Reflection.Assembly.Load" /> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk. </para>
            </item>
          </list>
          <para>The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context. </para>
          <para>The <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> method has the following disadvantages. Consider using <see cref="Overload:System.Reflection.Assembly.Load" /> instead.</para>
          <list type="bullet">
            <item>
              <para>If an assembly with the same identity is already loaded, <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> returns the loaded assembly even if a different path was specified. </para>
            </item>
            <item>
              <para>If an assembly is loaded with <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails. This can occur when an assembly is deserialized. </para>
            </item>
            <item>
              <para>If an assembly is loaded with <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, and the probing path includes an assembly with the same identity but a different location, an <see cref="T:System.InvalidCastException" />, <see cref="T:System.MissingMethodException" />, or other unexpected behavior can occur. </para>
            </item>
            <item>
              <para>
                <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> demands <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />, or <see cref="T:System.Net.WebPermission" />, on the specified path.</para>
            </item>
            <item>
              <para>If a native image exists for <paramref name="assemblyFile" />, it is not used. The assembly cannot be loaded as domain-neutral.</para>
            </item>
          </list>
          <para>The assembly is loaded with the evidence that the loader supplies.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly given its file name or path, hash value, and hash algorithm.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name or path of the file that contains the manifest of the assembly. </param>
        <param name="hashValue">
          <attribution license="cc4" from="Microsoft" modified="false" />The value of the computed hash code. </param>
        <param name="hashAlgorithm">
          <attribution license="cc4" from="Microsoft" modified="false" />The hash algorithm used for hashing files and for generating the strong name. </param>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="assemblyFile" /> parameter must refer to a URI without escape characters. This method supplies escape characters for all invalid characters in the URI.</para>
          <block subset="none" type="note">
            <para>File transfer protocol (FTP) is not supported. If the URI supplied for <paramref name="assemblyFile" /> is an FTP address, the assembly is not loaded. No exception is thrown.</para>
          </block>
          <para>
            <paramref name="assemblyFile" /> may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</para>
          <para>Assemblies can be loaded into one of three contexts, or can be loaded without context:</para>
          <list type="bullet">
            <item>
              <para>The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <see cref="P:System.AppDomainSetup.ApplicationBase" /> and <see cref="P:System.AppDomainSetup.PrivateBinPath" /> of the application domain. Most overloads of the <see cref="Overload:System.Reflection.Assembly.Load" /> method load assemblies into this context.</para>
            </item>
            <item>
              <para>The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing. <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, <see cref="Overload:System.AppDomain.CreateInstanceFrom" />, and <see cref="Overload:System.AppDomain.ExecuteAssembly" /> are examples of methods that load by path. </para>
            </item>
            <item>
              <para>The reflection-only context contains assemblies loaded with the <see cref="Overload:System.Reflection.Assembly.ReflectionOnlyLoad" /> and <see cref="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" /> methods; code in these contexts cannot be executed.</para>
            </item>
            <item>
              <para>If the user generated or found the assembly, it is not in any context. This applies to assemblies loaded using overloads of the <see cref="Overload:System.Reflection.Assembly.Load" /> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk. </para>
            </item>
          </list>
          <para>The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context. </para>
          <para>The <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> method has the following disadvantages. Consider using <see cref="Overload:System.Reflection.Assembly.Load" /> instead.</para>
          <list type="bullet">
            <item>
              <para>If an assembly with the same identity is already loaded, <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> returns the loaded assembly even if a different path was specified. </para>
            </item>
            <item>
              <para>If an assembly is loaded with <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails. This can occur when an assembly is deserialized. </para>
            </item>
            <item>
              <para>If an assembly is loaded with <see cref="Overload:System.Reflection.Assembly.LoadFrom" />, and the probing path includes an assembly with the same identity but a different location, an <see cref="T:System.InvalidCastException" />, <see cref="T:System.MissingMethodException" />, or other unexpected behavior can occur. </para>
            </item>
            <item>
              <para>
                <see cref="Overload:System.Reflection.Assembly.LoadFrom" /> demands <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />, or <see cref="T:System.Net.WebPermission" />, on the specified path.</para>
            </item>
            <item>
              <para>If a native image exists for <paramref name="assemblyFile" />, it is not used. The assembly cannot be loaded as domain neutral.</para>
            </item>
            <item>
              <para>In the .NET Framework version 1.0 and 1.1, policy is not applied.</para>
            </item>
          </list>
          <para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
          <list type="bullet">
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method with no <see cref="T:System.Security.Policy.Evidence" /> parameter, the assembly is loaded with the evidence that the loader supplies.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method with an <see cref="T:System.Security.Policy.Evidence" /> parameter, pieces of evidence are merged. Pieces of evidence supplied as an argument to the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method supersede pieces of evidence supplied by the loader.</para>
            </item>
            <item>
              <para>If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <see cref="T:System.IO.FileLoadException" /> because the equality and integrity of the different evidence specifications cannot be determined. The evidence that first succeeds is the evidence that is used. </para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method with a Byte[] parameter to load a common object file format (COFF) image, evidence is combined. Zone, Url and Site are inherited from the calling assembly, and Hash and StrongName are taken from the COFF assembly.</para>
            </item>
            <item>
              <para>When you use a <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method with a Byte[] parameter and <see cref="T:System.Security.Policy.Evidence" /> to load a COFF image, only the supplied evidence is used. Evidence of the calling assembly and evidence of the COFF image is ignored.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name or path of the file that contains the manifest of the assembly. </param>
        <param name="securityEvidence">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
        <param name="hashValue">
          <attribution license="cc4" from="Microsoft" modified="false" />The value of the computed hash code. </param>
        <param name="hashAlgorithm">
          <attribution license="cc4" from="Microsoft" modified="false" />The hash algorithm used for hashing files and for generating the strong name. </param>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded module.</para>
        </returns>
        <param name="moduleName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the module. This string must correspond to a file name in this assembly's manifest. </param>
        <param name="rawModule">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array that is a COFF-based image containing an emitted module, or a resource. </param>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file. The raw bytes representing the symbols for the module are also loaded.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded module.</para>
        </returns>
        <param name="moduleName">
          <attribution license="cc4" from="Microsoft" modified="false" />The name of the module. This string must correspond to a file name in this assembly's manifest. </param>
        <param name="rawModule">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array that is a COFF-based image containing an emitted module, or a resource. </param>
        <param name="rawSymbolStore">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array containing the raw bytes representing the symbols for the module. Must be null if this is a resource file. </param>
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Applications that load assemblies with this method will be affected by upgrades of those assemblies. Therefore, do not use this method; redesign the application to use the <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method overload or the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method overload.</para>
          <para>This method first calls <see cref="Overload:System.Reflection.Assembly.Load" />. If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly from the application directory or from the global assembly cache using a partial name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly. If <paramref name="partialName" /> is not found, this method returns null.</para>
        </returns>
        <param name="partialName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</para>
          <para>Applications that load assemblies with this method will be affected by upgrades of those assemblies. Therefore, do not use this method; redesign the application to use the <see cref="M:System.Reflection.Assembly.Load(System.String)" /> method or the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</para>
          <para>This method first calls <see cref="Overload:System.Reflection.Assembly.Load" />. If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly from the application directory or from the global assembly cache using a partial name. The assembly is loaded into the domain of the caller using the supplied evidence.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly. If <paramref name="partialName" /> is not found, this method returns null.</para>
        </returns>
        <param name="partialName">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly. </param>
        <param name="securityEvidence">
          <attribution license="cc4" from="Microsoft" modified="false" />Evidence for loading the assembly. </param>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>Location of the loaded assembly.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To get the location before the file has been shadow-copied, use the <see cref="P:System.Reflection.Assembly.CodeBase" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the full path or UNC location of the loaded file that contains the manifest.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the module that contains the manifest for the current assembly. </para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This event gives the callback a chance to find and load the module itself and return it.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a collection that contains the modules in this assembly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are equal.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, false.</para>
        </returns>
        <param name="left">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly to compare to <paramref name="right" />. </param>
        <param name="right">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly to compare to <paramref name="left" />.</param>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are not equal.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, false.</para>
        </returns>
        <param name="left">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly to compare to <paramref name="right" />.</param>
        <param name="right">
          <attribution license="cc4" from="Microsoft" modified="false" />The assembly to compare to <paramref name="left" />.</param>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="T:System.Security.PermissionSet" /> objects can contain sensitive information such as paths. Therefore, full trust is required to access these objects.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the grant set of the current assembly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If an assembly has been loaded into the reflection-only context, using the <see cref="Overload:System.Reflection.Assembly.ReflectionOnlyLoad" /> method, you cannot execute code in the assembly. To execute code, the assembly must be loaded into the execution context.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Boolean" /> value indicating whether this assembly was loaded into the reflection-only context.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You cannot execute code from an assembly loaded into the reflection-only context. To execute code, the assembly must be loaded into the execution context as well, using the <see cref="Overload:System.Reflection.Assembly.Load" /> method.</para>
          <para>The reflection-only context is no different from other contexts. Assemblies that are loaded into the context can be unloaded only by unloading the application domain. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly. The assembly is loaded into the reflection-only context of the caller's application domain.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="rawAssembly">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte array that is a COFF-based image containing an emitted assembly.</param>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Dependencies are not automatically loaded into the reflection-only context. </para>
          <para>You cannot execute code from an assembly loaded into the reflection-only context. To execute code, the assembly must be loaded into the execution context as well, using the <see cref="Overload:System.Reflection.Assembly.Load" /> method.</para>
          <para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
          <block subset="none" type="note">
            <para>Reflecting on executable files compiled in C++ might throw a <see cref="T:System.IO.FileLoadException" />. This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file. To preserve the .reloc address, specify /fixed:no when you are linking.</para>
          </block>
          <para>The reflection-only context is no different from other contexts. Assemblies that are loaded into the context can be unloaded only by unloading the application domain. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly into the reflection-only context, given its display name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyString">
          <attribution license="cc4" from="Microsoft" modified="false" />The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName" /> property.</param>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Dependencies are not automatically loaded into the reflection-only context. To automatically load dependencies, handle the <see cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" /> event and load the dependency in the event handler.</para>
          <para>You cannot execute code from an assembly that has been loaded into the reflection-only context. To execute the code, load the assembly with the <see cref="Overload:System.Reflection.Assembly.LoadFile" /> method.</para>
          <para>The <paramref name="assemblyFile" /> parameter must refer to a URI without escape characters. This method supplies escape characters for all invalid characters in the URI.</para>
          <para>The path specified for <paramref name="assemblyFile" /> is relative to the current directory. The assembly is loaded into the domain of the caller.</para>
          <para>The reflection-only context is no different from other contexts. Assemblies that are loaded into the context can be unloaded only by unloading the application domain. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly into the reflection-only context, given its path.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The path of the file that contains the manifest of the assembly.</param>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>By default, assemblies that you compile with the net_v40_long have <format type="text/html"><a href="4d05610a-0da6-4f08-acea-d54c9d6143c0">level 2</a></format> transparency, although you can explicitly make them <format type="text/html"><a href="5fd8f46d-3961-46a7-84af-2eb1f48e75cf">level 1</a></format> instead. Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency. </para>
          <para>See <format type="text/html"><a href="5e87881c-9c13-4b52-8ad1-e34bb46e8aaa">Security Changes in the .NET Framework 4</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the type of the current instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that represents the <see cref="T:System.Reflection.Assembly" /> type.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual string ToString()" />
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <para> This method returns the <see cref="P:System.Reflection.Assembly.FullName" /> of the
   current assembly.</para>
          <para>
            <block subset="none" type="note">This method
   overrides <see cref="M:System.Object.ToString" qualify="true" />
   .</block>
          </para>
        </remarks>
        <example>
          <para>The following example demonstrates the use of the <see cref="M:System.Reflection.Assembly.ToString" qualify="true" /> method in an assembly compiled into
   a file named "HelloWorld".</para>
          <code lang="C#">using System;
using System.Reflection;

public class AssemblyExample {
 public static void Main() {

 Assembly a = Assembly.Load("helloworld");
 Console.WriteLine(a.ToString());
 } 
}
</code>
          <para>The output is</para>
          <c>
            <para>HelloWorld, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null</para>
          </c>
        </example>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the full name of the assembly, also known as the display name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet). Before the net_v40_long, such assemblies were automatically loaded into a sandboxed application domain. Starting with the net_v40_short, they are loaded with full trust. </para>
          <para>As an alternative to using this method, you can apply the <format type="text/html"><a href="07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; Element</a></format> in your application configuration file. This causes the common language runtime to revert to the security policy of the net_v35_long.</para>
          <block subset="none" type="note">
            <para>If you use either of these solutions, you must be certain that it is safe to load <paramref name="assemblyFile" /> with full trust.</para>
          </block>
          <para>For a discussion of load contexts, including the load-from context, see the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method overload.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Loads an assembly into the load-from context, bypassing some security checks.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The loaded assembly.</para>
        </returns>
        <param name="assemblyFile">
          <attribution license="cc4" from="Microsoft" modified="false" />The name or path of the file that contains the manifest of the assembly.</param>
      </Docs>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>