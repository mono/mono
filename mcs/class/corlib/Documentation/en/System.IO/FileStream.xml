<?xml version="1.0" encoding="utf-8"?>
<Type Name="FileStream" FullName="System.IO.FileStream" FullNameSP="System_IO_FileStream" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public FileStream extends System.IO.Stream" />
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <example>
      <para>The following example demonstrates the use of a <see cref="T:System.IO.FileStream" />
object.</para>
      <code lang="C#">using System;
using System.IO;

class Directory {
   public static void Main(String[] args) { 
      FileStream fs = new FileStream("log.txt", FileMode.OpenOrCreate, FileAccess.Write);
      StreamWriter w = new StreamWriter(fs);         
      w.BaseStream.Seek(0, SeekOrigin.End);   // Set the file pointer to the end.

      Log ("Test1", w);
      Log ("Test2", w);
 
      w.Close(); // Close the writer and underlying file.     

      fs = new FileStream("log.txt", FileMode.OpenOrCreate, FileAccess.Read);

      StreamReader r = new StreamReader(fs);        
      r.BaseStream.Seek(0, SeekOrigin.Begin);   
      DumpLog (r);
   }

   public static void Log (String logMessage, StreamWriter w) {
      w.Write("Log Entry : ");
      w.WriteLine("{0} {1}", DateTime.Now.ToLongTimeString(), DateTime.Now.ToLongDateString());
      w.WriteLine(":");
      w.WriteLine(":{0}", logMessage);
      w.WriteLine ("-------------------------------");
      w.Flush();  
   }

   public static void DumpLog (StreamReader r) {
      while (r.Peek() &gt; -1) { // While not at the end of the file, write to standard output.     
        Console.WriteLine(r.ReadLine());
      }

      r.Close();
   }
}
</code>
      <para>Some example output is </para>
      <c>
        <para>Log Entry : 9:26:21 AM Friday, July 06, 2001</para>
        <para>:</para>
        <para>:Test1</para>
        <para>-------------------------------</para>
        <para>Log Entry : 9:26:21 AM Friday, July 06, 2001</para>
        <para>:</para>
        <para>:Test2</para>
        <para>-------------------------------</para>
      </c>
    </example>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Use the <see cref="T:System.IO.FileStream" /> class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the <see cref="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />, and <see cref="M:System.IO.FileStream.Flush" /> methods to perform synchronous operations, or the <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />, and <see cref="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" /> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a win8_appname_long app or desktop_appname app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. <see cref="T:System.IO.FileStream" /> buffers input and output for better performance.</para>
      <para>The <see cref="P:System.IO.FileStream.IsAsync" /> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the <see cref="T:System.IO.FileStream" /> class using a constructor that has an <paramref name="isAsync" />, <paramref name="useAsync" />, or <paramref name="options" /> parameter. When the property is true, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <see cref="P:System.IO.FileStream.IsAsync" /> property does not have to be true to call the <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, or <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> method. When the <see cref="P:System.IO.FileStream.IsAsync" /> property is false and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</para>
      <para>The <see cref="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" /> method supports random access to files. <see cref="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" /> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <see cref="T:System.IO.SeekOrigin" /> enumeration.</para>
      <block subset="none" type="note">
        <para>Disk files always support random access. At the time of construction, the <see cref="P:System.IO.FileStream.CanSeek" /> property value is set to true or false depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <see cref="P:System.IO.FileStream.CanSeek" /> property value is true. Otherwise, the <see cref="P:System.IO.FileStream.CanSeek" /> property value is false.</para>
      </block>
      <para>If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.</para>
      <para>For directory operations and other file operations, see the <see cref="T:System.IO.File" />, <see cref="T:System.IO.Directory" />, and <see cref="T:System.IO.Path" /> classes. The <see cref="T:System.IO.File" /> class is a utility class that has static methods primarily for the creation of <see cref="T:System.IO.FileStream" /> objects based on file paths. The <see cref="T:System.IO.MemoryStream" /> class creates a stream from a byte array and is similar to the <see cref="T:System.IO.FileStream" /> class.</para>
      <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
      <format type="text/html">
        <h2>Detection of Stream Position Changes</h2>
      </format>
      <para>When a <see cref="T:System.IO.FileStream" /> object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the <see cref="T:System.IO.FileStream" /> object and the cached data in the buffer could be compromised. The <see cref="T:System.IO.FileStream" /> object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the <see cref="T:System.IO.FileStream" /> object.</para>
      <para>If an unexpected change in the handle position is detected in a call to the <see cref="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" /> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.</para>
      <para>If an unexpected change in the handle position is detected in a call to the <see cref="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" /> method, the contents of the buffer are discarded and an <see cref="T:System.IO.IOException" /> exception is thrown.</para>
      <para>A <see cref="T:System.IO.FileStream" /> object will not have an exclusive hold on its handle when either the <see cref="P:System.IO.FileStream.SafeFileHandle" /> property is accessed to expose the handle or the <see cref="T:System.IO.FileStream" /> object is given the <see cref="P:System.IO.FileStream.SafeFileHandle" /> property in its constructor.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Exposes a <see cref="T:System.IO.Stream" /> around a file, supporting both synchronous and asynchronous read and write operations.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When <see cref="M:System.IO.Stream.Close" /> is called, the handle is also closed and the file's handle count is decremented.</para>
          <para>FileStream assumes that it has exclusive control over the handle. Reading, writing, or seeking while a FileStream is also holding a handle could result in data corruption. For data safety, call <see cref="M:System.IO.FileStream.Flush" /> before using the handle, and avoid calling any methods other than Close after you are done using the handle.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>FileShare.Read is the default for those <see cref="T:System.IO.FileStream" /> constructors without a FileShare parameter.</para>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission. </para>
        </summary>
        <param name="handle">
          <attribution license="cc4" from="Microsoft" modified="false" />A file handle for the file that the current FileStream object will encapsulate. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When <see cref="M:System.IO.Stream.Close" /> is called, the handle is also closed and the file's handle count is decremented.</para>
          <para>FileStream assumes that it has exclusive control over the handle. Reading, writing, or seeking while a FileStream is also holding a handle could result in data corruption. For data safety, call <see cref="M:System.IO.FileStream.Flush" /> before using the handle, and avoid calling any methods other than Close after you are done using the handle.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>FileShare.Read is the default for those <see cref="T:System.IO.FileStream" /> constructors without a FileShare parameter.</para>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission.</para>
        </summary>
        <param name="handle">
          <attribution license="cc4" from="Microsoft" modified="false" />A file handle for the file that the current FileStream object will encapsulate. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(string path, valuetype System.IO.FileMode mode)" />
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <paramref name="path " />is a zero-length string, contains only white space, or contains one or more implementation-specific invalid characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <para>
            <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Truncate" /> or <see cref="F:System.IO.FileMode.Open" />, but the specified file cannot be found. If a different mode is specified and the file cannot be found, a new one is created.</para>
        </exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred, such as specifying <see cref="F:System.IO.FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The directory information specified in <paramref name="path" /> does not exist.</exception>
        <exception cref="T:System.IO.PathTooLongException">The length of <paramref name="path" /> or the absolute path information for <paramref name="path " />exceeds the system-defined maximum length. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="mode" /> contains an invalid value. </para>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Requires permission to read, write, and append to files. See <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" qualify="true" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\.\PHYSICALDRIVE0 ".</para>
          <para>The <paramref name="path" /> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</para>
          <para>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the FileStream object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).</para>
          <block subset="none" type="note">
            <para>
              <paramref name="path" /> is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.</para>
          </block>
          <para>
            <see cref="P:System.IO.Stream.CanSeek" /> is true for all <see cref="T:System.IO.FileStream" /> objects that encapsulate files. If <paramref name="path" /> indicates a device that does not support seeking, the <see cref="P:System.IO.FileStream.CanSeek" /> property on the resulting <see cref="T:System.IO.FileStream" /> is false. For additional information, see <see cref="P:System.IO.Stream.CanSeek" />.</para>
          <para>FileShare.Read is the default for those <see cref="T:System.IO.FileStream" /> constructors without a FileShare parameter.</para>
          <para>For constructors without a <see cref="T:System.IO.FileAccess" /> parameter, if the <paramref name="mode" /> parameter is set to <see cref="F:System.IO.FileMode.Append" />, <see cref="F:System.IO.FileAccess.Write" /> is the default access. Otherwise, the access is set to <see cref="F:System.IO.FileAccess.ReadWrite" />.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path and creation mode.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />A relative or absolute path for the file that the current FileStream object will encapsulate. </param>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how to open or create the file. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>FileStream assumes that it has exclusive control over the handle. Reading, writing, or seeking while a FileStream is also holding a handle could result in data corruption. For data safety, call <see cref="M:System.IO.FileStream.Flush" /> before using the handle, and avoid calling any methods other than Close after you are done using the handle. Alternately, read and write to the handle before calling this FileStream constructor.</para>
          <para>FileShare.Read is the default for those <see cref="T:System.IO.FileStream" /> constructors without a FileShare parameter.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, and buffer size.</para>
        </summary>
        <param name="handle">
          <attribution license="cc4" from="Microsoft" modified="false" />A file handle for the file that the current FileStream object will encapsulate. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A <see cref="T:System.IO.FileAccess" /> constant that gets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. </param>
        <param name="bufferSize">
          <attribution license="cc4" from="Microsoft" modified="false" />A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size. For <paramref name="bufferSize" /> values between one and eight, the actual buffer size is set to eight bytes.</param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The FileStream object is given the specified access to the file. The ownership of the handle will be as specified. If this process owns the handle, a call to the <see cref="M:System.IO.Stream.Close" /> method will also close the handle and the file's handle count is decremented. The FileStream object is given the default buffer size of 8192 bytes.</para>
          <para>FileStream assumes that it has exclusive control over the handle. Reading, writing, or seeking while a FileStream is also holding a handle could result in data corruption. For data safety, call <see cref="M:System.IO.FileStream.Flush" /> before using the handle, and avoid calling methods other than Close after you are done using the handle.</para>
          <para>FileShare.Read is the default for those <see cref="T:System.IO.FileStream" /> constructors without a FileShare parameter.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission and FileStream instance ownership.</para>
        </summary>
        <param name="handle">
          <attribution license="cc4" from="Microsoft" modified="false" />A file handle for the file that the current FileStream object will encapsulate. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that gets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. </param>
        <param name="ownsHandle">
          <attribution license="cc4" from="Microsoft" modified="false" />true if the file handle will be owned by this FileStream instance; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access)" />
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="path " />is a zero-length string, contains only white space, or contains one or more implementation-specific invalid characters.</para>
          <para>-or-</para>
          <para>
            <paramref name="access " /> specified <see langword="Read" /> and <paramref name="mode" /> specified <see langword="Create" /> , <see langword="CreateNew" /> , <see langword="Truncate" /> or <see langword="Append" />.</para>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <para>
            <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Truncate" /> or <see cref="F:System.IO.FileMode.Open" /> , but the specified file was not found. If a different mode is specified and the file was not found, a new one is created.</para>
        </exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred, such as specifying <see cref="F:System.IO.FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The directory information specified by <paramref name="path" /> does not exist.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> specified a read-only file and <paramref name="access" />  is not <see langword="Read" />  , or <paramref name="path" /> specified a directory.</exception>
        <exception cref="T:System.IO.PathTooLongException">The length of <paramref name="path" /> or the absolute path information for <paramref name="path " />exceeds the system-defined maximum length. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="mode" /> or <paramref name="access" /> contain an invalid value. </para>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Requires permission to read, write, and append to files. See <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" qualify="true" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\.\PHYSICALDRIVE0 ".</para>
          <para>The <paramref name="path" /> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</para>
          <para>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the FileStream object has been closed, but read attempts will succeed). The buffer size is set to the default size of 8192 bytes (8 KB).</para>
          <block subset="none" type="note">
            <para>
              <paramref name="path" /> is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.</para>
          </block>
          <para>
            <see cref="P:System.IO.Stream.CanSeek" /> is true for all <see cref="T:System.IO.FileStream" /> objects that encapsulate files. If <paramref name="path" /> indicates a device that does not support seeking, the <see cref="P:System.IO.FileStream.CanSeek" /> property on the resulting <see cref="T:System.IO.FileStream" /> is false. For additional information, see <see cref="P:System.IO.Stream.CanSeek" />.</para>
          <para>FileShare.Read is the default for those <see cref="T:System.IO.FileStream" /> constructors without a FileShare parameter.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, and read/write permission.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />A relative or absolute path for the file that the current FileStream object will encapsulate. </param>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how to open or create the file. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file can be accessed by the FileStream object. This gets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. <see cref="P:System.IO.FileStream.CanSeek" /> is true if <paramref name="path" /> specifies a disk file. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>You set the <paramref name="isAsync" /> parameter to true to open the file handle asynchronously. When the parameter is true, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the parameter does not have to be true to call the <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, or <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> method. When the <paramref name="isAsync" /> parameter is false and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</para>
          <para>FileStream assumes that it has exclusive control over the handle. Reading, writing, or seeking while a FileStream is also holding a handle could result in data corruption. For data safety, call <see cref="M:System.IO.FileStream.Flush" /> before using the handle, and avoid calling any methods other than Close after you are done using the handle. Alternately, read and write to the handle before calling this FileStream constructor.</para>
          <para>FileShare.Read is the default for those <see cref="T:System.IO.FileStream" /> constructors without a FileShare parameter.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, buffer size, and synchronous or asynchronous state.</para>
        </summary>
        <param name="handle">
          <attribution license="cc4" from="Microsoft" modified="false" />A file handle for the file that this FileStream object will encapsulate. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that gets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. </param>
        <param name="bufferSize">
          <attribution license="cc4" from="Microsoft" modified="false" />A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size. For <paramref name="bufferSize" /> values between one and eight, the actual buffer size is set to eight bytes.</param>
        <param name="isAsync">
          <attribution license="cc4" from="Microsoft" modified="false" />true if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The FileStream object is given the specified access to the file. The ownership of the handle will be as specified. If this FileStream owns the handle, a call to the <see cref="M:System.IO.Stream.Close" /> method will also close the handle. In particular, the file's handle count is decremented. The FileStream object is given the specified buffer size.</para>
          <para>FileStream assumes that it has exclusive control over the handle. Reading, writing, or seeking while a FileStream is also holding a handle could result in data corruption. For data safety, call <see cref="M:System.IO.FileStream.Flush" /> before using the handle, and avoid calling any methods other than Close after you are done using the handle. Alternately, read and write to the handle before calling this FileStream constructor.</para>
          <para>FileShare.Read is the default for those <see cref="T:System.IO.FileStream" /> constructors without a FileShare parameter.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, FileStream instance ownership, and buffer size.</para>
        </summary>
        <param name="handle">
          <attribution license="cc4" from="Microsoft" modified="false" />A file handle for the file that this FileStream object will encapsulate. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that gets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. </param>
        <param name="ownsHandle">
          <attribution license="cc4" from="Microsoft" modified="false" />true if the file handle will be owned by this FileStream instance; otherwise, false. </param>
        <param name="bufferSize">
          <attribution license="cc4" from="Microsoft" modified="false" />A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size. For <paramref name="bufferSize" /> values between one and eight, the actual buffer size is set to eight bytes.</param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share)" />
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path " />is a zero-length string, contains only white space, or contains one or more implementation-specific invalid characters.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <para>
            <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Truncate" /> or <see cref="F:System.IO.FileMode.Open" /> , but the specified file cannot be found. If a different mode is specified and the file cannot be found, a new one is created.</para>
        </exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred, such as specifying <see cref="F:System.IO.FileMode.CreateNew" /> and the file specified by <paramref name="path" /> already exists.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The directory information specified by <paramref name="path" /> does not exist.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">The length of <paramref name="path" /> or the absolute path information for <paramref name="path " />exceeds the system-defined maximum length. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="mode" />, <paramref name="access" />, or <paramref name="share " />contains an invalid value. </para>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Requires permission to read, write, and append to files. See <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" qualify="true" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\.\PHYSICALDRIVE0 ".</para>
          <para>The <paramref name="path" /> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</para>
          <para>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the FileStream object has been closed, but read attempts will succeed). The buffer size is set to the default size of 8192 bytes (8 KB).</para>
          <block subset="none" type="note">
            <para>
              <paramref name="path" /> is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.</para>
          </block>
          <para>
            <see cref="P:System.IO.Stream.CanSeek" /> is true for all <see cref="T:System.IO.FileStream" /> objects that encapsulate files. If <paramref name="path" /> indicates a device that does not support seeking, the <see cref="P:System.IO.FileStream.CanSeek" /> property on the resulting <see cref="T:System.IO.FileStream" /> is false. For additional information, see <see cref="P:System.IO.Stream.CanSeek" />.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write permission, and sharing permission.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />A relative or absolute path for the file that the current FileStream object will encapsulate. </param>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how to open or create the file. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file can be accessed by the FileStream object. This gets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. <see cref="P:System.IO.FileStream.CanSeek" /> is true if <paramref name="path" /> specifies a disk file. </param>
        <param name="share">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file will be shared by processes. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The FileStream object is given the specified access to the file. The ownership of the handle will be as specified. If this FileStream owns the handle, a call to the <see cref="M:System.IO.Stream.Close" /> method will also close the handle. In particular, the file's handle count is decremented. The FileStream object is given the specified buffer size.</para>
          <para>FileStream assumes that it has exclusive control over the handle. Reading, writing, or seeking while a FileStream is also holding a handle could result in data corruption. For data safety, call <see cref="M:System.IO.FileStream.Flush" /> before using the handle, and avoid calling any methods other than Close after you are done using the handle. Alternately, read and write to the handle before calling this FileStream constructor.</para>
          <para>FileShare.Read is the default for those <see cref="T:System.IO.FileStream" /> constructors without a FileShare parameter.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, FileStream instance ownership, buffer size, and synchronous or asynchronous state.</para>
        </summary>
        <param name="handle">
          <attribution license="cc4" from="Microsoft" modified="false" />A file handle for the file that this FileStream object will encapsulate. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that gets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. </param>
        <param name="ownsHandle">
          <attribution license="cc4" from="Microsoft" modified="false" />true if the file handle will be owned by this FileStream instance; otherwise, false. </param>
        <param name="bufferSize">
          <attribution license="cc4" from="Microsoft" modified="false" />A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size. For <paramref name="bufferSize" /> values between one and eight, the actual buffer size is set to eight bytes.</param>
        <param name="isAsync">
          <attribution license="cc4" from="Microsoft" modified="false" />true if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize)" />
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path " />is a zero-length string, contains only white space, or contains one or more implementation-specific invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="bufferSize" /> is less than or equal to zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="mode" />, <paramref name="access" />, or <paramref name="share " />contain an invalid value.</para>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <para>
            <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Truncate" /> or <see cref="F:System.IO.FileMode.Open" /> , but the specified file cannot be found. If a different mode is specified and the file cannot be found, a new one is created.</para>
        </exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred, such as specifying <see cref="F:System.IO.FileMode.CreateNew" /> and the file specified by <paramref name="path" /> already exists.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The directory information specified in <paramref name="path" /> does not exist.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">The length of <paramref name="path" /> or the absolute path information for <paramref name="path " />exceeds the system-defined maximum length. </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Requires permission to read, write, and append to files. See <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" qualify="true" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\.\PHYSICALDRIVE0 ".</para>
          <para>The <paramref name="path" /> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</para>
          <block subset="none" type="note">
            <para>
              <paramref name="path" /> is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.</para>
          </block>
          <para>
            <see cref="P:System.IO.Stream.CanSeek" /> is true for all <see cref="T:System.IO.FileStream" /> objects that encapsulate files. If <paramref name="path" /> indicates a device that does not support seeking, the <see cref="P:System.IO.FileStream.CanSeek" /> property on the resulting <see cref="T:System.IO.FileStream" /> is false. For additional information, see <see cref="P:System.IO.Stream.CanSeek" />.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, and buffer size.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />A relative or absolute path for the file that the current FileStream object will encapsulate. </param>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how to open or create the file. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file can be accessed by the FileStream object. This gets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. <see cref="P:System.IO.FileStream.CanSeek" /> is true if <paramref name="path" /> specifies a disk file. </param>
        <param name="share">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file will be shared by processes. </param>
        <param name="bufferSize">
          <attribution license="cc4" from="Microsoft" modified="false" />A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size. For <paramref name="bufferSize" /> values between one and eight, the actual buffer size is set to eight bytes. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync)" />
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path " />is a zero-length string, contains only white space, or contains one or more implementation-specific invalid characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="bufferSize" /> is less than or equal to zero.</para>
          <para>-or-</para>
          <para>
            <paramref name="mode" />, <paramref name="access" />, or <paramref name="share " />contain an invalid value.</para>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <para>
            <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Truncate" /> or <see cref="F:System.IO.FileMode.Open" />, but the specified file cannot be found. If a different mode is specified and the file cannot be found, a new one is created.</para>
        </exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred, such as specifying <see cref="F:System.IO.FileMode.CreateNew" /> and the file specified by <paramref name="path" /> already exists.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The directory information specified by <paramref name="path" /> does not exist.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">The length of <paramref name="path" /> or the absolute path information for <paramref name="path " />exceeds the system-defined maximum length. </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Requires permission to read, write, and append to files. See <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" qualify="true" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" qualify="true" />.</permission>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\.\PHYSICALDRIVE0 ".</para>
          <para>The <paramref name="path" /> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</para>
          <block subset="none" type="note">
            <para>
              <paramref name="path" /> is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.</para>
          </block>
          <para>
            <see cref="P:System.IO.Stream.CanSeek" /> is true for all <see cref="T:System.IO.FileStream" /> objects that encapsulate files. If <paramref name="path" /> indicates a device that does not support seeking, the <see cref="P:System.IO.FileStream.CanSeek" /> property on the resulting <see cref="T:System.IO.FileStream" /> is false. For additional information, see <see cref="P:System.IO.Stream.CanSeek" />.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, buffer size, and synchronous or asynchronous state.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />A relative or absolute path for the file that the current FileStream object will encapsulate. </param>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how to open or create the file. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file can be accessed by the FileStream object. This gets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. <see cref="P:System.IO.FileStream.CanSeek" /> is true if <paramref name="path" /> specifies a disk file. </param>
        <param name="share">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file will be shared by processes. </param>
        <param name="bufferSize">
          <attribution license="cc4" from="Microsoft" modified="false" />A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size. For <paramref name="bufferSize" /> values between one and eight, the actual buffer size is set to eight bytes. </param>
        <param name="useAsync">
          <attribution license="cc4" from="Microsoft" modified="false" />Specifies whether to use asynchronous I/O or synchronous I/O. However, note that the underlying operating system might not support asynchronous I/O, so when specifying true, the handle might be opened synchronously depending on the platform. When opened asynchronously, the <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> and <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> methods perform better on large reads or writes, but they might be much slower for small reads or writes. If the application is designed to take advantage of asynchronous I/O, set the <paramref name="useAsync" /> parameter to true. Using asynchronous I/O correctly can speed up applications by as much as a factor of 10, but using it without redesigning the application for asynchronous I/O can decrease performance by as much as a factor of 10. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\.\PHYSICALDRIVE0 ".</para>
          <para>The <paramref name="fileOptions" /> parameter is used to provide access to more advanced operations that can be leveraged when creating a <see cref="T:System.IO.FileStream" /> object.</para>
          <para>The <paramref name="path" /> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</para>
          <block subset="none" type="note">
            <para>
              <paramref name="path" /> is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.</para>
          </block>
          <para>
            <see cref="P:System.IO.Stream.CanSeek" /> is true for all <see cref="T:System.IO.FileStream" /> objects that encapsulate files. If <paramref name="path" /> indicates a device that does not support seeking, the <see cref="P:System.IO.FileStream.CanSeek" /> property on the resulting <see cref="T:System.IO.FileStream" /> is false. For additional information, see <see cref="P:System.IO.Stream.CanSeek" />.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, the access other FileStreams can have to the same file, the buffer size, and additional file options.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />A relative or absolute path for the file that the current FileStream object will encapsulate. </param>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how to open or create the file. </param>
        <param name="access">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file can be accessed by the FileStream object. This gets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the FileStream object. <see cref="P:System.IO.FileStream.CanSeek" /> is true if <paramref name="path" /> specifies a disk file. </param>
        <param name="share">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file will be shared by processes. </param>
        <param name="bufferSize">
          <attribution license="cc4" from="Microsoft" modified="false" />A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size. For <paramref name="bufferSize" /> values between one and eight, the actual buffer size is set to eight bytes. </param>
        <param name="options">
          <attribution license="cc4" from="Microsoft" modified="false" />A value that specifies additional file options.</param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\.\PHYSICALDRIVE0 ".</para>
          <para>Use this <see cref="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" /> constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <see cref="M:System.IO.File.GetAccessControl(System.String)" /> and <see cref="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" /> methods.</para>
          <para>The <paramref name="fileOptions" /> parameter is used to provide access to more advanced operations that can be leveraged when creating a <see cref="T:System.IO.FileStream" /> object.</para>
          <para>The <paramref name="path" /> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</para>
          <block subset="none" type="note">
            <para>
              <paramref name="path" /> is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.</para>
          </block>
          <para>
            <see cref="P:System.IO.Stream.CanSeek" /> is true for all <see cref="T:System.IO.FileStream" /> objects that encapsulate files. If <paramref name="path" /> indicates a device that does not support seeking, the <see cref="P:System.IO.FileStream.CanSeek" /> property on the resulting <see cref="T:System.IO.FileStream" /> is false. For additional information, see <see cref="P:System.IO.Stream.CanSeek" />.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, access rights and sharing permission, the buffer size, and additional file options.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />A relative or absolute path for the file that the current <see cref="T:System.IO.FileStream" /> object will encapsulate.</param>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how to open or create the file.</param>
        <param name="rights">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines the access rights to use when creating access and audit rules for the file.</param>
        <param name="share">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file will be shared by processes.</param>
        <param name="bufferSize">
          <attribution license="cc4" from="Microsoft" modified="false" />A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size. For <paramref name="bufferSize" /> values between one and eight, the actual buffer size is set to eight bytes.</param>
        <param name="options">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that specifies additional file options.</param>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\.\PHYSICALDRIVE0 ".</para>
          <para>Use this <see cref="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" /> constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <see cref="M:System.IO.File.GetAccessControl(System.String)" /> and <see cref="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" /> methods.</para>
          <para>The <paramref name="fileOptions" /> parameter is used to provide access to more advanced operations that can be leveraged when creating a <see cref="T:System.IO.FileStream" /> object.</para>
          <para>The <paramref name="path" /> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</para>
          <block subset="none" type="note">
            <para>
              <paramref name="path" /> is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.</para>
          </block>
          <para>
            <see cref="P:System.IO.Stream.CanSeek" /> is true for all <see cref="T:System.IO.FileStream" /> objects that encapsulate files. If <paramref name="path" /> indicates a device that does not support seeking, the <see cref="P:System.IO.FileStream.CanSeek" /> property on the resulting <see cref="T:System.IO.FileStream" /> is false. For additional information, see <see cref="P:System.IO.Stream.CanSeek" />.</para>
          <block subset="none" type="note">
            <para>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, access rights and sharing permission, the buffer size, additional file options, access control and audit security.</para>
        </summary>
        <param name="path">
          <attribution license="cc4" from="Microsoft" modified="false" />A relative or absolute path for the file that the current <see cref="T:System.IO.FileStream" /> object will encapsulate.</param>
        <param name="mode">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how to open or create the file.</param>
        <param name="rights">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines the access rights to use when creating access and audit rules for the file.</param>
        <param name="share">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines how the file will be shared by processes.</param>
        <param name="bufferSize">
          <attribution license="cc4" from="Microsoft" modified="false" />A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size. For <paramref name="bufferSize" /> values between one and eight, the actual buffer size is set to eight bytes.</param>
        <param name="options">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that specifies additional file options.</param>
        <param name="fileSecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />A constant that determines the access control and audit security for the file.</param>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.IAsyncResult BeginRead(class System.Byte[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject)" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">The sum of <paramref name="offset and" /><paramref name="numBytes" /> is greater than the length of <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> or <paramref name="numBytes" /> is negative. </exception>
        <exception cref="T:System.IO.IOException">The asynchronous read operation attempted to read past the end of the file.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In the .NET Framework 4 and earlier versions, you have to use methods such as <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> and <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> to implement asynchronous file operations. These methods are still available in the net_v45 to support legacy code; however, the new async methods, such as <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />, and <see cref="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />, help you implement asynchronous file operations more easily.</para>
          <para>
            <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> must be called exactly once for every call to <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />. Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</para>
          <para>
            <see cref="T:System.IO.FileStream" /> provides two different modes of operation: synchronous I/O and asynchronous I/O. While either can be used, the underlying operating system resources might allow access in only one of these modes. By default, <see cref="T:System.IO.FileStream" /> opens the operating system handle synchronously. In Windows, this slows down asynchronous methods. If asynchronous methods are used, use the <see cref="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" /> constructor.</para>
          <block subset="none" type="note">
            <para>Use the <see cref="P:System.IO.FileStream.CanRead" /> property to determine whether the current instance supports reading. For additional information, see <see cref="P:System.IO.Stream.CanRead" />.</para>
          </block>
          <para>If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />. Errors that occur during an asynchronous read request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />.</para>
          <para>
            <see cref="M:System.IO.Stream.EndRead(System.IAsyncResult)" /> must be called with this <see cref="T:System.IAsyncResult" /> to find out how many bytes were read.</para>
          <para>Multiple simultaneous asynchronous requests render the request completion order uncertain.</para>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous read operation. (Consider using <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead; see the Remarks section.)</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that references the asynchronous read.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The buffer to read data into. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte offset in <paramref name="array" /> at which to begin reading. </param>
        <param name="numBytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to read. </param>
        <param name="userCallback">
          <attribution license="cc4" from="Microsoft" modified="false" />The method to be called when the asynchronous read operation is completed. </param>
        <param name="stateObject">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-provided object that distinguishes this particular asynchronous read request from other requests. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.IAsyncResult BeginWrite(class System.Byte[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject)" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">The sum of <paramref name="offset and " /><paramref name="numBytes" /> is greater than the length of <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> or <paramref name="numBytes" /> is negative.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.SystemNotSupportedException">The stream does not support writing. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In the .NET Framework 4 and earlier versions, you have to use methods such as <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> and <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> to implement asynchronous file operations. These methods are still available in the net_v45 to support legacy code; however, the new async methods, such as <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />, and <see cref="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />, help you implement asynchronous file operations more easily.</para>
          <para>
            <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> must be called exactly once on every <see cref="T:System.IAsyncResult" /> from <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />. <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> will block until the I/O operation has completed.</para>
          <para>This method overrides <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</para>
          <para>
            <see cref="T:System.IO.FileStream" /> provides two different modes of operation: synchronous I/O and asynchronous I/O. While either can be used, the underlying operating system resources might allow access in only one of these modes. By default, <see cref="T:System.IO.FileStream" /> opens the operating system handle synchronously. In Windows, this slows down asynchronous methods. If asynchronous methods are used, use the <see cref="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" /> constructor.</para>
          <para>If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />. Errors that occur during an asynchronous write request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />.</para>
          <para>Multiple simultaneous asynchronous requests render the request completion order uncertain.</para>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Begins an asynchronous write operation. (Consider using <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead; see the Remarks section.)</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that references the asynchronous write.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The buffer containing data to write to the current stream.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based byte offset in <paramref name="array" /> at which to begin copying bytes to the current stream.</param>
        <param name="numBytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to write. </param>
        <param name="userCallback">
          <attribution license="cc4" from="Microsoft" modified="false" />The method to be called when the asynchronous write operation is completed. </param>
        <param name="stateObject">
          <attribution license="cc4" from="Microsoft" modified="false" />A user-provided object that distinguishes this particular asynchronous write request from other requests. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="ILASM" Value=".property bool CanRead { public hidebysig virtual specialname bool get_CanRead() }" />
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the stream supports reading;
<see langword="false" /> if the stream is
   closed or was opened with write-only
   access.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If a class derived from <see cref="T:System.IO.Stream" /> does not support reading, calls to the <see cref="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.FileStream.ReadByte" />, and <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> methods throw a <see cref="T:System.NotSupportedException" />.</para>
          <para>If the stream is closed, this property returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current stream supports reading.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="ILASM" Value=".property bool CanSeek { public hidebysig virtual specialname bool get_CanSeek() }" />
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the stream supports seeking;
<see langword="false" /> if the stream is 
   closed or if the <see cref="T:System.IO.FileStream" /> was constructed from an
   operating-system handle such as a pipe or output to the console.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If a class derived from <see cref="T:System.IO.Stream" /> does not support seeking, calls to <see cref="P:System.IO.FileStream.Length" />, <see cref="M:System.IO.FileStream.SetLength(System.Int64)" />, <see cref="P:System.IO.FileStream.Position" />, and <see cref="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" /> throw a <see cref="T:System.NotSupportedException" />.</para>
          <para>If the stream is closed, this property returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current stream supports seeking.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="ILASM" Value=".property bool CanWrite { public hidebysig virtual specialname bool get_CanWrite() }" />
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the stream supports writing;
<see langword="false" /> if the stream is
   closed or was opened with read-only access.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If a class derived from <see cref="T:System.IO.Stream" /> does not support writing, a call to <see cref="M:System.IO.FileStream.SetLength(System.Int64)" />, <see cref="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />, or <see cref="M:System.IO.FileStream.WriteByte(System.Byte)" /> throws a <see cref="T:System.NotSupportedException" />.</para>
          <para>If the stream is closed, this property returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current stream supports writing.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Close()" />
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Closes the file and releases any resources associated with
      the current file stream.</para>
        </summary>
        <remarks>
          <para>This method is
      equivalent to <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />(<see langword="true" />).</para>
          <para>Any data previously written to the buffer is copied to the file
      before the file stream is closed, so it is not necessary to call <see cref="M:System.IO.FileStream.Flush" /> before
      invoking <see langword="Close" />. Following a call to <see langword="Close" />, any operations on the file stream
      might raise exceptions. Invoking this method on the
      same instance multiple times does not result in an exception.</para>
          <para>
            <block subset="none" type="usage">The <see cref="M:System.IO.FileStream.Finalize" />
method invokes <see langword="Close " />so that the file stream is closed
before the garbage collector finalizes the object. However, objects writing to
the <see cref="T:System.IO.FileStream" />, such as a <see cref="T:System.IO.StreamWriter" />, might not have flushed
the data from their internal buffers to the <see cref="T:System.IO.FileStream" /> when the call to <see langword="Finalize" /> closes
the stream. To prevent data loss, always call <see langword="Close" /> on the highest-level object.</block>
          </para>
          <para>
            <block subset="none" type="note">
   
   This method overrides <see cref="M:System.IO.Stream.Close" qualify="true" />.
</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Dispose(bool disposing)" />
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is called by the public <see cref="M:System.ComponentModel.Component.Dispose" /> method and the <see cref="M:System.Object.Finalize" /> method. <see cref="M:System.ComponentModel.Component.Dispose" /> invokes the protected <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> method with the <paramref name="disposing" /> parameter set to true. <see cref="M:System.Object.Finalize" /> invokes <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> with <paramref name="disposing" /> set to false.</para>
          <para>When the <paramref name="disposing" /> parameter is true, this method releases all resources held by any managed objects that this <see cref="T:System.IO.FileStream" /> references. This method invokes the <see cref="M:System.ComponentModel.Component.Dispose" /> method of each referenced object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the unmanaged resources used by the <see cref="T:System.IO.FileStream" /> and optionally releases the managed resources.</para>
        </summary>
        <param name="disposing">
          <attribution license="cc4" from="Microsoft" modified="false" />true to release both managed and unmanaged resources; false to release only unmanaged resources. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 EndRead(class System.IAsyncResult asyncResult)" />
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by a call to <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> was called multiple times with <paramref name="asyncResult" /> .</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In the .NET Framework 4 and earlier versions, you have to use methods such as <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> and <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> to implement asynchronous file operations. These methods are still available in the net_v45 to support legacy code; however, the new async methods, such as <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />, and <see cref="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />, help you implement asynchronous file operations more easily.</para>
          <para>
            <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> must be called exactly for every call to <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />. Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</para>
          <para>This method overrides <see cref="M:System.IO.Stream.EndRead(System.IAsyncResult)" />.</para>
          <para>
            <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> can be called on every <see cref="T:System.IAsyncResult" /> from <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />. Calling <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> tells you how many bytes were read from the stream. <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> will block until the I/O operation has completed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Waits for the pending asynchronous read operation to complete. (Consider using <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead; see the Remarks section.)</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes read from the stream, between 0 and the number of bytes you requested. Streams only return 0 at the end of the stream, otherwise, they should block until at least 1 byte is available.</para>
        </returns>
        <param name="asyncResult">
          <attribution license="cc4" from="Microsoft" modified="false" />The reference to the pending asynchronous request to wait for. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void EndWrite(class System.IAsyncResult asyncResult)" />
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by a call to <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> was called multiple times with <paramref name="asyncResult" /> .</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>In the .NET Framework 4 and earlier versions, you have to use methods such as <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> and <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> to implement asynchronous file operations. These methods are still available in the net_v45 to support legacy code; however, the new async methods, such as <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />, and <see cref="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />, help you implement asynchronous file operations more easily.</para>
          <para>This method overrides <see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />.</para>
          <para>
            <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> must be called exactly once on every <see cref="T:System.IAsyncResult" /> from <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />. <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> will block until the I/O operation has completed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ends an asynchronous write operation and blocks until the I/O operation is complete. (Consider using <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead; see the Remarks section.)</para>
        </summary>
        <param name="asyncResult">
          <attribution license="cc4" from="Microsoft" modified="false" />The pending asynchronous I/O request. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="ILASM" Value=".method family hidebysig virtual void Finalize()" />
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The garbage collector calls Finalize when the current object is ready to be finalized. Finalize closes the FileStream.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the FileStream.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Flush()" />
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been closed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.Flush" />. </para>
          <para>When you call the <see cref="M:System.IO.FileStream.Flush" /> method, the operating system I/O buffer is also flushed.</para>
          <para>A stream’s encoder is not flushed unless you explicitly call <see cref="M:System.IO.FileStream.Flush" /> or dispose of the object. Setting <see cref="P:System.IO.StreamWriter.AutoFlush" /> to true means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed. This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly. This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</para>
          <para>Because a buffer can be used for either reading or writing, <see cref="M:System.IO.FileStream.Flush" /> performs the following two functions: </para>
          <list type="bullet">
            <item>
              <para>Any data previously written to the buffer is copied to the file and the buffer is cleared except for its encoder state.</para>
            </item>
            <item>
              <para>If <see cref="P:System.IO.BufferedStream.CanSeek" /> is true and data was previously copied from the file to the buffer for reading, the current position within the file is decremented by the number of unread bytes in the buffer. The buffer is then cleared.</para>
            </item>
          </list>
          <para>Use the <see cref="M:System.IO.FileStream.Flush(System.Boolean)" /> method overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Clears buffers for this stream and causes any buffered data to be written to the file.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Use this overload when you want to ensure that all buffered data in intermediate file buffers is written to disk. </para>
          <para>When you call the <see cref="M:System.IO.FileStream.Flush(System.Boolean)" /> method, the operating system I/O buffer is also flushed.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.</para>
        </summary>
        <param name="flushToDisk">
          <attribution license="cc4" from="Microsoft" modified="false" />true to flush all intermediate file buffers; otherwise, false. </param>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When you call the <see cref="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" /> method, the operating system I/O buffer is also flushed.</para>
          <para>If the operation is canceled before it completes, the returned task contains the <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> value for the <see cref="P:System.Threading.Tasks.Task.Status" /> property. If the handle to the file is disposed, the returned task contains the <see cref="T:System.ObjectDisposedException" /> exception in the <see cref="P:System.Threading.Tasks.Task.Exception" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A task that represents the asynchronous flush operation. </para>
        </returns>
        <param name="cancellationToken">
          <attribution license="cc4" from="Microsoft" modified="false" />The token to monitor for cancellation requests.</param>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>While the <see cref="T:System.IO.FileStream" /> class and <see cref="M:System.IO.FileStream.GetAccessControl" /> can be used to retrieve the access control list (ACL) entries of an existing file, consider using <see cref="M:System.IO.File.GetAccessControl(System.String)" /> method, as it is easier to use.</para>
          <para>Use the <see cref="M:System.IO.FileStream.GetAccessControl" /> method to retrieve the ACL entries for a file.</para>
          <para>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file. For more information, see <format type="text/html"><a href="06fbf66d-6f02-4378-b863-b2f12e349045">ACL Technology Overview</a></format> and <format type="text/html"><a href="53758b39-bd9b-4640-bb04-cad5ed8d0abf">How to: Add or Remove an Access Control List Entry</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:System.Security.AccessControl.FileSecurity" /> object that encapsulates the access control list (ACL) entries for the file described by the current <see cref="T:System.IO.FileStream" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An object that encapsulates the access control settings for the file described by the current <see cref="T:System.IO.FileStream" /> object.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property is an operating system handle for use with operating-system-provided system calls (such as ReadFile on Windows). It will not work with C library functions that expect a file descriptor, such as fread.</para>
          <para>The operating system handle might have been opened synchronously or asynchronously, depending on which FileStream constructor was called. Use the <see cref="P:System.IO.FileStream.IsAsync" /> property to discover whether this handle was opened asynchronously. In Win32, this means the handle was opened for overlapped IO, and it requires different parameters to ReadFile and WriteFile.</para>
          <block subset="none" type="note">
            <para>Data corruption might occur if a FileStream is created, its handle is passed, some operation moves the handle's file pointer, and then the FileStream is used again. Multiple threads cannot safely write to the same file simultaneously, and FileStream buffering code assumes that it exclusively controls the handle. FileStream might throw an <see cref="T:System.IO.IOException" /> if FileStream detects that some other process has moved the file pointer. To avoid this, do not write any data into a portion of the file that FileStream might have buffered, and restore the file pointer to the location it had when methods were last called on FileStream.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the operating system file handle for the file that the current FileStream object encapsulates.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="ILASM" Value=".property bool IsAsync { public hidebysig virtual specialname bool get_IsAsync() }" />
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the
   current
<see cref="T:System.IO.FileStream" /> was opened
   asynchronously; otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The IsAsync property detects whether the FileStream handle was opened asynchronously, enabling your code to use the <see cref="P:System.IO.FileStream.Handle" /> property correctly. In Win32, IsAsync being true means the handle was opened for overlapped I/O, and thus requires different parameters to ReadFile and WriteFile.</para>
          <para>You specify this value when you create an instance of the <see cref="T:System.IO.FileStream" /> class using a constructor that has an <paramref name="isAsync" />, <paramref name="useAsync" />, or <paramref name="options" /> parameter. When the property is true, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <see cref="P:System.IO.FileStream.IsAsync" /> property does not have to be true to call the <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />, or <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> method. When the <see cref="P:System.IO.FileStream.IsAsync" /> property is false and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the FileStream was opened asynchronously or synchronously.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="ILASM" Value=".property int64 Length { public hidebysig virtual specialname int64 get_Length() }" />
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Int64" /> value containing the length of the stream in bytes.</para>
        </value>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.FileStream.CanSeek" /> for this stream is <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred, such as the file being closed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the length in bytes of the stream.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Locking a range of a file stream gives the threads of the locking process exclusive access to that range of the file stream.</para>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Prevents other processes from reading from or writing to the <see cref="T:System.IO.FileStream" />.</para>
        </summary>
        <param name="position">
          <attribution license="cc4" from="Microsoft" modified="false" />The beginning of the range to lock. The value of this parameter must be equal to or greater than zero (0). </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The range to be locked. </param>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the name of the FileStream that was passed to the constructor.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="ILASM" Value=".property int64 Position { public hidebysig virtual specialname int64 get_Position() public hidebysig virtual specialname void set_Position(int64 value) }" />
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para> A <see cref="T:System.Int64" /> containing the current position of this stream.</para>
        </value>
        <exception cref="T:System.NotSupportedException">The current stream does not support seeking.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Attempted seeking past the end of a stream that does not support this.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is negative.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Seeking to any location beyond the length of the stream is supported.  When you seek beyond the length of the file, the file size grows.  In Microsoft Windows NT and newer, any data added to the end of the file is set to zero.  In Microsoft Windows 98 or earlier, any data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream. Setting the position of the stream to a large value beyond the end of the stream in Windows 98 or earlier may result in an exception being raised.</para>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the current position of this stream.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 Read(class System.Byte[] array, int32 offset, int32 count)" />
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> or <paramref name="count " /> is negative.</exception>
        <exception cref="T:System.NotSupportedException">The current stream does not support reading.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset " /> + <paramref name="count" /> is greater than the length of <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />.</para>
          <para>The <paramref name="offset" /> parameter gives the offset of the byte in <paramref name="array" /> (the buffer index) at which to begin reading, and the <paramref name="count" /> parameter gives the maximum number of bytes to be read from this stream. The returned value is the actual number of bytes read, or zero if the end of the stream is reached. If the read operation is successful, the current position of the stream is advanced by the number of bytes read. If an exception occurs, the current position of the stream is unchanged.</para>
          <para>The <see cref="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" /> method returns zero only after reaching the end of the stream. Otherwise, <see cref="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" /> always reads at least one byte from the stream before returning. If no data is available from the stream upon a call to <see cref="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />, the method will block until at least one byte of data can be returned. An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</para>
          <para>Use <see cref="T:System.IO.BinaryReader" /> for reading primitive data types.</para>
          <para>Do not interrupt a thread that is performing a read operation. Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</para>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a block of bytes from the stream and writes the data in a given buffer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The total number of bytes read into the buffer. This might be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached.</para>
        </returns>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1<paramref name=")" /> replaced by the bytes read from the current source. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte offset in <paramref name="array" /> at which the read bytes will be placed. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to read. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> method enables you to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a win8_appname_long app or desktop_appname app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. The async methods are used in conjunction with the async and await keywords in Visual Basic and C#.</para>
          <para>Use the <see cref="P:System.IO.FileStream.CanRead" /> property to determine whether the current instance supports reading.</para>
          <para>If the operation is canceled before it completes, the returned task contains the <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> value for the <see cref="P:System.Threading.Tasks.Task.Status" /> property. If the handle to the file is disposed, the returned task contains the <see cref="T:System.ObjectDisposedException" /> exception in the <see cref="P:System.Threading.Tasks.Task.Exception" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A task that represents the asynchronous read operation. The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached. </para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />The buffer to write the data into.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to read.</param>
        <param name="cancellationToken">
          <attribution license="cc4" from="Microsoft" modified="false" />The token to monitor for cancellation requests.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 ReadByte()" />
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
        <exception cref="T:System.NotSupportedException">The current stream does not support reading.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.ReadByte" />.</para>
          <block subset="none" type="note">
            <para>Use the <see cref="P:System.IO.FileStream.CanRead" /> property to determine whether the current instance supports reading. For additional information, see <see cref="P:System.IO.Stream.CanRead" />.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a byte from the file and advances the read position one byte.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The byte, cast to an <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.IO.FileStream.SafeFileHandle" /> property automatically flushes the stream and sets the current stream position to 0.  This allows the file to be moved or the stream position to be reset by another stream using the <see cref="P:System.IO.FileStream.SafeFileHandle" /> returned by this property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> object that represents the operating system file handle for the file that the current <see cref="T:System.IO.FileStream" /> object encapsulates.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin)" />
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.NotSupportedException">The stream does not support seeking.</exception>
        <exception cref="T:System.ArgumentException">Attempted seeking before the beginning of the stream or to more than one byte past the end of the stream.</exception>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />.</para>
          <block subset="none" type="note">
            <para>Use the <see cref="P:System.IO.FileStream.CanSeek" /> property to determine whether the current instance supports seeking. For additional information, see <see cref="P:System.IO.Stream.CanSeek" />.</para>
          </block>
          <para>You can seek to any location beyond the length of the stream. When you seek beyond the length of the file, the file size grows. In Windows NT and later versions, data added to the end of the file is set to zero. In Windows 98 or earlier versions, data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</para>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the current position of this stream to the given value.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The new position in the stream.</para>
        </returns>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The point relative to <paramref name="origin" /> from which to begin seeking. </param>
        <param name="origin">
          <attribution license="cc4" from="Microsoft" modified="false" />Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />, using a value of type <see cref="T:System.IO.SeekOrigin" />. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>While the <see cref="T:System.IO.FileStream" /> class and <see cref="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" /> can be used on an existing file, consider using the <see cref="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" /> method as it is easier to use.</para>
          <para>The <see cref="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" /> method applies access control list (ACL) entries to a file that represents the noninherited ACL list. </para>
          <block subset="none" type="note">
            <para>The ACL specified for the <paramref name="fileSecurity" /> parameter replaces the existing ACL for the file. To add permissions for a new user, use the <see cref="M:System.IO.FileStream.GetAccessControl" /> method to obtain the existing ACL, modify it, and then use <see cref="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" /> to apply it back to the file.</para>
          </block>
          <para>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file. For more information, see <format type="text/html"><a href="06fbf66d-6f02-4378-b863-b2f12e349045">ACL Technology Overview</a></format> and <format type="text/html"><a href="53758b39-bd9b-4640-bb04-cad5ed8d0abf">How to: Add or Remove an Access Control List Entry</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Applies access control list (ACL) entries described by a <see cref="T:System.Security.AccessControl.FileSecurity" /> object to the file described by the current <see cref="T:System.IO.FileStream" /> object.</para>
        </summary>
        <param name="fileSecurity">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that describes an ACL entry to apply to the current file.</param>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void SetLength(int64 value)" />
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <exception cref="T:System.IO.IOException"> An I/O error occurred.</exception>
        <exception cref="T:System.NotSupportedException">The current stream does not support writing and seeking.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> is less than zero.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.</para>
          <para>If the given value is less than the current length of the stream, the stream is truncated. If the given value is larger than the current length of the stream, the stream is expanded. If the stream is expanded, the contents of the stream between the old and the new length are undefined.</para>
          <para>A stream must support both writing and seeking for SetLength to work.</para>
          <block subset="none" type="note">
            <para>Use the <see cref="P:System.IO.FileStream.CanWrite" /> property to determine whether the current instance supports writing, and the <see cref="P:System.IO.FileStream.CanSeek" /> property to determine whether seeking is supported. For additional information, see <see cref="P:System.IO.Stream.CanWrite" /> and <see cref="P:System.IO.Stream.CanSeek" />.</para>
          </block>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the length of this stream to the given value.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The new length of the stream. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Allows access by other processes to all or part of a file that was previously locked.</para>
        </summary>
        <param name="position">
          <attribution license="cc4" from="Microsoft" modified="false" />The beginning of the range to unlock. </param>
        <param name="length">
          <attribution license="cc4" from="Microsoft" modified="false" />The range to be unlocked. </param>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Write(class System.Byte[] array, int32 offset, int32 count)" />
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset " />+ <paramref name="count" /> is greater than the length of <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> or <paramref name="count" /> is negative.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.NotSupportedException">The current stream does not support writing.</exception>
        <exception cref="T:System.ObjectDisposedException">An I/O error occurred.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />.</para>
          <para>The <paramref name="offset" /> parameter gives the offset of the byte in <paramref name="array" /> (the buffer index) at which to begin copying, and the <paramref name="count" /> parameter gives the number of bytes that will be written to the stream. If the write operation is successful, the current position of the stream is advanced by the number of bytes written. If an exception occurs, the current position of the stream is unchanged.</para>
          <block subset="none" type="note">
            <para>Use the <see cref="P:System.IO.FileStream.CanWrite" /> property to determine whether the current instance supports writing. For additional information, see <see cref="P:System.IO.Stream.CanWrite" />.</para>
          </block>
          <para>Do not interrupt a thread that is performing a write operation. Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability. </para>
          <para>For a list of common file and directory operations, see <format type="text/html"><a href="bf00c380-706a-4e38-b829-454a480629fc">Common I/O Tasks</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a block of bytes to the file stream.</para>
        </summary>
        <param name="array">
          <attribution license="cc4" from="Microsoft" modified="false" />The buffer containing data to write to the stream.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based byte offset in <paramref name="array" /> from which to begin copying bytes to the stream. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to write. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> method enables you to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a win8_appname_long app or desktop_appname app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. The async methods are used in conjunction with the async and await keywords in Visual Basic and C#.</para>
          <para>Use the <see cref="P:System.IO.FileStream.CanWrite" /> property to determine whether the current instance supports reading.</para>
          <para>If the operation is canceled before it completes, the returned task contains the <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> value for the <see cref="P:System.Threading.Tasks.Task.Status" /> property. If the handle to the file is disposed, the returned task contains the <see cref="T:System.ObjectDisposedException" /> exception in the <see cref="P:System.Threading.Tasks.Task.Exception" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests. </para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A task that represents the asynchronous write operation.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />The buffer to write data from. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to write.</param>
        <param name="cancellationToken">
          <attribution license="cc4" from="Microsoft" modified="false" />The token to monitor for cancellation requests.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void WriteByte(unsigned int8 value)" />
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <exception cref="T:System.IO.IOException">The current stream is closed.</exception>
        <exception cref="T:System.NotSupportedException">The current stream does not support writing.</exception>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.WriteByte(System.Byte)" />.</para>
          <para>Use WriteByte to write a byte to a FileStream efficiently. If the stream is closed or not writable, an exception will be thrown.</para>
          <block subset="none" type="note">
            <para>Use the <see cref="P:System.IO.FileStream.CanWrite" /> property to determine whether the current instance supports writing. For additional information, see <see cref="P:System.IO.Stream.CanWrite" />.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a byte to the current position in the file stream.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />A byte to write to the stream. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>