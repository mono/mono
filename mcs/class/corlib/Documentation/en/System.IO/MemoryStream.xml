<?xml version="1.0" encoding="utf-8"?>
<Type Name="MemoryStream" FullName="System.IO.MemoryStream" FullNameSP="System_IO_MemoryStream" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public serializable MemoryStream extends System.IO.Stream" />
  <TypeSignature Language="C#" Value="public class MemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit MemoryStream extends System.IO.Stream" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>The current position of a stream is the position at which the next read or write operation could take place. The current position can be retrieved or set through the <see cref="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" /> method. When a new instance of <see cref="T:System.IO.MemoryStream" /> is created, the current position is set to zero.</para>
      <para>Memory streams created with an unsigned byte array provide a non-resizable stream of the data. When using a byte array, you can neither append to nor shrink the stream, although you might be able to modify the existing contents depending on the parameters passed into the constructor. Empty memory streams are resizable, and can be written to and read from.</para>
      <para>If a <see cref="T:System.IO.MemoryStream" /> object is added to a ResX file or a .resources file, call the <see cref="M:System.Resources.ResourceManager.GetStream(System.String)" /> method at runtime to retrieve it.</para>
      <para>If a <see cref="T:System.IO.MemoryStream" /> object is serialized to a resource file it will actually be serialized as an <see cref="T:System.IO.UnmanagedMemoryStream" />. This behavior provides better performance, as well as the ability to get a pointer to the data directly, without having to go through <see cref="T:System.IO.Stream" /> methods.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Creates a stream whose backing store is memory.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor()" />
      <MemberSignature Language="C#" Value="public MemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.IO.MemoryStream.CanRead" />, <see cref="P:System.IO.MemoryStream.CanSeek" />, and <see cref="P:System.IO.MemoryStream.CanWrite" /> properties are all set to true.</para>
          <para>The capacity of the current stream automatically increases when you use the <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" /> method to set the length to a value larger than the capacity of the current stream.</para>
          <para>This constructor exposes the underlying stream, which <see cref="M:System.IO.MemoryStream.GetBuffer" /> returns.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized to zero.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Byte[] buffer)" />
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.IO.MemoryStream.CanRead" />, <see cref="P:System.IO.MemoryStream.CanSeek" />, and <see cref="P:System.IO.MemoryStream.CanWrite" /> properties are all set to true. <see cref="P:System.IO.MemoryStream.Capacity" /> is set to the length of the specified byte array. The new stream can be written to, but is not resizable.</para>
          <para>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />).</para>
          <para>This constructor does not expose the underlying stream. <see cref="M:System.IO.MemoryStream.GetBuffer" /> throws <see cref="T:System.UnauthorizedAccessException" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array.</para>
        </summary>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />The array of unsigned bytes from which to create the current stream. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(int32 capacity)" />
      <MemberSignature Language="C#" Value="public MemoryStream (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is negative.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.IO.MemoryStream.CanRead" />, <see cref="P:System.IO.MemoryStream.CanSeek" />, and <see cref="P:System.IO.MemoryStream.CanWrite" /> properties are all set to true.</para>
          <para>The capacity automatically increases when you use the <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" /> method to set the length to a value larger than the capacity of the current stream. Except for a MemoryStream constructed with a byte[] parameter, write operations at the end of a MemoryStream expand the MemoryStream.</para>
          <para>This constructor exposes the underlying stream that <see cref="M:System.IO.MemoryStream.GetBuffer" /> returns.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized as specified.</para>
        </summary>
        <param name="capacity">
          <attribution license="cc4" from="Microsoft" modified="false" />The initial size of the internal array in bytes. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Byte[] buffer, bool writable)" />
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, bool writable) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.IO.MemoryStream.CanRead" /> and <see cref="P:System.IO.MemoryStream.CanSeek" /> properties are both set to true. <see cref="P:System.IO.MemoryStream.Capacity" /> is set to the length of the specified byte array.</para>
          <para>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />).</para>
          <para>This constructor does not expose the underlying stream. <see cref="M:System.IO.MemoryStream.GetBuffer" /> throws <see cref="T:System.UnauthorizedAccessException" />.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</para>
        </summary>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />The array of unsigned bytes from which to create this stream. </param>
        <param name="writable">
          <attribution license="cc4" from="Microsoft" modified="false" />The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Byte[] buffer, int32 index, int32 count)" />
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">(<paramref name="index" /> + <paramref name="count" /> ) is greater than the length of <paramref name="buffer" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.IO.MemoryStream.CanRead" />, <see cref="P:System.IO.MemoryStream.CanSeek" />, and <see cref="P:System.IO.MemoryStream.CanWrite" /> properties are all set to true, but the capacity cannot be changed. <see cref="P:System.IO.MemoryStream.Capacity" /> is set to <paramref name="count" />.</para>
          <para>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />).</para>
          <para>This constructor does not expose the underlying stream. <see cref="M:System.IO.MemoryStream.GetBuffer" /> throws <see cref="T:System.UnauthorizedAccessException" />. However, you can write to the stream.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region (index) of a byte array.</para>
        </summary>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />The array of unsigned bytes from which to create this stream. </param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index into <paramref name="buffer" /> at which the stream begins. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The length of the stream in bytes. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Byte[] buffer, int32 index, int32 count, bool writable)" />
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> are negative.</exception>
        <exception cref="T:System.ArgumentException">(<paramref name="index" /> + <paramref name="count" /> ) is greater than the length of <paramref name="buffer" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.IO.MemoryStream.CanRead" /> and <see cref="P:System.IO.MemoryStream.CanSeek" /> properties are both set to true. <see cref="P:System.IO.MemoryStream.Capacity" /> is set to <paramref name="count" />.</para>
          <para>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />).</para>
          <para>This constructor does not expose the underlying stream. <see cref="M:System.IO.MemoryStream.GetBuffer" /> throws <see cref="T:System.UnauthorizedAccessException" />. However, you can write to the stream if <paramref name="writable" /> is true.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</para>
        </summary>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />The array of unsigned bytes from which to create this stream. </param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index in <paramref name="buffer" /> at which the stream begins. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The length of the stream in bytes. </param>
        <param name="writable">
          <attribution license="cc4" from="Microsoft" modified="false" />The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Byte[] buffer, int32 index, int32 count, bool writable, bool publiclyVisible)" />
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable, bool publiclyVisible) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="publiclyVisible" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is negative.</exception>
        <exception cref="T:System.ArgumentException">(<paramref name="index" /> + <paramref name="count" /> ) is greater than the length of <paramref name="buffer" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.IO.MemoryStream.CanRead" /> and <see cref="P:System.IO.MemoryStream.CanSeek" /> properties are both set to true. <see cref="P:System.IO.MemoryStream.Capacity" /> is set to <paramref name="count" />.</para>
          <para>The new stream instance can be written to, but the <see cref="P:System.IO.MemoryStream.Capacity" /> of the underlying byte array cannot be changed. The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />).</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified, and the ability to call <see cref="M:System.IO.MemoryStream.GetBuffer" /> set as specified.</para>
        </summary>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />The array of unsigned bytes from which to create this stream. </param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index into <paramref name="buffer" /> at which the stream begins. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The length of the stream in bytes. </param>
        <param name="writable">
          <attribution license="cc4" from="Microsoft" modified="false" />The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing. </param>
        <param name="publiclyVisible">
          <attribution license="cc4" from="Microsoft" modified="false" />true to enable <see cref="M:System.IO.MemoryStream.GetBuffer" />, which returns the unsigned byte array from which the stream was created; otherwise, false. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="ILASM" Value=".property bool CanRead { public hidebysig virtual specialname bool get_CanRead() }" />
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true " />if the current 
   stream is open and supports reading; otherwise <see langword="false" />
   .</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If a class derived from <see cref="T:System.IO.Stream" /> does not support reading, calls to the <see cref="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.MemoryStream.ReadByte" /> methods throw a <see cref="T:System.NotSupportedException" />.</para>
          <para>If the stream is closed, this property returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current stream supports reading.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="ILASM" Value=".property bool CanSeek { public hidebysig virtual specialname bool get_CanSeek() }" />
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the stream is open and 
   supports seeking; otherwise <see langword="false" />
   .</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If a class derived from <see cref="T:System.IO.Stream" /> does not support seeking, calls to <see cref="P:System.IO.MemoryStream.Length" />, <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />, <see cref="P:System.IO.MemoryStream.Position" />, and <see cref="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" /> throw a <see cref="T:System.NotSupportedException" />.</para>
          <para>If the stream is closed, this property returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current stream supports seeking.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="ILASM" Value=".property bool CanWrite { public hidebysig virtual specialname bool get_CanWrite() }" />
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>
            <see langword="true" /> if the stream supports writing;
   otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If a class derived from <see cref="T:System.IO.Stream" /> does not support writing, a call to <see cref="M:System.IO.Stream.SetLength(System.Int64)" />, <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />, or <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> throws a <see cref="T:System.NotSupportedException" />.</para>
          <para>If the stream is closed, this property returns false.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current stream supports writing.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="ILASM" Value=".property int32 Capacity { public hidebysig virtual specialname int32 get_Capacity() public hidebysig virtual specialname void set_Capacity(int32 value) }" />
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para> A <see cref="T:System.Int32" /> containing the
   number of bytes allocated for the current stream.</para>
        </value>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is negative or less than the current length of the stream.</exception>
        <exception cref="T:System.NotSupportedException">A set operation was attempted on a stream whose capacity cannot be modified. </exception>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Capacity is the buffer length for system-provided byte arrays. Capacity cannot be set to a value less than the current length of the stream.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the number of bytes allocated for this stream.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Close()" />
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Closes the current <see cref="T:System.IO.MemoryStream" /> instance.</para>
        </summary>
        <remarks>
          <para> The stream will not support reading or writing after
      this method is invoked. Following a call to <see cref="M:System.IO.MemoryStream.Close" />
      , operations on the
      stream can raise an exception. </para>
          <para> The buffer of a closed <see cref="T:System.IO.MemoryStream" /> is still available, and the <see cref="M:System.IO.MemoryStream.ToArray" />
and <see cref="M:System.IO.MemoryStream.GetBuffer" /> methods can
be called successfully. </para>
          <block subset="none" type="note"> This method overrides <see cref="M:System.IO.Stream.Close" />
.</block>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Asynchronously reads all the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A task that represents the asynchronous copy operation.</para>
        </returns>
        <param name="destination">
          <attribution license="cc4" from="Microsoft" modified="false" />The stream to which the contents of the current stream will be copied.</param>
        <param name="bufferSize">
          <attribution license="cc4" from="Microsoft" modified="false" />The size, in bytes, of the buffer. This value must be greater than zero.</param>
        <param name="cancellationToken">
          <attribution license="cc4" from="Microsoft" modified="false" />The token to monitor for cancellation requests.</param>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method is called by the public <see cref="M:System.ComponentModel.Component.Dispose" /> method and the <see cref="M:System.Object.Finalize" /> method. <see cref="M:System.ComponentModel.Component.Dispose" /> invokes the protected <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> method with the <paramref name="disposing" /> parameter set to true. <see cref="M:System.Object.Finalize" /> invokes <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> with <paramref name="disposing" /> set to false.</para>
          <para>When the <paramref name="disposing" /> parameter is true, this method releases all resources held by any managed objects that this <see cref="T:System.IO.MemoryStream" /> references. This method invokes the <see cref="M:System.ComponentModel.Component.Dispose" /> method of each referenced object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Releases the unmanaged resources used by the <see cref="T:System.IO.MemoryStream" /> class and optionally releases the managed resources.</para>
        </summary>
        <param name="disposing">
          <attribution license="cc4" from="Microsoft" modified="false" />true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Flush()" />
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides the <see cref="M:System.IO.Stream.Flush" /> method.</para>
          <para>Because any data written to a <see cref="T:System.IO.MemoryStream" /> object is written into RAM, this method is redundant.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Because any data written to a <see cref="T:System.IO.MemoryStream" /> object is written into RAM, this method is redundant.</para>
          <para>If the operation is canceled before it completes, the returned task contains the <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> value for the <see cref="P:System.Threading.Tasks.Task.Status" /> property. </para>
          <para>You can create a cancellation token by creating an instance of the <see cref="T:System.Threading.CancellationTokenSource" /> class and passing the <see cref="P:System.Threading.CancellationTokenSource.Token" /> property as the <paramref name="cancellationToken" /> parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Asynchronously clears all buffers for this stream, and monitors cancellation requests.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A task that represents the asynchronous flush operation.</para>
        </returns>
        <param name="cancellationToken">
          <attribution license="cc4" from="Microsoft" modified="false" />The token to monitor for cancellation requests.</param>
      </Docs>
    </Member>
    <Member MemberName="GetBuffer">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Byte[] GetBuffer()" />
      <MemberSignature Language="C#" Value="public virtual byte[] GetBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBuffer() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <exception cref="T:System.UnauthorizedAccessException">The current instance was not created with a publicly visible buffer.</exception>
        <example>
          <para>The following example demonstrates that two calls to the <see cref="M:System.IO.MemoryStream.GetBuffer" />
method on a resizable stream do not return the same array if the underlying byte array is
reallocated.</para>
          <code lang="C#">using System;
using System.IO;

public class MemoryStreamTest {
   public static void Main() {

      MemoryStream ms = new MemoryStream(10);

      byte[] a = ms.GetBuffer();
      byte[] b = ms.GetBuffer();

      //Force reallocation of the underlying byte array.
      ms.Capacity = 10240;    
      byte[] c = ms.GetBuffer();


      if(Object.ReferenceEquals(a, b))
         Console.WriteLine("a and b represent the same instance.");
      else
         Console.WriteLine("a and b represent the different instances.");

      if(Object.ReferenceEquals(a, c))
         Console.WriteLine("a and c represent the same instance.");
      else
         Console.WriteLine("a and c represent the different instances.");

   }
}
</code>
          <para>The output is</para>
          <c>
            <para>a and b represent the same instance.</para>
            <para>a and c represent the different instances.</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Note that the buffer contains allocated bytes which might be unused. For example, if the string "test" is written into the <see cref="T:System.IO.MemoryStream" /> object, the length of the buffer returned from <see cref="M:System.IO.MemoryStream.GetBuffer" /> is 256, not 4, with 252 bytes unused. To obtain only the data in the buffer, use the <see cref="M:System.IO.MemoryStream.ToArray" /> method; however, <see cref="M:System.IO.MemoryStream.ToArray" /> creates a copy of the data in memory.</para>
          <para>The buffer can also be null.</para>
          <para>To create a MemoryStream instance with a publicly visible buffer, use <see cref="M:System.IO.MemoryStream.#ctor" />, <see cref="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)" />, or <see cref="M:System.IO.MemoryStream.#ctor(System.Int32)" />. If the current stream is resizable, two calls to this method do not return the same array if the underlying byte array is resized between calls. For additional information, see <see cref="P:System.IO.MemoryStream.Capacity" />.</para>
          <block subset="none" type="note">
            <para>This method works when the memory stream is closed.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the array of unsigned bytes from which this stream was created.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The byte array from which this stream was created, or the underlying array if a byte array was not provided to the <see cref="T:System.IO.MemoryStream" /> constructor during construction of the current instance.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="ILASM" Value=".property int64 Length { public hidebysig virtual specialname int64 get_Length() }" />
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Int64" /> containing the length of the stream in bytes.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>
            <block subset="none" type="note">This property 
      overrides <see cref="P:System.IO.Stream.Length" />.</block>
          </para>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets the length of the stream in bytes.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="ILASM" Value=".property int64 Position { public hidebysig virtual specialname int64 get_Position() public hidebysig virtual specialname void set_Position(int64 value) }" />
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Int64" /> containing the current position within the stream.</para>
        </value>
        <remarks>
          <para>
            <block subset="none" type="note">This property overrides <see cref="P:System.IO.Stream.Position" />.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is negative or greater than  the maximum length of a <see cref="T:System.IO.MemoryStream" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the current position within the stream.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 Read(class System.Byte[] buffer, int32 offset, int32 count)" />
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> or <paramref name="count" /> is negative.</exception>
        <exception cref="T:System.ArgumentException">(<paramref name="offset " /> + <paramref name="count" /> ) is larger than the length of <paramref name="buffer" />.</exception>
        <exception cref="T:System.ObjectDisposedException"> The current stream is closed.</exception>
        <example>
          <para>The following example demonstrates the result of reading from a <see cref="T:System.IO.MemoryStream" /> into its
   underlying byte array.</para>
          <code lang="C#">using System;
using System.IO;

public class MemoryStreamTest {
   public static void Main() {

      byte[] values = new byte [] {0,1,2,3,4,5,6,7,8,9};

      foreach (byte b in values) {
         Console.Write(b);
      }

      Console.WriteLine();

      MemoryStream ms = new MemoryStream (values);

      ms.Read(values, 1, 5);

      foreach (byte b in values) {
         Console.Write(b);
      }
   }
}
</code>
          <para>The output is</para>
          <c>
            <para>0123456789 </para>
            <para>0012346789</para>
          </c>
        </example>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />.</para>
          <para>The <paramref name="offset" /> parameter gives the offset of the first byte in <paramref name="buffer" /> to which data from the current stream is written. The <paramref name="count" /> parameter gives the maximum number of bytes to read from the current stream. The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</para>
          <para>If the read operation is successful, the current position within the stream advances by the number of bytes read. If an exception occurs, the current position within the stream remains unchanged.</para>
          <para>The Read method will return zero only if the end of the stream is reached. In all other cases, Read always reads at least one byte from the stream before returning. By definition, if no data is available from the stream upon a call to Read, the Read method returns zero (the end of the stream is reached automatically). An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</para>
          <para>Use <see cref="T:System.IO.BinaryReader" /> for reading primitive data types.</para>
          <block subset="none" type="note">
            <para>If the byte array specified in the <paramref name="buffer" /> parameter is the underlying buffer returned by the <see cref="M:System.IO.MemoryStream.GetBuffer" /> method, the array contents are overwritten, and no exception is thrown.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a block of bytes from the current stream and writes the data to a buffer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The total number of bytes written into the buffer. This can be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached before any bytes are read.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the characters read from the current stream. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based byte offset in <paramref name="buffer" /> at which to begin storing data from the current stream.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to read. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the operation is canceled before it completes, the returned task contains the <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> value for the <see cref="P:System.Threading.Tasks.Task.Status" /> property.</para>
          <para>You can create a cancellation token by creating an instance of the <see cref="T:System.Threading.CancellationTokenSource" /> class and passing the <see cref="P:System.Threading.CancellationTokenSource.Token" /> property as the <paramref name="cancellationToken" /> parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A task that represents the asynchronous read operation. The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached. </para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />The buffer to write the data into.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to read.</param>
        <param name="cancellationToken">
          <attribution license="cc4" from="Microsoft" modified="false" />The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 ReadByte()" />
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <exception cref="T:System.ObjectDisposedException"> The current stream is closed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.ReadByte" />.</para>
          <para>If the read operation is successful, the current position within the stream is advanced by one byte. If an exception occurs, the current position within the stream is unchanged.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Reads a byte from the current stream.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The byte cast to a <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc)" />
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <exception cref="T:System.IO.IOException">Seeking is attempted before the beginning of  the stream.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> is greater than the maximum length of <see cref="T:System.IO.MemoryStream" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="loc" /> is not a valid <see cref="T:System.IO.SeekOrigin" /> value.</exception>
        <exception cref="T:System.ObjectDisposedException"> The current stream is closed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />.</para>
          <para>Seeking to any location beyond the length of the stream is supported.</para>
          <para>Do not use the <see cref="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" /> method to determine the new position in the stream if the <see cref="T:System.IO.MemoryStream" /> was initialized with a non-zero offset. If you do, <see cref="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" /> will return an inaccurate value. Instead, use the <see cref="P:System.IO.MemoryStream.Position" /> property to get the new position of the stream.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the position within the current stream to the specified value.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The new position within the stream, calculated by combining the initial reference point and the offset.</para>
        </returns>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The new position within the stream. This is relative to the <paramref name="loc" /> parameter, and can be positive or negative. </param>
        <param name="loc">
          <attribution license="cc4" from="Microsoft" modified="false" />A value of type <see cref="T:System.IO.SeekOrigin" />, which acts as the seek reference point. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void SetLength(int64 value)" />
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <exception cref="T:System.NotSupportedException">
          <para>The current stream is not resizable and <paramref name="value" /> is greater than the current <see cref="P:System.IO.MemoryStream.Capacity" />.</para>
          <para>-or-</para>
          <para>The current stream does not support writing.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> is negative or is greater than the maximum length of the <see cref="T:System.IO.MemoryStream" />  - <paramref name="origin" />, where <paramref name="origin" /> is the index into the underlying buffer at which the stream starts.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.</para>
          <para>If the specified value is less than the current length of the stream, the stream is truncated. If after the truncation the current position within the stream is past the end of the stream, the <see cref="M:System.IO.MemoryStream.ReadByte" /> method returns -1, the <see cref="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)" /> method reads zero bytes into the provided byte array, and <see cref="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.MemoryStream.WriteByte(System.Byte)" /> methods append specified bytes at the end of the stream, increasing its length. If the specified value is larger than the current capacity and the stream is resizable, the capacity is increased, and the current position within the stream is unchanged. If the length is increased, the contents of the stream between the old and the new length are initialized to zeros.</para>
          <block subset="none" type="note">
            <para>A <see cref="T:System.IO.MemoryStream" /> instance must support writing for this method to work. Use the <see cref="P:System.IO.MemoryStream.CanWrite" /> property to determine whether the current instance supports writing. For additional information, see <see cref="P:System.IO.Stream.CanWrite" />.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Sets the length of the current stream to the specified value.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The value at which to set the length. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Byte[] ToArray()" />
      <MemberSignature Language="C#" Value="public virtual byte[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ToArray() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method omits unused bytes in <see cref="T:System.IO.MemoryStream" /> from the array. To get the entire buffer, use the <see cref="M:System.IO.MemoryStream.GetBuffer" /> method.</para>
          <para>This method returns a copy of the contents of the <see cref="T:System.IO.MemoryStream" /> as a byte array. If the current instance was constructed on a provided byte array, a copy of the section of the array to which this instance has access is returned. See the <see cref="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)" />  constructor for details.</para>
          <block subset="none" type="note">
            <para>This method works when the <see cref="T:System.IO.MemoryStream" /> is closed.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes the stream contents to a byte array, regardless of the <see cref="P:System.IO.MemoryStream.Position" /> property.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A new byte array.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Write(class System.Byte[] buffer, int32 offset, int32 count)" />
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <para>The current stream does not support writing.</para>
          <para>-or-</para>
          <para>The current position is closer than <paramref name="count " />bytes to the end of the stream, and the capacity cannot be modified.</para>
        </exception>
        <exception cref="T:System.ArgumentException">(<paramref name="offset " />+ <paramref name="count" /> ) is greater than the length of <paramref name="buffer" />. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> or <paramref name="count" /> are negative.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />.</para>
          <para>The <paramref name="offset" /> parameter gives the offset of the first byte in <paramref name="buffer" /> to write from, and the <paramref name="count" /> parameter gives the number of bytes to write. If the write operation is successful, the current position within the stream is advanced by the number of bytes written. If an exception occurs, the current position within the stream is unchanged.</para>
          <para>Except for a MemoryStream constructed with a byte[] parameter, write operations at the end of a MemoryStream expand the MemoryStream.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a block of bytes to the current stream using data read from a buffer.</para>
        </summary>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />The buffer to write data from. </param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to write. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the operation is canceled before it completes, the returned task contains the <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> value for the <see cref="P:System.Threading.Tasks.Task.Status" /> property.</para>
          <para>You can create a cancellation token by creating an instance of the <see cref="T:System.Threading.CancellationTokenSource" /> class and passing the <see cref="P:System.Threading.CancellationTokenSource.Token" /> property as the <paramref name="cancellationToken" /> parameter.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A task that represents the asynchronous write operation.</para>
        </returns>
        <param name="buffer">
          <attribution license="cc4" from="Microsoft" modified="false" />The buffer to write data from.</param>
        <param name="offset">
          <attribution license="cc4" from="Microsoft" modified="false" />The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to write.</param>
        <param name="cancellationToken">
          <attribution license="cc4" from="Microsoft" modified="false" />The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void WriteByte(unsigned int8 value)" />
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
        <exception cref="T:System.NotSupportedException">
          <para>The current stream does not support writing.</para>
          <para>-or-</para>
          <para>The current position is at the end of the stream, and the stream's capacity cannot be modified.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method overrides <see cref="M:System.IO.Stream.WriteByte(System.Byte)" />.</para>
          <para>Except for a MemoryStream constructed with a byte[] parameter, write operations at the end of a MemoryStream expand the MemoryStream.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes a byte to the current stream at the current position.</para>
        </summary>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte to write. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void WriteTo(class System.IO.Stream stream)" />
      <MemberSignature Language="C#" Value="public virtual void WriteTo (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.IO.Stream stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The current or target stream is closed.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When the current stream is open, this method is equivalent to calling <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> on the underlying buffer of this stream.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Writes the entire contents of this memory stream to another stream.</para>
        </summary>
        <param name="stream">
          <attribution license="cc4" from="Microsoft" modified="false" />The stream to write this memory stream to. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>