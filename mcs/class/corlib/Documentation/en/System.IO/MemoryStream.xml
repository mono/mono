<Type Name="MemoryStream" FullName="System.IO.MemoryStream" FullNameSP="System_IO_MemoryStream" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public serializable MemoryStream extends System.IO.Stream" />
  <TypeSignature Language="C#" Value="public class MemoryStream : System.IO.Stream" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Docs>
    <summary>
      <para> Provides support for creating and using a stream whose backing store is memory.</para>
    </summary>
    <remarks>
      <para>The <see cref="T:System.IO.MemoryStream" /> class creates streams that have memory as a backing
   store instead of a disk or a network connection. <see cref="T:System.IO.MemoryStream" />
   encapsulates data stored as an unsigned byte array. The encapsulated data is directly accessible
   in memory. Memory streams can reduce the need for temporary buffers and files
   in an application.</para>
      <para>The <paramref name="current position" /> of
a stream is the position at which the next read or write operation takes
place. The current position can be retrieved or set through the <see cref="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
method. When a new instance of <see cref="T:System.IO.MemoryStream" />
is created, the
current position is set to zero.</para>
      <para>The maximum length of a <see cref="T:System.IO.MemoryStream" /> is implementation-specific.</para>
      <para>
        <block subset="none" type="note">Memory streams created
   with an unsigned byte array provide a non-resizable stream view
   of the data. When using a byte array, you can neither
   append to nor shrink the stream, although you might be able to modify the existing
   contents depending on the parameters passed into the constructor.</block>
      </para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor()" />
      <MemberSignature Language="C#" Value="public MemoryStream ();" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters />
      <Docs>
        <summary>
          <para>Constructs and initializes a new resizable instance of the <see cref="T:System.IO.MemoryStream" />
class.</para>
        </summary>
        <remarks>
          <para>The <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, and <see cref="P:System.IO.Stream.CanWrite" /> properties of the
   new instance of the <see cref="T:System.IO.MemoryStream" /> class are set to <see langword="true" />.</para>
          <para>The capacity of the new stream instance can be increased
   by using the <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" /> method or by
   setting the <see cref="P:System.IO.MemoryStream.Capacity" /> property.</para>
          <para>The new stream exposes the underlying byte buffer, which
   can be accessed through the <see cref="M:System.IO.MemoryStream.GetBuffer" />
   method.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Byte[] buffer)" />
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">The <see cref="T:System.Byte" /> array from which to create the new stream.</param>
        <summary>
          <para>Constructs and initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class.</para>
        </summary>
        <remarks>
          <para>The <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, and <see cref="P:System.IO.Stream.CanWrite" />
properties of the new instance of the <see cref="T:System.IO.MemoryStream" /> class are set to
<see langword="true" />. <see cref="P:System.IO.MemoryStream.Capacity" /> is set to the length of the specified 
<see cref="T:System.Byte" /> 
array.</para>
          <para>
            <block subset="none" type="note">The new stream instance can be written to, but
   the <see cref="P:System.IO.MemoryStream.Capacity" /> of
   the underlying <see cref="T:System.Byte" />
   array cannot be changed. The length of the stream cannot be set
   to a value greater than <see cref="P:System.IO.MemoryStream.Capacity" />
   , but the
   stream can be truncated (see <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />).</block>
          </para>
          <para>The new stream does not expose the underlying byte buffer, and calls to the
<see cref="M:System.IO.MemoryStream.GetBuffer" /> method throw <see cref="T:System.UnauthorizedAccessException" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(int32 capacity)" />
      <MemberSignature Language="C#" Value="public MemoryStream (int capacity);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">A <see cref="T:System.Int32" /> that specifies the initial size of the internal <see cref="T:System.Byte" /> array.</param>
        <summary>
          <para>Constructs and initializes a new resizable instance of the <see cref="T:System.IO.MemoryStream" />
class.</para>
        </summary>
        <remarks>
          <para>The <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, and <see cref="P:System.IO.Stream.CanWrite" />
properties of the new instance of the <see cref="T:System.IO.MemoryStream" /> class are set to
<see langword="true" />.</para>
          <para>The <see cref="P:System.IO.MemoryStream.Capacity" /> of 
the new stream instance is set to <paramref name="capacity" /> can be increased
by using the <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" /> method <SPAN>or by
setting the <see cref="P:System.IO.MemoryStream.Capacity" /> property.</SPAN> Write operations at the end of
the new instance of the <see cref="T:System.IO.MemoryStream" /> class expand the <see cref="T:System.IO.MemoryStream" />.</para>
          <para>The new stream exposes the underlying byte buffer,
   which can be accessed through the <see cref="M:System.IO.MemoryStream.GetBuffer" />
   method.</para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is negative.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Byte[] buffer, bool writable)" />
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, bool writable);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">The <see cref="T:System.Byte" /> array from which to create the new stream.</param>
        <param name="writable">A <see cref="T:System.Boolean" /> that specifies whether the new stream instance supports writing.</param>
        <summary>
          <para>Constructs and initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class.</para>
        </summary>
        <remarks>
          <para>The <see cref="P:System.IO.Stream.CanRead" /> and <see cref="P:System.IO.Stream.CanSeek" /> properties of the new
   instance of the <see cref="T:System.IO.MemoryStream" /> class are set to <see langword="true" />. The <see cref="P:System.IO.MemoryStream.Capacity" /> property is set to the length of the specified
<see cref="T:System.Byte" /> array. The <see cref="P:System.IO.Stream.CanWrite" /> property is set to 
<paramref name="writable" /> 
.</para>
          <para>
            <block subset="none" type="note">The new stream instance can be written to depending on the value of <paramref name="writable" />, but the <see cref="P:System.IO.MemoryStream.Capacity" /> of the underlying <see cref="T:System.Byte" /> 
array cannot be changed. The length of the stream cannot be set
to a value larger than <see cref="P:System.IO.MemoryStream.Capacity" />, but the stream can be truncated
(see <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />).</block>
          </para>
          <para>The new stream does not expose the underlying <see cref="T:System.Byte" /> buffer, and calls to the <see cref="M:System.IO.MemoryStream.GetBuffer" />
method throw <see cref="T:System.UnauthorizedAccessException" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Byte[] buffer, int32 index, int32 count)" />
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The <see cref="T:System.Byte" /> array from which to create the new stream.</param>
        <param name="index">A <see cref="T:System.Int32" /> that specifies the index into <paramref name="buffer" /> at which the stream begins.</param>
        <param name="count">A <see cref="T:System.Int32" /> that specifies the length of the stream in bytes.</param>
        <summary>
          <para>Constructs and initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" />
class.</para>
        </summary>
        <remarks>
          <para>The <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, and <see cref="P:System.IO.Stream.CanWrite" /> properties of the
   new <see cref="T:System.IO.MemoryStream" /> instance are set to <see langword="true" />. The <see cref="P:System.IO.MemoryStream.Capacity" /> property
   is set to <paramref name="count" />
   .</para>
          <para>
            <block subset="none" type="note">The new stream instance can be written to, but the
<see cref="P:System.IO.MemoryStream.Capacity" /> of the underlying <see cref="T:System.Byte" /> 
array cannot be changed. The length of the stream cannot be set
to a value larger than <see cref="P:System.IO.MemoryStream.Capacity" />, but the stream can be truncated
(see <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />).</block>
          </para>
          <para>The new stream does not expose the underlying <see cref="T:System.Byte" /> 
buffer, and calls to the <see cref="M:System.IO.MemoryStream.GetBuffer" /> method throw <see cref="T:System.UnauthorizedAccessException" />
.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">(<paramref name="index" /> + <paramref name="count" /> ) is greater than the length of <paramref name="buffer" />.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Byte[] buffer, int32 index, int32 count, bool writable)" />
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">The <see cref="T:System.Byte" /> array from which to create the new stream.</param>
        <param name="index">A <see cref="T:System.Int32" /> that specifies the index in <paramref name="buffer" /> at which the stream begins.</param>
        <param name="count">A <see cref="T:System.Int32" /> that specifies the length of the stream in bytes.</param>
        <param name="writable">A <see cref="T:System.Boolean" /> that specifies whether the new stream instance supports writing.</param>
        <summary>
          <para>Constructs and initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" />
class.</para>
        </summary>
        <remarks>
          <para>The <see cref="P:System.IO.MemoryStream.CanRead" /> and <see cref="P:System.IO.MemoryStream.CanSeek" /> properties
   of the new <see cref="T:System.IO.MemoryStream" /> are
   set to <see langword="true" />. The <see cref="P:System.IO.MemoryStream.Capacity" /> property is set to <paramref name="count" />. The <see cref="P:System.IO.Stream.CanWrite" /> property is set to
<paramref name="writable" />.</para>
          <para>
            <block subset="none" type="note">The new stream instance can be written to depending on the value of <paramref name="writable" />, but the <see cref="P:System.IO.MemoryStream.Capacity" /> of the 
   underlying byte array cannot be changed. The length of the stream cannot be set
   to a value larger than <see cref="P:System.IO.MemoryStream.Capacity" />, but the stream can be truncated
   (see <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />).</block>
          </para>
          <para>The new stream does not expose the underlying byte
   buffer, and calls to the <see cref="M:System.IO.MemoryStream.GetBuffer" /> method throw <see cref="T:System.UnauthorizedAccessException" />.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> are negative.</exception>
        <exception cref="T:System.ArgumentException">(<paramref name="index" /> + <paramref name="count" /> ) is greater than the length of <paramref name="buffer" />.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="public rtspecialname specialname instance void .ctor(class System.Byte[] buffer, int32 index, int32 count, bool writable, bool publiclyVisible)" />
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberType>Constructor</MemberType>
      <ReturnValue />
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="publiclyVisible" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">The <see cref="T:System.Byte" /> array from which to create the new stream.</param>
        <param name="index">A <see cref="T:System.Int32" /> that specifies the index into <paramref name="buffer" /> at which the stream begins.</param>
        <param name="count">A <see cref="T:System.Int32" /> that specifies the length of the stream in bytes.</param>
        <param name="writable">A <see cref="T:System.Boolean" /> that specifies whether the new stream instance supports writing.</param>
        <param name="publiclyVisible">A <see cref="T:System.Boolean" /> that specifies whether <paramref name="buffer" /> is exposed via <see cref="M:System.IO.MemoryStream.GetBuffer" />, which returns the <see cref="T:System.Byte" /> array from which the stream was created. Specify <see langword="true" /> to expose <paramref name="buffer" />; otherwise, specify <see langword="false" />.</param>
        <summary>
          <para>Constructs and initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class.</para>
        </summary>
        <remarks>
          <para>The <see cref="P:System.IO.MemoryStream.CanRead" /> and <see cref="P:System.IO.MemoryStream.CanSeek" /> properties of
   the new <see cref="T:System.IO.MemoryStream" /> instance are
   set to <see langword="true" />. The <see cref="P:System.IO.MemoryStream.Capacity" /> property is set to <paramref name="count" />. The <see cref="P:System.IO.Stream.CanWrite" /> property is set to
<paramref name="writable" />.</para>
          <para>
            <block subset="none" type="note">The new stream instance can be written to depending on the value of <paramref name="writable" />, but the <see cref="P:System.IO.MemoryStream.Capacity" /> of the underlying <see cref="T:System.Byte" /> array cannot be changed. The length of the stream cannot be set
to a value larger than <see cref="P:System.IO.MemoryStream.Capacity" />, but the stream can be truncated
(see <see cref="M:System.IO.MemoryStream.SetLength(System.Int64)" />).</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is negative.</exception>
        <exception cref="T:System.ArgumentException">(<paramref name="index" /> + <paramref name="count" /> ) is greater than the length of <paramref name="buffer" />.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="ILASM" Value=".property bool CanRead { public hidebysig virtual specialname bool get_CanRead() }" />
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value indicating whether the current stream supports reading.</para>
        </summary>
        <value>
          <para>
            <see langword="true " />if the current 
   stream is open and supports reading; otherwise <see langword="false" />
   .</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="ILASM" Value=".property bool CanSeek { public hidebysig virtual specialname bool get_CanSeek() }" />
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value indicating whether the current stream
   supports seeking.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the stream is open and 
   supports seeking; otherwise <see langword="false" />
   .</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="ILASM" Value=".property bool CanWrite { public hidebysig virtual specialname bool get_CanWrite() }" />
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets a <see cref="T:System.Boolean" /> value indicating whether the current stream
   supports writing.</para>
        </summary>
        <value>
          <para>
            <see langword="true" /> if the stream supports writing;
   otherwise, <see langword="false" />.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="ILASM" Value=".property int32 Capacity { public hidebysig virtual specialname int32 get_Capacity() public hidebysig virtual specialname void set_Capacity(int32 value) }" />
      <MemberSignature Language="C#" Value="public virtual int Capacity { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets or sets the number of bytes allocated for the current
      stream.</para>
        </summary>
        <value>
          <para> A <see cref="T:System.Int32" /> containing the
   number of bytes allocated for the current stream.</para>
        </value>
        <remarks>
          <para>
            <see cref="P:System.IO.MemoryStream.Capacity" /> is
   the buffer length for system-provided byte arrays. If the current stream is
   created with a specified <see cref="T:System.Byte" />
   array, <see cref="P:System.IO.MemoryStream.Capacity" /> indicates the length of the portion of
   the provided array to which the current stream has access. <block subset="none" type="note">For additional information, see the <see cref="T:System.IO.MemoryStream" /> (<see cref="T:System.Byte" />[], <see cref="T:System.Int32" />, <see cref="T:System.Int32" /> ) constructor. </block></para>
          <para>
            <see cref="P:System.IO.MemoryStream.Capacity" />
cannot be set to a value less than the current length of the stream, but can be
set to less than the current capacity. If the capacity specified is less than
the current capacity, the size of the buffer used
to hold the stream can be reduced, but need not be.</para>
          <para>
            <block subset="none" type="note">If the value specified for a set operation is less than the default value,
   for performance reasons the property is set to the default. The default
   value of the <see cref="P:System.IO.MemoryStream.Capacity" /> property is
   unspecified.
</block>
          </para>
          <para>
            <block subset="none" type="behaviors">As described
   above.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is negative or less than the current length of the stream.</exception>
        <exception cref="T:System.NotSupportedException">A set operation was attempted on a stream whose capacity cannot be modified. </exception>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Close()" />
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Closes the current <see cref="T:System.IO.MemoryStream" /> instance.</para>
        </summary>
        <remarks>
          <para> The stream will not support reading or writing after
      this method is invoked. Following a call to <see cref="M:System.IO.MemoryStream.Close" />
      , operations on the
      stream can raise an exception. </para>
          <para> The buffer of a closed <see cref="T:System.IO.MemoryStream" /> is still available, and the <see cref="M:System.IO.MemoryStream.ToArray" />
and <see cref="M:System.IO.MemoryStream.GetBuffer" /> methods can
be called successfully. </para>
          <block subset="none" type="note"> This method overrides <see cref="M:System.IO.Stream.Close" />
.</block>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Flush()" />
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Overrides <see cref="M:System.IO.Stream.Flush" qualify="true" />
so that no action is performed.</para>
        </summary>
        <remarks>
          <para>Since any data written to a <see cref="T:System.IO.MemoryStream" /> is written into RAM, this 
   method is redundant.</para>
          <para>
            <block subset="none" type="note">This method overrides <see cref="M:System.IO.Stream.Flush" qualify="true" />.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="GetBuffer">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Byte[] GetBuffer()" />
      <MemberSignature Language="C#" Value="public virtual byte[] GetBuffer ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Returns the
      array of unsigned bytes from which this stream was created.</para>
        </summary>
        <returns>
          <para>The <see cref="T:System.Byte" /> array from which the current stream was created, or the
   underlying array if a <see cref="T:System.Byte" />
   array was not provided to the <see cref="T:System.IO.MemoryStream" />
   constructor during construction of the current instance.</para>
        </returns>
        <remarks>
          <para>To create a <see cref="T:System.IO.MemoryStream" /> instance with a publicly visible buffer use the default constructor, 
<see cref="T:System.IO.MemoryStream" />( 
<see cref="T:System.Byte" /> [], <see cref="T:System.Int32" />, <see cref="T:System.Int32" />, <see cref="T:System.Boolean" />, <see langword="true" />) or <see cref="T:System.IO.MemoryStream" />(<see cref="T:System.Int32" /> 
) constructor. </para>
          <para> If the current stream is resizable, multiple calls to
   this method do not return the same array if the underlying <see cref="T:System.Byte" />
   array is
   resized between calls. For additional information, see <see cref="P:System.IO.MemoryStream.Capacity" />
   . </para>
          <para>
            <block subset="none" type="note">This method works when the <see cref="T:System.IO.MemoryStream" /> is closed.</block>
          </para>
          <para>
            <block subset="none" type="behaviors">As described above.</block>
          </para>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current instance was not created with a publicly visible buffer.</exception>
        <example>
          <para>The following example demonstrates that two calls to the <see cref="M:System.IO.MemoryStream.GetBuffer" />
method on a resizable stream do not return the same array if the underlying byte array is
reallocated.</para>
          <code lang="C#">using System;
using System.IO;

public class MemoryStreamTest {
   public static void Main() {

      MemoryStream ms = new MemoryStream(10);

      byte[] a = ms.GetBuffer();
      byte[] b = ms.GetBuffer();

      //Force reallocation of the underlying byte array.
      ms.Capacity = 10240;    
      byte[] c = ms.GetBuffer();


      if(Object.ReferenceEquals(a, b))
         Console.WriteLine("a and b represent the same instance.");
      else
         Console.WriteLine("a and b represent the different instances.");

      if(Object.ReferenceEquals(a, c))
         Console.WriteLine("a and c represent the same instance.");
      else
         Console.WriteLine("a and c represent the different instances.");

   }
}
</code>
          <para>The output is</para>
          <c>
            <para>a and b represent the same instance.</para>
            <para>a and c represent the different instances.</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="ILASM" Value=".property int64 Length { public hidebysig virtual specialname int64 get_Length() }" />
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Gets the length of the stream in bytes.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Int64" /> containing the length of the stream in bytes.</para>
        </value>
        <remarks>
          <para>This property is read-only.</para>
          <para>
            <block subset="none" type="note">This property 
      overrides <see cref="P:System.IO.Stream.Length" />.</block>
          </para>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected override void ObjectInvariant ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="ILASM" Value=".property int64 Position { public hidebysig virtual specialname int64 get_Position() public hidebysig virtual specialname void set_Position(int64 value) }" />
      <MemberSignature Language="C#" Value="public override long Position { set; get; }" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Gets or sets the current position within the stream.</para>
        </summary>
        <value>
          <para>A <see cref="T:System.Int64" /> containing the current position within the stream.</para>
        </value>
        <remarks>
          <para>
            <block subset="none" type="note">This property overrides <see cref="P:System.IO.Stream.Position" />.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is negative or greater than  the maximum length of a <see cref="T:System.IO.MemoryStream" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 Read(class System.Byte[] buffer, int32 offset, int32 count)" />
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" /> array. When this method returns, <paramref name="buffer" /> contains the specified byte array with the values between <paramref name="offset " />and <paramref name="(offset + count - 1)" /> replaced by the characters read from the current stream.</param>
        <param name="offset">A <see cref="T:System.Int32" /> that specifies the byte offset in <paramref name="buffer" /> at which to begin writing.</param>
        <param name="count">A <see cref="T:System.Int32" /> that specifies the maximum number of bytes to read.</param>
        <summary>
          <para>Reads a block of bytes from the current stream at the current position, and
      writes the data to the specified byte array.</para>
        </summary>
        <returns>
          <para> A <see cref="T:System.Int32" /> that specifies the total number of bytes
   written into the buffer, or zero if the end of the stream is
   reached before any bytes are read.</para>
        </returns>
        <remarks>
          <para>If the read operation is successful, the current position within the
      stream advances by the number of bytes read. If an exception occurs, the current position within
      the stream remains unchanged.</para>
          <para>If the read takes place immediately following a seek beyond the end of the stream, the end of the stream is reached.</para>
          <block subset="none" type="note">
            <para>If the byte array specified in the <paramref name="buffer" /> parameter is the underlying buffer returned by the
   <see cref="M:System.IO.MemoryStream.GetBuffer" /> method, the array contents are overwritten, and no
      exception is thrown. </para>
            <para>This method overrides <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" qualify="true" />.</para>
          </block>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> or <paramref name="count" /> is negative.</exception>
        <exception cref="T:System.ArgumentException">(<paramref name="offset " /> + <paramref name="count" /> ) is larger than the length of <paramref name="buffer" />.</exception>
        <exception cref="T:System.ObjectDisposedException"> The current stream is closed.</exception>
        <example>
          <para>The following example demonstrates the result of reading from a <see cref="T:System.IO.MemoryStream" /> into its
   underlying byte array.</para>
          <code lang="C#">using System;
using System.IO;

public class MemoryStreamTest {
   public static void Main() {

      byte[] values = new byte [] {0,1,2,3,4,5,6,7,8,9};

      foreach (byte b in values) {
         Console.Write(b);
      }

      Console.WriteLine();

      MemoryStream ms = new MemoryStream (values);

      ms.Read(values, 1, 5);

      foreach (byte b in values) {
         Console.Write(b);
      }
   }
}
</code>
          <para>The output is</para>
          <c>
            <para>0123456789 </para>
            <para>0012346789</para>
          </c>
        </example>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 ReadByte()" />
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para> Reads a byte from the current stream at the current position.
      </para>
        </summary>
        <returns>
          <para> The byte cast to a <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.
   </para>
        </returns>
        <remarks>
          <para>If the read operation is successful, the current position
      within the stream is advanced by one byte. If an exception occurs, the
      current position within the stream is unchanged.</para>
          <para>If the read takes place immediately following a seek beyond the end of the stream, the end of the stream is reached.</para>
          <para>
            <block subset="none" type="note">This method overrides <see cref="M:System.IO.Stream.ReadByte" qualify="true" />.</block>
          </para>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"> The current stream is closed.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc)" />
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">A <see cref="T:System.Int64" /> that specifies the new position within the stream. This is relative to the <paramref name="loc " /> parameter, and can be positive or negative.</param>
        <param name="loc"> A <see cref="T:System.IO.SeekOrigin" /> value that specifies the seek reference point.</param>
        <summary>
          <para>Changes the position within the current stream by the given offset, which is relative to the stated origin.</para>
        </summary>
        <returns>
          <para>A <see cref="T:System.Int64" /> containing the new position within the stream, calculated by
   combining the seek reference point and the offset.</para>
        </returns>
        <remarks>
          <para>
            <block subset="none" type="note">This method overrides <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" qualify="true" />.</block>
          </para>
        </remarks>
        <exception cref="T:System.IO.IOException">Seeking is attempted before the beginning of  the stream.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> is greater than the maximum length of <see cref="T:System.IO.MemoryStream" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="loc" /> is not a valid <see cref="T:System.IO.SeekOrigin" /> value.</exception>
        <exception cref="T:System.ObjectDisposedException"> The current stream is closed.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void SetLength(int64 value)" />
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">A <see cref="T:System.Int64" /> that specifies the value at which to set the length.</param>
        <summary>
          <para>Sets the length of the current stream to the specified value.</para>
        </summary>
        <remarks>
          <para> If the specified value is less than the current length of the
      stream, the stream is truncated. If after the truncation the current position within the
      stream is past the end of the stream, the <see cref="M:System.IO.MemoryStream.ReadByte" />
      method returns -1, the <see cref="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)" /> method reads zero bytes into the provided byte
      array, and <see cref="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.MemoryStream.WriteByte(System.Byte)" /> methods
      
      append specified bytes at the end of the stream, increasing its length.</para>
          <para>If the specified value is larger than the current
      capacity and the stream is resizable, the capacity is increased, and the current position
      within the stream is unchanged. If the length is increased, the contents
      of the stream between the old and the new length are initialized to zeros. </para>
          <block subset="none" type="note">
            <para>A <see cref="T:System.IO.MemoryStream" /> instance must support writing for this method to
      work. Use the <see cref="P:System.IO.MemoryStream.CanWrite" /> property to determine whether the
      current instance supports writing. For additional information, see <see cref="P:System.IO.Stream.CanWrite" /> .</para>
            <para>This method overrides <see cref="M:System.IO.Stream.SetLength(System.Int64)" qualify="true" />.</para>
          </block>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <para>The current stream is not resizable and <paramref name="value" /> is greater than the current <see cref="P:System.IO.MemoryStream.Capacity" />.</para>
          <para>-or-</para>
          <para>The current stream does not support writing.</para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> is negative or is greater than the maximum length of the <see cref="T:System.IO.MemoryStream" />  - <paramref name="origin" />, where <paramref name="origin" /> is the index into the underlying buffer at which the stream starts.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Byte[] ToArray()" />
      <MemberSignature Language="C#" Value="public virtual byte[] ToArray ();" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Writes the entire stream contents to a <see cref="T:System.Byte" /> array,
   regardless of the current position within the stream.</para>
        </summary>
        <returns>
          <para> A new <see cref="T:System.Byte" /> array.
   </para>
        </returns>
        <remarks>
          <para>This method returns a copy of the contents of
      the <see cref="T:System.IO.MemoryStream" /> as a byte array. If the
      current instance was constructed on a provided byte array, a copy of the section
      of the array to which the current instance has access is returned. <block subset="none" type="note">For
      additional information, see the <see cref="T:System.IO.MemoryStream" /> (<see cref="T:System.Byte" />[], <see cref="T:System.Int32" />, <see cref="T:System.Int32" /> )
      constructor.</block></para>
          <para>
            <block subset="none" type="note">This method
      works when the <see cref="T:System.IO.MemoryStream" /> is
      closed.</block>
          </para>
          <para>
            <block subset="none" type="behaviors">As described
      above.</block>
          </para>
        </remarks>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void Write(class System.Byte[] buffer, int32 offset, int32 count)" />
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The <see cref="T:System.Byte" /> array to write data from.</param>
        <param name="offset">A <see cref="T:System.Int32" /> that specifies the zero based byte offset into <paramref name="buffer" /> at which to begin writing from.</param>
        <param name="count">A <see cref="T:System.Int32" /> that specifies the maximum number of bytes to write from <paramref name="buffer" />.</param>
        <summary>
          <para>Writes a block of bytes
      to the current stream at the current position using data read from buffer.</para>
        </summary>
        <remarks>
          <para> If the write operation is
      successful, the current position within the stream is advanced by the number of
      bytes written. If an exception occurs, the current position within the stream
      is unchanged.</para>
          <para>If the write takes place immediately following a seek beyond the end of the stream, that stream is zero-byte-extended to the new seek position before the given bytes are written.</para>
          <para>Write operations at the end of a resizable <see cref="T:System.IO.MemoryStream" /> expand
   the <see cref="T:System.IO.MemoryStream" />.</para>
          <para>
            <block subset="none" type="note">Use the <see cref="P:System.IO.MemoryStream.CanWrite" /> method to determine whether the current stream supports writing.</block>
          </para>
          <para>
            <block subset="none" type="note">This method overrides <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" qualify="true" />.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <para>The current stream does not support writing.</para>
          <para>-or-</para>
          <para>The current position is closer than <paramref name="count " />bytes to the end of the stream, and the capacity cannot be modified.</para>
        </exception>
        <exception cref="T:System.ArgumentException">(<paramref name="offset " />+ <paramref name="count" /> ) is greater than the length of <paramref name="buffer" />. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> or <paramref name="count" /> are negative.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void WriteByte(unsigned int8 value)" />
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Byte" /> to write.</param>
        <summary>
          <para>Writes a <see cref="T:System.Byte" /> to the current stream at the current position.</para>
        </summary>
        <remarks>
          <para>Write operations at the end of a resizable <see cref="T:System.IO.MemoryStream" />
expand the <see cref="T:System.IO.MemoryStream" />. If the write operation is
successful, the current position within the stream is advanced by one byte. If an
exception occurs, the position is unchanged.</para>
          <para>If the write takes place immediately following a seek beyond the end of the stream, that stream is zero-byte-extended to the new seek position before the given byte is written. </para>
          <para>
            <block subset="none" type="note">Use the <see cref="P:System.IO.MemoryStream.CanWrite" /> method to determine 
whether the current stream supports writing.</block>
          </para>
          <para>
            <block subset="none" type="note">This method overrides <see cref="M:System.IO.Stream.WriteByte(System.Byte)" qualify="true" />.</block>
          </para>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current stream is closed.</exception>
        <exception cref="T:System.NotSupportedException">
          <para>The current stream does not support writing.</para>
          <para>-or-</para>
          <para>The current position is at the end of the stream, and the stream's capacity cannot be modified.</para>
        </exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual void WriteTo(class System.IO.Stream stream)" />
      <MemberSignature Language="C#" Value="public virtual void WriteTo (System.IO.Stream stream);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The <see cref="T:System.IO.Stream" /> to write the current memory stream to.</param>
        <summary>
          <para>Writes the entire contents of the current <see cref="T:System.IO.MemoryStream" /> instance to a specified stream.</para>
        </summary>
        <remarks>
          <para>
            <block subset="none" type="note">This method is equivalent to calling <paramref name="stream" /><see langword=".Write(this.GetBuffer(), 0, this.GetBuffer().Length)" /> and passing in the underlying buffer of the current instance.</block>
          </para>
          <para>
            <block subset="none" type="behaviors">As described
      above.</block>
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The current or target stream is closed.</exception>
      </Docs>
      <Excluded>0</Excluded>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
</Type>
