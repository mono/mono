<?xml version="1.0" encoding="utf-8"?>
<Type Name="Encoding" FullName="System.Text.Encoding" FullNameSP="System_Text_Encoding" Maintainer="ecma">
  <TypeSignature Language="ILASM" Value=".class public abstract serializable Encoding extends System.Object" />
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <MemberOfLibrary>BCL</MemberOfLibrary>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyPublicKey>[00 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 ]</AssemblyPublicKey>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>This type is safe for multithreaded operations. </ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <remarks>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Encoding is the process of transforming a set of Unicode characters into a sequence of bytes. In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters. For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <see cref="T:System.Text.Encoding" />, see <format type="text/html"><a href="bf6d9823-4c2d-48af-b280-919c5af66ae9">Understanding Encodings</a></format>. </para>
      <para>Note that <see cref="T:System.Text.Encoding" /> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays. If your application must encode arbitrary binary data into text, it should use a protocol such as uuencode, which is implemented by methods such as <see cref="M:System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />.</para>
      <para>The .NET Framework provides the following implementations of the <see cref="T:System.Text.Encoding" /> class to support current Unicode encodings and other encodings: </para>
      <list type="bullet">
        <item>
          <para>
            <see cref="T:System.Text.ASCIIEncoding" /> encodes Unicode characters as single 7-bit ASCII characters. This encoding only supports character values between U+0000 and U+007F. Code page 20127. Also available through the <see cref="P:System.Text.Encoding.ASCII" /> property.</para>
        </item>
        <item>
          <para>
            <see cref="T:System.Text.UTF7Encoding" /> encodes Unicode characters using the UTF-7 encoding. This encoding supports all Unicode character values. Code page 65000. Also available through the <see cref="P:System.Text.Encoding.UTF7" /> property.</para>
        </item>
        <item>
          <para>
            <see cref="T:System.Text.UTF8Encoding" /> encodes Unicode characters using the UTF-8 encoding. This encoding supports all Unicode character values. Code page 65001. Also available through the <see cref="P:System.Text.Encoding.UTF8" /> property.</para>
        </item>
        <item>
          <para>
            <see cref="T:System.Text.UnicodeEncoding" /> encodes Unicode characters using the UTF-16 encoding. Both little endian and big endian byte orders are supported. Also available through the <see cref="P:System.Text.Encoding.Unicode" /> property and the <see cref="P:System.Text.Encoding.BigEndianUnicode" /> property.</para>
        </item>
        <item>
          <para>
            <see cref="T:System.Text.UTF32Encoding" /> encodes Unicode characters using the UTF-32 encoding. Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported. Also available through the <see cref="P:System.Text.Encoding.UTF32" /> property.</para>
        </item>
      </list>
      <para>The <see cref="T:System.Text.Encoding" /> class is primarily intended to convert between different encodings and Unicode. Often one of the derived Unicode classes is the correct choice for your application.</para>
      <para>You use the <see cref="M:System.Text.Encoding.GetEncoding(System.Int32)" /> method to obtain other encodings. You can call the <see cref="M:System.Text.Encoding.GetEncodings" /> method to get a list of all encodings.</para>
      <para>The following table lists the encodings supported by the .NET Framework. It lists each encoding's code page number, along with the values of the encoding's <see cref="P:System.Text.EncodingInfo.Name" /> and <see cref="P:System.Text.EncodingInfo.DisplayName" /> properties. . An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform. Note that code pages whose <see cref="P:System.Text.EncodingInfo.Name" /> property corresponds to an international standard do not necessarily comply in full with that standard. </para>
      <list type="table">
        <listheader>
          <item>
            <term>
              <para>Code Page </para>
            </term>
            <description>
              <para>Name </para>
            </description>
            <description>
              <para>Display Name </para>
            </description>
            <description>
              <para> </para>
            </description>
          </item>
        </listheader>
        <item>
          <term>
            <para>37 </para>
          </term>
          <description>
            <para>IBM037 </para>
          </description>
          <description>
            <para>IBM EBCDIC (US-Canada) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>437 </para>
          </term>
          <description>
            <para>IBM437 </para>
          </description>
          <description>
            <para>OEM United States </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>500 </para>
          </term>
          <description>
            <para>IBM500 </para>
          </description>
          <description>
            <para>IBM EBCDIC (International) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>708 </para>
          </term>
          <description>
            <para>ASMO-708 </para>
          </description>
          <description>
            <para>Arabic (ASMO 708) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>720 </para>
          </term>
          <description>
            <para>DOS-720 </para>
          </description>
          <description>
            <para>Arabic (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>737 </para>
          </term>
          <description>
            <para>ibm737 </para>
          </description>
          <description>
            <para>Greek (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>775 </para>
          </term>
          <description>
            <para>ibm775 </para>
          </description>
          <description>
            <para>Baltic (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>850 </para>
          </term>
          <description>
            <para>ibm850 </para>
          </description>
          <description>
            <para>Western European (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>852 </para>
          </term>
          <description>
            <para>ibm852 </para>
          </description>
          <description>
            <para>Central European (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>855 </para>
          </term>
          <description>
            <para>IBM855 </para>
          </description>
          <description>
            <para>OEM Cyrillic </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>857 </para>
          </term>
          <description>
            <para>ibm857 </para>
          </description>
          <description>
            <para>Turkish (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>858 </para>
          </term>
          <description>
            <para>IBM00858 </para>
          </description>
          <description>
            <para>OEM Multilingual Latin I </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>860 </para>
          </term>
          <description>
            <para>IBM860 </para>
          </description>
          <description>
            <para>Portuguese (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>861 </para>
          </term>
          <description>
            <para>ibm861 </para>
          </description>
          <description>
            <para>Icelandic (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>862 </para>
          </term>
          <description>
            <para>DOS-862 </para>
          </description>
          <description>
            <para>Hebrew (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>863 </para>
          </term>
          <description>
            <para>IBM863 </para>
          </description>
          <description>
            <para>French Canadian (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>864 </para>
          </term>
          <description>
            <para>IBM864 </para>
          </description>
          <description>
            <para>Arabic (864) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>865 </para>
          </term>
          <description>
            <para>IBM865 </para>
          </description>
          <description>
            <para>Nordic (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>866 </para>
          </term>
          <description>
            <para>cp866 </para>
          </description>
          <description>
            <para>Cyrillic (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>869 </para>
          </term>
          <description>
            <para>ibm869 </para>
          </description>
          <description>
            <para>Greek, Modern (DOS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>870 </para>
          </term>
          <description>
            <para>IBM870 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Multilingual Latin-2) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>874 </para>
          </term>
          <description>
            <para>windows-874 </para>
          </description>
          <description>
            <para>Thai (Windows) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>875 </para>
          </term>
          <description>
            <para>cp875 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Greek Modern) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>932 </para>
          </term>
          <description>
            <para>shift_jis </para>
          </description>
          <description>
            <para>Japanese (Shift-JIS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>936 </para>
          </term>
          <description>
            <para>gb2312 </para>
          </description>
          <description>
            <para>Chinese Simplified (GB2312) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>949 </para>
          </term>
          <description>
            <para>ks_c_5601-1987 </para>
          </description>
          <description>
            <para>Korean </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>950 </para>
          </term>
          <description>
            <para>big5 </para>
          </description>
          <description>
            <para>Chinese Traditional (Big5) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1026 </para>
          </term>
          <description>
            <para>IBM1026 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Turkish Latin-5) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1047 </para>
          </term>
          <description>
            <para>IBM01047 </para>
          </description>
          <description>
            <para>IBM Latin-1 </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1140 </para>
          </term>
          <description>
            <para>IBM01140 </para>
          </description>
          <description>
            <para>IBM EBCDIC (US-Canada-Euro) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1141 </para>
          </term>
          <description>
            <para>IBM01141 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Germany-Euro) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1142 </para>
          </term>
          <description>
            <para>IBM01142 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Denmark-Norway-Euro) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1143 </para>
          </term>
          <description>
            <para>IBM01143 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Finland-Sweden-Euro) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1144 </para>
          </term>
          <description>
            <para>IBM01144 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Italy-Euro) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1145 </para>
          </term>
          <description>
            <para>IBM01145 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Spain-Euro) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1146 </para>
          </term>
          <description>
            <para>IBM01146 </para>
          </description>
          <description>
            <para>IBM EBCDIC (UK-Euro) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1147 </para>
          </term>
          <description>
            <para>IBM01147 </para>
          </description>
          <description>
            <para>IBM EBCDIC (France-Euro) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1148 </para>
          </term>
          <description>
            <para>IBM01148 </para>
          </description>
          <description>
            <para>IBM EBCDIC (International-Euro) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1149 </para>
          </term>
          <description>
            <para>IBM01149 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Icelandic-Euro) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1200 </para>
          </term>
          <description>
            <para>utf-16 </para>
          </description>
          <description>
            <para>Unicode </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>1201 </para>
          </term>
          <description>
            <para>unicodeFFFE </para>
          </description>
          <description>
            <para>Unicode (Big endian) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>1250 </para>
          </term>
          <description>
            <para>windows-1250 </para>
          </description>
          <description>
            <para>Central European (Windows) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1251 </para>
          </term>
          <description>
            <para>windows-1251 </para>
          </description>
          <description>
            <para>Cyrillic (Windows) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1252 </para>
          </term>
          <description>
            <para>Windows-1252 </para>
          </description>
          <description>
            <para>Western European (Windows) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>1253 </para>
          </term>
          <description>
            <para>windows-1253 </para>
          </description>
          <description>
            <para>Greek (Windows) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1254 </para>
          </term>
          <description>
            <para>windows-1254 </para>
          </description>
          <description>
            <para>Turkish (Windows) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1255 </para>
          </term>
          <description>
            <para>windows-1255 </para>
          </description>
          <description>
            <para>Hebrew (Windows) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1256 </para>
          </term>
          <description>
            <para>windows-1256 </para>
          </description>
          <description>
            <para>Arabic (Windows) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1257 </para>
          </term>
          <description>
            <para>windows-1257 </para>
          </description>
          <description>
            <para>Baltic (Windows) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1258 </para>
          </term>
          <description>
            <para>windows-1258 </para>
          </description>
          <description>
            <para>Vietnamese (Windows) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>1361 </para>
          </term>
          <description>
            <para>Johab </para>
          </description>
          <description>
            <para>Korean (Johab) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10000 </para>
          </term>
          <description>
            <para>macintosh </para>
          </description>
          <description>
            <para>Western European (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10001 </para>
          </term>
          <description>
            <para>x-mac-japanese </para>
          </description>
          <description>
            <para>Japanese (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10002 </para>
          </term>
          <description>
            <para>x-mac-chinesetrad </para>
          </description>
          <description>
            <para>Chinese Traditional (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10003 </para>
          </term>
          <description>
            <para>x-mac-korean </para>
          </description>
          <description>
            <para>Korean (Mac) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>10004 </para>
          </term>
          <description>
            <para>x-mac-arabic </para>
          </description>
          <description>
            <para>Arabic (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10005 </para>
          </term>
          <description>
            <para>x-mac-hebrew </para>
          </description>
          <description>
            <para>Hebrew (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10006 </para>
          </term>
          <description>
            <para>x-mac-greek </para>
          </description>
          <description>
            <para>Greek (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10007 </para>
          </term>
          <description>
            <para>x-mac-cyrillic </para>
          </description>
          <description>
            <para>Cyrillic (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10008 </para>
          </term>
          <description>
            <para>x-mac-chinesesimp </para>
          </description>
          <description>
            <para>Chinese Simplified (Mac) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>10010 </para>
          </term>
          <description>
            <para>x-mac-romanian </para>
          </description>
          <description>
            <para>Romanian (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10017 </para>
          </term>
          <description>
            <para>x-mac-ukrainian </para>
          </description>
          <description>
            <para>Ukrainian (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10021 </para>
          </term>
          <description>
            <para>x-mac-thai </para>
          </description>
          <description>
            <para>Thai (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10029 </para>
          </term>
          <description>
            <para>x-mac-ce </para>
          </description>
          <description>
            <para>Central European (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10079 </para>
          </term>
          <description>
            <para>x-mac-icelandic </para>
          </description>
          <description>
            <para>Icelandic (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10081 </para>
          </term>
          <description>
            <para>x-mac-turkish </para>
          </description>
          <description>
            <para>Turkish (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>10082 </para>
          </term>
          <description>
            <para>x-mac-croatian </para>
          </description>
          <description>
            <para>Croatian (Mac) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>12000 </para>
          </term>
          <description>
            <para>utf-32 </para>
          </description>
          <description>
            <para>Unicode (UTF-32) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>12001 </para>
          </term>
          <description>
            <para>utf-32BE </para>
          </description>
          <description>
            <para>Unicode (UTF-32 Big endian) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>20000 </para>
          </term>
          <description>
            <para>x-Chinese-CNS </para>
          </description>
          <description>
            <para>Chinese Traditional (CNS) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20001 </para>
          </term>
          <description>
            <para>x-cp20001 </para>
          </description>
          <description>
            <para>TCA Taiwan </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20002 </para>
          </term>
          <description>
            <para>x-Chinese-Eten </para>
          </description>
          <description>
            <para>Chinese Traditional (Eten) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20003 </para>
          </term>
          <description>
            <para>x-cp20003 </para>
          </description>
          <description>
            <para>IBM5550 Taiwan </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20004 </para>
          </term>
          <description>
            <para>x-cp20004 </para>
          </description>
          <description>
            <para>TeleText Taiwan </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20005 </para>
          </term>
          <description>
            <para>x-cp20005 </para>
          </description>
          <description>
            <para>Wang Taiwan </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20105 </para>
          </term>
          <description>
            <para>x-IA5 </para>
          </description>
          <description>
            <para>Western European (IA5) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20106 </para>
          </term>
          <description>
            <para>x-IA5-German </para>
          </description>
          <description>
            <para>German (IA5) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20107 </para>
          </term>
          <description>
            <para>x-IA5-Swedish </para>
          </description>
          <description>
            <para>Swedish (IA5) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20108 </para>
          </term>
          <description>
            <para>x-IA5-Norwegian </para>
          </description>
          <description>
            <para>Norwegian (IA5) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20127 </para>
          </term>
          <description>
            <para>us-ascii </para>
          </description>
          <description>
            <para>US-ASCII </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>20261 </para>
          </term>
          <description>
            <para>x-cp20261 </para>
          </description>
          <description>
            <para>T.61 </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20269 </para>
          </term>
          <description>
            <para>x-cp20269 </para>
          </description>
          <description>
            <para>ISO-6937 </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20273 </para>
          </term>
          <description>
            <para>IBM273 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Germany) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20277 </para>
          </term>
          <description>
            <para>IBM277 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Denmark-Norway) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20278 </para>
          </term>
          <description>
            <para>IBM278 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Finland-Sweden) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20280 </para>
          </term>
          <description>
            <para>IBM280 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Italy) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20284 </para>
          </term>
          <description>
            <para>IBM284 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Spain) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20285 </para>
          </term>
          <description>
            <para>IBM285 </para>
          </description>
          <description>
            <para>IBM EBCDIC (UK) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20290 </para>
          </term>
          <description>
            <para>IBM290 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Japanese katakana) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20297 </para>
          </term>
          <description>
            <para>IBM297 </para>
          </description>
          <description>
            <para>IBM EBCDIC (France) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20420 </para>
          </term>
          <description>
            <para>IBM420 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Arabic) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20423 </para>
          </term>
          <description>
            <para>IBM423 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Greek) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20424 </para>
          </term>
          <description>
            <para>IBM424 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Hebrew) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20833 </para>
          </term>
          <description>
            <para>x-EBCDIC-KoreanExtended </para>
          </description>
          <description>
            <para>IBM EBCDIC (Korean Extended) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20838 </para>
          </term>
          <description>
            <para>IBM-Thai </para>
          </description>
          <description>
            <para>IBM EBCDIC (Thai) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20866 </para>
          </term>
          <description>
            <para>koi8-r </para>
          </description>
          <description>
            <para>Cyrillic (KOI8-R) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20871 </para>
          </term>
          <description>
            <para>IBM871 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Icelandic) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20880 </para>
          </term>
          <description>
            <para>IBM880 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Cyrillic Russian) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20905 </para>
          </term>
          <description>
            <para>IBM905 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Turkish) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20924 </para>
          </term>
          <description>
            <para>IBM00924 </para>
          </description>
          <description>
            <para>IBM Latin-1 </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20932 </para>
          </term>
          <description>
            <para>EUC-JP </para>
          </description>
          <description>
            <para>Japanese (JIS 0208-1990 and 0212-1990) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>20936 </para>
          </term>
          <description>
            <para>x-cp20936 </para>
          </description>
          <description>
            <para>Chinese Simplified (GB2312-80) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>20949 </para>
          </term>
          <description>
            <para>x-cp20949 </para>
          </description>
          <description>
            <para>Korean Wansung </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>21025 </para>
          </term>
          <description>
            <para>cp1025 </para>
          </description>
          <description>
            <para>IBM EBCDIC (Cyrillic Serbian-Bulgarian) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>21866 </para>
          </term>
          <description>
            <para>koi8-u </para>
          </description>
          <description>
            <para>Cyrillic (KOI8-U) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>28591 </para>
          </term>
          <description>
            <para>iso-8859-1 </para>
          </description>
          <description>
            <para>Western European (ISO) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>28592 </para>
          </term>
          <description>
            <para>iso-8859-2 </para>
          </description>
          <description>
            <para>Central European (ISO) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>28593 </para>
          </term>
          <description>
            <para>iso-8859-3 </para>
          </description>
          <description>
            <para>Latin 3 (ISO) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>28594 </para>
          </term>
          <description>
            <para>iso-8859-4 </para>
          </description>
          <description>
            <para>Baltic (ISO) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>28595 </para>
          </term>
          <description>
            <para>iso-8859-5 </para>
          </description>
          <description>
            <para>Cyrillic (ISO) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>28596 </para>
          </term>
          <description>
            <para>iso-8859-6 </para>
          </description>
          <description>
            <para>Arabic (ISO) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>28597 </para>
          </term>
          <description>
            <para>iso-8859-7 </para>
          </description>
          <description>
            <para>Greek (ISO) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>28598 </para>
          </term>
          <description>
            <para>iso-8859-8 </para>
          </description>
          <description>
            <para>Hebrew (ISO-Visual) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>28599 </para>
          </term>
          <description>
            <para>iso-8859-9 </para>
          </description>
          <description>
            <para>Turkish (ISO) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>28603 </para>
          </term>
          <description>
            <para>iso-8859-13 </para>
          </description>
          <description>
            <para>Estonian (ISO) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>28605 </para>
          </term>
          <description>
            <para>iso-8859-15 </para>
          </description>
          <description>
            <para>Latin 9 (ISO) </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>29001 </para>
          </term>
          <description>
            <para>x-Europa </para>
          </description>
          <description>
            <para>Europa </para>
          </description>
          <description>
            <para> </para>
          </description>
        </item>
        <item>
          <term>
            <para>38598 </para>
          </term>
          <description>
            <para>iso-8859-8-i </para>
          </description>
          <description>
            <para>Hebrew (ISO-Logical) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>50220 </para>
          </term>
          <description>
            <para>iso-2022-jp </para>
          </description>
          <description>
            <para>Japanese (JIS) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>50221 </para>
          </term>
          <description>
            <para>csISO2022JP </para>
          </description>
          <description>
            <para>Japanese (JIS-Allow 1 byte Kana) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>50222 </para>
          </term>
          <description>
            <para>iso-2022-jp </para>
          </description>
          <description>
            <para>Japanese (JIS-Allow 1 byte Kana - SO/SI) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>50225 </para>
          </term>
          <description>
            <para>iso-2022-kr </para>
          </description>
          <description>
            <para>Korean (ISO) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>50227 </para>
          </term>
          <description>
            <para>x-cp50227 </para>
          </description>
          <description>
            <para>Chinese Simplified (ISO-2022) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>51932 </para>
          </term>
          <description>
            <para>euc-jp </para>
          </description>
          <description>
            <para>Japanese (EUC) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>51936 </para>
          </term>
          <description>
            <para>EUC-CN </para>
          </description>
          <description>
            <para>Chinese Simplified (EUC) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>51949 </para>
          </term>
          <description>
            <para>euc-kr </para>
          </description>
          <description>
            <para>Korean (EUC) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>52936 </para>
          </term>
          <description>
            <para>hz-gb-2312 </para>
          </description>
          <description>
            <para>Chinese Simplified (HZ) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>54936 </para>
          </term>
          <description>
            <para>GB18030 </para>
          </description>
          <description>
            <para>Chinese Simplified (GB18030) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>57002 </para>
          </term>
          <description>
            <para>x-iscii-de </para>
          </description>
          <description>
            <para>ISCII Devanagari </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>57003 </para>
          </term>
          <description>
            <para>x-iscii-be </para>
          </description>
          <description>
            <para>ISCII Bengali </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>57004 </para>
          </term>
          <description>
            <para>x-iscii-ta </para>
          </description>
          <description>
            <para>ISCII Tamil </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>57005 </para>
          </term>
          <description>
            <para>x-iscii-te </para>
          </description>
          <description>
            <para>ISCII Telugu </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>57006 </para>
          </term>
          <description>
            <para>x-iscii-as </para>
          </description>
          <description>
            <para>ISCII Assamese </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>57007 </para>
          </term>
          <description>
            <para>x-iscii-or </para>
          </description>
          <description>
            <para>ISCII Oriya </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>57008 </para>
          </term>
          <description>
            <para>x-iscii-ka </para>
          </description>
          <description>
            <para>ISCII Kannada </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>57009 </para>
          </term>
          <description>
            <para>x-iscii-ma </para>
          </description>
          <description>
            <para>ISCII Malayalam </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>57010 </para>
          </term>
          <description>
            <para>x-iscii-gu </para>
          </description>
          <description>
            <para>ISCII Gujarati </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>57011 </para>
          </term>
          <description>
            <para>x-iscii-pa </para>
          </description>
          <description>
            <para>ISCII Punjabi </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>65000 </para>
          </term>
          <description>
            <para>utf-7 </para>
          </description>
          <description>
            <para>Unicode (UTF-7) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
        <item>
          <term>
            <para>65001 </para>
          </term>
          <description>
            <para>utf-8 </para>
          </description>
          <description>
            <para>Unicode (UTF-8) </para>
          </description>
          <description>
            <para>* </para>
          </description>
        </item>
      </list>
      <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, your application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> method or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
      <para>The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first). For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal): </para>
      <list type="bullet">
        <item>
          <para>UTF-16 big endian byte order: 00 41 </para>
        </item>
        <item>
          <para>UTF-16 little endian byte order: 41 00 </para>
        </item>
        <item>
          <para>UTF-32 big endian byte order: 00 00 00 41 </para>
        </item>
        <item>
          <para>UTF-32 little endian byte order: 41 00 00 00 </para>
        </item>
      </list>
      <para>It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</para>
      <para>The <see cref="M:System.Text.Encoding.GetPreamble" /> method retrieves an array of bytes that includes the byte order mark (BOM). If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</para>
      <para>For more information on byte order and the byte order mark, see The Unicode Standard at the <see cref="http://go.microsoft.com/fwlink/?LinkId=37123">Unicode home page</see>.</para>
      <para>Note that the encoding classes allow errors to:</para>
      <list type="bullet">
        <item>
          <para>Silently change to a "?" character. </para>
        </item>
        <item>
          <para>Use a "best fit" character.</para>
        </item>
        <item>
          <para>Change to an application-specific behavior through use of the <see cref="T:System.Text.EncoderFallback" /> and <see cref="T:System.Text.DecoderFallback" /> classes with the U+FFFD Unicode replacement character. </para>
        </item>
      </list>
      <para>Your applications are recommended to throw exceptions on all data stream errors. An application either uses a "throwonerror" flag when applicable or uses the <see cref="T:System.Text.EncoderExceptionFallback" /> and <see cref="T:System.Text.DecoderExceptionFallback" /> classes. Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements. For ANSI encodings, the best fit behavior is the default.</para>
    </remarks>
    <summary>
      <attribution license="cc4" from="Microsoft" modified="false" />
      <para>Represents a character encoding.</para>
    </summary>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="ILASM" Value="family rtspecialname specialname instance void .ctor()" />
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue />
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Derived classes override this constructor.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Derived classes override this constructor.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page.</para>
        </summary>
        <param name="codePage">
          <attribution license="cc4" from="Microsoft" modified="false" />The code page identifier of the preferred encoding.</param>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="ILASM" Value=".property class System.Text.Encoding ASCII { public hidebysig static specialname class System.Text.Encoding get_ASCII() }" />
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</para>
          <para>When selecting the ASCII encoding for your applications, consider the following:</para>
          <list type="bullet">
            <item>
              <para>The ASCII encoding is usually appropriate for protocols that require ASCII. </para>
            </item>
            <item>
              <para>If your application requires 8-bit encoding (which is sometimes incorrectly referred to as "ASCII"), the UTF-8 encoding is recommended over the ASCII encoding. For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable. Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</para>
            </item>
            <item>
              <para>Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit. Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</para>
            </item>
          </list>
          <para>The <see cref="T:System.Text.ASCIIEncoding" /> object that is returned by this property might not have the appropriate behavior for your application. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character. Instead, you can call the <see cref="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" /> method to instantiate an <see cref="T:System.Text.ASCIIEncoding" /> object whose fallback is either an <see cref="T:System.Text.EncoderFallbackException" /> or a <see cref="T:System.Text.DecoderFallbackException" />, as the following example illustrates. </para>
          <para>code reference: System.Text.Encoding.ASCII#1</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an encoding for the ASCII (7-bit) character set.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="ILASM" Value=".property class System.Text.Encoding BigEndianUnicode { public hidebysig static specialname class System.Text.Encoding get_BigEndianUnicode() }" />
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Text.Encoding" /> for the Unicode format in big-endian byte order. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Text.UnicodeEncoding" /> object that is returned by this property may not have the appropriate behavior for your application. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character. Instead, you can call the <see cref="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" /> constructor to instantiate a big endian <see cref="T:System.Text.UnicodeEncoding" /> object whose fallback is either an <see cref="T:System.Text.EncoderFallbackException" /> or a <see cref="T:System.Text.DecoderFallbackException" />, as the following example illustrates.</para>
          <para>code reference: System.Text.Encoding.BigEndianUnicode#2</para>
          <para>The returned <see cref="T:System.Text.UnicodeEncoding" /> object has <see cref="P:System.Text.Encoding.BodyName" />, <see cref="P:System.Text.Encoding.HeaderName" />, and <see cref="P:System.Text.Encoding.WebName" /> properties, which yield the name "unicodeFFFE". Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name "unicodeFFFE" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an encoding for the UTF-16 format that uses the big endian byte order.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If your application needs an encoding for a body name, it should call <see cref="M:System.Text.Encoding.GetEncoding(System.String)" /> with the <see cref="P:System.Text.Encoding.BodyName" /> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e-mail applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <see cref="P:System.Text.Encoding.WebName" />.</para>
          <para>In some cases, the value of the <see cref="P:System.Text.Encoding.BodyName" /> property corresponds to the international standard that defines that encoding. This does not imply that the actual implementation complies in full with that standard. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The clone is writable even if the original <see cref="T:System.Text.Encoding" /> object is read-only. Therefore, the properties of the clone can be modified.</para>
          <para>A shallow copy of an object is a copy of the object only. If the object contains references to other objects, the shallow copy does not create copies of the referred objects. It refers to the original objects instead. In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, creates a shallow copy of the current <see cref="T:System.Text.Encoding" /> object.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A copy of the current <see cref="T:System.Text.Encoding" /> object.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets the code page identifier of the current <see cref="T:System.Text.Encoding" />.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Byte[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, class System.Byte[] bytes)" />
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" />, <paramref name="dstEncoding" /> or <paramref name="bytes" /> is <see langword="null" />. </exception>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts an entire byte array from one encoding to another.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of type <see cref="T:System.Byte" /> containing the results of converting <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</para>
        </returns>
        <param name="srcEncoding">
          <attribution license="cc4" from="Microsoft" modified="false" />The encoding format of <paramref name="bytes" />. </param>
        <param name="dstEncoding">
          <attribution license="cc4" from="Microsoft" modified="false" />The target encoding format. </param>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The bytes to convert. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="ILASM" Value=".method public hidebysig static class System.Byte[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, class System.Byte[] bytes, int32 index, int32 count)" />
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="srcEncoding" />, <paramref name="dstEncoding " />, or <paramref name="bytes" /> is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" /> . </exception>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Converts a range of bytes in a byte array from one encoding to another.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array of type <see cref="T:System.Byte" /> containing the result of converting a range of bytes in <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</para>
        </returns>
        <param name="srcEncoding">
          <attribution license="cc4" from="Microsoft" modified="false" />The encoding of the source array, <paramref name="bytes" />. </param>
        <param name="dstEncoding">
          <attribution license="cc4" from="Microsoft" modified="false" />The encoding of the output array. </param>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The array of bytes to convert. </param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first element of <paramref name="bytes" /> to convert. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to convert. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Text.DecoderFallback" /> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character. Any one of the following handler types is supported:</para>
          <list type="bullet">
            <item>
              <para>A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</para>
            </item>
            <item>
              <para>A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <see cref="T:System.Text.DecoderFallback" />, which by default replaces bytes that cannot be decoded with a question mark ("?") character.</para>
            </item>
            <item>
              <para>An exception fallback handler, which throws an exception when bytes cannot be decoded. The .NET Framework includes one exception fallback handler, <see cref="T:System.Text.DecoderExceptionFallback" />, which throws a <see cref="T:System.Text.DecoderFallbackException" /> when bytes cannot be decoded. </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the <see cref="T:System.Text.DecoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="ILASM" Value=".property class System.Text.Encoding Default { public hidebysig static specialname class System.Text.Encoding get_Default() }" />
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Text.Encoding" /> for the ANSI code page of the current system.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>Different computers can use different encodings as the default, and the default encoding can even change on a single computer. Therefore, data streamed from one computer to another or even retrieved at different times on the same computer might be translated incorrectly. In addition, the encoding returned by the <see cref="P:System.Text.Encoding.Default" /> property uses best-fit fallback to map unsupported characters to characters supported by the code page. For these two reasons, using the default encoding is generally not recommended. To ensure that encoded bytes are decoded properly, your application should use a Unicode encoding, such as <see cref="T:System.Text.UTF8Encoding" /> or <see cref="T:System.Text.UnicodeEncoding" />, with a preamble. Another option is to use a higher-level protocol to ensure that the same format is used for encoding and decoding.</para>
          </block>
          <para>The system ANSI code page defined by <see cref="P:System.Text.Encoding.Default" /> covers the ASCII set of characters, but the encoding is different from the encoding for ASCII. Because all <see cref="P:System.Text.Encoding.Default" /> encodings lose data, your application might use <see cref="P:System.Text.Encoding.UTF8" /> instead. UTF-8 is often identical in the U+00 to U+7F range, but can encode other characters without loss. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an encoding for the operating system's current ANSI code page.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Text.EncoderFallback" /> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence. Any one of the following handler types is supported:</para>
          <list type="bullet">
            <item>
              <para>A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</para>
            </item>
            <item>
              <para>A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <see cref="T:System.Text.EncoderFallback" />, which by default replaces characters that cannot be encoded with a question mark ("?") character.</para>
            </item>
            <item>
              <para>An exception fallback handler, which throws an exception when characters cannot be encoded. The .NET Framework includes one exception fallback handler, <see cref="T:System.Text.EncoderExceptionFallback" />, which throws an <see cref="T:System.Text.EncoderFallbackException" /> when characters cannot be decoded. </para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets or sets the <see cref="T:System.Text.EncoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Text.Encoding.EncodingName" /> property is intended for display. To find a name that can be passed to the <see cref="M:System.Text.Encoding.GetEncoding(System.String)" /> method, use the <see cref="P:System.Text.Encoding.WebName" /> property.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets the human-readable description of the current encoding.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual bool Equals(object value)" />
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Two instances of <see cref="T:System.Text.Encoding" /> are considered equal if they correspond to the same code page and their EncoderFallback and DecoderFallback objects are equal. In particular, derived code pages all have a code page of 0 and their fallbacks are normally null (Nothing in Visual Basic .NET). Thus they are all considered equal to one another. One consequence is that when <see cref="M:System.Text.Encoding.Equals(System.Object)" /> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Determines whether the specified <see cref="T:System.Object" /> is equal to the current instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if <paramref name="value" /> is an instance of <see cref="T:System.Text.Encoding" /> and is equal to the current instance; otherwise, false. </para>
        </returns>
        <param name="value">
          <attribution license="cc4" from="Microsoft" modified="false" />The <see cref="T:System.Object" /> to compare with the current instance. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetByteCount(class System.Char[] chars)" />
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars " />is <see langword="null" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size required by <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> to store the resulting bytes, the application should use <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> method generally executes faster.</para>
          <para>The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method determines how many bytes result in encoding a set of Unicode characters, and the <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method performs the actual encoding. The <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method, which handles multiple conversions on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to encode many input characters to a code page and process the characters using multiple calls. In this case, your application probably needs to maintain state between calls, taking into account the state that is persisted by the <see cref="T:System.Text.Encoder" /> object being used.</para>
            </item>
            <item>
              <para>If the application handles string inputs, it is recommended to use the string version of <see cref="M:System.Text.Encoding.GetBytes(System.String)" />. </para>
            </item>
            <item>
              <para>The Unicode character buffer version of <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> allows some fast techniques, particularly with multiple calls using the <see cref="T:System.Text.Encoder" /> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" /> version that supports byte arrays is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Encoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes produced by encoding all the characters in the specified character array.</para>
        </returns>
        <param name="chars">
          <attribution license="cc4" from="Microsoft" modified="false" />The character array containing the characters to encode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetByteCount(string s)" />
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s " /> is <see langword="null" />.</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size required by <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> to store the resulting bytes, the application should use <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> method generally executes faster.</para>
          <para>The <see cref="M:System.Text.Encoding.GetByteCount(System.String)" /> method determines how many bytes result in encoding a set of Unicode characters, and the <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> method performs the actual encoding. The <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method, which handles multiple conversions on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetByteCount(System.String)" /> and <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to encode many input characters to a code page and process the characters using multiple calls. In this case, your application probably needs to maintain state between calls, taking into account the state that is persisted by the <see cref="T:System.Text.Encoder" /> object being used.</para>
            </item>
            <item>
              <para>If the application handles string inputs, the string version of <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> is recommended. </para>
            </item>
            <item>
              <para>The Unicode character buffer version of <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> allows some fast techniques, particularly with multiple calls using the <see cref="T:System.Text.Encoder" /> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" /> version that supports byte arrays is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Encoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetByteCount(System.String)" />. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes produced by encoding the specified characters.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the set of characters to encode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size that <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> requires to store the resulting bytes, the application should use <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> method generally executes faster.</para>
          <para>The <see cref="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" /> method determines how many bytes result in encoding a set of Unicode characters, and the <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> method performs the actual encoding. The <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method, which handles multiple conversions on a single input stream.</para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to encode many input characters to a code page and process the characters using multiple calls. In this case, your application probably needs to maintain state between calls, taking into account the state that is persisted by the <see cref="T:System.Text.Encoder" /> object being used.</para>
            </item>
            <item>
              <para>If the application handles string inputs, it is recommended to use the string version of <see cref="M:System.Text.Encoding.GetBytes(System.String)" />.</para>
            </item>
            <item>
              <para>The Unicode character buffer version of <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> allows some fast techniques, particularly with multiple calls using the <see cref="T:System.Text.Encoder" /> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> version that supports byte arrays is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Encoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes produced by encoding the specified characters.</para>
        </returns>
        <param name="chars">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the first character to encode. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters to encode. </param>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract int32 GetByteCount(class System.Char[] chars, int32 index, int32 count)" />
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars " />is <see langword="null" /> . </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>The number of bytes required to encode the specified elements in <paramref name="chars" /> is greater than <see cref="F:System.Int32.MaxValue" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="index" /> or <paramref name="count" /> is less than zero. </para>
          <para> -or- </para>
          <para>
            <paramref name="index" /> and <paramref name="count" /> do not specify a valid range in <paramref name="chars" /> (i.e. (<paramref name="index" /> + <paramref name="count" />) &gt; <paramref name="chars" />.Length).</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size required by <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> to store the resulting bytes, the application should use <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> method generally executes faster.</para>
          <para>The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method determines how many bytes result in encoding a set of Unicode characters, and the <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method performs the actual encoding. The <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method, which handles multiple conversions on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to encode many input characters to a code page and process the characters using multiple calls. In this case, your application probably needs to maintain state between calls, taking into account the state that is persisted by the <see cref="T:System.Text.Encoder" /> object being used.</para>
            </item>
            <item>
              <para>If the application handles string inputs, the string version of <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> is recommended.</para>
            </item>
            <item>
              <para>The Unicode character buffer version of <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> allows some fast techniques, particularly with multiple calls using the <see cref="T:System.Text.Encoder" /> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" /> version that supports byte arrays is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Encoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of bytes produced by encoding the specified characters.</para>
        </returns>
        <param name="chars">
          <attribution license="cc4" from="Microsoft" modified="false" />The character array containing the set of characters to encode. </param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first character to encode. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters to encode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Byte[] GetBytes(class System.Char[] chars)" />
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> method or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method determines how many bytes result in encoding a set of Unicode characters, and the <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method performs the actual encoding. The <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method, which handles multiple conversions on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to encode many input characters to a code page and process the characters using multiple calls. In this case, your application probably needs to maintain state between calls, taking into account the state that is persisted by the <see cref="T:System.Text.Encoder" /> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <see cref="T:System.Text.Encoder" /> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <see cref="T:System.Text.Encoding" /> won't be able to maintain the state, so the character will be sent to the <see cref="T:System.Text.EncoderFallback" />.)</para>
            </item>
            <item>
              <para>If the application handles string inputs, it is recommended to use the string version of <see cref="M:System.Text.Encoding.GetBytes(System.String)" />.</para>
            </item>
            <item>
              <para>The Unicode character buffer version of <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> allows some fast techniques, particularly with multiple calls using the <see cref="T:System.Text.Encoder" /> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" /> version that supports byte arrays is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Encoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A byte array containing the results of encoding the specified set of characters.</para>
        </returns>
        <param name="chars">
          <attribution license="cc4" from="Microsoft" modified="false" />The character array containing the characters to encode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Byte[] GetBytes(string s)" />
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> method or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>The <see cref="M:System.Text.Encoding.GetByteCount(System.String)" /> method determines how many bytes result in encoding a set of Unicode characters, and the <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> method performs the actual encoding. The <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method, which handles multiple conversions on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetByteCount(System.String)" /> and <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to encode many input characters to a code page and process the characters using multiple calls. In this case, your application probably needs to maintain state between calls, taking into account the state that is persisted by the <see cref="T:System.Text.Encoder" /> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <see cref="T:System.Text.Encoder" /> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <see cref="T:System.Text.Encoding" /> won't be able to maintain the state, so the character will be sent to the <see cref="T:System.Text.EncoderFallback" />.)</para>
            </item>
            <item>
              <para>If the application handles string inputs, it is recommended to use the string version of <see cref="M:System.Text.Encoding.GetBytes(System.String)" />. </para>
            </item>
            <item>
              <para>The Unicode character buffer version of <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> allows some fast techniques, particularly with multiple calls using the <see cref="T:System.Text.Encoder" /> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> version that supports byte arrays is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Encoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetByteCount(System.String)" />. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A byte array containing the results of encoding the specified set of characters.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the characters to encode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Byte[] GetBytes(class System.Char[] chars, int32 index, int32 count)" />
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> method or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method determines how many bytes result in encoding a set of Unicode characters, and the <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method performs the actual encoding. The <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method, which handles multiple conversions on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to encode many input characters to a code page and process the characters using multiple calls. In this case, your application probably needs to maintain state between calls, taking into account the state that is persisted by the <see cref="T:System.Text.Encoder" /> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <see cref="T:System.Text.Encoder" /> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <see cref="T:System.Text.Encoding" /> won't be able to maintain the state, so the character will be sent to the <see cref="T:System.Text.EncoderFallback" />.)</para>
            </item>
            <item>
              <para>If the application handles string inputs, it is recommended to use the string version of <see cref="M:System.Text.Encoding.GetBytes(System.String)" />.</para>
            </item>
            <item>
              <para>The Unicode character buffer version of <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> allows some fast techniques, particularly with multiple calls using the <see cref="T:System.Text.Encoder" /> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> version that supports byte arrays is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Encoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A byte array containing the results of encoding the specified set of characters.</para>
        </returns>
        <param name="chars">
          <attribution license="cc4" from="Microsoft" modified="false" />The character array containing the set of characters to encode. </param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first character to encode. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters to encode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size that <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> requires to store the resulting bytes, the application should use <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> method generally executes faster.</para>
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> object provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method determines how many bytes result in encoding a set of Unicode characters, and the <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> method performs the actual encoding. The <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method, which handles multiple conversions on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to encode many input characters to a code page and process the characters using multiple calls. In this case, your application probably needs to maintain state between calls, taking into account the state that is persisted by the <see cref="T:System.Text.Encoder" /> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <see cref="T:System.Text.Encoder" /> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <see cref="T:System.Text.Encoding" /> won't be able to maintain the state, so the character will be sent to the <see cref="T:System.Text.EncoderFallback" />.)</para>
            </item>
            <item>
              <para>If the application handles string inputs, it is recommended to use the string version of <see cref="M:System.Text.Encoding.GetBytes(System.String)" />. </para>
            </item>
            <item>
              <para>The Unicode character buffer version of <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> allows some fast techniques, particularly with multiple calls using the <see cref="T:System.Text.Encoder" /> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> version that supports byte arrays is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Encoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</para>
        </returns>
        <param name="chars">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the first character to encode. </param>
        <param name="charCount">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters to encode. </param>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the location at which to start writing the resulting sequence of bytes. </param>
        <param name="byteCount">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of bytes to write. </param>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract int32 GetBytes(class System.Char[] chars, int32 charIndex, int32 charCount, class System.Byte[] bytes, int32 byteIndex)" />
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="bytes" /> does not contain sufficient space to store the encoded characters.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="chars " />is <see langword="null" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="bytes " />is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="charIndex" /> &lt; 0. </para>
          <para> -or- </para>
          <para>
            <paramref name="charCount " /> &lt; 0. </para>
          <para> -or- </para>
          <para>
            <paramref name="byteIndex " /> &lt; 0. </para>
          <para> -or- </para>
          <para>(<paramref name="chars" />.Length - <paramref name="charIndex" />) &lt; <paramref name="charCount" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="byteIndex" /> &gt; <paramref name="bytes" />.Length.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size required by <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> to store the resulting bytes, the application should use <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> method generally executes faster.</para>
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> method or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method determines how many bytes result in encoding a set of Unicode characters, and the <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method performs the actual encoding. The <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method, which handles multiple conversions on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to encode many input characters to a code page and process the characters using multiple calls. In this case, your application probably needs to maintain state between calls, taking into account the state that is persisted by the <see cref="T:System.Text.Encoder" /> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <see cref="T:System.Text.Encoder" /> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <see cref="T:System.Text.Encoding" /> won't be able to maintain the state, so the character will be sent to the <see cref="T:System.Text.EncoderFallback" />.)</para>
            </item>
            <item>
              <para>If the application handles string inputs, it is recommended to use the string version of <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" />. </para>
            </item>
            <item>
              <para>The Unicode character buffer version of <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> allows some fast techniques, particularly with multiple calls using the <see cref="T:System.Text.Encoder" /> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" /> version that supports byte arrays is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Encoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The actual number of bytes written into <paramref name="bytes" />.</para>
        </returns>
        <param name="chars">
          <attribution license="cc4" from="Microsoft" modified="false" />The character array containing the set of characters to encode. </param>
        <param name="charIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first character to encode. </param>
        <param name="charCount">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters to encode. </param>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte array to contain the resulting sequence of bytes. </param>
        <param name="byteIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The index at which to start writing the resulting sequence of bytes. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetBytes(string s, int32 charIndex, int32 charCount, class System.Byte[] bytes, int32 byteIndex)" />
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="bytes" /> does not contain sufficient space to store the encoded characters.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="s " />is <see langword="null" />. </para>
          <para>-or- </para>
          <para>
            <paramref name="bytes " />is <see langword="null" />. </para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="charIndex" /> &lt; 0. </para>
          <para> -or- </para>
          <para>
            <paramref name="charCount " /> &lt; 0. </para>
          <para> -or- </para>
          <para>
            <paramref name="byteIndex " /> &lt; 0. </para>
          <para> -or- </para>
          <para>(<paramref name="s" />.Length - <paramref name="charIndex" />) &lt; <paramref name="charCount" />.</para>
          <para>-or-</para>
          <para>
            <paramref name="byteIndex" /> &gt;= <paramref name="bytes" />.Length.</para>
        </exception>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the set of characters to encode. </param>
        <param name="charIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first character to encode. </param>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte array to contain the resulting sequence of bytes. </param>
        <param name="byteIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The index at which to start writing the resulting sequence of bytes. </param>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size required by <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> to store the resulting bytes, the application should use <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> method generally executes faster.</para>
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> method or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>The <see cref="M:System.Text.Encoding.GetByteCount(System.String)" /> method determines how many bytes result in encoding a set of Unicode characters, and the <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> method performs the actual encoding. The <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method, which handles multiple conversions on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetByteCount(System.String)" /> and <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to encode many input characters to a code page and process the characters using multiple calls. In this case, your application probably needs to maintain state between calls, taking into account the state that is persisted by the <see cref="T:System.Text.Encoder" /> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <see cref="T:System.Text.Encoder" /> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <see cref="T:System.Text.Encoding" /> won't be able to maintain the state, so the character will be sent to the <see cref="T:System.Text.EncoderFallback" />.)</para>
            </item>
            <item>
              <para>If the application handles string inputs, it is recommended to use the string version of <see cref="M:System.Text.Encoding.GetBytes(System.String)" />. </para>
            </item>
            <item>
              <para>The Unicode character buffer version of <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" /> allows some fast techniques, particularly with multiple calls using the <see cref="T:System.Text.Encoder" /> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> version that supports byte arrays is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Encoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetByteCount(System.String)" />. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The actual number of bytes written into <paramref name="bytes" />.</para>
        </returns>
        <param name="s">
          <attribution license="cc4" from="Microsoft" modified="false" />The string containing the set of characters to encode. </param>
        <param name="charIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first character to encode. </param>
        <param name="charCount">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters to encode. </param>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte array to contain the resulting sequence of bytes. </param>
        <param name="byteIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The index at which to start writing the resulting sequence of bytes. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetCharCount(class System.Byte[] bytes)" />
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size required by <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> to store the resulting characters, the application should use <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" /> method generally executes faster.</para>
          <para>The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method determines how many characters result in decoding a sequence of bytes, and the  <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method performs the actual decoding. The <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> method, which handles multiple passes on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, your application probably needs to maintain state between calls.</para>
            </item>
            <item>
              <para>If the application handles string outputs, it is recommended to use the <see cref="M:System.Text.Encoding.GetString(System.Byte[])" /> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <see cref="T:System.String" /> type is to be preferred.</para>
            </item>
            <item>
              <para>The byte version of <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> version that supports output character buffers is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Decoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of characters produced by decoding the specified sequence of bytes.</para>
        </returns>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte array containing the sequence of bytes to decode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size that <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> requires to store the resulting characters, the application should use <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" /> method generally executes faster.</para>
          <para>The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method determines how many characters result in decoding a sequence of bytes, and the <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method performs the actual decoding. The <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> method, which handles multiple passes on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, your application probably needs to maintain state between calls.</para>
            </item>
            <item>
              <para>If the application handles string outputs, it is recommended to use the <see cref="M:System.Text.Encoding.GetString(System.Byte[])" /> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <see cref="T:System.String" /> type is to be preferred.</para>
            </item>
            <item>
              <para>The byte version of <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> version that supports output character buffers is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Decoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of characters produced by decoding the specified sequence of bytes.</para>
        </returns>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the first byte to decode. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to decode. </param>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract int32 GetCharCount(class System.Byte[] bytes, int32 index, int32 count)" />
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index " />and <paramref name="count " />do not specify a valid range in <paramref name="bytes" /> (i.e. (<paramref name="index" /> + <paramref name="count" />) &gt; <paramref name="bytes" />.Length).</exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size required by <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> to store the resulting characters, the application should use <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" /> method generally executes faster.</para>
          <para>The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method determines how many characters result in decoding a sequence of bytes, and the <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method performs the actual decoding. The <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> method, which handles multiple passes on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, your application probably needs to maintain state between calls.</para>
            </item>
            <item>
              <para>If the application handles string outputs, it is recommended to use the <see cref="M:System.Text.Encoding.GetString(System.Byte[])" /> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <see cref="T:System.String" /> type is to be preferred.</para>
            </item>
            <item>
              <para>The byte version of <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> version that supports output character buffers is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Decoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The number of characters produced by decoding the specified sequence of bytes.</para>
        </returns>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte array containing the sequence of bytes to decode. </param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first byte to decode. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to decode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Char[] GetChars(class System.Byte[] bytes)" />
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> gets characters from an input byte sequence. <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> is different than <see cref="Overload:System.Text.Decoder.GetChars" /> because <see cref="T:System.Text.Encoding" /> expects discrete conversions, while <see cref="T:System.Text.Decoder" /> is designed for multiple passes on a single input stream.</para>
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> method or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>Note   This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If your application needs to encode arbitrary binary data into text, it should use a protocol such as uuencode, which is implemented by methods such as <see cref="M:System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />.</para>
          <para>The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method determines how many characters result in decoding a sequence of bytes, and the <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method performs the actual decoding. The <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> method, which handles multiple passes on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, your application probably needs to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> call and continue at the beginning of the next <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> call. <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> will call the fallback for those incomplete sequences, but <see cref="T:System.Text.Decoder" /> will remember those sequences for the next call.)</para>
            </item>
            <item>
              <para>If the application handles string outputs, it is recommended to use the <see cref="M:System.Text.Encoding.GetString(System.Byte[])" /> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <see cref="T:System.String" /> type is to be preferred.</para>
            </item>
            <item>
              <para>The byte version of <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> version that supports output character buffers is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Decoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A character array containing the results of decoding the specified sequence of bytes.</para>
        </returns>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte array containing the sequence of bytes to decode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Char[] GetChars(class System.Byte[] bytes, int32 index, int32 count)" />
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes " />is <see langword="null" /> . </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index " />and <paramref name="count " />do not denote a valid range in the byte array. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>
            <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" /> gets characters from an input byte sequence. <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" /> is different than <see cref="Overload:System.Text.Decoder.GetChars" /> because <see cref="T:System.Text.Encoding" /> expects discrete conversions, while <see cref="T:System.Text.Decoder" /> is designed for multiple passes on a single input stream.</para>
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> method or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>Note   This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If your application needs to encode arbitrary binary data into text, it should use a protocol such as uuencode, which is implemented by methods such as <see cref="M:System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />.</para>
          <para>The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method determines how many characters result in decoding a sequence of bytes, and the <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method performs the actual decoding. The <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> method, which handles multiple passes on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, your application probably needs to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" /> call and continue at the beginning of the next <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" /> call. <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" /> will call the fallback for those incomplete sequences, but <see cref="T:System.Text.Decoder" /> will remember those sequences for the next call.)</para>
            </item>
            <item>
              <para>If the application handles string outputs, it is recommended to use the <see cref="M:System.Text.Encoding.GetString(System.Byte[])" /> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <see cref="T:System.String" /> type is to be preferred.</para>
            </item>
            <item>
              <para>The byte version of <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> version that supports output character buffers is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Decoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A character array containing the results of decoding the specified sequence of bytes.</para>
        </returns>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte array containing the sequence of bytes to decode. </param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first byte to decode. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to decode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size that <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> requires to store the resulting characters, the application should use <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" /> method generally executes faster.</para>
          <para>
            <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> gets characters from an input byte sequence. <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> is different than <see cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> because <see cref="T:System.Text.Encoding" /> expects discrete conversions, while <see cref="T:System.Text.Decoder" /> is designed for multiple passes on a single input stream.</para>
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> object provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>Note   This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If your application needs to encode arbitrary binary data into text, it should use a protocol such as uuencode, which is implemented by methods such as <see cref="M:System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />.</para>
          <para>The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method determines how many characters result in decoding a sequence of bytes, and the <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method performs the actual decoding. The <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> method, which handles multiple passes on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, your application probably needs to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> call and continue at the beginning of the next <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> call. <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> will call the fallback for those incomplete sequences, but <see cref="T:System.Text.Decoder" /> will remember those sequences for the next call.)</para>
            </item>
            <item>
              <para>If the application handles string outputs, the <see cref="M:System.Text.Encoding.GetString(System.Byte[])" /> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <see cref="T:System.String" /> type is to be preferred.</para>
            </item>
            <item>
              <para>The byte version of <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> version that supports output character buffers is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Decoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</para>
        </returns>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the first byte to decode. </param>
        <param name="byteCount">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to decode. </param>
        <param name="chars">
          <attribution license="cc4" from="Microsoft" modified="false" />A pointer to the location at which to start writing the resulting set of characters. </param>
        <param name="charCount">
          <attribution license="cc4" from="Microsoft" modified="false" />The maximum number of characters to write. </param>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract int32 GetChars(class System.Byte[] bytes, int32 byteIndex, int32 byteCount, class System.Char[] chars, int32 charIndex)" />
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="chars" /> does not contain sufficient space to store the decoded characters.</para>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="bytes " />is <see langword="null" /> . </para>
          <para>-or- </para>
          <para>
            <paramref name="chars " />is <see langword="null" /> . </para>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <para>
            <paramref name="byteIndex" /> &lt; 0. </para>
          <para> -or- </para>
          <para>
            <paramref name="byteCount " /> &lt; 0. </para>
          <para> -or- </para>
          <para>
            <paramref name="charIndex " /> &lt; 0. </para>
          <para> -or- </para>
          <para>
            <paramref name="byteIndex" /> and <paramref name="byteCount" /> do not specify a valid range in <paramref name="bytes" /> (i.e. (<paramref name="byteIndex " />+ <paramref name="byteCount " /> ) &gt; <paramref name="bytes" />.Length). </para>
          <para>-or- </para>
          <para>
            <paramref name="charIndex" /> &gt; <paramref name="chars" />.Length.</para>
        </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size required by <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> to store the resulting characters, the application should use <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. To calculate the maximum array size, the application should use <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" /> method generally executes faster.</para>
          <para>
            <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> gets characters from an input byte sequence. <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> is different than <see cref="Overload:System.Text.Decoder.GetChars" /> because <see cref="T:System.Text.Encoding" /> expects discrete conversions, while <see cref="T:System.Text.Decoder" /> is designed for multiple passes on a single input stream.</para>
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> method or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>Note    This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If your application needs to encode arbitrary binary data into text, it should use a protocol such as uuencode, which is implemented by methods such as <see cref="M:System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />.</para>
          <para>The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method determines how many characters result in decoding a sequence of bytes, and the <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method performs the actual decoding. The <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method expects discrete conversions, in contrast to the <see cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> method, which handles multiple passes on a single input stream. </para>
          <para>Several versions of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> are supported. The following are some programming considerations for use of these methods:</para>
          <list type="bullet">
            <item>
              <para>The application might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, your application probably needs to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> call and continue at the beginning of the next <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> call. <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> will call the fallback for those incomplete sequences, but <see cref="T:System.Text.Decoder" /> will remember those sequences for the next call.)</para>
            </item>
            <item>
              <para>If the application handles string outputs, the <see cref="M:System.Text.Encoding.GetString(System.Byte[])" /> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <see cref="T:System.String" /> type is to be preferred.</para>
            </item>
            <item>
              <para>The byte version of <see cref="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" /> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</para>
            </item>
            <item>
              <para>If your application must convert a large amount of data, it should reuse the output buffer. In this case, the <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> version that supports output character buffers is the best choice. </para>
            </item>
            <item>
              <para>Consider using the <see cref="Overload:System.Text.Decoder.Convert" /> method instead of <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</para>
            </item>
          </list>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The actual number of characters written into <paramref name="chars" />.</para>
        </returns>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte array containing the sequence of bytes to decode. </param>
        <param name="byteIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first byte to decode. </param>
        <param name="byteCount">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to decode. </param>
        <param name="chars">
          <attribution license="cc4" from="Microsoft" modified="false" />The character array to contain the resulting set of characters. </param>
        <param name="charIndex">
          <attribution license="cc4" from="Microsoft" modified="false" />The index at which to start writing the resulting set of characters. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Text.Decoder GetDecoder()" />
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" /> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> method of this class. However, a <see cref="T:System.Text.Decoder" /> maintains state information between calls so it correctly decodes byte sequences that span blocks. The <see cref="T:System.Text.Decoder" /> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation. Therefore, <see cref="M:System.Text.Encoding.GetDecoder" /> and <see cref="M:System.Text.Encoding.GetEncoder" /> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Text.Decoder" /> that converts an encoded sequence of bytes into a sequence of characters.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Text.Encoder GetEncoder()" />
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" /> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> method of this class. However, a <see cref="T:System.Text.Encoder" /> maintains state information between calls so it correctly encodes character sequences that span blocks. The <see cref="T:System.Text.Encoder" /> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block. Therefore, <see cref="M:System.Text.Encoding.GetDecoder" /> and <see cref="M:System.Text.Encoding.GetEncoder" /> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into an encoded sequence of bytes.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The fallback handler depends on the encoding type of <paramref name="codepage" />. If <paramref name="codepage" /> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used. Otherwise, a replacement fallback handler is used. These fallback handlers may not be appropriate for your application. To specify the fallback handler used by the encoding specified by <paramref name="codepage" />, you can call the <see cref="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" /> overload.</para>
          <para>The <see cref="M:System.Text.Encoding.GetEncoding(System.Int32)" /> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings. For a list of code pages, see the <see cref="T:System.Text.Encoding" /> class topic. Alternatively, you can call the <see cref="M:System.Text.Encoding.GetEncodings" /> method to get an array of <see cref="T:System.Text.EncodingInfo" /> objects that contains information about all encodings.</para>
          <para>To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, the application can either use a setting of 0 for the <paramref name="codepage" /> parameter or the <see cref="P:System.Text.Encoding.Default" /> property. To determine the default code pages used on the system, use the Windows GetSystemDefaultLangID function. To determine the current ANSI code page, use the Windows GetACP function.</para>
          <block subset="none" type="note">
            <para>Some unsupported code pages cause the exception <see cref="T:System.ArgumentException" /> to be thrown, whereas others cause <see cref="T:System.NotSupportedException" />. Therefore, your code must catch all exceptions indicated in the Exceptions section.</para>
          </block>
          <block subset="none" type="note">
            <para>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by Encoding.GetEncoding(0) is not recommended. For the most consistent results, applications should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</para>
          </block>
          <para>
            <see cref="M:System.Text.Encoding.GetEncoding(System.Int32)" /> returns a cached instance with default settings. The application should use the constructors of derived classes to get an instance with different settings. For example, the <see cref="T:System.Text.UTF32Encoding" /> class provides a constructor that lets you enable error detection.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the encoding associated with the specified code page identifier.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The encoding that is associated with the specified code page.</para>
        </returns>
        <param name="codepage">
          <attribution license="cc4" from="Microsoft" modified="false" />The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</param>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The fallback handler depends on the encoding type of <paramref name="name" />. If <paramref name="name" /> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used. Otherwise, a replacement fallback handler is used. These fallback handlers may not be appropriate for your application. To specify the fallback handler used by the encoding specified by <paramref name="name" />, you can call the <see cref="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" /> overload.</para>
          <para>The GetEncoding method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.</para>
          <block subset="none" type="note">
            <para>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, applications should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</para>
          </block>
          <para>For a list of code pages, see the <see cref="T:System.Text.Encoding" /> class topic. The application uses the <see cref="M:System.Text.Encoding.GetEncodings" /> method to get a list of all encodings.</para>
          <para>
            <see cref="M:System.Text.Encoding.GetEncoding(System.Int32)" /> returns a cached instance with default settings. The application should use the constructors of derived classes to get an instance with different settings. For example, the <see cref="T:System.Text.UTF32Encoding" /> class provides a constructor that lets you enable error detection.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the encoding associated with the specified code page name.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The encoding  associated with the specified code page.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The code page name of the preferred encoding. Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid. Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</param>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <block subset="none" type="note">
            <para>Some unsupported code pages cause the exception <see cref="T:System.ArgumentException" /> to be thrown, whereas others cause <see cref="T:System.NotSupportedException" />. Therefore, your code must catch all exceptions indicated in the Exceptions section.</para>
          </block>
          <para>The <see cref="M:System.Text.Encoding.GetEncoding(System.Int32)" /> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.</para>
          <block subset="none" type="note">
            <para>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by Encoding.GetEncoding(0) is not recommended. For the most consistent results, applications should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</para>
          </block>
          <para>For a list of code pages, see the <see cref="T:System.Text.Encoding" /> class topic. The application uses the <see cref="M:System.Text.Encoding.GetEncodings" /> method to get a list of all encodings.</para>
          <para>To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, the application can either use a setting of 0 for the <paramref name="codepage" /> parameter or use the <see cref="P:System.Text.Encoding.Default" /> property. To determine the default code pages used on the system, use the Windows GetSystemDefaultLangID function. To determine the current ANSI code page, use the Windows GetACP function.</para>
          <para>
            <see cref="M:System.Text.Encoding.GetEncoding(System.Int32)" /> returns a cached instance with default settings. The application should use the constructors of derived classes to get an instance with different settings. For example, the <see cref="T:System.Text.UTF32Encoding" /> class provides a constructor that lets you enable error detection.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the encoding associated with the specified code page identifier. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The encoding that is associated with the specified code page.</para>
        </returns>
        <param name="codepage">
          <attribution license="cc4" from="Microsoft" modified="false" />The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</param>
        <param name="encoderFallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides an error-handling procedure when a character cannot be encoded with the current encoding. </param>
        <param name="decoderFallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding. </param>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The GetEncoding method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.</para>
          <block subset="none" type="note">
            <para>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, applications should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</para>
          </block>
          <para>For a list of code pages, see the <see cref="T:System.Text.Encoding" /> class topic. The application uses the <see cref="M:System.Text.Encoding.GetEncodings" /> method to get a list of all encodings.</para>
          <para>
            <see cref="M:System.Text.Encoding.GetEncoding(System.Int32)" /> returns a cached instance with default settings. The application should use the constructors of derived classes to get an instance with different settings. For example, the <see cref="T:System.Text.UTF32Encoding" /> class provides a constructor that lets you enable error detection.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the encoding associated with the specified code page name. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The encoding that is associated with the specified code page.</para>
        </returns>
        <param name="name">
          <attribution license="cc4" from="Microsoft" modified="false" />The code page name of the preferred encoding. Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid. Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</param>
        <param name="encoderFallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides an error-handling procedure when a character cannot be encoded with the current encoding. </param>
        <param name="decoderFallback">
          <attribution license="cc4" from="Microsoft" modified="false" />An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding. </param>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This method returns a list of supported encodings, uniquely distinguished by code page. For a table that lists the supported encodings, see the <see cref="T:System.Text.Encoding" /> class topic. </para>
          <para>Encodings 50220 and 50222 are both associated with the name "iso-2022-jp", but they are not identical. Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters. The display name for encoding 50222 is "Japanese (JIS-Allow 1 byte Kana - SO/SI)" to distinguish it from encoding 50220, which has the display name "Japanese (JIS)".</para>
          <para>If your application requests the encoding name "iso-2022-jp", the .NET Framework returns encoding 50220. However, the encoding that is appropriate for your application will depend on the preferred treatment of the half-width Katakana characters.</para>
          <para>To get a specific encoding, your application should use the <see cref="M:System.Text.Encoding.GetEncoding(System.Int32)" /> method.</para>
          <para>
            <see cref="M:System.Text.Encoding.GetEncodings" /> is sometimes used to present the user with a list of encodings in a File <ui>Save as</ui> dialog box. However, many non-Unicode encodings are either incomplete and translate many characters to "?", or have subtly different behavior on different platforms. Consider using UTF-8 or UTF-16 as the default. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns an array that contains all encodings.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>An array that contains all encodings.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual int32 GetHashCode()" />
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <para>The algorithm used to
      generate the hash code is unspecified.</para>
          <para>
            <block subset="none" type="note">This method overrides <see cref="M:System.Object.GetHashCode" qualify="true" />.</block>
          </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Returns the hash code for the current instance.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The hash code for the current instance.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract int32 GetMaxByteCount(int32 charCount)" />
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <paramref name="charCount" /> parameter actually specifies the number of <see cref="T:System.Char" /> objects that represent the Unicode characters to encode, because the .NET Framework internally uses UTF-16 to represent Unicode characters. Consequently, most Unicode characters can be represented by one <see cref="T:System.Char" /> object, but a Unicode character represented by a surrogate pair, for example, requires two <see cref="T:System.Char" /> objects.</para>
          <para>To calculate the exact array size required by <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> to store the resulting bytes, the application should use <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />. To calculate the maximum array size, it should use <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> method generally executes faster.</para>
          <para>
            <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> retrieves a worst-case number, including the worst case for the currently selected <see cref="T:System.Text.EncoderFallback" />. If a fallback is chosen with a potentially large string, <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character. For example, this can happen for ISO-2022-JP. For more information, see the blog entry "<see cref="http://go.microsoft.com/fwlink/?LinkId=153702">What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?</see>" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).</para>
          <para>In most cases, this method retrieves reasonable values for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small. You might also want to consider a different approach using <see cref="Overload:System.Text.Encoding.GetByteCount" /> or <see cref="Overload:System.Text.Encoder.Convert" />.</para>
          <para>When using <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />, your application should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, the application might use the Convert method. </para>
          <para>Note that <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" /> considers potential leftover surrogates from a previous decoder operation. Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII. Your application should use the <see cref="P:System.Text.ASCIIEncoding.IsSingleByte" /> property if this information is necessary.</para>
          <block subset="none" type="note">
            <para>GetMaxByteCount(N) is not necessarily the same value as N* GetMaxByteCount(1).</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The maximum number of bytes produced by encoding the specified number of characters.</para>
        </returns>
        <param name="charCount">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of characters to encode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual abstract int32 GetMaxCharCount(int32 byteCount)" />
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>To calculate the exact array size required by <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> to store the resulting characters, the application should use <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />. To calculate the maximum array size, it should use <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />. The <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> method generally allows allocation of less memory, while the <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" /> method generally executes faster.</para>
          <para>
            <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" /> retrieves a worst-case number, including the worst case for the currently selected <see cref="T:System.Text.DecoderFallback" />. If a fallback is chosen with a potentially large string, <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" /> retrieves large values.</para>
          <para>In most cases, this method retrieves reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small. You might also want to consider a different approach using <see cref="Overload:System.Text.Encoding.GetCharCount" /> or <see cref="Overload:System.Text.Decoder.Convert" />.</para>
          <para>
            <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" /> has no relation to <see cref="M:System.Text.Encoding.GetBytes(System.String)" />. If your application needs a similar function to use with <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" />, it should use <see cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />.</para>
          <para>When using <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />, your application should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, the application might use the Convert method. </para>
          <para>Note that <see cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" /> considers the worst case for leftover bytes from a previous encoder operation. For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</para>
          <block subset="none" type="note">
            <para>GetMaxCharCount(N) is not necessarily the same value as N* GetMaxCharCount(1).</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The maximum number of characters produced by decoding the specified number of bytes.</para>
        </returns>
        <param name="byteCount">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to decode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual class System.Byte[] GetPreamble()" />
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Optionally, the <see cref="T:System.Text.Encoding" /> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF. </para>
          <para>The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal): </para>
          <list type="bullet">
            <item>
              <para>UTF-8: EF BB BF </para>
            </item>
            <item>
              <para>UTF-16 big endian byte order: FE FF </para>
            </item>
            <item>
              <para>UTF-16 little endian byte order: FF FE </para>
            </item>
            <item>
              <para>UTF-32 big endian byte order: 00 00 FE FF </para>
            </item>
            <item>
              <para>UTF-32 little endian byte order: FF FE 00 00 </para>
            </item>
          </list>
          <para>Your applications are recommended to use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the Encoding object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data. Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.  </para>
          <para>For standards that provide an encoding type, a BOM is somewhat redundant. However, it can be used to help a server send the correct encoding header. Alternatively, it can be used as a fallback in case the encoding is otherwise lost.  </para>
          <para>There are some disadvantages to using a BOM. For example, knowing how to limit the database fields that use a BOM can be difficult. Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data. In spite of the few disadvantages, however, the use of a BOM is highly recommended.</para>
          <para>For more information on byte order and the byte order mark, see The Unicode Standard at the <see cref="http://go.microsoft.com/fwlink/?LinkId=37123">Unicode home page</see>.</para>
          <block subset="none" type="note">
            <para>To ensure that the encoded bytes are decoded properly, your application should prefix encoded bytes with a preamble. However, most encodings do not provide a preamble. To ensure that the encoded bytes are decoded properly, the application should use a Unicode encoding, that is, <see cref="T:System.Text.UTF8Encoding" />, <see cref="T:System.Text.UnicodeEncoding" />, or <see cref="T:System.Text.UTF32Encoding" />, with a preamble.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A byte array containing a sequence of bytes that specifies the encoding used.</para>
          <para>-or- </para>
          <para>A byte array of length zero, if a preamble is not required.</para>
        </returns>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual string GetString(class System.Byte[] bytes)" />
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <see cref="T:System.Text.Decoder" /> object returned by the <see cref="M:System.Text.Encoding.GetDecoder" /> method of a derived class.</para>
          <para>See the Remarks section of the <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> reference topic for a discussion of decoding techniques and considerations.</para>
          <para>Note that the precise behavior of the <see cref="M:System.Text.Encoding.GetString(System.Byte[])" /> method for a particular <see cref="T:System.Text.Encoding" /> implementation depends on the fallback strategy defined for that <see cref="T:System.Text.Encoding" /> object. For more information, see the "Choosing a Fallback Strategy" section of the <format type="text/html"><a href="bf6d9823-4c2d-48af-b280-919c5af66ae9">Character Encoding in the .NET Framework</a></format> topic. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that contains the results of decoding the specified sequence of bytes.</para>
        </returns>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte array containing the sequence of bytes to decode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="ILASM" Value=".method public hidebysig virtual string GetString(class System.Byte[] bytes, int32 index, int32 count)" />
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes " /> is <see langword="null" />. </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index " />and <paramref name="count " />do not denote a valid range in <paramref name="bytes" />. </exception>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <see cref="T:System.Text.Decoder" /> or the <see cref="T:System.Text.Encoder" /> provided by the <see cref="M:System.Text.Encoding.GetDecoder" /> method or the <see cref="M:System.Text.Encoding.GetEncoder" /> method, respectively, of a derived class.</para>
          <para>See the Remarks section of the <see cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" /> reference topic for a discussion of decoding techniques and considerations.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>A string that contains the results of decoding the specified sequence of bytes.</para>
        </returns>
        <param name="bytes">
          <attribution license="cc4" from="Microsoft" modified="false" />The byte array containing the sequence of bytes to decode. </param>
        <param name="index">
          <attribution license="cc4" from="Microsoft" modified="false" />The index of the first byte to decode. </param>
        <param name="count">
          <attribution license="cc4" from="Microsoft" modified="false" />The number of bytes to decode. </param>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>If your application needs an encoding for a header name, it should call <see cref="M:System.Text.Encoding.GetEncoding(System.String)" /> with the <see cref="P:System.Text.Encoding.HeaderName" /> property. Often the method retrieves a different encoding from the test encoding furnished in the call. Generally only e-mail applications need to retrieve such an encoding.</para>
          <para>In some cases, the value of the <see cref="P:System.Text.Encoding.BodyName" /> property corresponds to the international standard that defines that encoding. This does not imply that the actual implementation complies in full with that standard. </para>
          <para>Note that <see cref="P:System.Text.Encoding.WebName" /> returns the name to use to describe an encoding. The <see cref="P:System.Text.Encoding.HeaderName" /> property defines a different encoding that might work better for an e-mail application, for example. However, use of the property to define the encoding is not recommended.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The default normalization form is <see cref="F:System.Text.NormalizationForm.FormC" />, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current <see cref="T:System.Text.Encoding" /> is always normalized; otherwise, false. The default is false.</para>
        </returns>
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The default normalization form is <see cref="F:System.Text.NormalizationForm.FormC" />, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</para>
        </summary>
        <returns>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>true if the current <see cref="T:System.Text.Encoding" /> object is always normalized using the specified <see cref="T:System.Text.NormalizationForm" /> value; otherwise, false. The default is false.</para>
        </returns>
        <param name="form">
          <attribution license="cc4" from="Microsoft" modified="false" />One of the <see cref="T:System.Text.NormalizationForm" /> values. </param>
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <since version=".NET 2.0" />
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For a single-byte encoding, for example, <see cref="T:System.Text.ASCIIEncoding" />, this property retrieves true.</para>
          <block subset="none" type="note">
            <para>You should be careful in what your application does with the value for <see cref="P:System.Text.Encoding.IsSingleByte" />. An assumption of how an Encoding will proceed may still be wrong. For example, Windows-1252 has a value of true for <see cref="P:System.Text.Encoding.IsSingleByte" />, but Encoding.GetMaxByteCount(1) returns 2. This is because the method considers potential leftover surrogates from a previous decoder operation.</para>
          </block>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="ILASM" Value=".property class System.Text.Encoding Unicode { public hidebysig static specialname class System.Text.Encoding get_Unicode() }" />
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Text.Encoding" /> for the Unicode format in little-endian byte
   order. </para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <format type="text/html"><a href="bf6d9823-4c2d-48af-b280-919c5af66ae9">Understanding Encodings</a></format>.</para>
          <para>The <see cref="T:System.Text.UnicodeEncoding" /> object that is returned by this property may not have the appropriate behavior for your application. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character. Instead, you can call the <see cref="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" /> constructor to instantiate a little endian <see cref="T:System.Text.UnicodeEncoding" /> object whose fallback is either an <see cref="T:System.Text.EncoderFallbackException" /> or a <see cref="T:System.Text.DecoderFallbackException" />, as the following example illustrates.</para>
          <para>code reference: System.Text.Encoding.Unicode#2</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an encoding for the UTF-16 format using the little endian byte order.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <since version=".NET 2.0" />
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="T:System.Text.UTF32Encoding" /> object that is returned by this property may not have the appropriate behavior for your application. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE). Instead, you can call the <see cref="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" /> constructor to instantiate a <see cref="T:System.Text.UTF32Encoding" /> object whose fallback is either an <see cref="T:System.Text.EncoderFallbackException" /> or a <see cref="T:System.Text.DecoderFallbackException" />, as the following example illustrates.</para>
          <para>code reference: System.Text.Encoding.UTF32#1</para>
          <para>For a discussion of little endian byte order, see the <see cref="T:System.Text.Encoding" /> class topic.</para>
          <para>For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <format type="text/html"><a href="bf6d9823-4c2d-48af-b280-919c5af66ae9">Understanding Encodings</a></format>.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an encoding for the UTF-32 format using the little endian byte order.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para />
          <para>UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications. Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead. </para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an encoding for the UTF-7 format.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="ILASM" Value=".property class System.Text.Encoding UTF8 { public hidebysig static specialname class System.Text.Encoding get_UTF8() }" />
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <value>
          <para>A <see cref="T:System.Text.Encoding" /> for the UTF-8 format.</para>
        </value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property returns a <see cref="T:System.Text.UTF8Encoding" /> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters. For information about the character encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <format type="text/html"><a href="bf6d9823-4c2d-48af-b280-919c5af66ae9">Understanding Encodings</a></format>. </para>
          <para>The <see cref="T:System.Text.UTF8Encoding" /> object that is returned by this property may not have the appropriate behavior for your application. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character. Instead, you can call the <see cref="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" /> constructor to instantiate a <see cref="T:System.Text.UTF8Encoding" /> object whose fallback is either an <see cref="T:System.Text.EncoderFallbackException" /> or a <see cref="T:System.Text.DecoderFallbackException" />, as the following example illustrates.</para>
          <para>code reference: System.Text.Encoding.UTF8#1</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>Gets an encoding for the UTF-8 format.</para>
        </summary>
      </Docs>
      <Excluded>0</Excluded>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <value>The name of the encoding in web form.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>The <see cref="P:System.Text.Encoding.WebName" /> property is the same as the <see cref="P:System.Text.EncodingInfo.Name" /> property.</para>
          <para>Note that <see cref="P:System.Text.Encoding.WebName" /> returns an IANA-registered name for the encoding. When its value is the name of a standard, the actual implementation of the encoding may not conform in full to that standard. The <see cref="P:System.Text.Encoding.HeaderName" /> property defines a different encoding that might work better for e-mail headers. However, most applications should use <see cref="P:System.Text.Encoding.WebName" /> instead.</para>
          <para>For more information on the IANA, go to <see cref="http://www.iana.org/">www.iana.org</see>.</para>
          <para>The <see cref="P:System.Text.Encoding.WebName" /> is the same as the <see cref="P:System.Text.EncodingInfo.Name" /> returned by <see cref="M:System.Text.Encoding.GetEncodings" />. Some of the web names are duplicates; see the remarks for <see cref="M:System.Text.Encoding.GetEncodings" /> for more information.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</para>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <value>To be added.</value>
        <remarks>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families. For globalization, using one of the Unicode encodings is recommended instead. It is also recommended to use <see cref="P:System.Text.Encoding.WebName" /> instead of <see cref="P:System.Text.Encoding.WindowsCodePage" /> to identify the code page.</para>
        </remarks>
        <summary>
          <attribution license="cc4" from="Microsoft" modified="false" />
          <para>When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</para>
        </summary>
      </Docs>
    </Member>
  </Members>
  <TypeExcluded>0</TypeExcluded>
</Type>