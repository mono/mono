<Type Name="Stdlib" FullName="Mono.Unix.Native.Stdlib">
  <TypeSignature Language="C#" Value="public class Stdlib" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Stdlib extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Posix</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are
  probably safe for multithreaded operations within managed code.  (Methods
  which are obviously unsafe are synchronized, such as 
  <see cref="M:Mono.Unix.Native.Stdlib.strerror" />, but any hidden dependencies 
  between e.g.
  <see cref="M:Mono.Unix.Native.Stdlib.strerror" /> and 
  <see cref="M:Mono.Unix.Native.Stdlib.fopen" /> are not protected.)
  No multithreading guarantee is made between managed and unmanaged code.  
  Check your operating system documentation for more information.
  </ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>C Standard Library functions.</summary>
    <remarks>The Stdlib class exports only functions that are part of the standard C library, from the ISO-9899 standard (C99).  As such, exports should be portable to any operating system supporting the standard C library, such as Microsoft Windows, as opposed to <see cref="T:Mono.Unix.Native.Syscall" /> which only supports Unix-like operating systems.</remarks>
  </Docs>
  <Members>
    <Member MemberName="_Exit">
      <MemberSignature Language="C#" Value="public static void _Exit (int status);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;_Exit&quot; cdecl)void _Exit(int32 status) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="status" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="status">The low-order eight bits of <paramref name="status" /> are generally made available to a parent process.</param>
        <summary>Perform normal program termination.</summary>
        <remarks>
          <para>
The <c>_Exit</c>(3) function terminates without calling the functions registered with the <see cref="M:Mono.Unix.Native.Stdlib.atexit" />(3) function, and may or may not perform the other actions listed in <see cref="M:Mono.Unix.Native.Stdlib.exit" />(3).
</para>
          <para>
The C Standard (ISO/IEC 9899:1999 ("ISO C99")) defines the values 0, <see cref="F:Mono.Unix.Native.Stdlib.EXIT_SUCCESS" />, and <see cref="F:Mono.Unix.Native.Stdlib.EXIT_FAILURE" /> as possible values of <paramref name="status" />.  Cooperating processes may use other values; in a program which might be called by a mail transfer agent, the values described in <c>sysexits</c>(3) may be used to provide more information to the parent process.
</para>
          <para>
This function never returns.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="_IOFBF">
      <MemberSignature Language="C#" Value="public static readonly int _IOFBF;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 _IOFBF" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Fully Buffered.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="_IOLBF">
      <MemberSignature Language="C#" Value="public static readonly int _IOLBF;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 _IOLBF" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Line buffered.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="_IONBF">
      <MemberSignature Language="C#" Value="public static readonly int _IONBF;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 _IONBF" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Specify unbuffered <c>FILE</c> streams.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="abort">
      <MemberSignature Language="C#" Value="public static void abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;abort&quot; cdecl)void abort() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cause abnormal program termination.</summary>
        <remarks>
          <para>The <c>abort</c>() function causes abnormal program termination to occur, unless the signal
<see cref="F:Mono.Unix.Native.Signum.SIGABRT" /> is being caught and the signal handler does not return.
</para>
          <para>
Any open streams are flushed and closed.
</para>
          <para>The <c>abort</c>() function never returns.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BUFSIZ">
      <MemberSignature Language="C#" Value="public static readonly int BUFSIZ;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 BUFSIZ" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>8192</MemberValue>
      <Docs>
        <summary>Buffer size.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="calloc">
      <MemberSignature Language="C#" Value="public static IntPtr calloc (ulong nmemb, ulong size);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_calloc&quot; cdecl lasterr)native int calloc(unsigned int64 nmemb, unsigned int64 size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nmemb" Type="System.UInt64" />
        <Parameter Name="size" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="nmemb">Number of objects to allocate.</param>
        <param name="size">Size of each object to allocate.</param>
        <summary>Allocate and zero-fill memory.</summary>
        <returns>The <c>calloc</c> function returns a pointer to the allocated memory if successful; otherwise <see cref="F:System.IntPtr.Zero" /> is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> returns <see cref="F:Mono.Unix.Native.Errno.ENOMEM" />.</returns>
        <remarks>
          <para>
The <c>calloc</c>() function allocates space for <paramref name="nmemb" /> objects, each <paramref name="size" /> bytes in length. The result is identical to calling <see cref="M:Mono.Unix.Native.Stdlib.malloc" />(3) with an argument of "<c>nmemb * size</c>," with the exception that the allocated memory is explicitly initialized to zero bytes.
</para>
          <para>
The return value of <c>calloc</c> must be passed to <see cref="M:Mono.Unix.Native.Stdlib.free" /> to avoid a memory leak.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="clearerr">
      <MemberSignature Language="C#" Value="public static int clearerr (IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_clearerr&quot; cdecl lasterr)int32 clearerr(native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="stream">The <c>FILE</c> stream to clear end-of-file and error indicators on.</param>
        <summary>Clear <c>FILE</c> stream status.</summary>
        <returns>The <c>clearerr</c>() function returns the value 0 if successful; otherwise the value -1 is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</returns>
        <remarks>Clears the end-of-file and error indicators for the stream pointed to by <paramref name="stream" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static readonly int EOF;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 EOF" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>End Of File.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="exit">
      <MemberSignature Language="C#" Value="public static void exit (int status);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;exit&quot; cdecl)void exit(int32 status) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="status" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="status">The low-order eight bits of <paramref name="status" /> are generally made available to a parent process.</param>
        <summary>Terminates the process that calls the function with the exit status <paramref name="status" />.</summary>
        <remarks>
          <para>The <c>exit</c> function terminates a process.</para>
          <para>Before termination, <c>exit</c>() performs the following functions in the order listed:</para>
          <list type="number">
            <item>
              <term>Call the functions registered with the <see cref="M:Mono.Unix.Native.Stdlib.atexit" />(3) function, in the reverse order of their registration.</term>
            </item>
            <item>
              <term>Flush all open output streams</term>
            </item>
            <item>
              <term>Close all open streams</term>
            </item>
            <item>
              <term>Unlink all files created with the <see cref="M:Mono.Unix.Native.Stdlib.tmpfile" />(3) function.</term>
            </item>
          </list>
          <para>The low-order eight bits of the <paramref name="status" /> argument is made available to a parent process which has called a <see cref="M:Mono.Unix.Native.Syscall.wait" />(2)-family function.
</para>
          <para>
The C Standard (ISO/IEC 9899:1999 ("ISO C99")) defines the values 0, <see cref="F:Mono.Unix.Native.Stdlib.EXIT_SUCCESS" />, and <see cref="F:Mono.Unix.Native.Stdlib.EXIT_FAILURE" /> as possible values of <paramref name="status" />.  Cooperating processes may use other values; in a program which might be called by a mail transfer agent, the values described in <c>sysexits</c>(3) may be used to provide more information to the parent process.
</para>
          <para>Note that <c>exit</c>() does nothing to prevent bottomless recursion should a function registered using <see cref="M:Mono.Unix.Native.Stdlib.atexit" />(3) itself call <c>exit</c>().  Such functions must call <see cref="M:Mono.Unix.Native.Stdlib._Exit" />() instead
     (although this has other effects as well which may not be desired).
</para>
          <para>
This function never returns.
</para>
          <example>
            <code lang="C#">
using System;
using Mono.Unix.Native;
using System.Runtime.InteropServices;

class Test
{
	public void SignalCatcher(int v)
	{
		// sleep signal caught.
		Console.WriteLine("Signal received: " + v);
		// this line will not be printed because process exits...
		Console.WriteLine("Exiting with: " + Stdlib.exit(9));
	}		
	
	public static void Main(string[] args)
	{
		Test t = new Test();
		Console.Write("waiting for event...");
		string x = Console.ReadLine();
	}
	
	public Test()
	{
		// create a signal handler delegate for sleep signals
		Console.WriteLine("signal result: " + 
			Syscall.signal(Signum.SIGALRM, 
				new SignalHandler (SignalCatcher)));
		// send a sleep signal
		Syscall.alarm(3);
	}
}</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EXIT_FAILURE">
      <MemberSignature Language="C#" Value="public static readonly int EXIT_FAILURE;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 EXIT_FAILURE" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Failure program exit status.</summary>
        <remarks>This is the value to return from <c>Main</c> when an error occurs.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EXIT_SUCCESS">
      <MemberSignature Language="C#" Value="public static readonly int EXIT_SUCCESS;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 EXIT_SUCCESS" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Success program exit status.</summary>
        <remarks>This is the value to return from <c>Main</c> when no errors occur.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fclose">
      <MemberSignature Language="C#" Value="public static int fclose (IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;fclose&quot; cdecl lasterr)int32 fclose(native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="stream">The <c>FILE</c> stream to close.</param>
        <summary>Close a <c>FILE</c> stream.</summary>
        <returns>
          <para>Upon successful completion 0 is returned.  Otherwise, <see cref="F:Mono.Unix.Native.Stdlib.EOF" /> is returned and the global variable <c>errno</c> is set to indicate the error.  In either case no further access to the stream is possible.</para>
          <para> The <c>fclose</c>() function may also fail and set <c>errno</c> for any of the errors specified for the routines <see cref="M:Mono.Unix.Native.Syscall.close" />(2) or <see cref="M:Mono.Unix.Native.Stdlib.fflush" />(3).
</para>
        </returns>
        <remarks>
          <para> The <c>fclose</c>() function dissociates the named stream from its underlying file or set of functions.  If the stream was being used for output, any buffered data is written first, using <see cref="M:Mono.Unix.Native.Stdlib.fflush" />(3).
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="feof">
      <MemberSignature Language="C#" Value="public static int feof (IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;feof&quot; cdecl)int32 feof(native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="stream">The <c>FILE</c> stream on which to test the end-of-file indicator.</param>
        <summary>Test end-of-file indicator for the <c>FILE</c> stream.</summary>
        <returns>Returns non-zero if the end-of-stream indicator for <paramref name="stream" /> is set.  Otherwise, 0 is returned.</returns>
        <remarks>The function <c>feof</c>() tests the end-of-file indicator for the stream pointed to by stream, returning non-zero if it is set.  The end-of-file indicator can only be cleared by the function <see cref="M:Mono.Unix.Native.Stdlib.clearerr" />().</remarks>
      </Docs>
    </Member>
    <Member MemberName="ferror">
      <MemberSignature Language="C#" Value="public static int ferror (IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;ferror&quot; cdecl)int32 ferror(native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="stream">The <c>FILE</c> stream on which to test the error indicator.</param>
        <summary>Tests the error indicator for the <c>FILE</c> stream.</summary>
        <returns>Returns non-zero if the error indicator is set on <paramref name="stream" />.  Otherwise, 0 is returned.</returns>
        <remarks>The function <c>ferror</c>() tests the error indicator for the stream pointed to by stream, returning non-zero if it is set.  The error indicator can only be reset by the <see cref="M:Mono.Unix.Native.Stdlib.clearerr" />() function.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fflush">
      <MemberSignature Language="C#" Value="public static int fflush (IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;fflush&quot; cdecl lasterr)int32 fflush(native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="stream">The <c>FILE</c> stream to flush.</param>
        <summary>Flush a <c>FILE</c> stream.</summary>
        <returns>Upon successful completion 0 is returned.  Otherwise, <see cref="F:Mono.Unix.Native.Stdlib.EOF" /> is returned and the global variable <c>errno</c> is set to indicate the error.

<block subset="none" type="usage"><para>The following errors are specified:</para><list type="table"><listheader><term>Error</term><description>Details</description></listheader><item><term><see cref="F:Mono.Unix.Native.Errno.EBADF" /></term><description>The <paramref name="stream" /> argument is not an open stream, or not a stream open for writing.</description></item></list><para>The function <c>fflush</c> may also fail and set <c>errno</c> for any of the errors specified for <see cref="M:Mono.Unix.Native.Syscall.write" />(2).</para></block></returns>
        <remarks>
          <para> The function <c>fflush</c>() forces a write of all buffered data for the given output or update <paramref name="stream" /> via the stream's underlying write function.  The open status of the stream is unaffected.</para>
          <para>If the stream argument is <see cref="F:System.IntPtr.Zero" />, <c>fflush</c>() flushes all open output streams.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fgetc">
      <MemberSignature Language="C#" Value="public static int fgetc (IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;fgetc&quot; cdecl lasterr)int32 fgetc(native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="stream">
          <c>FILE</c> stream to read a character from.</param>
        <summary>Get next character from a <c>FILE</c> input stream.</summary>
        <returns> If successful, returns the next requested object from the stream.  Character values are returned as an unsigned char converted to an int.  If the stream is at end-of-file or a read error occurs, the routines return <see cref="M:Mono.Unix.Native.Stdlib.EOF" />.  The routines <see cref="M:Mono.Unix.Native.Stdlib.feof" />(3) and <see cref="M:Mono.Unix.Native.Stdlib.ferror" />(3) must be used to distinguish between end-of-file and error.  If an error occurs, use <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.  The end-of-file condition is remembered, even on a terminal, and all subsequent attempts to read will return <see cref="M:Mono.Unix.Native.Stdlib.EOF" /> until the condition is cleared with <see cref="M:Mono.Unix.Native.Stdlib.clearerr" />(3).</returns>
        <remarks>The <c>fgetc</c>() function obtains the next input character (if present) from the stream pointed at by stream, or the next character pushed back on the stream via <see cref="M:Mono.Unix.Native.Stdlib.ungetc" />(3).</remarks>
      </Docs>
    </Member>
    <Member MemberName="fgetpos">
      <MemberSignature Language="C#" Value="public static int fgetpos (IntPtr stream, Mono.Unix.Native.FilePosition pos);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 fgetpos(native int stream, class Mono.Unix.Native.FilePosition pos) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
        <Parameter Name="pos" Type="Mono.Unix.Native.FilePosition" />
      </Parameters>
      <Docs>
        <param name="stream">
          <c>FILE</c> stream to retreive the current file position for.</param>
        <param name="pos">Where to store the current file position.</param>
        <summary>Retrieve the current file position of a <c>FILE</c> stream.</summary>
        <returns>
          <para>Returns <c>0</c> if successful; otherwise <c>-1</c> is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</para>
          <block subset="none" type="usage">
            <para>The following errors are specified:</para>
            <list type="table">
              <listheader>
                <term>Error</term>
                <description>Details</description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EBADF" />
                </term>
                <description>The <paramref name="stream" /> argument is not not a seekable stream</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EINVAL" />
                </term>
                <description>The <paramref name="whence" /> argument is invalid or the resulting file-position indicator would be set to a negative value.</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EOVERFLOW" />
                </term>
                <description>The resulting file offset would be a value which cannot be represented correctly in an object of type <see cref="System.Int64" /> for <see cref="M:Mono.Unix.Native.Stdlib.fseek" />() and <see cref="M:Mono.Unix.Native.Stdlib.ftell" />().</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.ESPIPE" />
                </term>
                <description>The file descriptor underlying stream is associated with a pipe or FIFO or file-position indicator value is unspecified (see <see cref="M:Mono.Unix.Native.Stdlib.ungetc" />(3)).</description>
              </item>
            </list>
          </block>
          <para>
            <c>fgetpos</c> may also fail for any of the error specified for the routines <see cref="M:Mono.Unix.Native.Stdlib.fflush" />(3), <see cref="M:Mono.Unix.Native.Syscall.fstat" />(2), <see cref="M:Mono.Unix.Native.Syscall.lseek" />(2), and <see cref="M:Mono.Unix.Native.Stdlib.malloc" />(3)
</para>
        </returns>
        <remarks>
          <para>The <c>fgetpos</c>() is an alternate interfaces for retrieving the current position in the file, similar to <see cref="M:Mono.Unix.Native.Stdlib.ftell" />(), except that the current position is stored in an opaque object of type <see cref="T:Mono.Unix.Native.FilePosition" /> pointed to by pos.  This provides a portable way to seek to offsets larger than those that can be represented by a long int.  They may also store additional state information in the <see cref="T:Mono.Unix.Native.FilePosition" /> object to facilitate seeking within files containing multibyte characters with state-dependent encodings.</para>
          <block subset="none" type="note">The value of <paramref name="pos" /> is modified by this operation.
</block>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fgets">
      <MemberSignature Language="C#" Value="public static System.Text.StringBuilder fgets (System.Text.StringBuilder sb, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.StringBuilder fgets(class System.Text.StringBuilder sb, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="sb">Where to store the next line of text from <paramref name="stream" />.</param>
        <param name="stream">The <c>FILE</c> stream to read a line from.</param>
        <summary>Read a line from a <c>FILE</c> stream.</summary>
        <returns>See the <see cref="M:Mono.Unix.Native.Stdlib.fgets(System.Text.StringBuilder,int,System.IntPtr)" /> documentation.</returns>
        <remarks>Identical to calling <c>fgets(<paramref name="sb" />, <paramref name="sb" />.Capacity, <paramref name="stream" />)</c>.
See the <see cref="M:Mono.Unix.Native.Stdlib.fgets(System.Text.StringBuilder,int,System.IntPtr)" /> documentation.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fgets">
      <MemberSignature Language="C#" Value="public static System.Text.StringBuilder fgets (System.Text.StringBuilder sb, int size, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.StringBuilder fgets(class System.Text.StringBuilder sb, int32 size, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="sb">Where to store the next line of text from <paramref name="stream" />.</param>
        <param name="size">The maximum number of characters that <paramref name="sb" /> can hold.</param>
        <param name="stream">The <c>FILE</c> stream to read a line from.</param>
        <summary>Read a line from a <c>FILE</c> stream.</summary>
        <returns>
          <para>Upon successful completion, returns <paramref name="sb" />.  If end-of-file occurs before any characters are read, returns <see langword="null" /> and the contents of <paramref name="sb" /> remains unchanged.  If an error occurs, <see langword="null" /> is returned and the contents of <paramref name="sb" /> are indeterminate.  <c>fgets</c> does not distinguish between end-of-file and error, and callers must use <see cref="M:Mono.Unix.Native.Stdlib.feof" />(3) and <see cref="M:Mono.Unix.Native.Stdlib.ferror" />(3) to determine which occurred.</para>
          <block subset="none" type="usage">
            <para>The following errors are specified:</para>
            <list type="table">
              <listheader>
                <term>Error</term>
                <description>Details</description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EBADF" />
                </term>
                <description>The given <paramref name="stream" /> is not a readable stream.</description>
              </item>
            </list>
          </block>
          <para>
            <c>fgetpos</c> may also fail for any of the error specified for the routines <see cref="M:Mono.Unix.Native.Stdlib.fflush" />(3), <see cref="M:Mono.Unix.Native.Syscall.fstat" />(2), <see cref="M:Mono.Unix.Native.Syscall.read" />(2), or <see cref="M:Mono.Unix.Native.Stdlib.malloc" />(3).
</para>
        </returns>
        <remarks>The <c>fgets</c>() function reads at most one less than the number of characters specified by <paramref name="size" /> from the given <paramref name="stream" /> and stores them in the string <paramref name="sb" />.  Reading stops when a newline character is found, at end-of-file or error.  The newline, if any, is retained.  If any characters are read and there is no error, a '\0' character is appended to end the string.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FILENAME_MAX">
      <MemberSignature Language="C#" Value="public static readonly int FILENAME_MAX;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 FILENAME_MAX" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>4096</MemberValue>
      <Docs>
        <summary>Maximum filename length.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fopen">
      <MemberSignature Language="C#" Value="public static IntPtr fopen (string path, string mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;fopen&quot; cdecl lasterr)native int fopen(string path, string mode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The filename to open.</param>
        <param name="mode">The file mode for opening.  See the Remarks section for more details.</param>
        <summary>Open a file and associate a <c>FILE</c> stream with it.</summary>
        <returns>
          <para>Upon successful completion, returns a <c>FILE</c> pointer.  Otherwise, <see cref="F:System.IntPtr.Zero" /> is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</para>
          <block subset="none" type="usage">
            <para>The following errors are specified:</para>
            <list type="table">
              <listheader>
                <term>Error</term>
                <description>Details</description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EINVAL" />
                </term>
                <description>The <paramref name="mode" /> argument was invalid.</description>
              </item>
            </list>
          </block>
          <para>
            <c>fopen</c> may also fail for any of the error specified for the routines <see cref="M:Mono.Unix.Native.Stdlib.malloc" />(3) and <see cref="M:Mono.Unix.Native.Syscall.open" />(2).
</para>
        </returns>
        <remarks>
          <para>The fopen() function opens the file whose name is the string pointed to by path and associates a stream with it.
</para>
          <para>Use <see cref="M:Mono.Unix.Native.Stdlib.fclose" /> to close the <c>FILE</c> stream.</para>
          <para>The argument <paramref name="mode" /> points to a string beginning with one of the following sequences (Additional characters may follow these sequences.):
</para>
          <list type="table">
            <listheader>
              <term>
                <paramref name="mode" />
              </term>
              <description>Description</description>
            </listheader>
            <item>
              <term>
                <c>"r"</c>
              </term>
              <description> Open text file for reading.  The stream is positioned at the beginning of the file.</description>
            </item>
            <item>
              <term>
                <c>"r+"</c>
              </term>
              <description>Open for reading and writing.  The stream is positioned at the beginning of the file.</description>
            </item>
            <item>
              <term>
                <c>"w"</c>
              </term>
              <description>Truncate file to zero length or create text file for writing.  The stream is positioned at the beginning of the file.</description>
            </item>
            <item>
              <term>
                <c>"w+"</c>
              </term>
              <description>Open for reading and writing.  The file is created if it does not exist, otherwise it is truncated.  The stream is positioned at the beginning of the file.</description>
            </item>
            <item>
              <term>
                <c>"a"</c>
              </term>
              <description>Open for writing.  The file is created if it does not exist.  The stream is positioned at the end of the file.  Subsequent writes to the file will always end up at the then current end of file, irrespective of any intervening <see cref="M:Mono.Unix.Native.Stdlib.fseek" />(3) or similar.</description>
            </item>
            <item>
              <term>
                <c>"a+"</c>
              </term>
              <description>Open for reading and writing.  The file is created if it does not exist.  The stream is positioned at the end of the file.  Subsequent writes to the file will always end up at the then current end of file, irrespective of any intervening <see cref="M:Mono.Unix.Native.Stdlib.fseek" />(3) or similar.</description>
            </item>
          </list>
          <para>The <paramref name="mode" /> string can also include the letter "b" either as a third character or as a character between the characters in any of the two-character strings described above, and is used to enable <i>binary</i> reading/writing on platforms which have different text/binary encodings (read: Microsoft Windows).  The default (non-<c>b</c><paramref name="mode" />) is text encoding.</para>
          <para>Any created files will have mode <c>S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</c> (0666), as modified by the process' umask value (see <see cref="M:Mono.Unix.Native.Syscall.umask" />(2)).
</para>
          <para>ANSI C requires that a file positioning function intervene between output and input, unless an input operation encounters end-of-file.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FOPEN_MAX">
      <MemberSignature Language="C#" Value="public static readonly int FOPEN_MAX;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 FOPEN_MAX" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>16</MemberValue>
      <Docs>
        <summary>Maximum number of <c>FILE</c> pointer that may be open at one time.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fprintf">
      <MemberSignature Language="C#" Value="public static int fprintf (IntPtr stream, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 fprintf(native int stream, string message) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stream">
          <c>FILE</c> stream to write to.</param>
        <param name="message">The string to write on <paramref name="stream" />.</param>
        <summary>Print to a <c>FILE</c> stream.</summary>
        <returns>Returns the number of characters printed or a negative value if an error occurs, and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.

<block subset="none" type="usage"><para>The following errors are specified:
  </para><list type="table"><listheader><term>Error</term><description>Details</description></listheader><item><term><see cref="F:Mono.Unix.Native.Errno.EILSEQ" /></term><description>An invalid wide character code was encountered</description></item><item><term><see cref="F:Mono.Unix.Native.Errno.ENOMEM" /></term><description>Insufficient storage space is available.</description></item></list><para>Any of the errors documented for the <see cref="M:Mono.Unix.Native.Syscall.write" /> system call may also be returned.
</para></block></returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="fprintf">
      <MemberSignature Language="C#" Value="public static int fprintf (IntPtr stream, string format, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 fprintf(native int stream, string format, object[] parameters) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Not necessarily portable due to cdecl restrictions.
Use fprintf (IntPtr, string) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="stream">
          <c>FILE</c> stream to write to.</param>
        <param name="format">The message format.</param>
        <param name="parameters">Arguments to the message format.</param>
        <summary>Print to a <c>FILE</c> stream.</summary>
        <returns>Returns the number of characters printed or a negative value if an error occurs, and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.

<block subset="none" type="usage"><para>The following errors are specified:
  </para><list type="table"><listheader><term>Error</term><description>Details</description></listheader><item><term><see cref="F:Mono.Unix.Native.Errno.EILSEQ" /></term><description>An invalid wide character code was encountered</description></item><item><term><see cref="F:Mono.Unix.Native.Errno.ENOMEM" /></term><description>Insufficient storage space is available.</description></item></list><para>Any of the errors documented for the <see cref="M:Mono.Unix.Native.Syscall.write" /> system call may also be returned.
</para></block></returns>
        <remarks>
          <para>The <c>fprintf</c>() family of functions produces output according to a format as described below.  <c>fprintf</c>() writes output to the given output <paramref name="stream" />.</para>
          <para>These functions write the output under the control of a <paramref name="format" /> string that specifies how subsequent arguments (or arguments accessed via the variable-length argument facilities of <c>stdarg</c>(3)) are converted for output.
</para>
          <para>The format string is composed of zero or more directives: ordinary characters (not %), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments.  Each conversion specification is introduced by the % character.  The arguments must correspond properly (after type promotion) with the conversion specifier.  After the %, the following appear in sequence:</para>
          <list type="bullet">
            <item>
              <term>An optional field, consisting of a decimal digit string followed by a <c>$</c>, specifying the next argument to access.  If this field is not provided, the argument following the last argument accessed will be used.  Arguments are numbered starting at <c>1</c>.  If unaccessed arguments in the format string are interspersed with ones that are accessed the results will be indeterminate.</term>
            </item>
            <item>
              <term>Zero or more of the following flags:

<list type="table"><listheader><term>Flag</term><description>Description</description></listheader><item><term>'<c>#</c>'</term><description>The value should be converted to an "alternate form".  For <c>c</c>, <c>d</c>, <c>i</c>, <c>n</c>, <c>p</c>, <c>s</c>, and <c>u</c> conversions, this option has no effect.  For <c>o</c> conversions, the precision of the number is increased to force the first character of the output string to a zero (except if a zero value is printed with an explicit precision of zero).  For <c>x</c> and <c>X</c> conversions, a non-zero result has the string '<c>0x</c>' (or '<c>0X</c>' for <c>X</c> conversions) prepended to it. For <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, and <c>G</c> conversions, the result will always contain a decimal point, even if no digits follow it (normally, a decimal point appears in the results of those conversions only if a digit follows).  For <c>g</c> and <c>G</c> conversions, trailing zeros are not removed from the result as they would otherwise be.</description></item><item><term>'<c>0</c>' (zero)</term><description>Zero padding.  For all conversions except <c>n</c>, the converted value is padded on the left with zeros rather than blanks.  If a precision is given with a numeric conversion (<c>d</c>, <c>i</c>, <c>o</c>, <c>u</c>, <c>i</c>, <c>x</c>, and <c>X</c>), the 0 flag is ignored.</description></item><item><term>'<c>-</c>'</term><description>A negative field width flag; the converted value is to be left adjusted on the field boundary.  Except for <c>n</c> conversions, the converted value is padded on the right with blanks, rather than on the left with blanks or zeros.  A <c>-</c> overrides a <c>0</c> if both are given.</description></item><item><term>'<c />' (space)</term><description>A blank should be left before a positive number produced by a signed conversion (<c>a</c>, <c>A</c>, <c>d</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, <c>G</c>, or <c>i</c>).</description></item><item><term>'<c>+</c>'</term><description>A sign must always be placed before a number produced by a signed conversion.  A <c>+</c> overrides a space if both are used.</description></item><item><term>'<c>'</c>'</term><description>Decimal conversions (<c>d</c>, <c>u</c>, or <c>i</c>) or the integral portion of a floating point conversion (<c>f</c> or <c>F</c>) should be grouped and separated by thousands using the non-monetary separator returned by <see cref="M:Mono.Unix.Native.Syscall.localeconv" />(3).</description></item></list></term>
            </item>
            <item>
              <term>An optional decimal digit string specifying a minimum field width.  If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-adjustment flag has been given) to fill out the field width.</term>
            </item>
            <item>
              <term>An optional precision, in the form of a period . followed by an optional digit string.  If the digit string is omitted, the precision is taken as zero.  This gives the minimum number of digits to appear for <c>d</c>, <c>i</c>, <c>o</c>, <c>u</c>, <c>x</c>, and <c>X</c> conversions, the number of digits to appear after the decimal-point for <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, and <c>F</c> conversions, the maximum number of significant digits for <c>g</c> and <c>G</c> conversions, or the maximum number of characters to be printed from a string for <c>s</c> conversions.</term>
            </item>
            <item>
              <term>An optional length modifier, that specifies the size of the argument.  The following length modifiers are valid for the <c>d</c>, <c>i</c>, <c>n</c>, <c>o</c>, <c>u</c>, <c>x</c>, or <c>X</c> conversion:

<list type="table"><listheader><term>Modifier</term><description><c>d</c>, <c>i</c></description><description><c>o, u, x, X</c></description><description><c>n</c></description></listheader><item><term><c>hh</c></term><description><c>signed char</c></description><description><c>unsigned char</c></description><description><c>signed char *</c></description></item><item><term><c>h</c></term><description><c>short</c></description><description><c>unsigned short</c></description><description><c>short *</c></description></item><item><term><c>l</c> (ell)</term><description><c>long</c></description><description><c>unsigned long</c></description><description><c>unsigned long *</c></description></item><item><term><c>ll</c> (ell ell)</term><description><c>long long</c></description><description><c>unsigned long long</c></description><description><c>long long *</c></description></item><item><term><c>j</c></term><description><c>intmax_t</c></description><description><c>uintmax_t</c></description><description><c>intmax_t *</c></description></item><item><term><c>t</c></term><description><c>ptrdiff_t</c></description><description>(see note)</description><description><c>ptrdiff_t *</c></description></item><item><term><c>z</c></term><description>(see note)</description><description><c>size_t</c></description><description>(see note)</description></item><item><term><c>q</c><i>(deprecated)</i></term><description><c>quad_t</c></description><description><c>u_quad_t</c></description><description><c>quad_t *</c></description></item></list><block subset="none" type="note"><para>the <c>t</c> modifier, when applied to a <c>o</c>, <c>u</c>, <c>x</c>, or <c>X</c> conversion, indicates that the argument is of an unsigned type equivalent in size to a <c>ptrdiff_t</c>.  The <c>z</c> modifier, when applied to a <c>d</c> or <c>i</c> conversion, indicates that the argument is of a signed type equivalent in size to a <c>size_t</c>.  Similarly, when applied to an <c>n</c> conversion, it indicates that the argument is a pointer to a signed type equivalent in size to a <c>size_t</c>.
  </para></block><para>The following length modifier is valid for the <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, or <c>G</c> conversion:</para><list type="table"><listheader><term>Modifier</term><description><c>a, A, e, E, f, F, g, G</c></description></listheader><item><term><c>L</c></term><description><c>long double</c></description></item></list><para>The following length modifier is valid for the <c>c</c> or <c>s</c> conversion:</para><list type="table"><listheader><term>Modifier</term><description><c>c</c></description><description><c>s</c></description></listheader><item><term><c>l</c> (ell)</term><description><c>wint_t</c></description><description><c>wchar_t *</c></description></item></list></term>
            </item>
            <item>
              <term>A character that specifies the type of conversion to be applied.</term>
            </item>
          </list>
          <para>A field width or precision, or both, may be indicated by an asterisk '<c>*</c>' or an asterisk followed by one or more decimal digits and a '<c>$</c>' instead of a digit string.  In this case, an <i>int</i> argument supplies the field width or precision.  A negative field width is treated as a left adjustment flag followed by a positive field width; a negative precision is treated as though it were missing.  If a single format directive mixes positional (<c>nn$</c>) and non-positional arguments, the results are undefined
</para>
          <para>The conversion specifiers and their meanings are:</para>
          <list type="table">
            <listheader>
              <term>Specifier</term>
              <description>Meaning</description>
            </listheader>
            <item>
              <term>
                <c>diouxX</c>
              </term>
              <description>The <c>int</c> (or appropriate variant) argument is converted to signed decimal (<c>d</c> and <c>i</c>), unsigned octal (<c>o</c>), unsigned decimal (<c>u</c>), or unsigned hexadecimal (<c>x</c> and <c>X</c>) notation.  The letters "<c>abcdef</c>" are used for <c>x</c> conversions; the letters "<c>ABCDEF</c>" are used for <c>X</c> conversions.  The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros.</description>
            </item>
            <item>
              <term>
                <c>DOU</c>
              </term>
              <description>The <c>long int</c> argument is converted to signed decimal, unsigned octal, or unsigned decimal, as if the format had been <c>ld</c>, <c>lo</c>, or <c>lu</c> respectively.  These conversion characters are deprecated, and will eventually disappear.</description>
            </item>
            <item>
              <term>
                <c>eE</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted in the style <c>[-]d.dddedd</c> where there is one digit before the decimal-point character and the number of digits after it is equal to the precision; if the precision is missing, it is taken as 6; if the precision is zero, no decimal-point character appears.  An <c>E</c> conversion uses the letter '<c>E</c>' (rather than '<c>e</c>') to introduce the exponent.  The exponent always contains at least two digits; if the value is zero, the exponent is 00.</description>
              <para>For <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, and <c>G</c> conversions, positive and negative infinity are represented as <c>inf</c> and <c>-inf</c> respectively when using the lowercase conversion character, and <c>INF</c> and <c>-INF</c> respectively when using the uppercase conversion character.  Similarly, <c>NaN</c> is represented as <c>nan</c> when using the lowercase conversion, and <c>NAN</c> when using the uppercase conversion.</para>
            </item>
            <item>
              <term>
                <c>fF</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted to decimal notation in the style <c>[-]ddd.ddd</c>, where the number of digits after the decimal-point character is equal to the precision specification.  If the precision is missing, it is taken as 6; if the precision is explicitly zero, no decimal-point character appears. If a decimal point appears, at least one digit appears before it.</description>
            </item>
            <item>
              <term>
                <c>gG</c>
              </term>
              <description>The <c>double</c> argument is converted in style <c>f</c> or <c>e</c> (or <c>F</c> or <c>E</c> for <c>G</c> conversions). The precision specifies the number of significant digits.  If the precision is missing, 6 digits are given; if the precision is zero, it is treated as 1. Style <c>e</c> is used if the exponent from its conversion is less than -4 or greater than or equal to the precision.  Trailing zeros are removed from the fractional part of the result; a decimal point appears only if it is followed by at least one digit.</description>
            </item>
            <item>
              <term>
                <c>aA</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted to hexadecimal notation in the style <c>[-]0xh.hhhp[]d</c>, where the number of digits after the hexadecimal-point character is equal to the precision specification.  If the precision is missing, it is taken as enough to represent the floating-point number exactly, and no rounding occurs.  If the precision is zero, no hexadecimal-point character appears.  The <c>p</c> is a literal character '<c>p</c>', and the exponent consists of a positive or negative sign followed by a decimal number representing an exponent of 2.  The <c>A</c> conversion uses the prefix "<c>0X</c>" (rather than "<c>0x</c>"), the letters "<c>ABCDEF</c>" (rather than "<c>abcdef</c>") to represent the hex digits, and the letter '<c>P</c>' (rather than '<c>p</c>') to separate the mantissa and exponent.

<para>Note that there may be multiple valid ways to represent floating-point numbers in this hexadecimal format.  For example, <c>0x3.24p+0</c>, <c>0x6.48p-1</c> and <c>0xc.9p-2</c> are all equivalent.  The format chosen depends on the internal representation of the number, but the implementation guarantees that the length of the mantissa will be minimized.  Zeroes are always represented with a mantissa of 0 (preceded by a '<c>-</c>' if appropriate) and an exponent of +0.
</para></description>
            </item>
            <item>
              <term>
                <c>C</c>
              </term>
              <description>Treated as <c>c</c> with the <c>l</c> (ell) modifier.</description>
            </item>
            <item>
              <term>
                <c>c</c>
              </term>
              <description>The <c>int</c> argument is converted to an <c>unsigned char</c>, and the resulting character is written.

<para>If the <c>l</c> (ell) modifier is used, the <c>wint_t</c> argument shall be converted to a <c>wchar_t</c>, and the (potentially multi-byte) sequence representing the single wide character is written, including any shift sequences.  If a shift sequence is used, the shift state is also restored to the original state after the character.
</para></description>
            </item>
            <item>
              <term>
                <c>S</c>
              </term>
              <description>Treated as <c>s</c> with the <c>l</c> (ell) modifier.</description>
            </item>
            <item>
              <term>
                <c>s</c>
              </term>
              <description>
The <c>char *</c> argument is expected to be a pointer to an array of character type (pointer to a string).  Characters from the array are written up to (but not including) a terminating NUL character; if a precision is specified, no more than the number specified are written.  If a precision is given, no null character need be present; if the precision is not specified, or is greater than the size of the array, the array must contain a terminating NUL character.

<para>If the <c>l</c> (ell) modifier is used, the <c>wchar_t *</c> argument is expected to be a pointer to an array of wide characters (pointer to a wide string).  For each wide character in the string, the (potentially multi-byte) sequence representing the wide character is written, including any shift sequences.  If any shift sequence is used, the shift state is also restored to the original state after the string.  Wide characters from the array are written up to (but not including) a terminating wide NUL character; if a precision is specified, no more than the number of bytes specified are written (including shift sequences).  Partial characters are never written.  If a precision is given, no null character need be present; if the precision is not specified, or is greater than the number of bytes required to render the multibyte representation of the string, the array must contain a terminating wide NUL character.</para></description>
            </item>
            <item>
              <term>
                <c>p</c>
              </term>
              <description>The <c>void *</c> pointer argument is printed in hexadecimal (as if by '<c>%#x</c>' or '<c>%#lx</c>').</description>
            </item>
            <item>
              <term>
                <c>n</c>
              </term>
              <description>The number of characters written so far is stored into the integer indicated by the <c>int *</c> (or variant) pointer argument.  No argument is converted.</description>
            </item>
            <item>
              <term>
                <c>%</c>
              </term>
              <description> A '<c>%</c>' is written.  No argument is converted.  The complete conversion specification is '<c>%%</c>'.</description>
            </item>
          </list>
          <para>The decimal point character is defined in the program's locale (category <c>LC_NUMERIC</c>)
</para>
          <para>In no case does a non-existent or small field width cause truncation of a numeric field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fputc">
      <MemberSignature Language="C#" Value="public static int fputc (int c, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;fputc&quot; cdecl lasterr)int32 fputc(int32 c, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Int32" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="c">The charater to write.</param>
        <param name="stream">The <c>FILE</c> stream to write to.</param>
        <summary>Output a character to a <c>FILE</c> stream.</summary>
        <returns>Returns the character written.  If an error occurrs, the value <see cref="F:Mono.Unix.Native.Stdlib.EOF" /> is returned.</returns>
        <remarks>The <c>fputc</c>() function writes the character <paramref name="c" /> (converted to an "unsigned char") to the output stream pointed to by <paramref name="stream" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fputs">
      <MemberSignature Language="C#" Value="public static int fputs (string s, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;fputs&quot; cdecl lasterr)int32 fputs(string s, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">The string to write.</param>
        <param name="stream">The <c>FILE</c> stream to write to.</param>
        <summary>Output a line to a <c>FILE</c> stream.</summary>
        <returns>
          <para>The <c>fputs</c> function returns <c>0</c> on success and <see cref="F:Mono.Unix.Native.Stdlib.EOF" /> on error, and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</para>
          <block subset="none" type="usage">
            <para>The following errors are specified:</para>
            <list type="table">
              <listheader>
                <term>Error</term>
                <description>Details</description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EBADF" />
                </term>
                <description>The <paramref name="stream" /> argument not a writable stream.</description>
              </item>
            </list>
          </block>
          <para>
            <c>fputs</c> may also fail for any of the errors specified for the routines <see cref="M:Mono.Unix.Native.Syscall.write" />(2).
</para>
        </returns>
        <remarks> The function <c>fputs</c>() writes the string pointed to by <paramref name="s" /> to the stream pointed to by <paramref name="stream" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fread">
      <MemberSignature Language="C#" Value="public static ulong fread (byte[] ptr, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 fread(unsigned int8[] ptr, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Byte[]" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Where to store the binary data read.</param>
        <param name="stream">The binary <c>FILE</c> stream to read from.</param>
        <summary>Read from a binary stream.</summary>
        <returns>
          <para>The function <c>fread</c>() advances the file position indicator for the stream by the number of bytes read.  It returns the number of objects read or written. If an error occurs, or the end-of-file is reached, the return value is a short object count (or zero).</para>
          <para>The function <c>fread</c>() does not distinguish between end-of-file and error, and callers must use <see cref="M:Mono.Unix.Native.Stdlib.feof" />(3) and <see cref="M:Mono.Unix.Native.Stdlib.ferror" />(3) to determine which occurred.</para>
        </returns>
        <remarks>The function <c>fread</c>() reads <c><paramref name="ptr" />.Length</c> bytes from the stream pointed to by <paramref name="stream" />, storing them at the location given by <paramref name="ptr" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fread">
      <MemberSignature Language="C#" Value="public static ulong fread (byte[] ptr, ulong size, ulong nmemb, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 fread(unsigned int8[] ptr, unsigned int64 size, unsigned int64 nmemb, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.UInt64" />
        <Parameter Name="nmemb" Type="System.UInt64" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Where to store the binary data read.</param>
        <param name="size">The size of each object to read.</param>
        <param name="nmemb">The number of objects to read.</param>
        <param name="stream">The binary <c>FILE</c> stream to read from.</param>
        <summary>Read from a binary stream.</summary>
        <returns>
          <para>The function <c>fread</c>() advances the file position indicator for the stream by the number of bytes read.  It returns the number of objects read or written. If an error occurs, or the end-of-file is reached, the return value is a short object count (or zero).</para>
          <para>The function <c>fread</c>() does not distinguish between end-of-file and error, and callers must use <see cref="M:Mono.Unix.Native.Stdlib.feof" />(3) and <see cref="M:Mono.Unix.Native.Stdlib.ferror" />(3) to determine which occurred.</para>
        </returns>
        <remarks>The function <c>fread</c>() reads <paramref name="nmemb" /> objects, each <paramref name="size" /> bytes long, from the stream pointed to by <paramref name="stream" />, storing them at the location given by <paramref name="ptr" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fread">
      <MemberSignature Language="C#" Value="public static ulong fread (IntPtr ptr, ulong size, ulong nmemb, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_fread&quot; cdecl lasterr)unsigned int64 fread(native int ptr, unsigned int64 size, unsigned int64 nmemb, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="size" Type="System.UInt64" />
        <Parameter Name="nmemb" Type="System.UInt64" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Where to store the binary data read.</param>
        <param name="size">The size of each object to read.</param>
        <param name="nmemb">The number of objects to read.</param>
        <param name="stream">The binary <c>FILE</c> stream to read from.</param>
        <summary>Read from a binary stream.</summary>
        <returns>
          <para>The function <c>fread</c>() advances the file position indicator for the stream by the number of bytes read.  It returns the number of objects read or written. If an error occurs, or the end-of-file is reached, the return value is a short object count (or zero).</para>
          <para>The function <c>fread</c>() does not distinguish between end-of-file and error, and callers must use <see cref="M:Mono.Unix.Native.Stdlib.feof" />(3) and <see cref="M:Mono.Unix.Native.Stdlib.ferror" />(3) to determine which occurred.</para>
        </returns>
        <remarks>The function <c>fread</c>() reads <paramref name="nmemb" /> objects, each <paramref name="size" /> bytes long, from the stream pointed to by <paramref name="stream" />, storing them at the location given by <paramref name="ptr" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fread">
      <MemberSignature Language="C#" Value="public static ulong fread (void* ptr, ulong size, ulong nmemb, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 fread(void* ptr, unsigned int64 size, unsigned int64 nmemb, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Void*" />
        <Parameter Name="size" Type="System.UInt64" />
        <Parameter Name="nmemb" Type="System.UInt64" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Where to store the binary data read.</param>
        <param name="size">The size of each object to read.</param>
        <param name="nmemb">The number of objects to read.</param>
        <param name="stream">The binary <c>FILE</c> stream to read from.</param>
        <summary>Read from a binary stream.</summary>
        <returns>
          <para>The function <c>fread</c>() advances the file position indicator for the stream by the number of bytes read.  It returns the number of objects read or written. If an error occurs, or the end-of-file is reached, the return value is a short object count (or zero).</para>
          <para>The function <c>fread</c>() does not distinguish between end-of-file and error, and callers must use <see cref="M:Mono.Unix.Native.Stdlib.feof" />(3) and <see cref="M:Mono.Unix.Native.Stdlib.ferror" />(3) to determine which occurred.</para>
        </returns>
        <remarks>The function <c>fread</c>() reads <paramref name="nmemb" /> objects, each <paramref name="size" /> bytes long, from the stream pointed to by <paramref name="stream" />, storing them at the location given by <paramref name="ptr" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="free">
      <MemberSignature Language="C#" Value="public static void free (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;free&quot; cdecl)void free(native int ptr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">The start of a memory area to free.</param>
        <summary>Free allocated memory.</summary>
        <remarks>The <c>free</c>() function causes the allocated memory referenced by <paramref name="ptr" /> to be made available for future allocations.  If <paramref name="ptr" /> is <see cref="F:System.IntPtr.Zero" />, no action occurs.</remarks>
      </Docs>
    </Member>
    <Member MemberName="freopen">
      <MemberSignature Language="C#" Value="public static IntPtr freopen (string path, string mode, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;freopen&quot; cdecl lasterr)native int freopen(string path, string mode, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.String" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="path">The filename to open.</param>
        <param name="mode">The file mode for opening. See the Remarks section for more details.</param>
        <param name="stream">The <c>FILE</c> stream to reopen.</param>
        <summary>Reopen a <c>FILE</c> stream.</summary>
        <returns>
          <para>Upon successful completion, returns a <c>FILE</c> pointer.  Otherwise, <see cref="F:System.IntPtr.Zero" /> is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</para>
          <block subset="none" type="usage">
            <para>The following errors are specified:</para>
            <list type="table">
              <listheader>
                <term>Error</term>
                <description>Details</description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EINVAL" />
                </term>
                <description>The <paramref name="mode" /> argument was invalid.</description>
              </item>
            </list>
          </block>
          <para>
            <c>freopen</c> may also fail for any of the error specified for the routines <see cref="M:Mono.Unix.Native.Stdlib.malloc" />(3),
<see cref="M:Mono.Unix.Native.Syscall.open" />(2), 
<see cref="M:Mono.Unix.Native.Stdlib.fclose" />(3), and
<see cref="M:Mono.Unix.Native.Stdlib.fflush" />(3).
</para>
        </returns>
        <remarks>
          <para>The <c>freopen</c>() function opens the file whose name is the string pointed to by <paramref name="path" /> and associates the stream pointed to by <paramref name="stream" /> with it.  The original stream (if it exists) is closed.
</para>
          <para>Use <see cref="M:Mono.Unix.Native.Stdlib.fclose" /> to close the returned <c>FILE</c> stream.</para>
          <para>The argument <paramref name="mode" /> points to a string beginning with one of the following sequences (Additional characters may follow these sequences.):
</para>
          <list type="table">
            <listheader>
              <term>
                <paramref name="mode" />
              </term>
              <description>Description</description>
            </listheader>
            <item>
              <term>
                <c>"r"</c>
              </term>
              <description> Open text file for reading.  The stream is positioned at the beginning of the file.</description>
            </item>
            <item>
              <term>
                <c>"r+"</c>
              </term>
              <description>Open for reading and writing.  The stream is positioned at the beginning of the file.</description>
            </item>
            <item>
              <term>
                <c>"w"</c>
              </term>
              <description>Truncate file to zero length or create text file for writing.  The stream is positioned at the beginning of the file.</description>
            </item>
            <item>
              <term>
                <c>"w+"</c>
              </term>
              <description>Open for reading and writing.  The file is created if it does not exist, otherwise it is truncated.  The stream is positioned at the beginning of the file.</description>
            </item>
            <item>
              <term>
                <c>"a"</c>
              </term>
              <description>Open for writing.  The file is created if it does not exist.  The stream is positioned at the end of the file.  Subsequent writes to the file will always end up at the then current end of file, irrespective of any intervening <see cref="M:Mono.Unix.Native.Stdlib.fseek" />(3) or similar.</description>
            </item>
            <item>
              <term>
                <c>"a+"</c>
              </term>
              <description>Open for reading and writing.  The file is created if it does not exist.  The stream is positioned at the end of the file.  Subsequent writes to the file will always end up at the then current end of file, irrespective of any intervening <see cref="M:Mono.Unix.Native.Stdlib.fseek" />(3) or similar.</description>
            </item>
          </list>
          <para>The <paramref name="mode" /> string can also include the letter "b" either as a third character or as a character between the characters in any of the two-character strings described above, and is used to enable <i>binary</i> reading/writing on platforms which have different text/binary encodings (read: Microsoft Windows).  The default (non-<c>b</c><paramref name="mode" />) is text encoding.</para>
          <para>If the <paramref name="path" /> argument is <see langword="null" />, <c>freopen</c>() attempts to re-open the file associated with <paramref name="stream" /> with a new mode.  The new mode must be compatible with the mode that the stream was originally opened with:
</para>
          <list type="bullet">
            <item>
              <term>Streams originally opened with mode <c>"r"</c> can only be reopened with that same mode.</term>
            </item>
            <item>
              <term>Streams originally opened with mode <c>"a"</c> can be reopened with the same mode, or mode <c>"w"</c>.</term>
            </item>
            <item>
              <term>Streams originally opened with mode <c>"w"</c> can be reopened with the same mode, or mode <c>"a"</c>.</term>
            </item>
            <item>
              <term>Streams originally opened with mode <c>"r+"</c>, <c>"w+"</c>, or <c>"a+"</c> can be reopened with any mode.</term>
            </item>
          </list>
          <para>The primary use of the <c>freopen</c>() function is to change the file associated with a standard text stream (<see cref="F:Mono.Unix.Native.Stdlib.stderr" />, <see cref="F:Mono.Unix.Native.Stdlib.stdin" />, or <see cref="F:Mono.Unix.Native.Stdlib.stdout" />).
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fseek">
      <MemberSignature Language="C#" Value="public static int fseek (IntPtr stream, long offset, Mono.Unix.Native.SeekFlags origin);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 fseek(native int stream, int64 offset, valuetype Mono.Unix.Native.SeekFlags origin) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="Mono.Unix.Native.SeekFlags" />
      </Parameters>
      <Docs>
        <param name="stream">
          <c>FILE</c> stream to seek.</param>
        <param name="offset">Number of bytes to add to the the file offset specified by <paramref name="whence" />.</param>
        <param name="origin">File offset to add <paramref name="offset" /> to.</param>
        <summary>Set file position for a <c>FILE</c> stream.</summary>
        <returns>
          <para>Returns <c>0</c> if successful; otherwise <c>-1</c> is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</para>
          <block subset="none" type="usage">
            <para>The following errors are specified:</para>
            <list type="table">
              <listheader>
                <term>Error</term>
                <description>Details</description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EBADF" />
                </term>
                <description>The <paramref name="stream" /> argument is not not a seekable stream</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EINVAL" />
                </term>
                <description>The <paramref name="whence" /> argument is invalid or the resulting file-position indicator would be set to a negative value.</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EOVERFLOW" />
                </term>
                <description>The resulting file offset would be a value which cannot be represented correctly in an object of type <see cref="System.Int64" /> for <see cref="M:Mono.Unix.Native.Stdlib.fseek" />() and <see cref="M:Mono.Unix.Native.Stdlib.ftell" />().</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.ESPIPE" />
                </term>
                <description>The file descriptor underlying stream is associated with a pipe or FIFO or file-position indicator value is unspecified (see <see cref="M:Mono.Unix.Native.Stdlib.ungetc" />(3)).</description>
              </item>
            </list>
          </block>
          <para>
            <c>fseek</c> may also fail for any of the error specified for the routines <see cref="M:Mono.Unix.Native.Stdlib.fflush" />(3), <see cref="M:Mono.Unix.Native.Syscall.fstat" />(2), <see cref="M:Mono.Unix.Native.Syscall.lseek" />(2), and <see cref="M:Mono.Unix.Native.Stdlib.malloc" />(3)
</para>
        </returns>
        <remarks>The <c>fseek</c>() function sets the file position indicator for the stream pointed to by <paramref name="stream" />.  The new position, measured in bytes, is obtained by adding <paramref name="offset" /> bytes to the position specified by <paramref name="whence" />.  If whence is set to <see cref="F:Mono.Unix.Native.SeekFlags.SEEK_SET" />, <see cref="F:Mono.Unix.Native.SeekFlags.SEEK_CUR" />, or <see cref="F:Mono.Unix.Native.SeekFlags.SEEK_END" />, the offset is relative to the start of the file, the current position indicator, or end-of-file, respectively.  A successful call to the <c>fseek</c>() function clears the end-of-file indicator for the stream and undoes any effects of the <see cref="M:Mono.Unix.Native.Stdlib.ungetc" />(3) and <see cref="M:Mono.Unix.Native.Stdlib.ungetwc" />(3) functions on the same stream.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fsetpos">
      <MemberSignature Language="C#" Value="public static int fsetpos (IntPtr stream, Mono.Unix.Native.FilePosition pos);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 fsetpos(native int stream, class Mono.Unix.Native.FilePosition pos) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
        <Parameter Name="pos" Type="Mono.Unix.Native.FilePosition" />
      </Parameters>
      <Docs>
        <param name="stream">
          <c>FILE</c> stream to set the current file position for.</param>
        <param name="pos">The file position to seek to.</param>
        <summary>Sets the current file position of a <c>FILE</c> stream.</summary>
        <returns>
          <para>Returns <c>0</c> if successful; otherwise <c>-1</c> is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</para>
          <block subset="none" type="usage">
            <para>The following errors are specified:</para>
            <list type="table">
              <listheader>
                <term>Error</term>
                <description>Details</description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EBADF" />
                </term>
                <description>The <paramref name="stream" /> argument is not not a seekable stream</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EINVAL" />
                </term>
                <description>The <paramref name="whence" /> argument is invalid or the resulting file-position indicator would be set to a negative value.</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EOVERFLOW" />
                </term>
                <description>The resulting file offset would be a value which cannot be represented correctly in an object of type <see cref="System.Int64" /> for <see cref="M:Mono.Unix.Native.Stdlib.fseek" />() and <see cref="M:Mono.Unix.Native.Stdlib.ftell" />().</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.ESPIPE" />
                </term>
                <description>The file descriptor underlying stream is associated with a pipe or FIFO or file-position indicator value is unspecified (see <see cref="M:Mono.Unix.Native.Stdlib.ungetc" />(3)).</description>
              </item>
            </list>
          </block>
          <para>
            <c>fsetpos</c> may also fail for any of the error specified for the routines <see cref="M:Mono.Unix.Native.Stdlib.fflush" />(3), <see cref="M:Mono.Unix.Native.Syscall.fstat" />(2), <see cref="M:Mono.Unix.Native.Syscall.lseek" />(2), and <see cref="M:Mono.Unix.Native.Stdlib.malloc" />(3)
</para>
        </returns>
        <remarks>The <c>fsetpos</c>() function is an alternate interfaces for setting the current position in the file, similar to <see cref="M:Mono.Unix.Native.Stdlib.fseek" />(), except that the current position is stored in an opaque object of type <see cref="T:Mono.Unix.Native.FilePosition" /> pointed to by pos.  This provides a portable way to seek to offsets larger than those that can be represented by a long int.  It may also store additional state information in the <see cref="T:Mono.Unix.Native.FilePosition" /> object to facilitate seeking within files containing multibyte characters with state-dependent encodings.
</remarks>
      </Docs>
    </Member>
    <Member MemberName="ftell">
      <MemberSignature Language="C#" Value="public static long ftell (IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_ftell&quot; cdecl lasterr)int64 ftell(native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="stream">
          <c>FILE</c> stream to get the file position from.</param>
        <summary>Get current file position for <c>FILE</c> stream.</summary>
        <returns>
          <para>Returns the current file offset if successful; otherwise <c>-1</c> is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</para>
          <block subset="none" type="usage">
            <para>The following errors are specified:</para>
            <list type="table">
              <listheader>
                <term>Error</term>
                <description>Details</description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EBADF" />
                </term>
                <description>The <paramref name="stream" /> argument is not not a seekable stream</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EINVAL" />
                </term>
                <description>The <paramref name="whence" /> argument is invalid or the resulting file-position indicator would be set to a negative value.</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EOVERFLOW" />
                </term>
                <description>The resulting file offset would be a value which cannot be represented correctly in an object of type <see cref="System.Int64" /> for <see cref="M:Mono.Unix.Native.Stdlib.fseek" />() and <see cref="M:Mono.Unix.Native.Stdlib.ftell" />().</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.ESPIPE" />
                </term>
                <description>The file descriptor underlying stream is associated with a pipe or FIFO or file-position indicator value is unspecified (see <see cref="M:Mono.Unix.Native.Stdlib.ungetc" />(3)).</description>
              </item>
            </list>
          </block>
          <para>
            <c>ftell</c> may also fail for any of the error specified for the routines <see cref="M:Mono.Unix.Native.Stdlib.fflush" />(3), <see cref="M:Mono.Unix.Native.Syscall.fstat" />(2), <see cref="M:Mono.Unix.Native.Syscall.lseek" />(2), and <see cref="M:Mono.Unix.Native.Stdlib.malloc" />(3)
</para>
        </returns>
        <remarks>The <c>ftell</c>() function obtains the current value of the file position indicator for the stream pointed to by <paramref name="stream" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="fwrite">
      <MemberSignature Language="C#" Value="public static ulong fwrite (byte[] ptr, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 fwrite(unsigned int8[] ptr, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Byte[]" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">The data to write.</param>
        <param name="stream">The binary <c>FILE</c> stream to write to.</param>
        <summary>Write to a binary <c>FILE</c> stream.</summary>
        <returns>
          <para>The function <c>fwrite</c>() advance the file position indicator for the stream by the number of bytes written.  It returns the number of objects written. If an error occurs, or the end-of-file is reached, the return value is a short object count (or zero).</para>
          <para>The function <c>fwrite</c>() returns a value less than <paramref name="nmemb" /> only if a write error has occurred.
</para>
        </returns>
        <remarks>
          <para>The function <c>fwrite</c>() writes <c><paramref name="ptr" />.Length</c> bytes to the stream pointed to by <paramref name="stream" />, obtaining them from the location given by <paramref name="ptr" />.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fwrite">
      <MemberSignature Language="C#" Value="public static ulong fwrite (byte[] ptr, ulong size, ulong nmemb, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 fwrite(unsigned int8[] ptr, unsigned int64 size, unsigned int64 nmemb, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.UInt64" />
        <Parameter Name="nmemb" Type="System.UInt64" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">The data to write.</param>
        <param name="size">The size of each object to write.</param>
        <param name="nmemb">The number of objects to write.</param>
        <param name="stream">The binary <c>FILE</c> stream to write to.</param>
        <summary>Write to a binary <c>FILE</c> stream.</summary>
        <returns>
          <para>The function <c>fwrite</c>() advance the file position indicator for the stream by the number of bytes written.  It returns the number of objects written. If an error occurs, or the end-of-file is reached, the return value is a short object count (or zero).</para>
          <para>The function <c>fwrite</c>() returns a value less than <paramref name="nmemb" /> only if a write error has occurred.
</para>
        </returns>
        <remarks>
          <para>The function <c>fwrite</c>() writes <paramref name="nmemb" /> objects, each <paramref name="size" /> bytes long, to the stream pointed to by <paramref name="stream" />, obtaining them from the location given by <paramref name="ptr" />.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fwrite">
      <MemberSignature Language="C#" Value="public static ulong fwrite (IntPtr ptr, ulong size, ulong nmemb, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_fwrite&quot; cdecl lasterr)unsigned int64 fwrite(native int ptr, unsigned int64 size, unsigned int64 nmemb, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="size" Type="System.UInt64" />
        <Parameter Name="nmemb" Type="System.UInt64" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">The data to write.</param>
        <param name="size">The size of each object to write.</param>
        <param name="nmemb">The number of objects to write.</param>
        <param name="stream">The binary <c>FILE</c> stream to write to.</param>
        <summary>Write to a binary <c>FILE</c> stream.</summary>
        <returns>
          <para>The function <c>fwrite</c>() advance the file position indicator for the stream by the number of bytes written.  It returns the number of objects written. If an error occurs, or the end-of-file is reached, the return value is a short object count (or zero).</para>
          <para>The function <c>fwrite</c>() returns a value less than <paramref name="nmemb" /> only if a write error has occurred.
</para>
        </returns>
        <remarks>
          <para>The function <c>fwrite</c>() writes <paramref name="nmemb" /> objects, each <paramref name="size" /> bytes long, to the stream pointed to by <paramref name="stream" />, obtaining them from the location given by <paramref name="ptr" />.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fwrite">
      <MemberSignature Language="C#" Value="public static ulong fwrite (void* ptr, ulong size, ulong nmemb, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 fwrite(void* ptr, unsigned int64 size, unsigned int64 nmemb, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Void*" />
        <Parameter Name="size" Type="System.UInt64" />
        <Parameter Name="nmemb" Type="System.UInt64" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">The data to write.</param>
        <param name="size">The size of each object to write.</param>
        <param name="nmemb">The number of objects to write.</param>
        <param name="stream">The binary <c>FILE</c> stream to write to.</param>
        <summary>Write to a binary <c>FILE</c> stream.</summary>
        <returns>
          <para>The function <c>fwrite</c>() advance the file position indicator for the stream by the number of bytes written.  It returns the number of objects written. If an error occurs, or the end-of-file is reached, the return value is a short object count (or zero).</para>
          <para>The function <c>fwrite</c>() returns a value less than <paramref name="nmemb" /> only if a write error has occurred.
</para>
        </returns>
        <remarks>
          <para>The function <c>fwrite</c>() writes <paramref name="nmemb" /> objects, each <paramref name="size" /> bytes long, to the stream pointed to by <paramref name="stream" />, obtaining them from the location given by <paramref name="ptr" />.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="getc">
      <MemberSignature Language="C#" Value="public static int getc (IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;getc&quot; cdecl lasterr)int32 getc(native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="stream">
          <c>FILE</c> stream to read a character from.</param>
        <summary>Get next character from a <c>FILE</c> input stream.</summary>
        <returns>If successful, returns the next requested object from the stream.  Character values are returned as an unsigned char converted to an int.  If the stream is at end-of-file or a read error occurs, the routines return <see cref="M:Mono.Unix.Native.Stdlib.EOF" />.  The routines <see cref="M:Mono.Unix.Native.Stdlib.feof" />(3) and <see cref="M:Mono.Unix.Native.Stdlib.ferror" />(3) must be used to distinguish between end-of-file and error.  If an error occurs, use <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.  The end-of-file condition is remembered, even on a terminal, and all subsequent attempts to read will return <see cref="M:Mono.Unix.Native.Stdlib.EOF" /> until the condition is cleared with <see cref="M:Mono.Unix.Native.Stdlib.clearerr" />(3).</returns>
        <remarks>The <c>getc</c>() function obtains the next input character (if present) from the stream pointed at by stream, or the next character pushed back on the stream via <see cref="M:Mono.Unix.Native.Stdlib.ungetc" />(3).</remarks>
      </Docs>
    </Member>
    <Member MemberName="getchar">
      <MemberSignature Language="C#" Value="public static int getchar ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;getchar&quot; cdecl lasterr)int32 getchar() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Get next character from standard input.</summary>
        <returns>If successful, returns the next requested object from the stream.  Character values are returned as an unsigned char converted to an int.  If the stream is at end-of-file or a read error occurs, the routines return <see cref="M:Mono.Unix.Native.Stdlib.EOF" />.  The routines <see cref="M:Mono.Unix.Native.Stdlib.feof" />(3) and <see cref="M:Mono.Unix.Native.Stdlib.ferror" />(3) must be used to distinguish between end-of-file and error.  If an error occurs, use <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.  The end-of-file condition is remembered, even on a terminal, and all subsequent attempts to read will return <see cref="M:Mono.Unix.Native.Stdlib.EOF" /> until the condition is cleared with <see cref="M:Mono.Unix.Native.Stdlib.clearerr" />(3).</returns>
        <remarks>The <c>getchar</c>() function is equivalent to <c><see cref="M:Mono.Unix.Native.Stdlib.getc" /> (<see cref="F:Mono.Unix.Native.Stdlib.stdin" />)</c>, 
obtaining the next input character (if present) from <see cref="F:Mono.Unix.Native.Stdlib.stdin" />, or the next character pushed back on <c>stdin</c> via <see cref="M:Mono.Unix.Native.Stdlib.ungetc" />(3).</remarks>
      </Docs>
    </Member>
    <Member MemberName="getenv">
      <MemberSignature Language="C#" Value="public static string getenv (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string getenv(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The environment variable to read.</param>
        <summary>Read an environment variable.</summary>
        <returns>The <c>getenv</c>() function returns the value of the environment variable as a string.  If the variable name is not in the current environment, <see langword="null" /> is returned.</returns>
        <remarks>The <c>getenv</c>() function obtains the current value of the environment variable, <paramref name="name" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public static Mono.Unix.Native.Errno GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Mono.Unix.Native.Errno GetLastError() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Unix.Native.Errno</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reads and translates <c>errno</c>.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="L_tmpnam">
      <MemberSignature Language="C#" Value="public static readonly int L_tmpnam;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 L_tmpnam" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>20</MemberValue>
      <Docs>
        <summary>The number of characters filled by <see cref="M:Mono.Unix.Native.Stdlib.tmpnam" />(3).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="malloc">
      <MemberSignature Language="C#" Value="public static IntPtr malloc (ulong size);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_malloc&quot; cdecl lasterr)native int malloc(unsigned int64 size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="size">Amount of memory to allocate.</param>
        <summary>Allocate memory.</summary>
        <returns>The <c>malloc</c>() function returns a pointer to the allocated memory if successful; otherwise a <see cref="F:System.IntPtr.Zero" /> pointer is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> returns <see cref="F:Mono.Unix.Native.Errno.ENOMEM" />.</returns>
        <remarks>
          <para>The <c>malloc</c>() function allocates <paramref name="size" /> bytes of memory.  The allocated space is suitably aligned (after possible pointer coercion) for storage of any type of object.  If the space is at least <paramref name="pagesize" /> bytes in length (see <see cref="M:Mono.Unix.Native.Syscall.getpagesize" />(3)), the returned memory will be page boundary aligned as well.  If <c>malloc</c>() fails, <see cref="F:System.IntPtr.Zero" /> is returned.</para>
          <para>You should <see cref="M:Mono.Unix.Native.Stdlib.free" /> the return value to avoid a memory leak.</para>
          <para>Note that <c>malloc</c>() does NOT normally initialize the returned memory to zero bytes.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MB_CUR_MAX">
      <MemberSignature Language="C#" Value="public static readonly int MB_CUR_MAX;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MB_CUR_MAX" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>6</MemberValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="perror">
      <MemberSignature Language="C#" Value="public static int perror (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 perror(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The error message prefix to print.</param>
        <summary>Print an error message to <see cref="F:Mono.Unix.Native.Stdlib.stderr" />.</summary>
        <returns>The <c>perror</c>() function returns the value 0 if successful; otherwise the value -1 is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</returns>
        <remarks>The <c>perror</c>() function finds the error message corresponding to the current value of <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> and writes it, followed by a newline, to the standard error file descriptor.  If the argument string is not <see langword="null" /> and does not point to the null character, this string is prepended to the message string and separated from it by a colon and space ("<c>: </c>"); otherwise, only the error message string is printed.</remarks>
      </Docs>
    </Member>
    <Member MemberName="printf">
      <MemberSignature Language="C#" Value="public static int printf (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 printf(string message) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">The message to print.</param>
        <summary>Prints a message on <see cref="F:Mono.Unix.Native.Stdlib.stdout" />.</summary>
        <returns>Returns the number of characters printed or a negative value if an error occurs, and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.

<block subset="none" type="usage"><para>The following errors are specified:
  </para><list type="table"><listheader><term>Error</term><description>Details</description></listheader><item><term><see cref="F:Mono.Unix.Native.Errno.EILSEQ" /></term><description>An invalid wide character code was encountered</description></item><item><term><see cref="F:Mono.Unix.Native.Errno.ENOMEM" /></term><description>Insufficient storage space is available.</description></item></list><para>Any of the errors documented for the <see cref="M:Mono.Unix.Native.Syscall.write" /> system call may also be returned.
</para></block></returns>
        <remarks />
      </Docs>
    </Member>
    <Member MemberName="printf">
      <MemberSignature Language="C#" Value="public static int printf (string format, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 printf(string format, object[] parameters) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Not necessarily portable due to cdecl restrictions.
Use printf (string) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">The message format.</param>
        <param name="parameters">Arguments for the message format.</param>
        <summary>Prints a message on <see cref="F:Mono.Unix.Native.Stdlib.stdout" />.</summary>
        <returns>Returns the number of characters printed or a negative value if an error occurs, and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.

<block subset="none" type="usage"><para>The following errors are specified:
  </para><list type="table"><listheader><term>Error</term><description>Details</description></listheader><item><term><see cref="F:Mono.Unix.Native.Errno.EILSEQ" /></term><description>An invalid wide character code was encountered</description></item><item><term><see cref="F:Mono.Unix.Native.Errno.ENOMEM" /></term><description>Insufficient storage space is available.</description></item></list><para>Any of the errors documented for the <see cref="M:Mono.Unix.Native.Syscall.write" /> system call may also be returned.
</para></block></returns>
        <remarks>
          <para>The <c>printf</c>() family of functions produces output according to a format as described below.  <c>printf</c>() writes output to the given output <paramref name="stream" />.</para>
          <para>These functions write the output under the control of a <paramref name="format" /> string that specifies how subsequent arguments (or arguments accessed via the variable-length argument facilities of <c>stdarg</c>(3)) are converted for output.
</para>
          <para>The format string is composed of zero or more directives: ordinary characters (not %), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments.  Each conversion specification is introduced by the % character.  The arguments must correspond properly (after type promotion) with the conversion specifier.  After the %, the following appear in sequence:</para>
          <list type="bullet">
            <item>
              <term>An optional field, consisting of a decimal digit string followed by a <c>$</c>, specifying the next argument to access.  If this field is not provided, the argument following the last argument accessed will be used.  Arguments are numbered starting at <c>1</c>.  If unaccessed arguments in the format string are interspersed with ones that are accessed the results will be indeterminate.</term>
            </item>
            <item>
              <term>Zero or more of the following flags:

<list type="table"><listheader><term>Flag</term><description>Description</description></listheader><item><term>'<c>#</c>'</term><description>The value should be converted to an "alternate form".  For <c>c</c>, <c>d</c>, <c>i</c>, <c>n</c>, <c>p</c>, <c>s</c>, and <c>u</c> conversions, this option has no effect.  For <c>o</c> conversions, the precision of the number is increased to force the first character of the output string to a zero (except if a zero value is printed with an explicit precision of zero).  For <c>x</c> and <c>X</c> conversions, a non-zero result has the string '<c>0x</c>' (or '<c>0X</c>' for <c>X</c> conversions) prepended to it. For <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, and <c>G</c> conversions, the result will always contain a decimal point, even if no digits follow it (normally, a decimal point appears in the results of those conversions only if a digit follows).  For <c>g</c> and <c>G</c> conversions, trailing zeros are not removed from the result as they would otherwise be.</description></item><item><term>'<c>0</c>' (zero)</term><description>Zero padding.  For all conversions except <c>n</c>, the converted value is padded on the left with zeros rather than blanks.  If a precision is given with a numeric conversion (<c>d</c>, <c>i</c>, <c>o</c>, <c>u</c>, <c>i</c>, <c>x</c>, and <c>X</c>), the 0 flag is ignored.</description></item><item><term>'<c>-</c>'</term><description>A negative field width flag; the converted value is to be left adjusted on the field boundary.  Except for <c>n</c> conversions, the converted value is padded on the right with blanks, rather than on the left with blanks or zeros.  A <c>-</c> overrides a <c>0</c> if both are given.</description></item><item><term>'<c />' (space)</term><description>A blank should be left before a positive number produced by a signed conversion (<c>a</c>, <c>A</c>, <c>d</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, <c>G</c>, or <c>i</c>).</description></item><item><term>'<c>+</c>'</term><description>A sign must always be placed before a number produced by a signed conversion.  A <c>+</c> overrides a space if both are used.</description></item><item><term>'<c>'</c>'</term><description>Decimal conversions (<c>d</c>, <c>u</c>, or <c>i</c>) or the integral portion of a floating point conversion (<c>f</c> or <c>F</c>) should be grouped and separated by thousands using the non-monetary separator returned by <see cref="M:Mono.Unix.Native.Syscall.localeconv" />(3).</description></item></list></term>
            </item>
            <item>
              <term>An optional decimal digit string specifying a minimum field width.  If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-adjustment flag has been given) to fill out the field width.</term>
            </item>
            <item>
              <term>An optional precision, in the form of a period . followed by an optional digit string.  If the digit string is omitted, the precision is taken as zero.  This gives the minimum number of digits to appear for <c>d</c>, <c>i</c>, <c>o</c>, <c>u</c>, <c>x</c>, and <c>X</c> conversions, the number of digits to appear after the decimal-point for <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, and <c>F</c> conversions, the maximum number of significant digits for <c>g</c> and <c>G</c> conversions, or the maximum number of characters to be printed from a string for <c>s</c> conversions.</term>
            </item>
            <item>
              <term>An optional length modifier, that specifies the size of the argument.  The following length modifiers are valid for the <c>d</c>, <c>i</c>, <c>n</c>, <c>o</c>, <c>u</c>, <c>x</c>, or <c>X</c> conversion:

<list type="table"><listheader><term>Modifier</term><description><c>d</c>, <c>i</c></description><description><c>o, u, x, X</c></description><description><c>n</c></description></listheader><item><term><c>hh</c></term><description><c>signed char</c></description><description><c>unsigned char</c></description><description><c>signed char *</c></description></item><item><term><c>h</c></term><description><c>short</c></description><description><c>unsigned short</c></description><description><c>short *</c></description></item><item><term><c>l</c> (ell)</term><description><c>long</c></description><description><c>unsigned long</c></description><description><c>unsigned long *</c></description></item><item><term><c>ll</c> (ell ell)</term><description><c>long long</c></description><description><c>unsigned long long</c></description><description><c>long long *</c></description></item><item><term><c>j</c></term><description><c>intmax_t</c></description><description><c>uintmax_t</c></description><description><c>intmax_t *</c></description></item><item><term><c>t</c></term><description><c>ptrdiff_t</c></description><description>(see note)</description><description><c>ptrdiff_t *</c></description></item><item><term><c>z</c></term><description>(see note)</description><description><c>size_t</c></description><description>(see note)</description></item><item><term><c>q</c><i>(deprecated)</i></term><description><c>quad_t</c></description><description><c>u_quad_t</c></description><description><c>quad_t *</c></description></item></list><block subset="none" type="note"><para>the <c>t</c> modifier, when applied to a <c>o</c>, <c>u</c>, <c>x</c>, or <c>X</c> conversion, indicates that the argument is of an unsigned type equivalent in size to a <c>ptrdiff_t</c>.  The <c>z</c> modifier, when applied to a <c>d</c> or <c>i</c> conversion, indicates that the argument is of a signed type equivalent in size to a <c>size_t</c>.  Similarly, when applied to an <c>n</c> conversion, it indicates that the argument is a pointer to a signed type equivalent in size to a <c>size_t</c>.
  </para></block><para>The following length modifier is valid for the <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, or <c>G</c> conversion:</para><list type="table"><listheader><term>Modifier</term><description><c>a, A, e, E, f, F, g, G</c></description></listheader><item><term><c>L</c></term><description><c>long double</c></description></item></list><para>The following length modifier is valid for the <c>c</c> or <c>s</c> conversion:</para><list type="table"><listheader><term>Modifier</term><description><c>c</c></description><description><c>s</c></description></listheader><item><term><c>l</c> (ell)</term><description><c>wint_t</c></description><description><c>wchar_t *</c></description></item></list></term>
            </item>
            <item>
              <term>A character that specifies the type of conversion to be applied.</term>
            </item>
          </list>
          <para>A field width or precision, or both, may be indicated by an asterisk '<c>*</c>' or an asterisk followed by one or more decimal digits and a '<c>$</c>' instead of a digit string.  In this case, an <i>int</i> argument supplies the field width or precision.  A negative field width is treated as a left adjustment flag followed by a positive field width; a negative precision is treated as though it were missing.  If a single format directive mixes positional (<c>nn$</c>) and non-positional arguments, the results are undefined
</para>
          <para>The conversion specifiers and their meanings are:</para>
          <list type="table">
            <listheader>
              <term>Specifier</term>
              <description>Meaning</description>
            </listheader>
            <item>
              <term>
                <c>diouxX</c>
              </term>
              <description>The <c>int</c> (or appropriate variant) argument is converted to signed decimal (<c>d</c> and <c>i</c>), unsigned octal (<c>o</c>), unsigned decimal (<c>u</c>), or unsigned hexadecimal (<c>x</c> and <c>X</c>) notation.  The letters "<c>abcdef</c>" are used for <c>x</c> conversions; the letters "<c>ABCDEF</c>" are used for <c>X</c> conversions.  The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros.</description>
            </item>
            <item>
              <term>
                <c>DOU</c>
              </term>
              <description>The <c>long int</c> argument is converted to signed decimal, unsigned octal, or unsigned decimal, as if the format had been <c>ld</c>, <c>lo</c>, or <c>lu</c> respectively.  These conversion characters are deprecated, and will eventually disappear.</description>
            </item>
            <item>
              <term>
                <c>eE</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted in the style <c>[-]d.dddedd</c> where there is one digit before the decimal-point character and the number of digits after it is equal to the precision; if the precision is missing, it is taken as 6; if the precision is zero, no decimal-point character appears.  An <c>E</c> conversion uses the letter '<c>E</c>' (rather than '<c>e</c>') to introduce the exponent.  The exponent always contains at least two digits; if the value is zero, the exponent is 00.</description>
              <para>For <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, and <c>G</c> conversions, positive and negative infinity are represented as <c>inf</c> and <c>-inf</c> respectively when using the lowercase conversion character, and <c>INF</c> and <c>-INF</c> respectively when using the uppercase conversion character.  Similarly, <c>NaN</c> is represented as <c>nan</c> when using the lowercase conversion, and <c>NAN</c> when using the uppercase conversion.</para>
            </item>
            <item>
              <term>
                <c>fF</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted to decimal notation in the style <c>[-]ddd.ddd</c>, where the number of digits after the decimal-point character is equal to the precision specification.  If the precision is missing, it is taken as 6; if the precision is explicitly zero, no decimal-point character appears. If a decimal point appears, at least one digit appears before it.</description>
            </item>
            <item>
              <term>
                <c>gG</c>
              </term>
              <description>The <c>double</c> argument is converted in style <c>f</c> or <c>e</c> (or <c>F</c> or <c>E</c> for <c>G</c> conversions). The precision specifies the number of significant digits.  If the precision is missing, 6 digits are given; if the precision is zero, it is treated as 1. Style <c>e</c> is used if the exponent from its conversion is less than -4 or greater than or equal to the precision.  Trailing zeros are removed from the fractional part of the result; a decimal point appears only if it is followed by at least one digit.</description>
            </item>
            <item>
              <term>
                <c>aA</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted to hexadecimal notation in the style <c>[-]0xh.hhhp[]d</c>, where the number of digits after the hexadecimal-point character is equal to the precision specification.  If the precision is missing, it is taken as enough to represent the floating-point number exactly, and no rounding occurs.  If the precision is zero, no hexadecimal-point character appears.  The <c>p</c> is a literal character '<c>p</c>', and the exponent consists of a positive or negative sign followed by a decimal number representing an exponent of 2.  The <c>A</c> conversion uses the prefix "<c>0X</c>" (rather than "<c>0x</c>"), the letters "<c>ABCDEF</c>" (rather than "<c>abcdef</c>") to represent the hex digits, and the letter '<c>P</c>' (rather than '<c>p</c>') to separate the mantissa and exponent.

<para>Note that there may be multiple valid ways to represent floating-point numbers in this hexadecimal format.  For example, <c>0x3.24p+0</c>, <c>0x6.48p-1</c> and <c>0xc.9p-2</c> are all equivalent.  The format chosen depends on the internal representation of the number, but the implementation guarantees that the length of the mantissa will be minimized.  Zeroes are always represented with a mantissa of 0 (preceded by a '<c>-</c>' if appropriate) and an exponent of +0.
</para></description>
            </item>
            <item>
              <term>
                <c>C</c>
              </term>
              <description>Treated as <c>c</c> with the <c>l</c> (ell) modifier.</description>
            </item>
            <item>
              <term>
                <c>c</c>
              </term>
              <description>The <c>int</c> argument is converted to an <c>unsigned char</c>, and the resulting character is written.

<para>If the <c>l</c> (ell) modifier is used, the <c>wint_t</c> argument shall be converted to a <c>wchar_t</c>, and the (potentially multi-byte) sequence representing the single wide character is written, including any shift sequences.  If a shift sequence is used, the shift state is also restored to the original state after the character.
</para></description>
            </item>
            <item>
              <term>
                <c>S</c>
              </term>
              <description>Treated as <c>s</c> with the <c>l</c> (ell) modifier.</description>
            </item>
            <item>
              <term>
                <c>s</c>
              </term>
              <description>
The <c>char *</c> argument is expected to be a pointer to an array of character type (pointer to a string).  Characters from the array are written up to (but not including) a terminating NUL character; if a precision is specified, no more than the number specified are written.  If a precision is given, no null character need be present; if the precision is not specified, or is greater than the size of the array, the array must contain a terminating NUL character.

<para>If the <c>l</c> (ell) modifier is used, the <c>wchar_t *</c> argument is expected to be a pointer to an array of wide characters (pointer to a wide string).  For each wide character in the string, the (potentially multi-byte) sequence representing the wide character is written, including any shift sequences.  If any shift sequence is used, the shift state is also restored to the original state after the string.  Wide characters from the array are written up to (but not including) a terminating wide NUL character; if a precision is specified, no more than the number of bytes specified are written (including shift sequences).  Partial characters are never written.  If a precision is given, no null character need be present; if the precision is not specified, or is greater than the number of bytes required to render the multibyte representation of the string, the array must contain a terminating wide NUL character.</para></description>
            </item>
            <item>
              <term>
                <c>p</c>
              </term>
              <description>The <c>void *</c> pointer argument is printed in hexadecimal (as if by '<c>%#x</c>' or '<c>%#lx</c>').</description>
            </item>
            <item>
              <term>
                <c>n</c>
              </term>
              <description>The number of characters written so far is stored into the integer indicated by the <c>int *</c> (or variant) pointer argument.  No argument is converted.</description>
            </item>
            <item>
              <term>
                <c>%</c>
              </term>
              <description> A '<c>%</c>' is written.  No argument is converted.  The complete conversion specification is '<c>%%</c>'.</description>
            </item>
          </list>
          <para>The decimal point character is defined in the program's locale (category <c>LC_NUMERIC</c>)
</para>
          <para>In no case does a non-existent or small field width cause truncation of a numeric field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="putc">
      <MemberSignature Language="C#" Value="public static int putc (int c, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;putc&quot; cdecl lasterr)int32 putc(int32 c, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Int32" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="c">The charater to write.</param>
        <param name="stream">The <c>FILE</c> stream to write to.</param>
        <summary>Output a character to a <c>FILE</c> stream.</summary>
        <returns>Returns the character written.  If an error occurrs, the value <see cref="F:Mono.Unix.Native.Stdlib.EOF" /> is returned.</returns>
        <remarks>The <c>putc</c>() function writes the character <paramref name="c" /> (converted to an "unsigned char") to the output stream pointed to by <paramref name="stream" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="putchar">
      <MemberSignature Language="C#" Value="public static int putchar (int c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;putchar&quot; cdecl lasterr)int32 putchar(int32 c) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">The charater to write.</param>
        <summary>Output a character to a <see cref="F:Mono.Unix.Native.Stdlib.stdout" />.</summary>
        <returns>Returns the character written.  If an error occurrs, the value <see cref="F:Mono.Unix.Native.Stdlib.EOF" /> is returned.</returns>
        <remarks>The <c>putchar</c>() function is identical to <see cref="M:Mono.Unix.Native.Stdlib.putc" />() with an output stream of <see cref="F:Mono.Unix.Native.Stdlib.stdout" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="puts">
      <MemberSignature Language="C#" Value="public static int puts (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;puts&quot; cdecl lasterr)int32 puts(string s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>Output a line to <see cref="F:Mono.Unix.Native.Stdlib.stdout" />.</summary>
        <returns>
          <para>The <c>fputs</c> function returns <c>0</c> on success and <see cref="F:Mono.Unix.Native.Stdlib.EOF" /> on error, and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</para>
          <block subset="none" type="usage">
            <para>The following errors are specified:</para>
            <list type="table">
              <listheader>
                <term>Error</term>
                <description>Details</description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EBADF" />
                </term>
                <description>The <paramref name="stream" /> argument not a writable stream.</description>
              </item>
            </list>
          </block>
          <para>
            <c>fputs</c> may also fail for any of the errors specified for the routines <see cref="M:Mono.Unix.Native.Syscall.write" />(2).
</para>
        </returns>
        <remarks>The function <c>puts</c>() writes the string <paramref name="s" />, and a terminating newline character, to the stream <see cref="F:Mono.Unix.Native.Stdlib.stdout" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="raise">
      <MemberSignature Language="C#" Value="public static int raise (Mono.Unix.Native.RealTimeSignum rts);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 raise(valuetype Mono.Unix.Native.RealTimeSignum rts) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rts" Type="Mono.Unix.Native.RealTimeSignum" />
      </Parameters>
      <Docs>
        <param name="rts">A realtime signal to send to the current process.</param>
        <summary>Send a realtime signal to the current process.</summary>
        <returns>The <c>raise</c>() function returns the value 0 if successful; otherwise the value -1 is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.
        </returns>
        <remarks>The <c>raise</c>() function sends the signal <paramref name="sig" /> to the current process.</remarks>
      </Docs>
    </Member>
    <Member MemberName="raise">
      <MemberSignature Language="C#" Value="public static int raise (Mono.Unix.Native.Signum sig);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 raise(valuetype Mono.Unix.Native.Signum sig) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sig" Type="Mono.Unix.Native.Signum" />
      </Parameters>
      <Docs>
        <param name="sig">A signal to send to the current process.</param>
        <summary>Send a signal to the current process.</summary>
        <returns>The <c>raise</c>() function returns the value 0 if successful; otherwise the value -1 is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.
</returns>
        <remarks>The <c>raise</c>() function sends the signal <paramref name="sig" /> to the current process.</remarks>
      </Docs>
    </Member>
    <Member MemberName="rand">
      <MemberSignature Language="C#" Value="public static int rand ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;rand&quot; cdecl)int32 rand() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Generates a random number.</summary>
        <returns>To be added.</returns>
        <remarks>The <c>rand</c>() function computes a sequence of pseudo-random integers in the range of 0 to <see cref="F:Mono.Unix.Native.Stdlib.RAND_MAX" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="RAND_MAX">
      <MemberSignature Language="C#" Value="public static readonly int RAND_MAX;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 RAND_MAX" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2147483647</MemberValue>
      <Docs>
        <summary>The maximum value returned by <see cref="M:Mono.Unix.Native.Stdlib.rand" />(3).</summary>
        <remarks>The maximum value returned by <see cref="M:Mono.Unix.Native.Stdlib.rand" />(3).</remarks>
      </Docs>
    </Member>
    <Member MemberName="realloc">
      <MemberSignature Language="C#" Value="public static IntPtr realloc (IntPtr ptr, ulong size);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_realloc&quot; cdecl lasterr)native int realloc(native int ptr, unsigned int64 size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="size" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="ptr">Pointer to the start of a memory area to reallocate.</param>
        <param name="size">The new size for the allocated memory.</param>
        <summary>Reallocate a memory block.</summary>
        <returns>The <c>realloc</c>() function returns a pointer, possibly identical to <paramref name="ptr" />, to the allocated memory if successful; otherwise a <see cref="F:System.IntPtr.Zero" /> pointer is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> returns <see cref="F:Mono.Unix.Native.Errno.ENOMEM" />. The <c>realloc</c>() function always leaves the original buffer intact when an error occurs.</returns>
        <remarks>The <c>realloc</c>() function changes the size of the previously allocated memory referenced by <paramref name="ptr" /> to <paramref name="size" /> bytes.  The contents of the memory are unchanged up to the lesser of the new and old sizes.  If the new size is larger, the value of the newly allocated portion of the memory is undefined.  If the requested memory cannot be allocated, <see cref="F:System.IntPtr.Zero" /> is returned and the memory referenced by <paramref name="ptr" /> is valid and unchanged.  If memory can be allocated, the memory referenced by <paramref name="ptr" /> is freed and a pointer to the newly allocated memory is returned.  Note that this may be different from the value passed as <paramref name="ptr" />.  If <paramref name="ptr" /> is <see cref="F:System.IntPtr.Zero" />, the <c>realloc</c>() function behaves identically to <see cref="M:Mono.Unix.Native.Stdlib.malloc" />() for the specified size.</remarks>
      </Docs>
    </Member>
    <Member MemberName="remove">
      <MemberSignature Language="C#" Value="public static int remove (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;remove&quot; cdecl lasterr)int32 remove(string filename) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">To be added.</param>
        <summary>Remove a directory entry.</summary>
        <returns>The <c>remove</c>() function returns the value 0 if successful; otherwise the value -1 is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</returns>
        <remarks>
          <para>The <c>remove</c>() function removes the file or directory specified by <paramref name="path" />.</para>
          <para>If <paramref name="path" /> specifies a directory, <c>remove(<paramref name="path" />)</c> is the equivalent of <c><see cref="M:Mono.Unix.Native.Syscall.rmdir" />(<paramref name="path" />)</c>.  Otherwise, it is the equivalent of <c><see cref="M:Mono.Unix.Native.Syscall.unlink" />(<paramref name="path" />)</c>.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="rename">
      <MemberSignature Language="C#" Value="public static int rename (string oldpath, string newpath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;rename&quot; cdecl lasterr)int32 rename(string oldpath, string newpath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldpath" Type="System.String" />
        <Parameter Name="newpath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldpath">The old path name.</param>
        <param name="newpath">The new path name.</param>
        <summary>Rename oldpath to newpath.</summary>
        <returns>The <c>rename</c>() function returns the value 0 if successful; otherwise the value -1 is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</returns>
        <remarks>
          <para>The <c>rename</c>() system call causes the link named <paramref name="oldpath" /> to be renamed as <paramref name="newpath" />.  If <paramref name="newpath" /> exists, it is first removed.  Both <paramref name="oldpath" /> and <paramref name="newpath" /> must be of the same type (that is, both directories or both non-directories), and must reside on the same file system.</para>
          <para>The <c>rename</c>() system call guarantees that if <paramref name="newpath" /> already exists, an instance of <paramref name="newpath" /> will always exist, even if the system should crash in the middle of the operation.</para>
          <para>If the final component of <paramref name="oldpath" /> is a symbolic link, the symbolic link is renamed, not the file or directory to which it points.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="rewind">
      <MemberSignature Language="C#" Value="public static int rewind (IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_rewind&quot; cdecl lasterr)int32 rewind(native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="stream">
          <c>FILE</c> stream to set file position indicator to the beginning of the file.</param>
        <summary>Set the file position indicator of the <c>FILE</c> stream to the beginning of the file.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>The <c>rewind</c>() function sets the file position indicator for the stream pointed to by <paramref name="stream" /> to the beginning of the file.  It is equivalent to:</para>
          <para>
            <see cref="M:Mono.Unix.Native.Stdlib.fseek" />(<paramref name="stream" />, 0, <see cref="F:Mono.Unix.Native.SeekFlags.SEEK_SET" />)
</para>
          <para>except that the error indicator for the stream is also cleared (see <see cref="M:Mono.Unix.Native.Stdlib.clearerr" />(3)).</para>
          <para>Since <c>rewind</c>() does not return a value, an application wishing to detect errors should call <c><see cref="M:Mono.Unix.Native.Stdlib.SetLastError" />((<see cref="T:Mono.Unix.Native.Error" />)0)</c>, then call <c>rewind</c>(), and if <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> is non-zero, assume an error has occurred.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="setbuf">
      <MemberSignature Language="C#" Value="public static int setbuf (IntPtr stream, byte* buf);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 setbuf(native int stream, unsigned int8* buf) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
        <Parameter Name="buf" Type="System.Byte*" />
      </Parameters>
      <Docs>
        <param name="stream">The <c>FILE</c> stream to set buffering operations on.</param>
        <param name="buf">The buffer to use for buffering.</param>
        <summary>Control <c>FILE</c> stream buffering operations.</summary>
        <returns>The <c>setbuf</c>() function returns the value 0 if successful; otherwise the value -1 is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</returns>
        <remarks>
          <para>The <c>setbuf</c> function disables <c>FILE</c> stream buffering if <paramref name="buf" /> is <see cref="F:System.IntPtr.Zero" />, otherwise full buffering is enabled (and <paramref name="buf" /> is used as the buffer).
</para>
          <para>The <c>setbuf</c> function is an alias for calls to <see /><see cref="M:Mono.Unix.Native.Stdlib.setvbuf" />.  Except for the lack of a return value, the <c>setbuf</c> function is exactly equivalent to the call:</para>
          <para>
            <see cref="M:Mono.Unix.Native.Stdlib.setvbuf" /> (<paramref name="stream" />, <paramref name="buf" />, <paramref name="buf" /> ? <see cref="M:Mono.Unix.Native.Stdlib._IOFBF" /> : <see cref="M:Mono.Unix.Native.Stdlib._IONBF" />, <see cref="M:Mono.Unix.Native.Stdlib.BUFSIZ" />);
</para>
          <para>This function requires that <paramref name="buf" /> refer to at least <see cref="M:Mono.Unix.Native.Stdlib.BUFSIZ" /> bytes of memory.  This memory must remain valid until the next <c>setbuf</c>, <see cref="M:Mono.Unix.Native.Stdlib.setvbuf" />, or <see cref="M:Mono.Unix.Native.Stdlib.fclose" /> call.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="setbuf">
      <MemberSignature Language="C#" Value="public static int setbuf (IntPtr stream, IntPtr buf);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_setbuf&quot; cdecl lasterr)int32 setbuf(native int stream, native int buf) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
        <Parameter Name="buf" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="stream">The <c>FILE</c> stream to set buffering operations on.</param>
        <param name="buf">The buffer to use for buffering.</param>
        <summary>Control <c>FILE</c> stream buffering operations.</summary>
        <returns>The <c>setbuf</c>() function returns the value 0 if successful; otherwise the value -1 is returned and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</returns>
        <remarks>
          <para>The <c>setbuf</c> function disables <c>FILE</c> stream buffering if <paramref name="buf" /> is <see cref="F:System.IntPtr.Zero" />, otherwise full buffering is enabled (and <paramref name="buf" /> is used as the buffer).
</para>
          <para>The <c>setbuf</c> function is an alias for calls to <see /><see cref="M:Mono.Unix.Native.Stdlib.setvbuf" />.  Except for the lack of a return value, the <c>setbuf</c> function is exactly equivalent to the call:</para>
          <para>
            <see cref="M:Mono.Unix.Native.Stdlib.setvbuf" /> (<paramref name="stream" />, <paramref name="buf" />, <paramref name="buf" /> ? <see cref="M:Mono.Unix.Native.Stdlib._IOFBF" /> : <see cref="M:Mono.Unix.Native.Stdlib._IONBF" />, <see cref="M:Mono.Unix.Native.Stdlib.BUFSIZ" />);
</para>
          <para>This function requires that <paramref name="buf" /> refer to at least <see cref="M:Mono.Unix.Native.Stdlib.BUFSIZ" /> bytes of memory.  This memory must remain valid until the next <c>setbuf</c>, <see cref="M:Mono.Unix.Native.Stdlib.setvbuf" />, or <see cref="M:Mono.Unix.Native.Stdlib.fclose" /> call.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="protected static void SetLastError (Mono.Unix.Native.Errno error);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetLastError(valuetype Mono.Unix.Native.Errno error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="Mono.Unix.Native.Errno" />
      </Parameters>
      <Docs>
        <param name="error">To be added.</param>
        <summary>Writes <c>errno</c>.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSignalAction">
      <MemberSignature Language="C#" Value="public static int SetSignalAction (Mono.Unix.Native.RealTimeSignum rts, Mono.Unix.Native.SignalAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SetSignalAction(valuetype Mono.Unix.Native.RealTimeSignum rts, valuetype Mono.Unix.Native.SignalAction action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rts" Type="Mono.Unix.Native.RealTimeSignum" />
        <Parameter Name="action" Type="Mono.Unix.Native.SignalAction" />
      </Parameters>
      <Docs>
        <param name="rts">To be added.</param>
        <param name="action">
          A <see cref="T:Mono.Unix.Native.SignalAction" /> specifying what to
          do when the <paramref name="signum" /> signal is emitted.
        </param>
        <summary>
          Specifies what should happen when a signal is emitted.
        </summary>
        <returns>
          <para>
            A <see cref="T:System.Int32" />; if equal to <c>0</c>, the call
            was successful.  <c>-1</c> is returned on failure, and sets 
            <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" />
            to indicate the error.
          </para>
          <block subset="none" type="usage">
            <para>
              Possible errors include:
            </para>
            <list type="table">
              <listheader>
                <term>
                  Error
                </term>
                <description>
                  Details
                </description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EINVAL" />
                </term>
                <description>
                  <para>
                    <paramref name="signum" /> is invalid.
                  </para>
                </description>
              </item>
            </list>
          </block>
        </returns>
        <remarks>
          <para>
            This is the safer, restricted form of 
            <see cref="M:Mono.Unix.Native.Stdlib.signal(Mono.Unix.Native.RealTimeSignum,Mono.Unix.Native.SignalHandler)" />.
            While <c>signal</c>(2) permits an arbitrary method to be set as
            the signal handler, this method permits specifying only the
            default, ignore, or error handlers.
          </para>
          <block subset="none" type="behaviors">
            <para>
              If <paramref name="action" /> is
              <see cref="F:Mono.Unix.Native.SignalAction.Default" />, then
              this method is equivalent to 
              <c>signal(<paramref name="signum" />, SIG_DFL)</c>.
            </para>
            <para>
              If <paramref name="action" /> is
              <see cref="F:Mono.Unix.Native.SignalAction.Ignore" />, then
              this method is equivalent to 
              <c>signal(<paramref name="signum" />, SIG_IGN)</c>.
            </para>
            <para>
              If <paramref name="action" /> is
              <see cref="F:Mono.Unix.Native.SignalAction.Error" />, then
              this method is equivalent to 
              <c>signal(<paramref name="signum" />, SIG_ERR)</c>.
            </para>
          </block>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSignalAction">
      <MemberSignature Language="C#" Value="public static int SetSignalAction (Mono.Unix.Native.Signum signal, Mono.Unix.Native.SignalAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SetSignalAction(valuetype Mono.Unix.Native.Signum signal, valuetype Mono.Unix.Native.SignalAction action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signal" Type="Mono.Unix.Native.Signum" />
        <Parameter Name="action" Type="Mono.Unix.Native.SignalAction" />
      </Parameters>
      <Docs>
        <param name="signal">To be added.</param>
        <param name="action">
          A <see cref="T:Mono.Unix.Native.SignalAction" /> specifying what to
          do when the <paramref name="signum" /> signal is emitted.
        </param>
        <summary>
          Specifies what should happen when a signal is emitted.
        </summary>
        <returns>
          <para>
            A <see cref="T:System.Int32" />; if equal to <c>0</c>, the call
            was successful.  <c>-1</c> is returned on failure, and sets 
            <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" />
            to indicate the error.
          </para>
          <block subset="none" type="usage">
            <para>
              Possible errors include:
            </para>
            <list type="table">
              <listheader>
                <term>
                  Error
                </term>
                <description>
                  Details
                </description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EINVAL" />
                </term>
                <description>
                  <para>
                    <paramref name="signum" /> is invalid.
                  </para>
                </description>
              </item>
            </list>
          </block>
        </returns>
        <remarks>
          <para>
            This is the safer, restricted form of 
            <see cref="M:Mono.Unix.Native.Stdlib.signal(Mono.Unix.Native.Signum,Mono.Unix.Native.SignalHandler)" />.
            While <c>signal</c>(2) permits an arbitrary method to be set as
            the signal handler, this method permits specifying only the
            default, ignore, or error handlers.
          </para>
          <block subset="none" type="behaviors">
            <para>
              If <paramref name="action" /> is
              <see cref="F:Mono.Unix.Native.SignalAction.Default" />, then
              this method is equivalent to 
              <c>signal(<paramref name="signum" />, SIG_DFL)</c>.
            </para>
            <para>
              If <paramref name="action" /> is
              <see cref="F:Mono.Unix.Native.SignalAction.Ignore" />, then
              this method is equivalent to 
              <c>signal(<paramref name="signum" />, SIG_IGN)</c>.
            </para>
            <para>
              If <paramref name="action" /> is
              <see cref="F:Mono.Unix.Native.SignalAction.Error" />, then
              this method is equivalent to 
              <c>signal(<paramref name="signum" />, SIG_ERR)</c>.
            </para>
          </block>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="setvbuf">
      <MemberSignature Language="C#" Value="public static int setvbuf (IntPtr stream, byte* buf, int mode, ulong size);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 setvbuf(native int stream, unsigned int8* buf, int32 mode, unsigned int64 size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
        <Parameter Name="buf" Type="System.Byte*" />
        <Parameter Name="mode" Type="System.Int32" />
        <Parameter Name="size" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="stream">The <c>FILE</c> stream to set buffering behavior on.</param>
        <param name="buf">The buffer to use for buffering.</param>
        <param name="mode">The type of buffering to start using with <paramref name="stream" />.</param>
        <param name="size">The size of the buffer <paramref name="buf" />.</param>
        <summary>Control <c>FILE</c> stream buffering operations.</summary>
        <returns>The <c>setvbuf</c>() function returns 0 on success, or <see cref="F:Mono.Unix.Native.Stdlib.EOF" /> if the request cannot be honored (note that the stream is still functional in this case).</returns>
        <remarks>
          <para>The three types of buffering available are unbuffered, block buffered, and line buffered.  When an output stream is unbuffered, information appears on the destination file or terminal as soon as written; when it is block buffered many characters are saved up and written as a block; when it is line buffered characters are saved up until a new- line is output or input is read from any stream attached to a terminal device (typically <see cref="F:Mono.Unix.Native.Stdlib.stdin" />).  The function <see cref="M:Mono.Unix.Native.Stdlib.fflush" />(3) may be used to force the block out early.  (See <see cref="M:Mono.Unix.Native.Stdlib.fclose" />(3).)
</para>
          <para>Normally all files are block buffered.  When the first I/O operation occurs on a file, <see cref="M:Mono.Unix.Native.Stdlib.malloc" />(3) is called, and an optimally-sized buffer is obtained.  If a stream refers to a terminal (as <see cref="F:Mono.Unix.Native.Stdlib.stdout" /> normally does) it is line buffered.  The standard error stream <see cref="F:Mono.Unix.Native.Stdlib.stderr" /> is always unbuffered.</para>
          <para>The <c>setvbuf</c> function may be used to alter the buffering behavior of a stream.  The <paramref name="mode" /> argument must be one of the following three values:
</para>
          <list type="table">
            <listheader>
              <term>Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>
                <see cref="F:Mono.Unix.Native.Stdlib._IONBF" />
              </term>
              <description>unbuffered</description>
            </item>
            <item>
              <term>
                <see cref="F:Mono.Unix.Native.Stdlib._IOLBF" />
              </term>
              <description>line buffered</description>
            </item>
            <item>
              <term>
                <see cref="F:Mono.Unix.Native.Stdlib._IOFBF" />
              </term>
              <description>fully buffered</description>
            </item>
          </list>
          <para>The <paramref name="size" /> argument may be given as zero to obtain deferred optimal-size buffer allocation as usual.  If it is not zero, then except for unbuffered files, the <paramref name="buf" /> argument should point to a buffer at least <paramref name="size" /> bytes long; this buffer will be used instead of the current buffer.  If <paramref name="buf" /> is not <see langword="null" />, it is the caller's responsibility to <see cref="M:Mono.Unix.Native.Stdlib.free" />(3) this buffer after closing the stream.
</para>
          <para>The <c>setvbuf</c>() function may be used at any time, but may have peculiar side effects (such as discarding input or flushing output) if the stream is ''active''.  Portable applications should call it only once on any given stream, and before any I/O is performed.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="setvbuf">
      <MemberSignature Language="C#" Value="public static int setvbuf (IntPtr stream, IntPtr buf, int mode, ulong size);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_setvbuf&quot; cdecl lasterr)int32 setvbuf(native int stream, native int buf, int32 mode, unsigned int64 size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IntPtr" />
        <Parameter Name="buf" Type="System.IntPtr" />
        <Parameter Name="mode" Type="System.Int32" />
        <Parameter Name="size" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="stream">The <c>FILE</c> stream to set buffering behavior on.</param>
        <param name="buf">The buffer to use for buffering.</param>
        <param name="mode">The type of buffering to start using with <paramref name="stream" />.</param>
        <param name="size">The size of the buffer <paramref name="buf" />.</param>
        <summary>Control <c>FILE</c> stream buffering.</summary>
        <returns>The <c>setvbuf</c>() function returns 0 on success, or <see cref="F:Mono.Unix.Native.Stdlib.EOF" /> if the request cannot be honored (note that the stream is still functional in this case).</returns>
        <remarks>
          <para>The three types of buffering available are unbuffered, block buffered, and line buffered.  When an output stream is unbuffered, information appears on the destination file or terminal as soon as written; when it is block buffered many characters are saved up and written as a block; when it is line buffered characters are saved up until a new- line is output or input is read from any stream attached to a terminal device (typically <see cref="F:Mono.Unix.Native.Stdlib.stdin" />).  The function <see cref="M:Mono.Unix.Native.Stdlib.fflush" />(3) may be used to force the block out early.  (See <see cref="M:Mono.Unix.Native.Stdlib.fclose" />(3).)
</para>
          <para>Normally all files are block buffered.  When the first I/O operation occurs on a file, <see cref="M:Mono.Unix.Native.Stdlib.malloc" />(3) is called, and an optimally-sized buffer is obtained.  If a stream refers to a terminal (as <see cref="F:Mono.Unix.Native.Stdlib.stdout" /> normally does) it is line buffered.  The standard error stream <see cref="F:Mono.Unix.Native.Stdlib.stderr" /> is always unbuffered.</para>
          <para>The <c>setvbuf</c> function may be used to alter the buffering behavior of a stream.  The <paramref name="mode" /> argument must be one of the following three values:
</para>
          <list type="table">
            <listheader>
              <term>Value</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>
                <see cref="F:Mono.Unix.Native.Stdlib._IONBF" />
              </term>
              <description>unbuffered</description>
            </item>
            <item>
              <term>
                <see cref="F:Mono.Unix.Native.Stdlib._IOLBF" />
              </term>
              <description>line buffered</description>
            </item>
            <item>
              <term>
                <see cref="F:Mono.Unix.Native.Stdlib._IOFBF" />
              </term>
              <description>fully buffered</description>
            </item>
          </list>
          <para>The <paramref name="size" /> argument may be given as zero to obtain deferred optimal-size buffer allocation as usual.  If it is not zero, then except for unbuffered files, the <paramref name="buf" /> argument should point to a buffer at least <paramref name="size" /> bytes long; this buffer will be used instead of the current buffer.  If <paramref name="buf" /> is not <see cref="System.IntPtr.Zero" />, it is the caller's responsibility to <see cref="M:Mono.Unix.Native.Stdlib.free" />(3) this buffer after closing the stream.
</para>
          <para>The <c>setvbuf</c>() function may be used at any time, but may have peculiar side effects (such as discarding input or flushing output) if the stream is ''active''.  Portable applications should call it only once on any given stream, and before any I/O is performed.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SIG_DFL">
      <MemberSignature Language="C#" Value="public static readonly Mono.Unix.Native.SignalHandler SIG_DFL;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Mono.Unix.Native.SignalHandler SIG_DFL" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Mono.Unix.Native.SignalHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Default signal behavior.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SIG_ERR">
      <MemberSignature Language="C#" Value="public static readonly Mono.Unix.Native.SignalHandler SIG_ERR;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Mono.Unix.Native.SignalHandler SIG_ERR" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Mono.Unix.Native.SignalHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Error signal.</summary>
        <remarks>This value is returned by <see cref="M:Mono.Unix.Native.Stdlib.signal" />(3) when an error occurs.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SIG_IGN">
      <MemberSignature Language="C#" Value="public static readonly Mono.Unix.Native.SignalHandler SIG_IGN;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Mono.Unix.Native.SignalHandler SIG_IGN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Mono.Unix.Native.SignalHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ignore the signal.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="signal">
      <MemberSignature Language="C#" Value="public static Mono.Unix.Native.SignalHandler signal (Mono.Unix.Native.Signum signum, Mono.Unix.Native.SignalHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Unix.Native.SignalHandler signal(valuetype Mono.Unix.Native.Signum signum, class Mono.Unix.Native.SignalHandler handler) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This is not safe; use Mono.Unix.UnixSignal for signal delivery or SetSignalAction()")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Mono.Unix.Native.SignalHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signum" Type="Mono.Unix.Native.Signum" />
        <Parameter Name="handler" Type="Mono.Unix.Native.SignalHandler" />
      </Parameters>
      <Docs>
        <param name="signum">The signal to handle.</param>
        <param name="handler">The handler to invoke when the process receives a <paramref name="signum" /> signal.</param>
        <summary>Register a handler for a given signal.</summary>
        <returns>
          <para>The previous value of the signal handler, or <see cref="F:Mono.Unix.Native.Stdlib.SIG_ERR" /> on error and <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> indicates the error.</para>
          <block subset="none" type="usage">
            <para>The following errors are specified:</para>
            <list type="table">
              <listheader>
                <term>Error</term>
                <description>Details</description>
              </listheader>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EINVAL" />
                </term>
                <description>The <paramref name="signum" /> argument is not a valid signal number.</description>
              </item>
              <item>
                <term>
                  <see cref="F:Mono.Unix.Native.Errno.EINVAL" />
                </term>
                <description>An attempt is made to ignore or supply a handler for <see cref="F:Mono.Unix.Native.Signum.SIGKILL" /> or <see cref="F:Mono.Unix.Native.Signum.SIGSTOP" />.</description>
              </item>
            </list>
          </block>
        </returns>
        <remarks>
          <block subset="none" type="note">
            <para>
              This method should not be used in new code, as the Platform Invoke
              mechanism is not signal-safe, yet the Platform Invoke mechanism is
              required for unmanaged code to invoke managed code.
            </para>
            <para>
              New code should use the replacement method
              <see cref="M:Mono.Unix.Native.Stdlib.SetSignalAction" /> or the
              type <see cref="T:Mono.Unix.UnixSignal" />.
            </para>
          </block>
          <para>This signal() facility is a simplified interface to the more general <see cref="M:Mono.Unix.Native.Syscall.sigaction" />(2) facility.</para>
          <para>Signals allow the manipulation of a process from outside its domain as well as allowing the process to manipulate itself or copies of itself (children).  There are two general types of signals: those that cause termination of a process and those that do not.  Signals which cause termination of a program might result from an irrecoverable error or might be the result of a user at a terminal typing the 'interrupt' character.  Signals are used when a process is stopped because it wishes to access its control terminal while in the background (see <c>tty</c>(4)).  Signals are optionally generated when a process resumes after being stopped, when the status of child processes changes, or when input is ready at the control terminal.  Most signals result in the termination of the process receiving them if no action is taken; some signals instead cause the process receiving them to be stopped, or are simply discarded if the process has not requested otherwise. Except for the <see cref="F:Mono.Unix.Native.Signum.SIGKILL" /> and <see cref="F:Mono.Unix.Native.Signum.SIGSTOP" /> signals, the <c>signal</c>() function allows for a signal to be caught, to be ignored, or to generate an interrupt.
</para>
          <para>The <paramref name="sig" /> argument specifies which signal was received.  The <paramref name="func" /> procedure allows a user to choose the action upon receipt of a signal.  To set the default action of the signal to occur as listed above, <paramref name="func" /> should be <see cref="F:Mono.Unix.Native.Stdlib.SIG_DFL" />.  A <see cref="F:Mono.Unix.Native.Stdlib.SIG_DFL" /> resets the default action. To ignore the signal func should be <see cref="F:Mono.Unix.Native.Stdlib.SIG_IGN" />.  This will cause subsequent instances of the signal to be ignored and pending instances to be discarded.  If <see cref="F:Mono.Unix.Native.Stdlib.SIG_IGN" /> is not used, further occurrences of the signal are automatically blocked and <paramref name="func" /> is called.
</para>
          <para>The handled signal is unblocked when the function returns and the process continues from where it left off when the signal occurred.
</para>
          <para>For some system calls, if a signal is caught while the call is executing and the call is prematurely terminated, the call is automatically restarted.  (The handler is installed using the SA_RESTART flag with <see cref="M:Mono.Unix.Native.Syscall.sigaction" />(2).)  The affected system calls include <see cref="M:Mono.Unix.Native.Syscall.read" />(2), <see cref="M:Mono.Unix.Native.Syscall.write" />(2), <see cref="M:Mono.Unix.Native.Syscall.sendto" />(2), <see cref="M:Mono.Unix.Native.Syscall.recvfrom" />(2), <see cref="M:Mono.Unix.Native.Syscall.sendmsg" />(2) and <see cref="M:Mono.Unix.Native.Syscall.recvmsg" />(2) on a communications channel or a low speed device and during a <see cref="M:Mono.Unix.Native.Syscall.ioctl" />(2) or <see cref="M:Mono.Unix.Native.Syscall.wait" />(2).  However, calls that have already committed are not restarted, but instead return a partial success (for example, a short read count).  These semantics could be changed with <see cref="M:Mono.Unix.Native.Syscall.siginterrupt" />(3)
</para>
          <para>When a process which has installed signal handlers forks, the child process inherits the signals.  All caught signals may be reset to their default action by a call to the <see cref="M:Mono.Unix.Native.Syscall.execve" />(2) function; ignored signals remain ignored.
</para>
          <para>If a process explicitly specifies <see cref="F:Mono.Unix.Native.Stdlib.SIG_IGN" /> as the action for the signal <see cref="F:Mono.Unix.Native.Stdlib.SIGCHLD" />, the system will not create zombie processes when children of the calling process exit.  As a consequence, the system will discard the exit status from the child processes.  If the calling process subsequently issues a call to <see cref="M:Mono.Unix.Native.Syscall.wait" />(2) or equivalent, it will block until all of the calling process's children terminate, and then return a value of -1 with <see cref="M:Mono.Unix.Native.Stdlib.GetLastError" /> returning <see cref="F:Mono.Unix.Native.Errno.ECHILD" />.
</para>
        </remarks>
        <altmember cref="M:Mono.Unix.Native.Stdlib.SetSignalAction" />
        <altmember cref="T:Mono.Unix.UnixSignal" />
      </Docs>
    </Member>
    <Member MemberName="snprintf">
      <MemberSignature Language="C#" Value="public static int snprintf (System.Text.StringBuilder s, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 snprintf(class System.Text.StringBuilder s, string message) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Text.StringBuilder" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The buffer to print the message into.</param>
        <param name="message">The message to print.</param>
        <summary>Print a string into a buffer.</summary>
        <returns>Returns the number of characters printed or the number of characters that would have been printed if the <paramref name="size" /> were unlimited (again, not including the final '<c>\0</c>').</returns>
        <remarks>The <c>snprintf</c> function will fill at most <see cref="P:System.Text.StringBuilder.Capacity" /> characters of the input buffer with the string <paramref name="message" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="snprintf">
      <MemberSignature Language="C#" Value="public static int snprintf (System.Text.StringBuilder s, string format, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 snprintf(class System.Text.StringBuilder s, string format, object[] parameters) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Not necessarily portable due to cdecl restrictions.
Use snprintf (StringBuilder, string) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Text.StringBuilder" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The buffer to print the message into.</param>
        <param name="format">The message format string.</param>
        <param name="parameters">Arguments for the message format string.</param>
        <summary>Print a string into a buffer.</summary>
        <returns>Returns the number of characters printed or the number of characters that would have been printed if the <paramref name="size" /> were unlimited (again, not including the final '<c>\0</c>').</returns>
        <remarks>
          <para>The <c>snprintf</c>() family of functions produces output according to a format as described below.  <c>snprintf</c>() writes output to the given output <paramref name="stream" />.</para>
          <para>These functions write the output under the control of a <paramref name="format" /> string that specifies how subsequent arguments (or arguments accessed via the variable-length argument facilities of <c>stdarg</c>(3)) are converted for output.
</para>
          <para>The format string is composed of zero or more directives: ordinary characters (not %), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments.  Each conversion specification is introduced by the % character.  The arguments must correspond properly (after type promotion) with the conversion specifier.  After the %, the following appear in sequence:</para>
          <list type="bullet">
            <item>
              <term>An optional field, consisting of a decimal digit string followed by a <c>$</c>, specifying the next argument to access.  If this field is not provided, the argument following the last argument accessed will be used.  Arguments are numbered starting at <c>1</c>.  If unaccessed arguments in the format string are interspersed with ones that are accessed the results will be indeterminate.</term>
            </item>
            <item>
              <term>Zero or more of the following flags:

<list type="table"><listheader><term>Flag</term><description>Description</description></listheader><item><term>'<c>#</c>'</term><description>The value should be converted to an "alternate form".  For <c>c</c>, <c>d</c>, <c>i</c>, <c>n</c>, <c>p</c>, <c>s</c>, and <c>u</c> conversions, this option has no effect.  For <c>o</c> conversions, the precision of the number is increased to force the first character of the output string to a zero (except if a zero value is printed with an explicit precision of zero).  For <c>x</c> and <c>X</c> conversions, a non-zero result has the string '<c>0x</c>' (or '<c>0X</c>' for <c>X</c> conversions) prepended to it. For <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, and <c>G</c> conversions, the result will always contain a decimal point, even if no digits follow it (normally, a decimal point appears in the results of those conversions only if a digit follows).  For <c>g</c> and <c>G</c> conversions, trailing zeros are not removed from the result as they would otherwise be.</description></item><item><term>'<c>0</c>' (zero)</term><description>Zero padding.  For all conversions except <c>n</c>, the converted value is padded on the left with zeros rather than blanks.  If a precision is given with a numeric conversion (<c>d</c>, <c>i</c>, <c>o</c>, <c>u</c>, <c>i</c>, <c>x</c>, and <c>X</c>), the 0 flag is ignored.</description></item><item><term>'<c>-</c>'</term><description>A negative field width flag; the converted value is to be left adjusted on the field boundary.  Except for <c>n</c> conversions, the converted value is padded on the right with blanks, rather than on the left with blanks or zeros.  A <c>-</c> overrides a <c>0</c> if both are given.</description></item><item><term>'<c />' (space)</term><description>A blank should be left before a positive number produced by a signed conversion (<c>a</c>, <c>A</c>, <c>d</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, <c>G</c>, or <c>i</c>).</description></item><item><term>'<c>+</c>'</term><description>A sign must always be placed before a number produced by a signed conversion.  A <c>+</c> overrides a space if both are used.</description></item><item><term>'<c>'</c>'</term><description>Decimal conversions (<c>d</c>, <c>u</c>, or <c>i</c>) or the integral portion of a floating point conversion (<c>f</c> or <c>F</c>) should be grouped and separated by thousands using the non-monetary separator returned by <see cref="M:Mono.Unix.Native.Syscall.localeconv" />(3).</description></item></list></term>
            </item>
            <item>
              <term>An optional decimal digit string specifying a minimum field width.  If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-adjustment flag has been given) to fill out the field width.</term>
            </item>
            <item>
              <term>An optional precision, in the form of a period . followed by an optional digit string.  If the digit string is omitted, the precision is taken as zero.  This gives the minimum number of digits to appear for <c>d</c>, <c>i</c>, <c>o</c>, <c>u</c>, <c>x</c>, and <c>X</c> conversions, the number of digits to appear after the decimal-point for <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, and <c>F</c> conversions, the maximum number of significant digits for <c>g</c> and <c>G</c> conversions, or the maximum number of characters to be printed from a string for <c>s</c> conversions.</term>
            </item>
            <item>
              <term>An optional length modifier, that specifies the size of the argument.  The following length modifiers are valid for the <c>d</c>, <c>i</c>, <c>n</c>, <c>o</c>, <c>u</c>, <c>x</c>, or <c>X</c> conversion:

<list type="table"><listheader><term>Modifier</term><description><c>d</c>, <c>i</c></description><description><c>o, u, x, X</c></description><description><c>n</c></description></listheader><item><term><c>hh</c></term><description><c>signed char</c></description><description><c>unsigned char</c></description><description><c>signed char *</c></description></item><item><term><c>h</c></term><description><c>short</c></description><description><c>unsigned short</c></description><description><c>short *</c></description></item><item><term><c>l</c> (ell)</term><description><c>long</c></description><description><c>unsigned long</c></description><description><c>unsigned long *</c></description></item><item><term><c>ll</c> (ell ell)</term><description><c>long long</c></description><description><c>unsigned long long</c></description><description><c>long long *</c></description></item><item><term><c>j</c></term><description><c>intmax_t</c></description><description><c>uintmax_t</c></description><description><c>intmax_t *</c></description></item><item><term><c>t</c></term><description><c>ptrdiff_t</c></description><description>(see note)</description><description><c>ptrdiff_t *</c></description></item><item><term><c>z</c></term><description>(see note)</description><description><c>size_t</c></description><description>(see note)</description></item><item><term><c>q</c><i>(deprecated)</i></term><description><c>quad_t</c></description><description><c>u_quad_t</c></description><description><c>quad_t *</c></description></item></list><block subset="none" type="note"><para>the <c>t</c> modifier, when applied to a <c>o</c>, <c>u</c>, <c>x</c>, or <c>X</c> conversion, indicates that the argument is of an unsigned type equivalent in size to a <c>ptrdiff_t</c>.  The <c>z</c> modifier, when applied to a <c>d</c> or <c>i</c> conversion, indicates that the argument is of a signed type equivalent in size to a <c>size_t</c>.  Similarly, when applied to an <c>n</c> conversion, it indicates that the argument is a pointer to a signed type equivalent in size to a <c>size_t</c>.
  </para></block><para>The following length modifier is valid for the <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, or <c>G</c> conversion:</para><list type="table"><listheader><term>Modifier</term><description><c>a, A, e, E, f, F, g, G</c></description></listheader><item><term><c>L</c></term><description><c>long double</c></description></item></list><para>The following length modifier is valid for the <c>c</c> or <c>s</c> conversion:</para><list type="table"><listheader><term>Modifier</term><description><c>c</c></description><description><c>s</c></description></listheader><item><term><c>l</c> (ell)</term><description><c>wint_t</c></description><description><c>wchar_t *</c></description></item></list></term>
            </item>
            <item>
              <term>A character that specifies the type of conversion to be applied.</term>
            </item>
          </list>
          <para>A field width or precision, or both, may be indicated by an asterisk '<c>*</c>' or an asterisk followed by one or more decimal digits and a '<c>$</c>' instead of a digit string.  In this case, an <i>int</i> argument supplies the field width or precision.  A negative field width is treated as a left adjustment flag followed by a positive field width; a negative precision is treated as though it were missing.  If a single format directive mixes positional (<c>nn$</c>) and non-positional arguments, the results are undefined
</para>
          <para>The conversion specifiers and their meanings are:</para>
          <list type="table">
            <listheader>
              <term>Specifier</term>
              <description>Meaning</description>
            </listheader>
            <item>
              <term>
                <c>diouxX</c>
              </term>
              <description>The <c>int</c> (or appropriate variant) argument is converted to signed decimal (<c>d</c> and <c>i</c>), unsigned octal (<c>o</c>), unsigned decimal (<c>u</c>), or unsigned hexadecimal (<c>x</c> and <c>X</c>) notation.  The letters "<c>abcdef</c>" are used for <c>x</c> conversions; the letters "<c>ABCDEF</c>" are used for <c>X</c> conversions.  The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros.</description>
            </item>
            <item>
              <term>
                <c>DOU</c>
              </term>
              <description>The <c>long int</c> argument is converted to signed decimal, unsigned octal, or unsigned decimal, as if the format had been <c>ld</c>, <c>lo</c>, or <c>lu</c> respectively.  These conversion characters are deprecated, and will eventually disappear.</description>
            </item>
            <item>
              <term>
                <c>eE</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted in the style <c>[-]d.dddedd</c> where there is one digit before the decimal-point character and the number of digits after it is equal to the precision; if the precision is missing, it is taken as 6; if the precision is zero, no decimal-point character appears.  An <c>E</c> conversion uses the letter '<c>E</c>' (rather than '<c>e</c>') to introduce the exponent.  The exponent always contains at least two digits; if the value is zero, the exponent is 00.</description>
              <para>For <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, and <c>G</c> conversions, positive and negative infinity are represented as <c>inf</c> and <c>-inf</c> respectively when using the lowercase conversion character, and <c>INF</c> and <c>-INF</c> respectively when using the uppercase conversion character.  Similarly, <c>NaN</c> is represented as <c>nan</c> when using the lowercase conversion, and <c>NAN</c> when using the uppercase conversion.</para>
            </item>
            <item>
              <term>
                <c>fF</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted to decimal notation in the style <c>[-]ddd.ddd</c>, where the number of digits after the decimal-point character is equal to the precision specification.  If the precision is missing, it is taken as 6; if the precision is explicitly zero, no decimal-point character appears. If a decimal point appears, at least one digit appears before it.</description>
            </item>
            <item>
              <term>
                <c>gG</c>
              </term>
              <description>The <c>double</c> argument is converted in style <c>f</c> or <c>e</c> (or <c>F</c> or <c>E</c> for <c>G</c> conversions). The precision specifies the number of significant digits.  If the precision is missing, 6 digits are given; if the precision is zero, it is treated as 1. Style <c>e</c> is used if the exponent from its conversion is less than -4 or greater than or equal to the precision.  Trailing zeros are removed from the fractional part of the result; a decimal point appears only if it is followed by at least one digit.</description>
            </item>
            <item>
              <term>
                <c>aA</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted to hexadecimal notation in the style <c>[-]0xh.hhhp[]d</c>, where the number of digits after the hexadecimal-point character is equal to the precision specification.  If the precision is missing, it is taken as enough to represent the floating-point number exactly, and no rounding occurs.  If the precision is zero, no hexadecimal-point character appears.  The <c>p</c> is a literal character '<c>p</c>', and the exponent consists of a positive or negative sign followed by a decimal number representing an exponent of 2.  The <c>A</c> conversion uses the prefix "<c>0X</c>" (rather than "<c>0x</c>"), the letters "<c>ABCDEF</c>" (rather than "<c>abcdef</c>") to represent the hex digits, and the letter '<c>P</c>' (rather than '<c>p</c>') to separate the mantissa and exponent.

<para>Note that there may be multiple valid ways to represent floating-point numbers in this hexadecimal format.  For example, <c>0x3.24p+0</c>, <c>0x6.48p-1</c> and <c>0xc.9p-2</c> are all equivalent.  The format chosen depends on the internal representation of the number, but the implementation guarantees that the length of the mantissa will be minimized.  Zeroes are always represented with a mantissa of 0 (preceded by a '<c>-</c>' if appropriate) and an exponent of +0.
</para></description>
            </item>
            <item>
              <term>
                <c>C</c>
              </term>
              <description>Treated as <c>c</c> with the <c>l</c> (ell) modifier.</description>
            </item>
            <item>
              <term>
                <c>c</c>
              </term>
              <description>The <c>int</c> argument is converted to an <c>unsigned char</c>, and the resulting character is written.

<para>If the <c>l</c> (ell) modifier is used, the <c>wint_t</c> argument shall be converted to a <c>wchar_t</c>, and the (potentially multi-byte) sequence representing the single wide character is written, including any shift sequences.  If a shift sequence is used, the shift state is also restored to the original state after the character.
</para></description>
            </item>
            <item>
              <term>
                <c>S</c>
              </term>
              <description>Treated as <c>s</c> with the <c>l</c> (ell) modifier.</description>
            </item>
            <item>
              <term>
                <c>s</c>
              </term>
              <description>
The <c>char *</c> argument is expected to be a pointer to an array of character type (pointer to a string).  Characters from the array are written up to (but not including) a terminating NUL character; if a precision is specified, no more than the number specified are written.  If a precision is given, no null character need be present; if the precision is not specified, or is greater than the size of the array, the array must contain a terminating NUL character.

<para>If the <c>l</c> (ell) modifier is used, the <c>wchar_t *</c> argument is expected to be a pointer to an array of wide characters (pointer to a wide string).  For each wide character in the string, the (potentially multi-byte) sequence representing the wide character is written, including any shift sequences.  If any shift sequence is used, the shift state is also restored to the original state after the string.  Wide characters from the array are written up to (but not including) a terminating wide NUL character; if a precision is specified, no more than the number of bytes specified are written (including shift sequences).  Partial characters are never written.  If a precision is given, no null character need be present; if the precision is not specified, or is greater than the number of bytes required to render the multibyte representation of the string, the array must contain a terminating wide NUL character.</para></description>
            </item>
            <item>
              <term>
                <c>p</c>
              </term>
              <description>The <c>void *</c> pointer argument is printed in hexadecimal (as if by '<c>%#x</c>' or '<c>%#lx</c>').</description>
            </item>
            <item>
              <term>
                <c>n</c>
              </term>
              <description>The number of characters written so far is stored into the integer indicated by the <c>int *</c> (or variant) pointer argument.  No argument is converted.</description>
            </item>
            <item>
              <term>
                <c>%</c>
              </term>
              <description> A '<c>%</c>' is written.  No argument is converted.  The complete conversion specification is '<c>%%</c>'.</description>
            </item>
          </list>
          <para>The decimal point character is defined in the program's locale (category <c>LC_NUMERIC</c>)
</para>
          <para>In no case does a non-existent or small field width cause truncation of a numeric field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="snprintf">
      <MemberSignature Language="C#" Value="public static int snprintf (System.Text.StringBuilder s, ulong n, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 snprintf(class System.Text.StringBuilder s, unsigned int64 n, string message) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Text.StringBuilder" />
        <Parameter Name="n" Type="System.UInt64" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The buffer to print the message into.</param>
        <param name="n">The size of the buffer.</param>
        <param name="message">The message to print.</param>
        <summary>Print a string into a buffer.</summary>
        <returns>Returns the number of characters printed or the number of characters that would have been printed if the <paramref name="size" /> were unlimited (again, not including the final '<c>\0</c>').</returns>
        <remarks>The <c>snprintf</c> function will fill at most <paramref name="n" /> characters of the input buffer with the string <paramref name="message" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="snprintf">
      <MemberSignature Language="C#" Value="public static int snprintf (System.Text.StringBuilder s, ulong n, string format, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 snprintf(class System.Text.StringBuilder s, unsigned int64 n, string format, object[] parameters) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Not necessarily portable due to cdecl restrictions.
Use snprintf (StringBuilder, string) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Text.StringBuilder" />
        <Parameter Name="n" Type="System.UInt64" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The buffer to print the message into.</param>
        <param name="n">The size of the buffer.</param>
        <param name="format">The message format string.</param>
        <param name="parameters">Arguments for the message format string.</param>
        <summary>Print a string into a buffer.</summary>
        <returns>Returns the number of characters printed or the number of characters that would have been printed if the <paramref name="size" /> were unlimited (again, not including the final '<c>\0</c>').</returns>
        <remarks>
          <para>The <c>snprintf</c>() family of functions produces output according to a format as described below.  <c>snprintf</c>() writes output to the given output <paramref name="stream" />.</para>
          <para>These functions write the output under the control of a <paramref name="format" /> string that specifies how subsequent arguments (or arguments accessed via the variable-length argument facilities of <c>stdarg</c>(3)) are converted for output.
</para>
          <para>The format string is composed of zero or more directives: ordinary characters (not %), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments.  Each conversion specification is introduced by the % character.  The arguments must correspond properly (after type promotion) with the conversion specifier.  After the %, the following appear in sequence:</para>
          <list type="bullet">
            <item>
              <term>An optional field, consisting of a decimal digit string followed by a <c>$</c>, specifying the next argument to access.  If this field is not provided, the argument following the last argument accessed will be used.  Arguments are numbered starting at <c>1</c>.  If unaccessed arguments in the format string are interspersed with ones that are accessed the results will be indeterminate.</term>
            </item>
            <item>
              <term>Zero or more of the following flags:

<list type="table"><listheader><term>Flag</term><description>Description</description></listheader><item><term>'<c>#</c>'</term><description>The value should be converted to an "alternate form".  For <c>c</c>, <c>d</c>, <c>i</c>, <c>n</c>, <c>p</c>, <c>s</c>, and <c>u</c> conversions, this option has no effect.  For <c>o</c> conversions, the precision of the number is increased to force the first character of the output string to a zero (except if a zero value is printed with an explicit precision of zero).  For <c>x</c> and <c>X</c> conversions, a non-zero result has the string '<c>0x</c>' (or '<c>0X</c>' for <c>X</c> conversions) prepended to it. For <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, and <c>G</c> conversions, the result will always contain a decimal point, even if no digits follow it (normally, a decimal point appears in the results of those conversions only if a digit follows).  For <c>g</c> and <c>G</c> conversions, trailing zeros are not removed from the result as they would otherwise be.</description></item><item><term>'<c>0</c>' (zero)</term><description>Zero padding.  For all conversions except <c>n</c>, the converted value is padded on the left with zeros rather than blanks.  If a precision is given with a numeric conversion (<c>d</c>, <c>i</c>, <c>o</c>, <c>u</c>, <c>i</c>, <c>x</c>, and <c>X</c>), the 0 flag is ignored.</description></item><item><term>'<c>-</c>'</term><description>A negative field width flag; the converted value is to be left adjusted on the field boundary.  Except for <c>n</c> conversions, the converted value is padded on the right with blanks, rather than on the left with blanks or zeros.  A <c>-</c> overrides a <c>0</c> if both are given.</description></item><item><term>'<c />' (space)</term><description>A blank should be left before a positive number produced by a signed conversion (<c>a</c>, <c>A</c>, <c>d</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, <c>G</c>, or <c>i</c>).</description></item><item><term>'<c>+</c>'</term><description>A sign must always be placed before a number produced by a signed conversion.  A <c>+</c> overrides a space if both are used.</description></item><item><term>'<c>'</c>'</term><description>Decimal conversions (<c>d</c>, <c>u</c>, or <c>i</c>) or the integral portion of a floating point conversion (<c>f</c> or <c>F</c>) should be grouped and separated by thousands using the non-monetary separator returned by <see cref="M:Mono.Unix.Native.Syscall.localeconv" />(3).</description></item></list></term>
            </item>
            <item>
              <term>An optional decimal digit string specifying a minimum field width.  If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-adjustment flag has been given) to fill out the field width.</term>
            </item>
            <item>
              <term>An optional precision, in the form of a period . followed by an optional digit string.  If the digit string is omitted, the precision is taken as zero.  This gives the minimum number of digits to appear for <c>d</c>, <c>i</c>, <c>o</c>, <c>u</c>, <c>x</c>, and <c>X</c> conversions, the number of digits to appear after the decimal-point for <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, and <c>F</c> conversions, the maximum number of significant digits for <c>g</c> and <c>G</c> conversions, or the maximum number of characters to be printed from a string for <c>s</c> conversions.</term>
            </item>
            <item>
              <term>An optional length modifier, that specifies the size of the argument.  The following length modifiers are valid for the <c>d</c>, <c>i</c>, <c>n</c>, <c>o</c>, <c>u</c>, <c>x</c>, or <c>X</c> conversion:

<list type="table"><listheader><term>Modifier</term><description><c>d</c>, <c>i</c></description><description><c>o, u, x, X</c></description><description><c>n</c></description></listheader><item><term><c>hh</c></term><description><c>signed char</c></description><description><c>unsigned char</c></description><description><c>signed char *</c></description></item><item><term><c>h</c></term><description><c>short</c></description><description><c>unsigned short</c></description><description><c>short *</c></description></item><item><term><c>l</c> (ell)</term><description><c>long</c></description><description><c>unsigned long</c></description><description><c>unsigned long *</c></description></item><item><term><c>ll</c> (ell ell)</term><description><c>long long</c></description><description><c>unsigned long long</c></description><description><c>long long *</c></description></item><item><term><c>j</c></term><description><c>intmax_t</c></description><description><c>uintmax_t</c></description><description><c>intmax_t *</c></description></item><item><term><c>t</c></term><description><c>ptrdiff_t</c></description><description>(see note)</description><description><c>ptrdiff_t *</c></description></item><item><term><c>z</c></term><description>(see note)</description><description><c>size_t</c></description><description>(see note)</description></item><item><term><c>q</c><i>(deprecated)</i></term><description><c>quad_t</c></description><description><c>u_quad_t</c></description><description><c>quad_t *</c></description></item></list><block subset="none" type="note"><para>the <c>t</c> modifier, when applied to a <c>o</c>, <c>u</c>, <c>x</c>, or <c>X</c> conversion, indicates that the argument is of an unsigned type equivalent in size to a <c>ptrdiff_t</c>.  The <c>z</c> modifier, when applied to a <c>d</c> or <c>i</c> conversion, indicates that the argument is of a signed type equivalent in size to a <c>size_t</c>.  Similarly, when applied to an <c>n</c> conversion, it indicates that the argument is a pointer to a signed type equivalent in size to a <c>size_t</c>.
  </para></block><para>The following length modifier is valid for the <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, or <c>G</c> conversion:</para><list type="table"><listheader><term>Modifier</term><description><c>a, A, e, E, f, F, g, G</c></description></listheader><item><term><c>L</c></term><description><c>long double</c></description></item></list><para>The following length modifier is valid for the <c>c</c> or <c>s</c> conversion:</para><list type="table"><listheader><term>Modifier</term><description><c>c</c></description><description><c>s</c></description></listheader><item><term><c>l</c> (ell)</term><description><c>wint_t</c></description><description><c>wchar_t *</c></description></item></list></term>
            </item>
            <item>
              <term>A character that specifies the type of conversion to be applied.</term>
            </item>
          </list>
          <para>A field width or precision, or both, may be indicated by an asterisk '<c>*</c>' or an asterisk followed by one or more decimal digits and a '<c>$</c>' instead of a digit string.  In this case, an <i>int</i> argument supplies the field width or precision.  A negative field width is treated as a left adjustment flag followed by a positive field width; a negative precision is treated as though it were missing.  If a single format directive mixes positional (<c>nn$</c>) and non-positional arguments, the results are undefined
</para>
          <para>The conversion specifiers and their meanings are:</para>
          <list type="table">
            <listheader>
              <term>Specifier</term>
              <description>Meaning</description>
            </listheader>
            <item>
              <term>
                <c>diouxX</c>
              </term>
              <description>The <c>int</c> (or appropriate variant) argument is converted to signed decimal (<c>d</c> and <c>i</c>), unsigned octal (<c>o</c>), unsigned decimal (<c>u</c>), or unsigned hexadecimal (<c>x</c> and <c>X</c>) notation.  The letters "<c>abcdef</c>" are used for <c>x</c> conversions; the letters "<c>ABCDEF</c>" are used for <c>X</c> conversions.  The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros.</description>
            </item>
            <item>
              <term>
                <c>DOU</c>
              </term>
              <description>The <c>long int</c> argument is converted to signed decimal, unsigned octal, or unsigned decimal, as if the format had been <c>ld</c>, <c>lo</c>, or <c>lu</c> respectively.  These conversion characters are deprecated, and will eventually disappear.</description>
            </item>
            <item>
              <term>
                <c>eE</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted in the style <c>[-]d.dddedd</c> where there is one digit before the decimal-point character and the number of digits after it is equal to the precision; if the precision is missing, it is taken as 6; if the precision is zero, no decimal-point character appears.  An <c>E</c> conversion uses the letter '<c>E</c>' (rather than '<c>e</c>') to introduce the exponent.  The exponent always contains at least two digits; if the value is zero, the exponent is 00.</description>
              <para>For <c>a</c>, <c>A</c>, <c>e</c>, <c>E</c>, <c>f</c>, <c>F</c>, <c>g</c>, and <c>G</c> conversions, positive and negative infinity are represented as <c>inf</c> and <c>-inf</c> respectively when using the lowercase conversion character, and <c>INF</c> and <c>-INF</c> respectively when using the uppercase conversion character.  Similarly, <c>NaN</c> is represented as <c>nan</c> when using the lowercase conversion, and <c>NAN</c> when using the uppercase conversion.</para>
            </item>
            <item>
              <term>
                <c>fF</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted to decimal notation in the style <c>[-]ddd.ddd</c>, where the number of digits after the decimal-point character is equal to the precision specification.  If the precision is missing, it is taken as 6; if the precision is explicitly zero, no decimal-point character appears. If a decimal point appears, at least one digit appears before it.</description>
            </item>
            <item>
              <term>
                <c>gG</c>
              </term>
              <description>The <c>double</c> argument is converted in style <c>f</c> or <c>e</c> (or <c>F</c> or <c>E</c> for <c>G</c> conversions). The precision specifies the number of significant digits.  If the precision is missing, 6 digits are given; if the precision is zero, it is treated as 1. Style <c>e</c> is used if the exponent from its conversion is less than -4 or greater than or equal to the precision.  Trailing zeros are removed from the fractional part of the result; a decimal point appears only if it is followed by at least one digit.</description>
            </item>
            <item>
              <term>
                <c>aA</c>
              </term>
              <description>The <c>double</c> argument is rounded and converted to hexadecimal notation in the style <c>[-]0xh.hhhp[]d</c>, where the number of digits after the hexadecimal-point character is equal to the precision specification.  If the precision is missing, it is taken as enough to represent the floating-point number exactly, and no rounding occurs.  If the precision is zero, no hexadecimal-point character appears.  The <c>p</c> is a literal character '<c>p</c>', and the exponent consists of a positive or negative sign followed by a decimal number representing an exponent of 2.  The <c>A</c> conversion uses the prefix "<c>0X</c>" (rather than "<c>0x</c>"), the letters "<c>ABCDEF</c>" (rather than "<c>abcdef</c>") to represent the hex digits, and the letter '<c>P</c>' (rather than '<c>p</c>') to separate the mantissa and exponent.

<para>Note that there may be multiple valid ways to represent floating-point numbers in this hexadecimal format.  For example, <c>0x3.24p+0</c>, <c>0x6.48p-1</c> and <c>0xc.9p-2</c> are all equivalent.  The format chosen depends on the internal representation of the number, but the implementation guarantees that the length of the mantissa will be minimized.  Zeroes are always represented with a mantissa of 0 (preceded by a '<c>-</c>' if appropriate) and an exponent of +0.
</para></description>
            </item>
            <item>
              <term>
                <c>C</c>
              </term>
              <description>Treated as <c>c</c> with the <c>l</c> (ell) modifier.</description>
            </item>
            <item>
              <term>
                <c>c</c>
              </term>
              <description>The <c>int</c> argument is converted to an <c>unsigned char</c>, and the resulting character is written.

<para>If the <c>l</c> (ell) modifier is used, the <c>wint_t</c> argument shall be converted to a <c>wchar_t</c>, and the (potentially multi-byte) sequence representing the single wide character is written, including any shift sequences.  If a shift sequence is used, the shift state is also restored to the original state after the character.
</para></description>
            </item>
            <item>
              <term>
                <c>S</c>
              </term>
              <description>Treated as <c>s</c> with the <c>l</c> (ell) modifier.</description>
            </item>
            <item>
              <term>
                <c>s</c>
              </term>
              <description>
The <c>char *</c> argument is expected to be a pointer to an array of character type (pointer to a string).  Characters from the array are written up to (but not including) a terminating NUL character; if a precision is specified, no more than the number specified are written.  If a precision is given, no null character need be present; if the precision is not specified, or is greater than the size of the array, the array must contain a terminating NUL character.

<para>If the <c>l</c> (ell) modifier is used, the <c>wchar_t *</c> argument is expected to be a pointer to an array of wide characters (pointer to a wide string).  For each wide character in the string, the (potentially multi-byte) sequence representing the wide character is written, including any shift sequences.  If any shift sequence is used, the shift state is also restored to the original state after the string.  Wide characters from the array are written up to (but not including) a terminating wide NUL character; if a precision is specified, no more than the number of bytes specified are written (including shift sequences).  Partial characters are never written.  If a precision is given, no null character need be present; if the precision is not specified, or is greater than the number of bytes required to render the multibyte representation of the string, the array must contain a terminating wide NUL character.</para></description>
            </item>
            <item>
              <term>
                <c>p</c>
              </term>
              <description>The <c>void *</c> pointer argument is printed in hexadecimal (as if by '<c>%#x</c>' or '<c>%#lx</c>').</description>
            </item>
            <item>
              <term>
                <c>n</c>
              </term>
              <description>The number of characters written so far is stored into the integer indicated by the <c>int *</c> (or variant) pointer argument.  No argument is converted.</description>
            </item>
            <item>
              <term>
                <c>%</c>
              </term>
              <description> A '<c>%</c>' is written.  No argument is converted.  The complete conversion specification is '<c>%%</c>'.</description>
            </item>
          </list>
          <para>The decimal point character is defined in the program's locale (category <c>LC_NUMERIC</c>)
</para>
          <para>In no case does a non-existent or small field width cause truncation of a numeric field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="srand">
      <MemberSignature Language="C#" Value="public static void srand (uint seed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;srand&quot; cdecl)void srand(unsigned int32 seed) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seed" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="seed">The value to seed the random number generator with.</param>
        <summary>Initialize the random number generator.</summary>
        <remarks>
          <para>The <c>srand</c>() function sets its argument <paramref name="seed" /> as the seed for a new sequence of pseudo-random numbers to be returned by <see cref="M:Mono.Unix.Native.Stdlib.rand" />().  These sequences are repeatable by calling <c>srand</c>() with the same seed value.</para>
          <para>If no <paramref name="seed" /> value is provided, the functions are automatically seeded with a value of 1.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="stderr">
      <MemberSignature Language="C#" Value="public static readonly IntPtr stderr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly native int stderr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Standard error <c>FILE</c> stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="stdin">
      <MemberSignature Language="C#" Value="public static readonly IntPtr stdin;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly native int stdin" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Standard input <c>FILE</c> stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="stdout">
      <MemberSignature Language="C#" Value="public static readonly IntPtr stdout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly native int stdout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Standard output <c>FILE</c> stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="strerror">
      <MemberSignature Language="C#" Value="public static string strerror (Mono.Unix.Native.Errno errnum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string strerror(valuetype Mono.Unix.Native.Errno errnum) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errnum" Type="Mono.Unix.Native.Errno" />
      </Parameters>
      <Docs>
        <param name="errnum">Error number to get a message for.</param>
        <summary>Get error message string for 'errnum'.</summary>
        <returns>A string describing <paramref name="errnum" />.</returns>
        <remarks>
          <para>The strerror() function accepts an error number argument errnum and returns a pointer to the corresponding message string.</para>
          <para>If the error number is not recognized, these functions return an error message string containing "<c>Unknown error: </c>" followed by the error number in decimal.
</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="strlen">
      <MemberSignature Language="C#" Value="public static ulong strlen (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;MonoPosixHelper&quot; as &quot;Mono_Posix_Stdlib_strlen&quot; cdecl lasterr)unsigned int64 strlen(native int s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="system">
      <MemberSignature Language="C#" Value="public static int system (string string);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;system&quot; cdecl lasterr)int32 system(string string) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="string">The command to execute.</param>
        <summary>Pass a command to the shell.</summary>
        <returns>
          <para>If <paramref name="string" /> is <see langword="null" />, <c>system</c> will return a non-zero value if the command interpreter <c>sh</c>(1) is available, and zero if it is not.</para>
          <para>Otherwise, the <c>system</c> function returns the exit status of the shell as returned by <see cref="M:Mono.Unix.Native.Syscall.waitpid" />(2), or -1 if an error occurred when invoking <see cref="M:Mono.Unix.Native.Syscall.fork" />(2) or <see cref="M:Mono.Unix.Native.Syscall.waitpid" />(2).  A return value of 127 means the execution of the shell failed.
</para>
        </returns>
        <remarks>The <c>system</c>() function hands the argument <paramref name="string" /> to the command interpreter <c>sh</c>(1).  The calling process waits for the shell to finish executing the command, ignoring <see cref="F:Mono.Unix.Native.Signum.SIGINT" /> and <see cref="F:Mono.Unix.Native.Signum.SIGQUIT" />, and blocking <see cref="F:Mono.Unix.Native.Signum.SIGCHLD" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TMP_MAX">
      <MemberSignature Language="C#" Value="public static readonly int TMP_MAX;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 TMP_MAX" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>238328</MemberValue>
      <Docs>
        <summary>Maximum number of times <see cref="M:Mono.Unix.Native.Stdlib.tmpnam" />(3) will return different strings.</summary>
        <remarks>If <see cref="M:Mono.Unix.Native.Stdlib.tmpnam" />(3) is called more than <c>TMP_MAX</c> times, the behavior is implementation defined.</remarks>
      </Docs>
    </Member>
    <Member MemberName="tmpfile">
      <MemberSignature Language="C#" Value="public static IntPtr tmpfile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;tmpfile&quot; cdecl lasterr)native int tmpfile() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Create a temporary file.</summary>
        <returns>The <c>tmpfile</c>() function returns a pointer to an open file stream on success, and <see cref="F:System.IntPtr.Zero" /> on error.</returns>
        <remarks>
          <para>The <c>tmpfile</c>() function returns a pointer to a stream associated with a file descriptor returned by the routine <see cref="M:Mono.Unix.Native.Syscall.mkstemp" />(3).  The created file is unlinked before <c>tmpfile</c>() returns, causing the file to be automatically deleted when the last reference to it is closed.  The file is opened with the access value '<c>w+</c>'.  The file is created in the directory determined by the environment variable <c>TMPDIR</c> if set.  The default location if <c>TMPDIR</c> is not set is <c>/tmp</c>.</para>
          <para />
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="tmpnam">
      <MemberSignature Language="C#" Value="public static string tmpnam ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string tmpnam() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Syscall.mkstemp() should be preferred.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Generate a temporary file name.</summary>
        <returns>Returns a file name on success, and <see langword="null" /> on error.</returns>
        <remarks>The <c>tmpnam</c>() function returns a pointer to a file name, in the <c>/tmp</c> directory, which did not reference an existing file at some indeterminate point in the past.</remarks>
      </Docs>
    </Member>
    <Member MemberName="tmpnam">
      <MemberSignature Language="C#" Value="public static string tmpnam (System.Text.StringBuilder s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string tmpnam(class System.Text.StringBuilder s) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Syscall.mkstemp() should be preferred.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="s">Buffer to store the temporary filename into</param>
        <summary>Generate a temporary file name.</summary>
        <returns>Returns a file name on success, and <see langword="null" /> on error.</returns>
        <remarks>
          <para>The <c>tmpnam</c>() function returns a pointer to a file name, in the <c>/tmp</c> directory, which did not reference an existing file at some indeterminate point in the past.  If the argument <paramref name="s" /> is not <see langword="null" />, the file name is copied into the buffer it references.</para>
          <para>The buffer referenced by <paramref name="s" /> is expected to be at least <see cref="F:Mono.Unix.Native.Stdlib.L_tmpnam" /> bytes in length.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ungetc">
      <MemberSignature Language="C#" Value="public static int ungetc (int c, IntPtr stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;msvcrt&quot; as &quot;ungetc&quot; cdecl lasterr)int32 ungetc(int32 c, native int stream) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Int32" />
        <Parameter Name="stream" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="c">The character to unget.</param>
        <param name="stream">The <c>FILE</c> stream to unget <paramref name="c" /> on.</param>
        <summary>Un-get character from input <c>FILE</c> stream.</summary>
        <returns>The <c>ungetc</c>() function returns the character pushed-back after the conversion, or <see cref="F:Mono.Unix.Native.Stdlib.EOF" /> if the operation fails.  If the value of the argument <paramref name="c" /> character equals <see cref="F:Mono.Unix.Native.Stdlib.EOF" />, the operation will fail and the stream will remain unchanged.</returns>
        <remarks>
          <para>The <c>ungetc</c>() function pushes the character <paramref name="c" /> (converted to an unsigned char) back onto the input stream pointed to by <paramref name="stream" />.  The pushed-back characters will be returned by subsequent reads on the stream (in reverse order).  A successful intervening call, using the same stream, to one of the file positioning functions (<see cref="M:Mono.Unix.Native.Stdlib.fseek" />(3), <see cref="M:Mono.Unix.Native.Stdlib.fsetpos" />(3), or <see cref="M:Mono.Unix.Native.Stdlib.rewind" />(3)) will discard the pushed back characters.
</para>
          <para>One character of push-back is guaranteed, but as long as there is sufficient memory, an effectively infinite amount of pushback is allowed.
</para>
          <para>If a character is successfully pushed-back, the end-of-file indicator for the stream is cleared.  The file-position indicator is decremented by each successful call to <c>ungetc</c>(); if its value was 0 before a call, its value is unspecified after the call.
</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
