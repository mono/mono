<Type Name="UnixFileSystemInfo" FullName="Mono.Unix.UnixFileSystemInfo">
  <TypeSignature Language="C#" Value="public abstract class UnixFileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit UnixFileSystemInfo extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Posix</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>All public static members of this type are safe for multithreaded operations. No instance members are guaranteed to be thread safe.</ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides information and performs operations on file system
    entries.</summary>
    <remarks>
      <para>
        The <see cref="T:Mono.Unix.UnixFileSystemInfo" /> class provides
        information about a file system entry and permits file system entry
        manipulation such as:
      </para>
      <list type="bullet">
        <item>
          <term>Determining the full file name with 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
          </term>
        </item>
        <item>
          <term>Determining whether the file exists with 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.Exists" /></term>
        </item>
        <item>
          <term>Querying file system entry metadata such as the 
            hardware device it resides on 
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.Device" />),
            the file system inode
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.Inode" />),
            file access permissions
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.FileAccessPermissions" />),
            file type
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.FileType" />),
            file owner information
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.OwnerUser" />),
            group information
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.OwnerGroup" />),
            file size
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.Length" />),
            various times maintained by the operating system
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.LastAccessTime" />,
            <see cref="P:Mono.Unix.UnixFileSystemInfo.LastWriteTime" />,
            <see cref="P:Mono.Unix.UnixFileSystemInfo.LastStatusChangeTime" />),
            and more.
          </term>
        </item>
        <item>
          <term>Creating hard links with
            <see cref="M:Mono.Unix.UnixFileSystemInfo.CreateLink" />.
          </term>
        </item>
        <item>
          <term>Creating symbolic links with
            <see cref="M:Mono.Unix.UnixFileSystemInfo.CreateSymbolicLink" />.
          </term>
        </item>
        <item>
          <term>File system entry deletion with
            <see cref="M:Mono.Unix.UnixFileSystemInfo.Delete" />.
          </term>
        </item>
        <item>
          <term>Setting file system owner and group information with
            <see cref="M:Mono.Unix.UnixFileSystemInfo.SetOwner" />.
          </term>
        </item>
      </list>
      <para>
        Information provided by this type may not be valid for any significant
        period of time, due to potential race conditions with other processes
        running on the system or because of file management actions performed
        within the current process.
      </para>
      <para>
        The only guarantee is that the information provided <i>was</i> valid
        at some point in time, <i>or</i> an 
        <see cref="T:System.InvalidOperationException" /> exception will be
        thrown when attempting to access the provided information.
        <block subset="none" type="note">
          To clarify, once the file system entry 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is found, 
          it won't be checked for again until a call to
          <see cref="P:Mono.Unix.UnixFileSystemInfo.Refresh" />.
          <c>FullName</c> will be checked for during object construction, but
          need not exist during object construction -- 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.Exists" /> will let you
          know if the file currently exists and does an implicit 
          <c>Refresh</c>.  If <c>FullName</c> doesn't exist when the
          <c>UnixFileSystemInfo</c> is created, it will be checked for
          whenever information about the file system entry is required,
          such as with 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.Device" /> and
          <see cref="P:Mono.Unix.UnixFileSystemInfo.Length" />.
        </block></para>
      <para>
        Check the individual method and property documentation to determine if
        and when an exception will be thrown.
      </para>
    </remarks>
    <altmember cref="T:Mono.Unix.UnixDirectoryInfo" />
    <altmember cref="T:Mono.Unix.UnixFileInfo" />
    <altmember cref="T:Mono.Unix.UnixSymbolicLinkInfo" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UnixFileSystemInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">A <see cref="T:System.String" /> containing the
        name of the file system object to query.</param>
        <summary>Creates a <see cref="T:Mono.Unix.UnixFileSystemInfo" />
          subclass.
        </summary>
        <remarks>
          <para>The <paramref name="path" /> argument is permitted to specify
          relative or absolute path information. Relative path information is 
          interpreted as relative to the current working directory. 
          <block subset="none" type="note">To obtain the current working 
          directory, see 
          <see cref="M:Mono.Unix.UnixDirectoryInfo.GetCurrentDirectory" qualify="true" />.
          </block></para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="path" /> is a zero-length string.</para>
          <para>-or-</para>
          <para>
            <paramref name="path" /> contains an invalid character.
            See <see cref="M:Mono.Unix.UnixPath.GetInvalidPathChars" />.
          </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BlocksAllocated">
      <MemberSignature Language="C#" Value="public long BlocksAllocated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 BlocksAllocated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of file system blocks used by this file
          system entry.</summary>
        <value>A <see cref="T:System.Int64" /> containing the number of file
          system blocks used by this file system entry.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_blocks" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="BlockSize">
      <MemberSignature Language="C#" Value="public long BlockSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 BlockSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the preferred blocksize for filesystem I/O.</summary>
        <value>A <see cref="T:System.Int64" /> containing the preferred block 
          size for file system I/O on this file system entry.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_blksize" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="CanAccess">
      <MemberSignature Language="C#" Value="public bool CanAccess (Mono.Unix.Native.AccessModes mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanAccess(valuetype Mono.Unix.Native.AccessModes mode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="Mono.Unix.Native.AccessModes" />
      </Parameters>
      <Docs>
        <param name="mode">A <see cref="T:Mono.Unix.Native.AccessModes" />
          specifying what kind of access the process would like.
        </param>
        <summary>Determines whether or not the process can access
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> with the
          specified access <paramref name="mode" /></summary>
        <returns>A <see cref="T:System.Boolean" /> specifying whether or not
          the process can access
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
        </returns>
        <remarks>
          <para>
            Note that this method is subject to external race conditions --
            just because you can access 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> now doesn't
            mean you'll be able to access it later, as another thread/process
            may change the access permissions.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateLink">
      <MemberSignature Language="C#" Value="public Mono.Unix.UnixFileSystemInfo CreateLink (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Unix.UnixFileSystemInfo CreateLink(string path) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Unix.UnixFileSystemInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
        </param>
        <summary>Creates a hard link so that 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> and 
          <paramref name="path" /> are the same file.</summary>
        <returns>A <see cref="T:Mono.Unix.UnixFileSystemInfo" /> instance which
          represents <paramref name="path" />.</returns>
        <remarks>
          <para>The <paramref name="path" /> argument is permitted to specify
          relative or absolute path information. Relative path information is 
          interpreted as relative to the current working directory. 
          <block subset="none" type="note">To obtain the current working 
            directory, see 
            <see cref="M:Mono.Unix.UnixDirectoryInfo.GetCurrentDirectory" />.
          </block></para>
          <para>
            After creating the link, the link count 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.LinkCount" /> will be
            incremented, and there will be no way to distinguish the two
            files -- they're the same file with two (or more) different names.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <para>
            The file system containing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
            does not support hard links.
            [<see cref="F:Mono.Unix.Native.Errno.EOPNOTSUPP" />]
          </para>
          <para>-or-</para>
          <para>The file
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
            is a directory or is flagged immutable or append-only
            (see <see cref="M:Mono.Unix.Native.Syscall.chflags" />).
            [<see cref="F:Mono.Unix.Native.Errno.EPERM" />]
          </para>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <para>Search permission is denied for a component of the path
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> or
            <paramref name="path" />.
            [<see cref="F:Mono.Unix.Native.Errno.EACCESS" />]
          </para>
          <para>-or-</para>
          <para>
            <paramref name="path" /> requires writing in a directory with a
            mode that denies write permissions.
            [<see cref="F:Mono.Unix.Native.Errno.EACCESS" />]
          </para>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          A component of the path prefix of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
          or <paramref name="path" /> is not a
          directory.
            [<see cref="F:Mono.Unix.Native.Errno.ENOTDIR" />]
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <para>
            A component of 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
            or <paramref name="path" />
            that must exist does not exist.
            [<see cref="F:Mono.Unix.Native.Errno.ENOENT" />]
          </para>
          <para>-or-</para>
          <para>
            The file 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
            does not exist.
            [<see cref="F:Mono.Unix.Native.Errno.ENOENT" />]
          </para>
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>
            <paramref name="path" />
            resides on a read-only file system.
            [<see cref="F:Mono.Unix.Native.Errno.EROFS" />]
          </para>
          <para>-or-</para>
          <para>The directory for <paramref name="path" /> cannot be extended 
            because there is no space left.
            [<see cref="F:Mono.Unix.Native.Errno.ENOSPC" />]
          </para>
          <para>-or-</para>
          <para>An I/O error occurred while making the directory entry.
            [<see cref="F:Mono.Unix.Native.Errno.EIO" />]
          </para>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> or
          <paramref name="path" />
          was too long.
            [<see cref="F:Mono.Unix.Native.Errno.ENAMETOOLONG" />]
        </exception>
        <exception cref="T:Mono.Unix.UnixIOException">
          <para>Too many symbolic links were encountered in translating 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> or
            <paramref name="path" />
            [<see cref="F:Mono.Unix.Native.Errno.ELOOP" />]
          </para>
          <para>-or-</para>
          <para>
            <see cref="P:Mono.Unix.UnixFileInfo.Directory" /> cannot be
          extended because the user's quota of disk blocks on the file system
          containing this directory has been exhausted.
            [<see cref="F:Mono.Unix.Native.Errno.EDQUOT" />]
          </para>
          <para>-or-</para>
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.LinkCount" />
            would exceed its limit.  Use 
            <see cref="M:Mono.Unix.UnixFileSystemInfo.GetConfigurationValue" />(<see cref="M:Mono.Unix.Native.PathconfName._PC_LINK_MAX" />) 
            to determine the maximum link value.
            [<see cref="F:Mono.Unix.Native.Errno.EMLINK" />]
          </para>
          <para>-or-</para>
          <para>
            <paramref name="path" /> already exists.
            [<see cref="F:Mono.Unix.Native.Errno.EEXIST" />]
          </para>
          <para>-or-</para>
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> and
            <paramref name="path" /> are on different file systems.
            [<see cref="F:Mono.Unix.Native.Errno.EXDEV" />]
          </para>
        </exception>
        <altmember cref="M:Mono.Unix.Native.Syscall.link" />
      </Docs>
    </Member>
    <Member MemberName="CreateSymbolicLink">
      <MemberSignature Language="C#" Value="public Mono.Unix.UnixSymbolicLinkInfo CreateSymbolicLink (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Mono.Unix.UnixSymbolicLinkInfo CreateSymbolicLink(string path) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Unix.UnixSymbolicLinkInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">A <see cref="T:System.String" /> containing the name
        of the symbolic link to create.</param>
        <summary>Create a symbolic link so that <paramref name="path" /> 
          "points to" <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
        </summary>
        <returns>A <see cref="T:Mono.Unix.UnixSymbolicLinkInfo" /> instance
          containing information about the created symbolic link.</returns>
        <remarks>
          <para>The <paramref name="path" /> argument is permitted to specify
          relative or absolute path information. Relative path information is 
          interpreted as relative to the current working directory. 
          <block subset="none" type="note">To obtain the current working 
            directory, see 
            <see cref="M:Mono.Unix.UnixDirectoryInfo.GetCurrentDirectory" />.
          </block></para>
          <para>
            The created symbolic link will contain the full path name, 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.  
            If this is undesirable (for instance, you want the created
            symbolic link to contain relative path information), use
            <see cref="M:Mono.Unix.UnixSymbolicLinkInfo.CreateSymbolicLinkTo" />
            instead.  <c>UnixSymbolicLinkInfo.CreateSymbolicLinkTo</c> 
            uses the exact path provided to the 
            <see cref="T:Mono.Unix.UnixSymbolicLinkInfo" /> constructor when
            creating the symbolic link, while this method uses the
            fully-qualified file name to create the symbolic link.
          </para>
          <example>
            <para>The <c>ln</c>(1) command:</para>
            <code lang="sh">ln -s target symlink</code>
            <para>
              Can be created using <see cref="N:Mono.Unix" /> in two ways.
              First, it can be created using 
              <see cref="M:Mono.Unix.UnixFileSystemInfo.CreateSymbolicLink" />:
            </para>
            <code lang="C#">UnixFileInfo f = new UnixFileInfo ("target.ufi");
f.CreateSymbolicLink ("symlink.ufi");</code>
            <para>
              Second, it can be created using 
              <see cref="M:Mono.Unix.UnixSymbolicLinkInfo.CreateSymbolicLinkTo" />:
            </para>
            <code lang="C#">UnixSymbolicLinkInfo s = 
    new UnixSymbolicLinkInfo ("symlink.usli");
s.CreateSymbolicLinkTo ("target.usli");</code>
            <para>
              The links created by the above differ; in particular, the target
              of 
              <see cref="M:Mono.Unix.UnixFileSystemInfo.CreateSymbolicLink" />
              is the full path name of the target, while 
              <see cref="M:Mono.Unix.UnixSymbolicLinkInfo.CreateSymbolicLinkTo" /> contains no extra information:
            </para>
            <code lang="sh">$ ls -lF symlink* | cut -c 39-
symlink -&gt; target
symlink.ufi -&gt; /full/path/to/target.ufi
symlink.usli -&gt; target.usli
            </code>
          </example>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <para>Search permission is denied for a component of the path
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> or 
          <paramref name="path" />.
            [<see cref="F:Mono.Unix.Native.Errno.EACCES" />]
          </para>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          A component of the path prefix of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is not a
          directory.
            [<see cref="F:Mono.Unix.Native.Errno.ENOTDIR" />]
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          A component of <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
          that must exist does not exist.
            [<see cref="F:Mono.Unix.Native.Errno.ENOENT" />]
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> was too long.
            [<see cref="F:Mono.Unix.Native.Errno.ENAMETOOLONG" />]
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>
            <paramref name="path" /> resides on a read-only file system.
            [<see cref="F:Mono.Unix.Native.Errno.EROFS" />]
          </para>
          <para>-or-</para>
          <para>The directory containing <paramref name="path" />
          cannot be extended because there is no space left on the file
          system containing the directory.
            [<see cref="F:Mono.Unix.Native.Errno.ENOSPC" />]
          </para>
          <para>-or-</para>
          <para>There are no free inodes on the file system on which the file
          is being created.
            [<see cref="F:Mono.Unix.Native.Errno.ENOSPC" />]
          </para>
          <para>-or-</para>
          <para>An I/O error occurred while making the directory entry or
          allocating the inode.
            [<see cref="F:Mono.Unix.Native.Errno.EIO" />]
          </para>
        </exception>
        <exception cref="T:Mono.Unix.UnixIOException">
          <para>Too many symbolic links were encountered in translating 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.ELOOP" />]
          </para>
          <para>-or-</para>
          <para>The user's quota of inodes on the file system containing
          <see cref="P:Mono.Unix.UnixFileInfo.Directory" /> has been exhausted.
            [<see cref="F:Mono.Unix.Native.Errno.EDQUOT" />]
          </para>
          <para>-or-</para>
          <para>The directory containing <paramref name="path" /> cannot be
          extended because the user's quota of disk blocks on the file system
          containing this directory has been exhausted.
            [<see cref="F:Mono.Unix.Native.Errno.EDQUOT" />]
          </para>
          <para>-or-</para>
          <para>
            <paramref name="path" /> already exists.</para>
        </exception>
        <altmember cref="M:Mono.Unix.Native.Syscall.symlink" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public abstract void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Delete() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deletes the file system entry
        <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.</summary>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <para>The filesystem containing 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> does not
          support the removal of file system entries.</para>
          <para>-or-</para>
          <para>The directory containing 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
          has the <see cref="F:Mono.Unix.FileSpecialAttributes.Sticky" /> bit
          set and the process's 
          <see cref="P:Mono.Unix.UnixEnvironment.EffectiveUserId" /> is
          neither the uid of the file to be deleted nor that of the directory
          containing it.</para>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <para>Write access to the directory containing
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> was not
          allowed for the processe's effective user id 
          <see cref="P:Mono.Unix.UnixEnvironment.EffectiveUserId" />.</para>
          <para>-or-</para>
          <para>One of the directories in 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> did not have
          search (execute) permissions.</para>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          A component of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is not a
          directory.
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> does not
          exist.
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> contains 
          files other than '<c>.</c>' and '<c>..</c>' in it.</para>
          <para>-or-</para>
          <para>An I/O error occurred while deleting the file system entry or
          deallocating the inode.</para>
          <para>-or-</para>
          <para>The directory entry to be removed resides in a read-only file
          system.</para>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> was too long.
        </exception>
        <exception cref="T:Mono.Unix.UnixIOException">
          <para>Too many symbolic links were encountered in translating 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.</para>
          <para>-or</para>
          <para>The directory to be removed is the mount point for a mounted
          filesystem.</para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Device">
      <MemberSignature Language="C#" Value="public long Device { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Device" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the device ID that this file system entry resides on.</summary>
        <value>A <see cref="T:System.Int64" /> containing the device ID that
          this file system entry resides on.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_dev" />
        <altmember cref="F:Mono.Unix.Native.System.stat" />
      </Docs>
    </Member>
    <Member MemberName="DeviceType">
      <MemberSignature Language="C#" Value="public long DeviceType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 DeviceType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the device type of this inode.</summary>
        <value>A <see cref="T:System.Int64" /> containing the type of this
          inode.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_rdev" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a <see cref="T:System.Boolean" /> indicating whether
        the specified file system object exists.</summary>
        <value>
          <para>
            <see langword="true" /> if the caller has the required permissions 
            and <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />
            contains the name of an existing file or directory; otherwise, 
            <see langword="false" />. 
            If <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is
            <see langword="null" /> or a zero-length string,
            returns <see langword="false" />.
          </para>
        </value>
        <remarks>
          <para>If the caller does not have sufficient permissions to read 
          the file system object 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />, no
          exception is thrown and the method returns <see langword="false" />
          regardless of the existence of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FileAccessPermissions">
      <MemberSignature Language="C#" Value="public Mono.Unix.FileAccessPermissions FileAccessPermissions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Unix.FileAccessPermissions FileAccessPermissions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Unix.FileAccessPermissions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the file system entry access permissions.</summary>
        <value>A <see cref="T:Mono.Unix.FileAccessPermissions" /> value which
          controls access to the file system entry.</value>
        <remarks>
          <para>
            Access to file system objects 
            (as represented by <see cref="T:Mono.Unix.UnixFileSystemInfo" />)
            is controlled by the file system access permissions, 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileAccessPermissions" />.
            <see cref="T:Mono.Unix.FileAccessPermissions" /> is a nine-bit field
            specifying read, write, and execute access for the owner, group, and
            everyone else (other).
          </para>
          <para>
            Access by the file's owner is controlled by the bits specified by
            <c>
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.FileAccessPermissions" />
            &amp; 
            <see cref="F:Mono.Unix.FileAccessPermissions.UserReadWriteExecute" />)</c>.
            The owner permissions supersede group permissions and other
            permissions, even if the owner belongs to the group.
          </para>
          <para>
            Access by the file's owner group is controlled by the bits
            specified by <c>
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.FileAccessPermissions" />
            &amp; 
            <see cref="F:Mono.Unix.FileAccessPermissions.GroupReadWriteExecute" />)</c>.
            All group members get these access permissions.
            See also
            <see cref="P:Mono.Unix.UnixFileSystemInfo.OwnerGroup" />.<see cref="M:Mono.Unix.UnixGroupInfo.GetMembers" />.
          </para>
          <para>
            All other users (users who are not the file's owner nor belonging
            to the file's owner group) get the file access permissions
            specified by <c>
            (<see cref="P:Mono.Unix.UnixFileSystemInfo.FileAccessPermissions" />
            &amp; 
            <see cref="F:Mono.Unix.FileAccessPermissions.OtherReadWriteExecute" />)</c>.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FileSpecialAttributes">
      <MemberSignature Language="C#" Value="public Mono.Unix.FileSpecialAttributes FileSpecialAttributes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Unix.FileSpecialAttributes FileSpecialAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Unix.FileSpecialAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the file system entry special attributes.</summary>
        <value>A <see cref="T:Mono.Unix.FileSpecialAttributes" /> value which
          contains the file special attributes to use.</value>
        <remarks>
          <para>Callers may need to be the super user (often the <c>root</c>
            user) to change the file special attributes.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FileType">
      <MemberSignature Language="C#" Value="public Mono.Unix.FileTypes FileType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Unix.FileTypes FileType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Unix.FileTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type of this file system entry.</summary>
        <value>A <see cref="T:Mono.Unix.FileTypes" /> value specifying the type
          of this file system entry.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the fully-qualified path name.</summary>
        <value>A <see cref="T:System.String" /> containing the fully-qualified
          path name.</value>
        <remarks>
        </remarks>
        <altmember cref="M:Mono.Unix.UnixPath.GetFullPath" />
      </Docs>
    </Member>
    <Member MemberName="FullPath">
      <MemberSignature Language="C#" Value="protected string FullPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the fully qualified path name.</summary>
        <value>A <see cref="T:System.String" /> containing the fully qualified
          path name.</value>
        <remarks>
          <para>
            If <paramref name="value" /> is a different path, then the state is
            invalidated.  This shouldn't matter, as the state will be
            re-validated on the next member access.
          </para>
          <para>It is possible for the object state to be inconsistent if 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullPath" /> is set but
            not <see cref="P:Mono.Unix.UnixFileSystemInfo.OriginalPath" />.
            All methods in this class do not use <c>OriginalPath</c> but use
            <c>FullPath</c>; subclasses such as 
            <see cref="T:Mono.Unix.UnixSymbolicLinkInfo" /> do use
            <c>OriginalPath</c>.  If <c>FullPath</c> is set then
            <c>OriginalPath</c> should also be set if possible for
            consistency.
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.ArgumentException">
          <para>
            <paramref name="path" /> is a zero-length string.</para>
          <para>-or-</para>
          <para>
            <paramref name="path" /> contains an invalid character.
            See <see cref="M:Mono.Unix.UnixPath.GetInvalidPathChars" />.
          </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationValue">
      <MemberSignature Language="C#" Value="public long GetConfigurationValue (Mono.Unix.Native.PathconfName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetConfigurationValue(valuetype Mono.Unix.Native.PathconfName name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="Mono.Unix.Native.PathconfName" />
      </Parameters>
      <Docs>
        <param name="name">A <see cref="T:Mono.Unix.Native.PathconfName" />
          value specifying which configuration value to retreive.</param>
        <summary>Gets a configurable system limit or option variable
          associated with 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
        </summary>
        <returns>A <see cref="T:System.Int64" /> containing the value
          of the configuration variable <paramref name="name" />.
          If there is no value for the configuration variable 
          <paramref name="name" />, then <c>-1</c> is returned.
        </returns>
        <remarks>
        </remarks>
        <exception cref="T:System.ArgumentException">
          The implementation does not support an association of 
          <paramref name="name" /> with 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <para>Search permission is denied for a component of the path
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.EACCES" />]
          </para>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          A component of the path prefix of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is not a
          directory.
            [<see cref="F:Mono.Unix.Native.Errno.ENOTDIR" />]
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          A component of <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
          that must exist does not exist.
            [<see cref="F:Mono.Unix.Native.Errno.ENOENT" />]
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> was too long.
            [<see cref="F:Mono.Unix.Native.Errno.ENAMETOOLONG" />]
        </exception>
        <exception cref="T:System.IO.IOException">
          An I/O error occurred while reading from or writing to the file
          system.
        </exception>
        <exception cref="T:Mono.Unix.UnixIOException">
          <para>Too many symbolic links were encountered in translating 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.ELOOP" />]
          </para>
        </exception>
        <altmember cref="M:Mono.Unix.Native.Syscall.pathconf" />
      </Docs>
    </Member>
    <Member MemberName="GetFileStatus">
      <MemberSignature Language="C#" Value="protected virtual bool GetFileStatus (string path, out Mono.Unix.Native.Stat stat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GetFileStatus(string path, valuetype Mono.Unix.Native.Stat stat) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="stat" Type="Mono.Unix.Native.Stat&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path">A <see cref="T:System.String" /> containing the path
          to retrieve information about</param>
        <param name="stat">A <see cref="T:Mono.Unix.Native.Stat" /> which will
          contain information about <paramref name="path" />.</param>
        <summary>Gets file status information.</summary>
        <returns>A <see cref="T:System.Boolean" /> specifying whether 
          <paramref name="stat" /> was filled.  If <see langword="true" />, then 
          <paramref name="path" /> exists and <paramref name="stat" /> contains
          valid information.  Otherwise, <paramref name="path" /> is assumed to
          not exist and <paramref name="stat" /> is assumed to contain invalid
          information.
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntry">
      <MemberSignature Language="C#" Value="public static Mono.Unix.UnixFileSystemInfo GetFileSystemEntry (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Mono.Unix.UnixFileSystemInfo GetFileSystemEntry(string path) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Unix.UnixFileSystemInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Inode">
      <MemberSignature Language="C#" Value="public long Inode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Inode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the inode of this file system entry.</summary>
        <value>A <see cref="T:System.Int64" /> containing the inode of this
          file system entry.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_ino" />
        <altmember cref="F:Mono.Unix.Native.System.stat" />
      </Docs>
    </Member>
    <Member MemberName="IsBlockDevice">
      <MemberSignature Language="C#" Value="public bool IsBlockDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBlockDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Is 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> a 
          <see cref="F:Mono.Unix.FileTypes.BlockDevice" />?</summary>
        <value>
          A <see cref="T:System.Boolean" /> indicating whether or not 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is a 
          <see cref="F:Mono.Unix.FileTypes.BlockDevice" />.
        </value>
        <remarks>
          <para>This is equivalent to comparing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileType" /> to 
            <see cref="F:Mono.Unix.FileTypes.BlockDevice" />.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsCharacterDevice">
      <MemberSignature Language="C#" Value="public bool IsCharacterDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCharacterDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Is 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> a 
          <see cref="F:Mono.Unix.FileTypes.CharacterDevice" />?</summary>
        <value>
          A <see cref="T:System.Boolean" /> indicating whether or not 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is a 
          <see cref="F:Mono.Unix.FileTypes.CharacterDevice" />.
        </value>
        <remarks>
          <para>This is equivalent to comparing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileType" /> to 
            <see cref="F:Mono.Unix.FileTypes.CharacterDevice" />.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsDirectory">
      <MemberSignature Language="C#" Value="public bool IsDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Is 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> a 
          <see cref="F:Mono.Unix.FileTypes.Directory" />?</summary>
        <value>
          A <see cref="T:System.Boolean" /> indicating whether or not 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is a 
          <see cref="F:Mono.Unix.FileTypes.Directory" />.
        </value>
        <remarks>
          <para>This is equivalent to comparing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileType" /> to 
            <see cref="F:Mono.Unix.FileTypes.Directory" />.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsFifo">
      <MemberSignature Language="C#" Value="public bool IsFifo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFifo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Is 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> a 
          <see cref="F:Mono.Unix.FileTypes.Fifo" />?</summary>
        <value>
          A <see cref="T:System.Boolean" /> indicating whether or not 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is a 
          <see cref="F:Mono.Unix.FileTypes.Fifo" />.
        </value>
        <remarks>
          <para>This is equivalent to comparing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileType" /> to 
            <see cref="F:Mono.Unix.FileTypes.Fifo" />.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsRegularFile">
      <MemberSignature Language="C#" Value="public bool IsRegularFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRegularFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Is 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> a 
          <see cref="F:Mono.Unix.FileTypes.RegularFile" />?</summary>
        <value>
          A <see cref="T:System.Boolean" /> indicating whether or not 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is a 
          <see cref="F:Mono.Unix.FileTypes.RegularFile" />.
        </value>
        <remarks>
          <para>This is equivalent to comparing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileType" /> to 
            <see cref="F:Mono.Unix.FileTypes.RegularFile" />.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSetGroup">
      <MemberSignature Language="C#" Value="public bool IsSetGroup { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSetGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Does
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FileSpecialAttributes" /> include
          <see cref="F:Mono.Unix.FileSpecialAttributes.SetGroupId" />?</summary>
        <value>
          A <see cref="T:System.Boolean" /> indicating whether or not 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FileSpecialAttributes" /> includes
          <see cref="F:Mono.Unix.FileSpecialAttributes.SetGroupId" />.
        </value>
        <remarks>
          <para>This is equivalent to comparing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileSpecialAttributes" /> with
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetGroupId" />.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSetUser">
      <MemberSignature Language="C#" Value="public bool IsSetUser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSetUser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Does
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FileSpecialAttributes" /> include
          <see cref="F:Mono.Unix.FileSpecialAttributes.SetUserId" />?</summary>
        <value>
          A <see cref="T:System.Boolean" /> indicating whether or not 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FileSpecialAttributes" /> includes
          <see cref="F:Mono.Unix.FileSpecialAttributes.SetUserId" />.
        </value>
        <remarks>
          <para>This is equivalent to comparing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileSpecialAttributes" /> with
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetUserId" />.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSocket">
      <MemberSignature Language="C#" Value="public bool IsSocket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSocket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Is 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> a 
          <see cref="F:Mono.Unix.FileTypes.Socket" />?</summary>
        <value>
          A <see cref="T:System.Boolean" /> indicating whether or not 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is a 
          <see cref="F:Mono.Unix.FileTypes.Socket" />.
        </value>
        <remarks>
          <para>This is equivalent to comparing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileType" /> to 
            <see cref="F:Mono.Unix.FileTypes.Socket" />.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSticky">
      <MemberSignature Language="C#" Value="public bool IsSticky { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSticky" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Does
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FileSpecialAttributes" /> include
          <see cref="F:Mono.Unix.FileSpecialAttributes.Sticky" />?</summary>
        <value>
          A <see cref="T:System.Boolean" /> indicating whether or not 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FileSpecialAttributes" /> includes
          <see cref="F:Mono.Unix.FileSpecialAttributes.Sticky" />.
        </value>
        <remarks>
          <para>This is equivalent to comparing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileSpecialAttributes" /> with
            <see cref="F:Mono.Unix.FileSpecialAttributes.Sticky" />.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSymbolicLink">
      <MemberSignature Language="C#" Value="public bool IsSymbolicLink { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSymbolicLink" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Is 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> a 
          <see cref="F:Mono.Unix.FileTypes.SymbolicLink" />?</summary>
        <value>
          A <see cref="T:System.Boolean" /> indicating whether or not 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is a 
          <see cref="F:Mono.Unix.FileTypes.SymbolicLink" />.
        </value>
        <remarks>
          <para>This is equivalent to comparing 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FileType" /> to 
            <see cref="F:Mono.Unix.FileTypes.SymbolicLink" />.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LastAccessTime">
      <MemberSignature Language="C#" Value="public DateTime LastAccessTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastAccessTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the last file access time expressed in local
        time.</summary>
        <value>The last access time of 
        <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />
        expressed in the local time.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_atime" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="LastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public DateTime LastAccessTimeUtc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastAccessTimeUtc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the last file access time expressed in
        coordinated universal time (UTC).</summary>
        <value>The last access time of 
        <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />
        expressed in coordinated universal time (UTC).</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_atime" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="LastStatusChangeTime">
      <MemberSignature Language="C#" Value="public DateTime LastStatusChangeTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastStatusChangeTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the last status change time expressed in local
        time.</summary>
        <value>The last status change time of 
        <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />
        expressed in the local time.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_ctime" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="LastStatusChangeTimeUtc">
      <MemberSignature Language="C#" Value="public DateTime LastStatusChangeTimeUtc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastStatusChangeTimeUtc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the last status change time expressed in
        coordinated universal time (UTC).</summary>
        <value>The last status change time of 
        <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />
        expressed in coordinated universal time (UTC).</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_ctime" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="LastWriteTime">
      <MemberSignature Language="C#" Value="public DateTime LastWriteTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastWriteTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the last file write time expressed in local
        time.</summary>
        <value>The last write time of 
        <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />
        expressed in the local time.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_mtime" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="LastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public DateTime LastWriteTimeUtc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastWriteTimeUtc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the last file write time expressed in
        coordinated universal time (UTC).</summary>
        <value>The last write time of 
        <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />
        expressed in coordinated universal time (UTC).</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_mtime" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the file system entry size, in bytes.</summary>
        <value>A <see cref="T:System.Int64" /> containing the size of this file
          system entry, in bytes.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_size" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="LinkCount">
      <MemberSignature Language="C#" Value="public long LinkCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LinkCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current link count of this file system entry.</summary>
        <value>A <see cref="T:System.Int64" /> containing link count of this
          file system entry.</value>
        <remarks>
          <para>A link count is the number of file system entries that share
            this <see cref="P:Mono.Unix.UnixFileSystemInfo.Inode" />.
          </para>
          <para>
            Use 
            <see cref="M:Mono.Unix.UnixFileSystemInfo.GetConfigurationValue" />(<see cref="M:Mono.Unix.Native.PathconfName._PC_LINK_MAX" />) 
            to determine the maximum link count.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The file system entry name.</summary>
        <value>A <see cref="T:System.String" /> containing the file system
          entry name.  
        </value>
        <remarks>
          <para>
            This will generally be 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> without the 
            directory name.
          </para>
        </remarks>
        <altmember cref="M:Mono.Unix.UnixPath.GetFileName" />
        <altmember cref="M:Mono.Unix.UnixPath.GetDirectoryName" />
      </Docs>
    </Member>
    <Member MemberName="OriginalPath">
      <MemberSignature Language="C#" Value="protected string OriginalPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The original string passed to the 
          <see cref="C:Mono.Unix.UnixFileSystemInfo(System.String)" />
          constructor.</summary>
        <value>A <see cref="T:System.String" /> containing 
          the original string passed to the 
          <see cref="C:Mono.Unix.UnixFileSystemInfo(System.String)" />
          constructor.  It may contain relative path information without a
          qualifying directory, if that's what was originally provided to the
          constructor.
        </value>
        <remarks>
          <para>This is primarily useful if you need relative path names
            instead of fully-qualified directory names, such as when dealing
            with symbolic links (with 
            <see cref="T:Mono.Unix.UnixSymbolicLinkInfo" />).
          </para>
          <para>It is possible for the object state to be inconsistent if 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullPath" /> is set but
            not <see cref="P:Mono.Unix.UnixFileSystemInfo.OriginalPath" />.
            All methods in this class do not use <c>OriginalPath</c> but use
            <c>FullPath</c>; subclasses such as 
            <see cref="T:Mono.Unix.UnixSymbolicLinkInfo" /> do use
            <c>OriginalPath</c>.  If <c>FullPath</c> is set then
            <c>OriginalPath</c> should also be set if possible for
            consistency.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerGroup">
      <MemberSignature Language="C#" Value="public Mono.Unix.UnixGroupInfo OwnerGroup { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Unix.UnixGroupInfo OwnerGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Unix.UnixGroupInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets information about the owner group.</summary>
        <value>A <see cref="T:Mono.Unix.UnixGroupInfo" /> instance containing
          information about the owner group.</value>
        <remarks>
          <para>This is identical to <see cref="C:Mono.Unix.UnixGroupInfo" />(<see cref="P:Mono.Unix.UnixFileSystemInfo.OwnerGroupId" />).
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_gid" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="OwnerGroupId">
      <MemberSignature Language="C#" Value="public long OwnerGroupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 OwnerGroupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the owner group id.</summary>
        <value>A <see cref="T:System.Int64" /> containing the owner group id.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_gid" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="OwnerUser">
      <MemberSignature Language="C#" Value="public Mono.Unix.UnixUserInfo OwnerUser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Mono.Unix.UnixUserInfo OwnerUser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Unix.UnixUserInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets information about the owner user.</summary>
        <value>A <see cref="T:Mono.Unix.UnixUserInfo" /> containing information
          about the owner user.</value>
        <remarks>
          <para>This is identical to <see cref="C:Mono.Unix.UnixUserInfo" />(<see cref="P:Mono.Unix.UnixFileSystemInfo.OwnerUserId" />).
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_uid" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="OwnerUserId">
      <MemberSignature Language="C#" Value="public long OwnerUserId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 OwnerUserId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the owner user id.</summary>
        <value>
          A <see cref="T:System.Int64" /> containing the owner user id.
        </value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_uid" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="Protection">
      <MemberSignature Language="C#" Value="public Mono.Unix.Native.FilePermissions Protection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Mono.Unix.Native.FilePermissions Protection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Mono.Unix.Native.FilePermissions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the file system entry protection.</summary>
        <value>A <see cref="T:Mono.Unix.Native.FilePermissions" /> value
          containing the file system entry protection.</value>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
        <altmember cref="F:Mono.Unix.Native.Stat.st_mode" />
        <altmember cref="F:Mono.Unix.Native.Syscall.stat" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Refreshes the file system metadata presented.</summary>
        <remarks>
          <para>This method does not throw exceptions.</para>
          <para>
            Many properties and members will throw a
            <see cref="T:System.InvalidOperationException" /> if 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't
            exist (that is, 
            <see cref="P:Mono.Unix.UnixFileSystemInfo.Exists" /> returns
            <see langword="false" />).
          </para>
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is checked
            during <see cref="T:Mono.Unix.UnixFileSystemInfo" /> creation and
            on every property access until the file is found.  Once found, the
            file will not be checked for until 
            <see cref="M:Mono.Unix.UnixFileSystemInfo.Refresh" /> is invoked.
          </para>
          <para>
            Consequently, if the file system entry is removed
            (via <see cref="M:Mono.Unix.UnixFileSystemInfo.Delete" /> or
            another process or some other means) or changed
            (written to, <c>touch(1)</c>'d, etc.), the information provided by
            this class will be stale and out of date.
          </para>
          <para>
            Use this method to refresh the information provided by this class.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public void SetLength (long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLength(int64 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="length">A <see cref="T:System.Int64" /> containing the 
          desired file size for 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /></param>
        <summary>Truncate or extend 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> to be
          <paramref name="length" /> bytes in size.
        </summary>
        <remarks>
          <para>If <see cref="P:Mono.Unix.UnixFileSystemInfo.Length" /> is
            less than <paramref name="length" />, the file will be extended as
            if by writing bytes with the value zero.
          </para>
          <para>If <see cref="P:Mono.Unix.UnixFileSystemInfo.Length" /> is
            greater than <paramref name="length" />, then the extra data is
            lost.
          </para>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <para>Search permission is denied for a component of the path
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.EACCES" />]
          </para>
          <para>-or-</para>
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is not
            writable by the user.
            [<see cref="F:Mono.Unix.Native.Errno.EACCES" />]
          </para>
          <para>-or-</para>
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is a
          directory.
            [<see cref="F:Mono.Unix.Native.Errno.EISDIR" />]
          </para>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          A component of the path prefix of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is not a
          directory.
            [<see cref="F:Mono.Unix.Native.Errno.ENOTDIR" />]
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          A component of <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
          that must exist does not exist.
            [<see cref="F:Mono.Unix.Native.Errno.ENOENT" />]
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> resides on a
          read-only file system.
            [<see cref="F:Mono.Unix.Native.Errno.EROFS" />]
          </para>
          <para>-or-</para>
          <para>An I/O error occurred while making the directory entry or
          allocating the inode.
            [<see cref="F:Mono.Unix.Native.Errno.EIO" />]
          </para>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> was too long.
            [<see cref="F:Mono.Unix.Native.Errno.ENAMETOOLONG" />]
        </exception>
        <exception cref="T:Mono.Unix.UnixIOException">
          <para>Too many symbolic links were encountered in translating 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.ELOOP" />]
          </para>
          <para>-or-</para>
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is a
          pure procedure (shared text) file that is being executed and 
          <see cref="M:Mono.Unix.Native.Syscall.open" /> requests write
          access.
            [<see cref="F:Mono.Unix.Native.Errno.ETXTBSY" />]
          </para>
        </exception>
        <altmember cref="M:Mono.Unix.Native.Syscall.truncate" />
      </Docs>
    </Member>
    <Member MemberName="SetOwner">
      <MemberSignature Language="C#" Value="public void SetOwner (Mono.Unix.UnixUserInfo owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOwner(class Mono.Unix.UnixUserInfo owner) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="Mono.Unix.UnixUserInfo" />
      </Parameters>
      <Docs>
        <param name="owner">A <see cref="T:Mono.Unix.UnixUserInfo" /> containing 
          information about the new owner user and owner group.
        </param>
        <summary>Set the owner user and owner group of
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
        </summary>
        <remarks>
          <para>
            If this is called by the non-super user (usually the <c>root</c>
            user), then the 
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetUserId" /> and
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetGroupId" /> bits
            are cleared.
          </para>
          <para>
            Classes deriving from <see cref="T:Mono.Unix.UnixFileSystemInfo" />
            can change this method to operate on a different file.  This
            default version will follow symbolic links, changing the
            permissions of the symbolic link target instead of the symbolic
            link itself.
            <see cref="M:Mono.Unix.UnixSymbolicLinkInfo.SetOwner" /> changes
            permissions on the symbolic link itself.
          </para>
          <para>
            This is (almost) equivalent to calling 
            <see cref="M:Mono.Unix.UnixFileSystemInfo.SetOwner" />(<paramref name="owner" />.UserId, 
            <paramref name="group" />.GroupId).
          </para>
          <para>
            This is (almost) equivalent to calling 
            <see cref="M:Mono.Unix.UnixFileSystemInfo.SetOwner" />(<paramref name="owner" />.UserId, 
            <paramref name="owner" />.GroupId).
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          The effective user ID does not match the owner of the file and the
          effective user ID is not the super-user.
            [<see cref="F:Mono.Unix.Native.Errno.EPERM" />]
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <para>Search permission is denied for a component of the path
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.EACCES" />]
          </para>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          A component of the path prefix of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is not a
          directory.
            [<see cref="F:Mono.Unix.Native.Errno.ENOTDIR" />]
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          A component of <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
          that must exist does not exist.
            [<see cref="F:Mono.Unix.Native.Errno.ENOENT" />]
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> resides on a
          read-only file system.
            [<see cref="F:Mono.Unix.Native.Errno.EROFS" />]
          </para>
          <para>-or-</para>
          <para>An I/O error occurred while making the directory entry or
          allocating the inode.
            [<see cref="F:Mono.Unix.Native.Errno.EIO" />]
          </para>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> was too long.
            [<see cref="F:Mono.Unix.Native.Errno.ENAMETOOLONG" />]
        </exception>
        <exception cref="T:Mono.Unix.UnixIOException">
          <para>Too many symbolic links were encountered in translating 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.ELOOP" />]
          </para>
          <para>-or-</para>
          <para>An attempt was made to set the sticky bit upon an
            executable.
            [<see cref="F:Mono.Unix.Native.Errno.EFTYPE" />]
          </para>
        </exception>
        <altmember cref="M:Mono.Unix.Native.Syscall.chown" />
      </Docs>
    </Member>
    <Member MemberName="SetOwner">
      <MemberSignature Language="C#" Value="public void SetOwner (string owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOwner(string owner) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owner">A <see cref="T:System.String" /> containing the
          user name to use for the new user-id and group-id.</param>
        <summary>Set the owner user ID and owner group ID of
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
        </summary>
        <remarks>
          <para>The user <paramref name="owner" /> is looked up in the local 
            password database and the resulting 
            <see cref="P:Mono.Unix.UnixUserInfo.UserId" /> and 
            <see cref="P:Mono.Unix.UnixUserInfo.GroupId" /> are used as the new
            owner user id and owner group id for
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
          </para>
          <para>
            If this is called by the non-super user (usually the <c>root</c>
            user), then the 
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetUserId" /> and
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetGroupId" /> bits
            are cleared.
          </para>
          <para>
            Classes deriving from <see cref="T:Mono.Unix.UnixFileSystemInfo" />
            can change this method to operate on a different file.  This
            default version will follow symbolic links, changing the
            permissions of the symbolic link target instead of the symbolic
            link itself.
            <see cref="M:Mono.Unix.UnixSymbolicLinkInfo.SetOwner" /> changes
            permissions on the symbolic link itself.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          The effective user ID does not match the owner of the file and the
          effective user ID is not the super-user.
            [<see cref="F:Mono.Unix.Native.Errno.EPERM" />]
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <para>Search permission is denied for a component of the path
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.EACCES" />]
          </para>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          A component of the path prefix of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is not a
          directory.
            [<see cref="F:Mono.Unix.Native.Errno.ENOTDIR" />]
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          A component of <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
          that must exist does not exist.
            [<see cref="F:Mono.Unix.Native.Errno.ENOENT" />]
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> resides on a
          read-only file system.
            [<see cref="F:Mono.Unix.Native.Errno.EROFS" />]
          </para>
          <para>-or-</para>
          <para>An I/O error occurred while making the directory entry or
          allocating the inode.
            [<see cref="F:Mono.Unix.Native.Errno.EIO" />]
          </para>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> was too long.
            [<see cref="F:Mono.Unix.Native.Errno.ENAMETOOLONG" />]
        </exception>
        <exception cref="T:Mono.Unix.UnixIOException">
          <para>Too many symbolic links were encountered in translating 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.ELOOP" />]
          </para>
          <para>-or-</para>
          <para>An attempt was made to set the sticky bit upon an
            executable.
            [<see cref="F:Mono.Unix.Native.Errno.EFTYPE" />]
          </para>
        </exception>
        <altmember cref="T:Mono.Unix.UnixUserInfo" />
        <altmember cref="M:Mono.Unix.Native.Syscall.chown" />
      </Docs>
    </Member>
    <Member MemberName="SetOwner">
      <MemberSignature Language="C#" Value="public void SetOwner (Mono.Unix.UnixUserInfo owner, Mono.Unix.UnixGroupInfo group);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOwner(class Mono.Unix.UnixUserInfo owner, class Mono.Unix.UnixGroupInfo group) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="Mono.Unix.UnixUserInfo" />
        <Parameter Name="group" Type="Mono.Unix.UnixGroupInfo" />
      </Parameters>
      <Docs>
        <param name="owner">A <see cref="T:Mono.Unix.UnixUserInfo" /> containing 
          information about the new owner user.  If <see langword="null" />,
          the owner user id is unchanged.</param>
        <param name="group">A <see cref="T:Mono.Unix.UnixUserInfo" /> containing 
          information about the new owner group.  If <see langword="null" />,
          the owner group id is unchanged.</param>
        <summary>Set the owner user and owner group of
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
        </summary>
        <remarks>
          <para>
            If this is called by the non-super user (usually the <c>root</c>
            user), then the 
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetUserId" /> and
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetGroupId" /> bits
            are cleared.
          </para>
          <para>
            Classes deriving from <see cref="T:Mono.Unix.UnixFileSystemInfo" />
            can change this method to operate on a different file.  This
            default version will follow symbolic links, changing the
            permissions of the symbolic link target instead of the symbolic
            link itself.
            <see cref="M:Mono.Unix.UnixSymbolicLinkInfo.SetOwner" /> changes
            permissions on the symbolic link itself.
          </para>
          <para>
            This is (almost) equivalent to calling 
            <see cref="M:Mono.Unix.UnixFileSystemInfo.SetOwner" />(<paramref name="owner" />.UserId, 
            <paramref name="group" />.GroupId).
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          The effective user ID does not match the owner of the file and the
          effective user ID is not the super-user.
            [<see cref="F:Mono.Unix.Native.Errno.EPERM" />]
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <para>Search permission is denied for a component of the path
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.EACCES" />]
          </para>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          A component of the path prefix of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is not a
          directory.
            [<see cref="F:Mono.Unix.Native.Errno.ENOTDIR" />]
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          A component of <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
          that must exist does not exist.
            [<see cref="F:Mono.Unix.Native.Errno.ENOENT" />]
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> resides on a
          read-only file system.
            [<see cref="F:Mono.Unix.Native.Errno.EROFS" />]
          </para>
          <para>-or-</para>
          <para>An I/O error occurred while making the directory entry or
          allocating the inode.
            [<see cref="F:Mono.Unix.Native.Errno.EIO" />]
          </para>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> was too long.
            [<see cref="F:Mono.Unix.Native.Errno.ENAMETOOLONG" />]
        </exception>
        <exception cref="T:Mono.Unix.UnixIOException">
          <para>Too many symbolic links were encountered in translating 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.ELOOP" />]
          </para>
          <para>-or-</para>
          <para>An attempt was made to set the sticky bit upon an
            executable.
            [<see cref="F:Mono.Unix.Native.Errno.EFTYPE" />]
          </para>
        </exception>
        <altmember cref="M:Mono.Unix.Native.Syscall.chown" />
      </Docs>
    </Member>
    <Member MemberName="SetOwner">
      <MemberSignature Language="C#" Value="public virtual void SetOwner (long owner, long group);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetOwner(int64 owner, int64 group) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Int64" />
        <Parameter Name="group" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="owner">A <see cref="T:System.Int64" /> containing the user
          id of the new owner user.  If <c>-1</c>, the owner user id is
          unchanged.</param>
        <param name="group">A <see cref="T:System.Int64" /> containing the
          group id of the new owner group.  If <c>-1</c>, the owner group id is
          unchanged.</param>
        <summary>Set the owner user ID and owner group ID of
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
        </summary>
        <remarks>
          <para>
            If this is called by the non-super user (usually the <c>root</c>
            user), then the 
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetUserId" /> and
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetGroupId" /> bits
            are cleared.
          </para>
          <para>
            Classes deriving from <see cref="T:Mono.Unix.UnixFileSystemInfo" />
            can change this method to operate on a different file.  This
            default version will follow symbolic links, changing the
            permissions of the symbolic link target instead of the symbolic
            link itself.
            <see cref="M:Mono.Unix.UnixSymbolicLinkInfo.SetOwner" /> changes
            permissions on the symbolic link itself.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          The effective user ID does not match the owner of the file and the
          effective user ID is not the super-user.
            [<see cref="F:Mono.Unix.Native.Errno.EPERM" />]
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <para>Search permission is denied for a component of the path
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.EACCES" />]
          </para>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          A component of the path prefix of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is not a
          directory.
            [<see cref="F:Mono.Unix.Native.Errno.ENOTDIR" />]
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          A component of <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
          that must exist does not exist.
            [<see cref="F:Mono.Unix.Native.Errno.ENOENT" />]
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> resides on a
          read-only file system.
            [<see cref="F:Mono.Unix.Native.Errno.EROFS" />]
          </para>
          <para>-or-</para>
          <para>An I/O error occurred while making the directory entry or
          allocating the inode.
            [<see cref="F:Mono.Unix.Native.Errno.EIO" />]
          </para>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> was too long.
            [<see cref="F:Mono.Unix.Native.Errno.ENAMETOOLONG" />]
        </exception>
        <exception cref="T:Mono.Unix.UnixIOException">
          <para>Too many symbolic links were encountered in translating 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.ELOOP" />]
          </para>
          <para>-or-</para>
          <para>An attempt was made to set the sticky bit upon an
            executable.
            [<see cref="F:Mono.Unix.Native.Errno.EFTYPE" />]
          </para>
        </exception>
        <altmember cref="M:Mono.Unix.Native.Syscall.chown" />
      </Docs>
    </Member>
    <Member MemberName="SetOwner">
      <MemberSignature Language="C#" Value="public void SetOwner (string owner, string group);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOwner(string owner, string group) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.String" />
        <Parameter Name="group" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owner">A <see cref="T:System.String" /> containing the 
          user name of the owner user id to use.</param>
        <param name="group">A <see cref="T:System.String" /> containing the 
          group name of the owner group id to use.</param>
        <summary>Set the owner user ID and owner group ID of
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
        </summary>
        <remarks>
          <para>
            If this is called by the non-super user (usually the <c>root</c>
            user), then the 
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetUserId" /> and
            <see cref="F:Mono.Unix.FileSpecialAttributes.SetGroupId" /> bits
            are cleared.
          </para>
          <para>
            Classes deriving from <see cref="T:Mono.Unix.UnixFileSystemInfo" />
            can change this method to operate on a different file.  This
            default version will follow symbolic links, changing the
            permissions of the symbolic link target instead of the symbolic
            link itself.
            <see cref="M:Mono.Unix.UnixSymbolicLinkInfo.SetOwner" /> changes
            permissions on the symbolic link itself.
          </para>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          The effective user ID does not match the owner of the file and the
          effective user ID is not the super-user.
            [<see cref="F:Mono.Unix.Native.Errno.EPERM" />]
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <para>Search permission is denied for a component of the path
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.EACCES" />]
          </para>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          A component of the path prefix of 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> is not a
          directory.
            [<see cref="F:Mono.Unix.Native.Errno.ENOTDIR" />]
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          A component of <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> 
          that must exist does not exist.
            [<see cref="F:Mono.Unix.Native.Errno.ENOENT" />]
        </exception>
        <exception cref="T:System.IO.IOException">
          <para>
            <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> resides on a
          read-only file system.
            [<see cref="F:Mono.Unix.Native.Errno.EROFS" />]
          </para>
          <para>-or-</para>
          <para>An I/O error occurred while making the directory entry or
          allocating the inode.
            [<see cref="F:Mono.Unix.Native.Errno.EIO" />]
          </para>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> was too long.
            [<see cref="F:Mono.Unix.Native.Errno.ENAMETOOLONG" />]
        </exception>
        <exception cref="T:Mono.Unix.UnixIOException">
          <para>Too many symbolic links were encountered in translating 
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
            [<see cref="F:Mono.Unix.Native.Errno.ELOOP" />]
          </para>
          <para>-or-</para>
          <para>An attempt was made to set the sticky bit upon an
            executable.
            [<see cref="F:Mono.Unix.Native.Errno.EFTYPE" />]
          </para>
        </exception>
        <altmember cref="T:Mono.Unix.UnixUserInfo" />
        <altmember cref="T:Mono.Unix.UnixGroupInfo" />
        <altmember cref="M:Mono.Unix.Native.Syscall.chown" />
      </Docs>
    </Member>
    <Member MemberName="ToStat">
      <MemberSignature Language="C#" Value="public Mono.Unix.Native.Stat ToStat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Mono.Unix.Native.Stat ToStat() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Mono.Unix.Native.Stat</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the instance into a 
          <see cref="T:Mono.Unix.Native.Stat" /> intance.</summary>
        <returns>A <see cref="T:Mono.Unix.Native.Stat" /> which contains
          information about <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" />.
        </returns>
        <remarks>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:Mono.Unix.UnixFileSystemInfo.FullName" /> doesn't exist.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFileSystemEntry">
      <MemberSignature Language="C#" Value="public static bool TryGetFileSystemEntry (string path, out Mono.Unix.UnixFileSystemInfo entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetFileSystemEntry(string path, class Mono.Unix.UnixFileSystemInfo entry) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="entry" Type="Mono.Unix.UnixFileSystemInfo&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="entry">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
